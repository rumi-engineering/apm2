# Security Policy
APM2 is operated under a **fail-closed security posture** intended to make software releases verifiable, reproducible, and resistant to common supply-chain and credential compromise scenarios. The repository’s security policy is expressed as a set of mandatory invariants backed by automated gates in continuous integration and by cryptographic provenance for released artifacts. In practice, this means that security controls are enforced at build time and release time, and are treated as a release-blocking requirement rather than discretionary guidance.

The repository defines two distinct **security modes**. **MODE_HIGH_ASSURANCE** is the default posture for releases and any change that is intended to ship; in this mode, security gates are mandatory and exceptions are prohibited. **MODE_DEVELOPER** is a local-development convenience posture that allows work to proceed when advisory signals (e.g., static analysis warnings) are present; it is intended to reduce friction during iteration, but it must not be used to bypass CI enforcement or release criteria. In other words, developer mode may reduce local strictness, but it does not change the release acceptance bar.

APM2’s primary security objective is **release integrity**: consumers must be able to verify that a published artifact was built from this repository under controlled conditions. All releases are therefore required to be signed using **Sigstore keyless signing** via GitHub Actions OIDC, with signatures (`.sig`) and signing certificates (`.pem`) published alongside artifacts. Keyless signing is used to bind artifact signatures to an authenticated workload identity rather than long-lived signing keys, reducing the risk and operational complexity of key management while preserving verifiability.

In addition to signing, all releases must include **SLSA Level 3 provenance** generated by the `slsa-github-generator` and attached to the GitHub release. Provenance is treated as a first-class security artifact: it provides consumers and internal auditors with a cryptographically verifiable chain of custody showing that artifacts were produced by the expected CI workflow from the expected repository source. This provenance requirement is specifically intended to mitigate CI/CD compromise and “shadow build” scenarios, and to enable post-hoc investigation when anomalous artifacts are detected.

APM2 also requires publication of **SBOMs (Software Bills of Materials)** for each release. SBOMs must be generated with `syft` and published in both CycloneDX and SPDX formats. SBOMs serve two complementary purposes: (a) they provide transparency into included dependencies and versions for consumers and auditors, and (b) they enable vulnerability management workflows (internal and external) that can rapidly identify whether a newly disclosed issue affects a shipped artifact.

The security policy treats pre-merge code hygiene and dependency governance as mandatory **security gates**. All pull requests intended to merge must pass static analysis and security tooling, including `cargo clippy` with warnings treated as errors (`-D warnings`), `cargo-deny` (licenses, advisories, and bans), and `cargo-audit` (RustSec vulnerability database). This gate set is designed to prevent common classes of defects from reaching the mainline, and to prevent the build graph from quietly drifting into insecure or non-compliant dependency states.

Dependency policy is explicitly governed and enforced. Dependencies must have no known vulnerabilities per RustSec, must satisfy approved licensing constraints, and must not include banned crates (e.g., examples such as `openssl` where policy prohibits them). This approach treats the dependency graph as a security boundary: introducing or upgrading a crate is a security-relevant action that must be justified by necessity and must remain within the repository’s published constraints.

Secret protection is treated as an invariant rather than a best practice. Secrets must not appear in logs; log output must be routed through a redaction filter, and sensitive environment variables must never be logged. Secrets must not appear in release artifacts; artifacts are expected to be scanned prior to publishing, and error messages must be sanitized to prevent incidental leakage. Credentials must be stored using secure mechanisms appropriate to the environment: OS keyring for user credentials, GitHub Actions secrets for CI, and an explicit prohibition against plaintext credential files.

Finally, APM2 defines a structured **vulnerability handling and disclosure policy**. Findings are classified by severity (Critical, High, Medium, Low) with target response timelines, and security issues are expected to be reported and coordinated through GitHub Security Advisories. The policy commits to acknowledging reports within 48 hours and coordinating disclosure with reporters, with public disclosure expected after a patch is available. The intent is to maintain a predictable and auditable response process without delaying remediation.

