# Signing and Verification
APM2 enforces a release integrity policy based on **Sigstore keyless signing** to provide strong authenticity and provenance guarantees without relying on long‑lived private signing keys. The intent is to make every released artifact independently verifiable by downstream users and auditors, while reducing operational key management risk (key storage, rotation, and compromise response). Under this policy, the release process treats cryptographic signatures and attestations as mandatory release artifacts rather than optional metadata.

Keyless signing in APM2 is implemented using the **GitHub Actions OIDC** identity as the source of truth for “who performed the build.” During a release workflow, GitHub Actions obtains an OIDC token that attests to the workflow identity and execution context. That token is presented to Sigstore’s certificate authority (Fulcio), which issues a **short‑lived signing certificate** bound to the workflow identity. The workflow then uses Cosign to generate a signature over the artifact using an ephemeral keypair associated with the issued certificate. This approach binds the signature to a verifiable workload identity instead of a manually managed key, thereby shifting the trust anchor from “possession of a private key” to “proven execution of a specific CI workflow identity.”

APM2 requires that release workflows are configured with explicit permissions necessary to support this integrity model, including `id-token: write` for OIDC token minting, `contents: write` for publishing release assets, and `attestations: write` for generating and uploading provenance attestations. These permissions are part of the security posture: without them, the workflow cannot produce verifiable signatures or attestations, and the release should be considered non‑compliant. In other words, workflow permissioning is treated as a prerequisite for trustworthy artifact production.

For binary artifacts, APM2 uses Cosign’s blob signing workflow (`cosign sign-blob`) to produce two associated release assets per artifact: a signature file (`.sig`) and a signing certificate file (`.pem`). These assets are published alongside the artifact in the release, enabling consumers to verify integrity and provenance without accessing internal build systems. For container images, APM2 uses Cosign’s image signing workflow (`cosign sign`) to attach signatures to the registry artifact. In both cases, the signature binds to the cryptographic digest of the artifact, providing tamper evidence: if the artifact changes, verification fails.

Verification in APM2 is designed to be feasible for external consumers using public trust anchors and explicit identity constraints. Consumers verify artifacts using `cosign verify-blob` (for binaries) or `cosign verify` (for container images) and must apply both an **OIDC issuer constraint** (e.g., `https://token.actions.githubusercontent.com`) and a **certificate identity constraint** that restricts acceptable signatures to those produced by workflows from the expected repository and workflow path. This identity‑constrained verification pattern is crucial: it prevents accepting signatures produced by other repositories or workflows that may also use Sigstore, and it ensures that “signed” means “signed by the intended CI identity,” not merely “signed by someone.”

APM2 additionally requires **SLSA provenance verification** as part of the broader integrity model. Provenance attestations are intended to prove that artifacts were produced by the expected build pipeline from the expected source repository. Verifiers can use `slsa-verifier verify-artifact` (or equivalent tooling) to validate provenance against the expected source URI and artifact, enabling policy enforcement and audit workflows beyond signature checking alone. Signatures establish integrity and identity; provenance establishes build origin and build process claims.

The policy relies on transparency to strengthen non‑repudiation and auditability. Sigstore signatures are recorded in the **Rekor transparency log**, which provides an append‑only, publicly auditable record of signing events. In operational terms, transparency logging provides detection and response leverage: it makes certain classes of stealth signing attacks harder to conceal, and it supports forensic investigation by enabling third parties to correlate published artifacts with recorded signing events. Rekor log queries and entry inspection (e.g., via `rekor-cli`) are therefore part of the integrity ecosystem, even if routine users primarily rely on Cosign’s verification commands.

The certificate identity embedded in the Fulcio-issued certificate is treated as a primary verification primitive. The certificate includes issuer information, a subject that encodes the GitHub workflow identity, and GitHub-specific extensions (repository, ref, workflow SHA). Collectively, these fields allow verifiers to confirm that the signature was produced by a specific workflow from the intended repository and release reference (such as a tag). This design enables verifiers to build tight acceptance policies (identity regex patterns) that bind signatures to organizational release practices, rather than accepting broad signatures based only on repository name strings or human assertions.

Finally, the policy explicitly rejects long‑lived key storage as a security requirement by design. Private keys are ephemeral and exist only during signing; certificates are short‑lived and are validated against the transparency log for time validity and inclusion. Operational troubleshooting guidance therefore emphasizes identity and transparency constraints: expired certificates are expected behavior mitigated by Rekor inclusion, identity mismatches indicate policy constraint issues (wrong repo/workflow/ref assumptions), and missing transparency log entries indicate misconfiguration or non‑compliance. The practical result is a signing and verification posture that is auditable, identity‑bound, and compatible with automated policy enforcement in downstream environments.
