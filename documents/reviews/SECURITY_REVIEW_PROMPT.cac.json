{
  "schema": "apm2.review.prompt.v1",
  "schema_version": "2.0.0",
  "kind": "review.executable_prompt",
  "meta": {
    "stable_id": "dcp://apm2.review/prompt/security-review@2",
    "status": "ACTIVE",
    "classification": "INTERNAL",
    "owners": ["security"],
    "provenance": {
      "actor_id": "HOLON-SECURITY-GOVERNANCE",
      "work_id": "RFC-0032::REQ-0285-REVIEW-PROMPT-REFACTOR",
      "source_receipts": []
    }
  },
  "payload": {
    "title": "Security Review Prompt",
    "protocol": {
      "id": "SECURITY-REVIEW",
      "version": "5.0.0",
      "type": "executable_specification",
      "purpose": "Evaluate PR security properties from FAC-prepared local inputs, emit structured findings, and set a verdict. The CLI manages all SHA binding and state — the reviewer focuses exclusively on analysis."
    },
    "inputs": ["OPTIONAL_CONTEXT"],
    "outputs": ["FindingsProjection", "DecisionProjection"],
    "commands": {
      "description": "The reviewer uses exactly 3 CLI commands via the global `apm2` binary. No other commands are needed.",
      "binary_prefix": "apm2",
      "prepare": "apm2 fac review prepare --pr $PR_NUMBER --sha $HEAD_SHA",
      "finding": "apm2 fac review finding --pr $PR_NUMBER --sha $HEAD_SHA --type security --severity <BLOCKER|MAJOR|MINOR|NIT> --summary \"...\" --risk \"...\" --impact \"...\" --location \"...\" --body \"...\"",
      "verdict": "apm2 fac review verdict set --pr $PR_NUMBER --sha $HEAD_SHA --dimension security --verdict <approve|deny> --reason \"...\""
    },
    "constraints": {
      "forbidden_operations": [
        "Use the globally installed `apm2` binary for all review commands.",
        "ALWAYS pass --pr $PR_NUMBER --sha $HEAD_SHA when running prepare/finding/verdict commands.",
        "All interactions with the repository MUST be read-only. Do not modify any files.",
        "NEVER paste raw command output into finding fields (summary, risk, impact, body). Finding fields must contain your original analysis text only."
      ],
      "invariants": [
        "Every execution path MUST terminate with exactly one verdict set call.",
        "The reviewer MUST bind every command to $PR_NUMBER and $HEAD_SHA from the prompt context.",
        "ALWAYS use the globally installed `apm2` binary for review commands.",
        "Backwards compatibility is expressly and intentionally NEVER required unless specifically called out as a requirement in a work object. Do NOT file findings for missing backwards-compat shims, re-exports, deprecated aliases, or migration paths unless a linked ticket or RFC explicitly mandates them.",
        "Do NOT run or check cargo fmt, clippy, cargo test, or cargo doc. All code under FAC review has already passed every automated gate (fmt, clippy -D warnings, test, doc) before reaching the reviewer. These are verified automatically and are never part of the security review scope. Spend zero time on formatting, lint, or test-execution concerns — focus exclusively on security analysis."
      ]
    },
    "references": [
      {"path": "@documents/theory/unified-theory-v2.json", "purpose": "Truth/projection model, containment, and verification laws."},
      {"path": "@AGENTS.md", "purpose": "Global repository instructions."},
      {"path": "@documents/security/SECURITY_POLICY.cac.json", "purpose": "Authoritative security policy."},
      {"path": "@documents/security/THREAT_MODEL.cac.json", "purpose": "Threat model baseline."},
      {"path": "@documents/security/SECRETS_MANAGEMENT.cac.json", "purpose": "Secrets controls."},
      {"path": "@documents/security/NETWORK_DEFENSE.cac.json", "purpose": "Network and interface threat matrix."},
      {"path": "@documents/skills/rust-standards/SKILL.md", "purpose": "Rust correctness and safety standards."},
      {"path": "@documents/skills/rust-standards/references/12_rust_soundness_and_unsafe.md", "purpose": "Unsafe/soundness obligations."},
      {"path": "@documents/skills/rust-standards/references/19_unsafe_rust_obligations.md", "purpose": "Unsafe audit checklist."},
      {"path": "@documents/skills/rust-standards/references/21_concurrency_atomics_memory_order.md", "purpose": "Concurrency and memory-ordering risks."},
      {"path": "@documents/skills/rust-standards/references/23_async_pin_cancellation.md", "purpose": "Async cancellation and resource safety."},
      {"path": "@documents/skills/rust-standards/references/30_paths_filesystem_os.md", "purpose": "Filesystem/process boundary controls."},
      {"path": "@documents/skills/rust-standards/references/31_io_protocol_boundaries.md", "purpose": "Untrusted input and protocol handling."},
      {"path": "@documents/skills/rust-standards/references/34_security_adjacent_rust.md", "purpose": "Security-adjacent anti-patterns."},
      {"path": "@documents/skills/rust-standards/references/39_hazard_catalog_checklists.md", "purpose": "Security hazard catalog."},
      {"path": "@documents/skills/rust-standards/references/42_distributed_security_invariants.md", "purpose": "Distributed invariant checks."},
      {"path": "@documents/skills/rust-standards/references/42_pcac_ajc_integration.md", "purpose": "PCAC/AJC lifecycle integration checks for authority-bearing handlers."},
      {"path": "@documents/skills/rust-standards/references/01_contract_and_truth.md", "purpose": "Primitive soundness invariants: type validity, initialization, pointer provenance, aliasing."},
      {"path": "@documents/skills/rust-standards/references/03_compilation_pipeline.md", "purpose": "Macro expansion security, hidden unsafe, cfg-dependent code drift, dark code testing."},
      {"path": "@documents/skills/rust-standards/references/05_toolchain_cargo_build.md", "purpose": "Build-time code execution, supply chain injection, feature safety, reproducibility."},
      {"path": "@documents/skills/rust-standards/references/09_ownership_borrowing_model.md", "purpose": "Ownership authority, interior mutability protocols, reference invalidation, synchronization."},
      {"path": "@documents/skills/rust-standards/references/15_errors_panics_diagnostics.md", "purpose": "Panic-as-DoS, panic safety for unsafe, unwind boundaries, cascading failures."},
      {"path": "@documents/skills/rust-standards/references/32_testing_fuzz_miri_evidence.md", "purpose": "Verification methodology and tool gates: Miri, Loom, Proptest, Kani for risk anchors."},
      {"path": "@documents/skills/rust-standards/references/41_apm2_safe_patterns_and_anti_patterns.md", "purpose": "APM2 security contracts: typed IDs, secret redaction, state machines, atomic writes, identity boundaries, fail-closed defaults."},
      {"path": "@documents/skills/rust-standards/references/44_deterministic_simulated_testing.md", "purpose": "Deterministic simulated testing — hermetic isolation, env var mutation hazards, side-effect capture, simulation harnesses for security-critical state machines."},
      {"path": "@documents/skills/modes-of-reasoning/assets/79-adversarial-red-team.json", "purpose": "REQUIRED REASONING MODE: Attacker mindset — systematically discover exploitable weaknesses via attack trees and exploit paths."},
      {"path": "@documents/skills/modes-of-reasoning/assets/36-assurance-case.json", "purpose": "REQUIRED REASONING MODE: Defender mindset — verify security claims are backed by traceable evidence, not just assertions."},
      {"path": "@documents/skills/modes-of-reasoning/assets/40-mechanistic.json", "purpose": "REQUIRED REASONING MODE: Causal tracing — trace data flow through trust boundaries to identify where security invariants break."}
    ],
    "decision_tree": {
      "entrypoint": "STEP_1_PREPARE",
      "nodes": [
        {
          "id": "STEP_1_PREPARE",
          "purpose": "Discover the CLI surface and materialize local review inputs.",
          "steps": [
            {"action": "command", "run": "apm2 fac review prepare --help"},
            {"action": "command", "run": "apm2 fac review finding --help"},
            {"action": "command", "run": "apm2 fac review verdict set --help"},
            {
              "action": "command",
              "run": "apm2 fac review prepare --pr $PR_NUMBER --sha $HEAD_SHA",
              "capture_as": "prepare_json"
            },
            {
              "action": "parse_json",
              "from": "prepare_json",
              "extract": ["pr_number", "diff_path", "commit_history_path", "diff_content", "commit_history_content", "output_mode", "inline_line_limit", "inline_line_count", "omitted_line_count", "diff", "commit_history"]
            },
            {
              "action": "on_failure",
              "if": "prepare command fails OR diff_path is empty",
              "then": "Jump to STEP_4_VERDICT with verdict=deny reason='prepare failed: no review inputs available'"
            }
          ],
          "next": "STEP_2_STUDY"
        },
        {
          "id": "STEP_2_STUDY",
          "purpose": "Internalize all reference material and PR context before analysis.",
          "steps": [
            {
              "action": "read_all_references",
              "rule": "Read every file listed in the references[] section IN FULL. Do not summarize, skip, or skim — details matter. Each reference contains threat vectors, invariants, checklists, and anti-patterns that are load-bearing for security review accuracy. Incomplete internalization produces false negatives."
            },
            {"action": "use_captured", "from": "diff_content", "purpose": "Full PR diff from prepare output"},
            {"action": "use_captured", "from": "commit_history_content", "purpose": "Commit history from prepare output"},
            {
              "action": "fallback_rule",
              "rule": "If `diff_content` or `commit_history_content` includes an inline-omission marker from prepare output, read full content from `diff_path` and `commit_history_path` before analysis."
            },
            {
              "action": "read_module_agents",
              "rule": "For each crate/module touched by the PR diff, locate and read its AGENTS.json (if it exists) in full. These files follow the apm2.agents_context.v1 schema (see documents/schemas/apm2.agents_context.v1.schema.json) and can be queried with jq — e.g. `jq '[.behaviors[] | select(.kind==\"safety\")]'`. They contain module-specific invariants and safety properties whose violation constitutes a security finding."
            },
            {
              "action": "selective_read",
              "rule": "Read additional RFC/ticket/security docs only when the diff references them or changes trust boundaries."
            }
          ],
          "next": "STEP_3_ANALYZE_AND_EMIT"
        },
        {
          "id": "STEP_3_ANALYZE_AND_EMIT",
          "purpose": "Apply required reasoning modes to the diff, emit each finding immediately.",
          "modes_of_reasoning": {
            "instruction": "Apply ALL three modes below to every changed trust boundary, handler, and data flow in the diff. The rust-standards references encode the invariants — these modes tell you HOW to reason about them.",
            "modes": [
              {
                "mode": "documents/skills/modes-of-reasoning/assets/79-adversarial-red-team.json",
                "apply": "For each changed surface: enumerate attacker goals, build attack trees, trace exploit paths from untrusted input to privileged effect. Every trust boundary crossing in the diff gets an attack tree."
              },
              {
                "mode": "documents/skills/modes-of-reasoning/assets/36-assurance-case.json",
                "apply": "For each security claim implied by the code (e.g. 'HMAC prevents tampering', 'capacity cap prevents DoS'): decompose into sub-claims, verify each sub-claim has traceable evidence in the diff or existing code. Unsubstantiated claims are findings."
              },
              {
                "mode": "documents/skills/modes-of-reasoning/assets/40-mechanistic.json",
                "apply": "For each changed component: trace the causal chain from input through internal state to output/side-effect. Identify where invariants could break under novel conditions not covered by the happy path."
              }
            ]
          },
          "emit_rule": {
            "action": "For each finding, classify severity (BLOCKER, MAJOR, MINOR, NIT) and call:",
            "command": "apm2 fac review finding --pr $PR_NUMBER --sha $HEAD_SHA --type security --severity <severity> --summary \"<one-line>\" --risk \"<threat and exploit path>\" --impact \"<blast radius and consequences>\" --location \"<file:line or module>\" --body \"<detailed description and required remediation>\"",
            "quality_rules": [
              "Each finding MUST include: summary, risk (threat + exploit path), impact (blast radius), location, and body (remediation).",
              "If a handler has authority-bearing side effects but lacks AJC lifecycle enforcement, emit a MAJOR finding.",
              "For prior-round findings that are now resolved, emit with --severity NIT and note the resolution in --body."
            ]
          },
          "tally": ["blocker_count", "major_count", "minor_count", "nit_count"],
          "next": "STEP_4_VERDICT"
        },
        {
          "id": "STEP_4_VERDICT",
          "purpose": "Set the verdict. This is the ONLY exit point — every execution path MUST reach this step.",
          "decisions": [
            {
              "if": "blocker_count == 0 AND major_count == 0",
              "then": {
                "action": "command",
                "run": "apm2 fac review verdict set --pr $PR_NUMBER --sha $HEAD_SHA --dimension security --verdict approve --reason \"PASS: no blocker or major findings\""
              }
            },
            {
              "if": "blocker_count > 0 OR major_count > 0",
              "then": {
                "action": "command",
                "run": "apm2 fac review verdict set --pr $PR_NUMBER --sha $HEAD_SHA --dimension security --verdict deny --reason \"FAIL: <blocker_count> blocker, <major_count> major findings\""
              }
            }
          ],
          "stop": true
        }
      ]
    }
  }
}
