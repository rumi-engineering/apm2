---
name: holonic-agent-network
description: Theoretical foundations for holonic agent coordination. Defines axioms, boundaries, and protocols for multi-agent systems.
user-invocable: false
---

## Reference Documents

| Document | Purpose |
|----------|---------|
| [Principia Holonica](references/principia-holonic.md) | **Axiomatic law for agents.** Defines existence (Markov blanket), truth topology (ledger), holarchy physics, resource boundedness, and the algorithm of action. Read this first. |
| [Agent-Native Software](references/agent-native-software.md) | **Architectural doctrine.** Problem statement, canonical terminology (Work Substrate, Plan, ChangeSet, Gate, Finding, Countermeasure), spec/state separation, internal forge model, and recurrence feedback loops. |

---

Holonic systems describe complex organizations as recursive compositions of units (“holons”) that function as autonomous actors while also operating as constrained parts of larger aggregates. A holon is characterized by its externally observable interface, the boundary conditions under which it operates, and the invariants it is obligated to preserve. A holarchy is the resulting composition across scales; in software settings this composition may be represented as a hierarchy, a partially ordered set, or an overlay network, depending on membership and dependency structure.

In software engineering, a holonic boundary is treated as a contract surface. The contract specifies admissible inputs, outputs, and state transitions, and it constrains side effects and authority. Inputs are typically modeled as typed work requests, constraints, and references to context and policies. Outputs are modeled as artifacts and declared external effects. Allowed state transitions are defined by an explicit lifecycle that includes success states, failure states, retry states, and escalation states. Boundary invariants include safety properties, integrity properties, and operational properties such as idempotency requirements and monotonicity constraints.

In agent-native software systems, a holon is modeled as a runtime envelope that hosts one or more language-model-driven agents and the tool interfaces available to them. The language model is treated as a probabilistic worker that executes within bounded episodes, while the envelope is treated as the durable locus of state, authority, and governance. The envelope mediates access to tools, constrains side effects, records outputs, and enforces policy. The holon interface provides standardized operations for work intake, artifact emission, verification, and escalation.

Agent execution is modeled as episodic control under bounded context windows. Each episode instantiates an agent with a curated context package consisting of the goal specification, the current tracked state of the work, applicable constraints and budgets, and references to relevant artifacts and evidence. The agent produces proposals, intermediate artifacts, and tool invocation requests. The envelope validates requests, executes permitted tool calls, collects outputs, and persists accepted artifacts. Episode results update a structured progress state that can be used to formulate subsequent episodes. The episode loop terminates under explicit stop conditions computed by the envelope over structured state.

Holonic control is commonly described using cybernetic terminology. A holon is treated as a controller that observes signals, evaluates deviation from a target, selects actions under constraints, and applies actions through interfaces to an environment. In software, observation corresponds to reading repository state, build and test outcomes, policy decisions, telemetry, and incident states. Decision corresponds to selecting work steps and tool actions subject to authorization and resource budgets. Action corresponds to applying code changes, executing tests, producing release artifacts, and performing controlled operational operations. The update step corresponds to verifying outputs and committing durable records and state transitions.

Resource boundedness is treated as a formal discipline. Budgets are specified for time, compute, tool invocations, monetary spend, and rate limits, and they are enforced by the envelope rather than asserted by agent narrative. Authority is often modeled as time-bounded and scope-bounded leases that grant permissions for specific actions within a defined window, with revocation and expiration semantics. Boundedness also includes constraints on retry behavior, branching behavior, and logging or telemetry volume, typically implemented via quotas and backpressure.

Stop conditions are expressed as checkable predicates over structured signals. Goal satisfaction is modeled as the conjunction of acceptance criteria satisfaction and the presence of required evidence artifacts, along with successful completion of mandated checks. Risk boundaries are modeled as policy violations, missing evidence, attempted unauthorized side effects, or invocation of disallowed tools or dependencies. Diminishing-return boundaries are modeled as repeated unsuccessful episodes without new observable progress, exhaustion of budget, or failure to acquire required information. Escalation triggers are modeled as ambiguity in requirements, conflicting constraints, or operations above a configured risk tier.

Work tracking is represented by first-class work objects with stable identities. A work object includes a WorkID, a lifecycle state, a set of bound requirements and constraints, and an explicit list of produced artifacts. Attempts are recorded with AttemptIDs or EpisodeIDs that capture the episodic provenance of agent runs. Inputs and outputs are represented as typed references rather than free-form narrative. Progress state includes completed subgoals, open risks, unresolved questions, and the next-step plan, each represented as structured fields suitable for deterministic evaluation and policy checks.

Holonic SDLC decomposition is expressed as traceable refinement across artifact levels rather than lossless compilation. Higher-level artifacts such as PRDs and RFCs bind to lower-level work units such as tickets and patches through explicit identifiers and relationships. Refinement steps record assumptions introduced during disambiguation, tradeoffs and constraints, and the mapping from acceptance criteria to verification artifacts. Bidirectional links are maintained so that lower-level changes can be traced back to originating requirements and decisions, and operational feedback can be attributed to the changes and rationale that produced it.

Verification and trust separation are modeled by treating language-model inference as untrusted or probabilistic and the envelope’s enforcement mechanisms as trusted within a defined threat model. Capability-based access control constrains tool usage via explicit allowlists and least-privilege scopes. Deterministic checks include compilation, static analysis, schema validation, unit and integration tests, and policy rule evaluation. Evidence collection consists of durable references to produced artifacts, tool outputs, and check results, annotated with provenance metadata such as policy version, environment identity, and input digests. Sandbox isolation controls execution environment resources and boundaries, and it constrains network egress, filesystem access, and secret material.

Evidence is preferred over narrative as the basis of system truth claims. Assertions such as “tests passed,” “build reproducible,” or “requirement satisfied” are represented as check results with explicit parameters: which tests, which inputs, which environment, which outputs, and which policy interpretation. Evidence bundles are structured collections of artifacts and check outputs sufficient to justify a state transition such as merge acceptance, release promotion, or deployment approval. The integrity of evidence requires explicit trust assumptions and mechanisms, including tamper-evidence via hashing and signing, provenance capture, access control, and replayability where required.

Durable state is commonly represented as a durable record plus derived projections. The durable record may be append-only event logs, audit logs, or transactional stores with write-ahead logging, depending on implementation. Derived state is computed from the durable record and current observations, and is used to drive stop conditions, scheduling decisions, and policy evaluation. Deterministic projection is achievable within constrained domains when inputs and projection code are controlled; in general systems must account for nondeterminism arising from time, IO, dependency resolution, and heterogeneous execution environments.

Identity and routing are treated as separate concerns from network endpoints. Logical identities for holons and agents are represented as stable identifiers that persist across process restarts and infrastructure churn. Mapping from identity to current transport locator requires discovery mechanisms. Identity issuance, rotation, and revocation are security-critical and must be defined in the trust model. Authorization binds capabilities to identities and scopes those capabilities to work items, environments, and policy versions. Replay protection and auditability require message authentication, nonces or counters, and explicit recording of command identifiers and idempotency keys.

Topology and membership are defined explicitly rather than assumed. Holonic overlays may be represented as graphs, with hierarchical views constructed for coordination when required. Membership semantics define how entities join and leave, how membership changes propagate, and what consistency properties are required for coordination. When exclusive ownership, leases, or global invariants are required, coordination typically depends on a quorum or consensus substrate. When high availability is prioritized under partitions, operations are constrained to commutative or reconcileable forms and reconciliation is treated as a first-class protocol.

Conflict resolution is modeled as deterministic protocol over explicit state machines where possible. Command handling uses idempotency keys to make retries safe under duplication. Work lifecycle transitions are defined as monotonic state changes with explicit preconditions and postconditions. Leases are used for exclusive actions such as merges and deployments, with defined semantics for expiration, renewal, and disputed ownership. Concurrent contributions are reconciled via merge strategies, conflict reports, and arbitration paths for high-impact disputes, and these mechanisms are represented as explicit transitions such as claim, execute, propose, verify, accept, reject, rollback, and escalate.

Observability is defined as causal reconstruction across boundaries. Correlation identifiers are propagated through work intake, episodes, tool calls, artifact production, and external side effects. Boundary events are emitted as structured records with stable schemas, enabling replay and analysis. Telemetry systems enforce controlled cardinality and sampling policies to prevent unbounded growth in identifier dimensions. The intended observable is a trace from data to decision that indicates which signals and evidence were used to justify actions and state transitions, independent of agent narrative.

Release and post-release control are modeled as governed protocols. Deployable changes are associated with content-addressed artifacts such as image digests and binary hashes, and with explicit configuration and flag states. Progressive delivery mechanisms such as staged rollouts and canaries are represented as protocol steps with defined promotion and rollback conditions, and rollbacks are modeled as testable actions with associated evidence. Post-release telemetry is linked back to originating work objects and evidence bundles via artifact identifiers and configuration provenance, enabling attribution from runtime outcomes to specific changes and decisions.

Learning and evolution are modeled as constrained modification of verification and policy. Operational failures are represented as candidates for new deterministic checks, regression tests, or policy refinements. Gate evolution is governed by meta-controls such as budget limits, corpus replay, canary validation, and rollback safety, and it is tracked via versioned policy artifacts. Metrics used for control are treated as projections from substrate events rather than narrative reports, and metric selection and aggregation are treated as part of the system’s governance surface.