{
  "schema": "cac.reasoning_mode.v1",
  "schema_version": "1.0.0",
  "kind": "reasoning.mode",
  "meta": {
    "stable_id": "dcp://apm2.agents/mor/mode/rough-set@1",
    "classification": "PUBLIC",
    "created_at": "2025-02-01T00:00:00Z"
  },
  "payload": {
    "id": 27,
    "name": "rough-set",
    "cat": "uncertain",
    "core": "Approximate concepts via lower and upper bounds based on indiscernibility: objects identical on observed features belong to the same equivalence class; lower approximation = classes wholly inside target; upper = classes overlapping target; boundary = upper minus lower (irreducible uncertainty from feature limitations)",
    "out": [
      "lower_approximation: set of objects definitely in concept (all equivalence-class members belong)",
      "upper_approximation: set of objects possibly in concept (at least one class member belongs)",
      "boundary_region: objects in upper but not lower (classification uncertain given features)",
      "approximation_quality: |lower|/|upper| ratio (1.0 = crisp, <1 = rough)",
      "reduct: minimal feature subset preserving classification power",
      "decision_rules: if-then rules extracted from lower approximation (certain) and boundary (possible)"
    ],
    "proc": [
      "1. Define universe U and feature set F; partition U into equivalence classes by indiscernibility on F",
      "2. For target concept X, compute lower(X) = union of equivalence classes entirely contained in X",
      "3. Compute upper(X) = union of equivalence classes overlapping X (intersection non-empty)",
      "4. Derive boundary(X) = upper(X) - lower(X); quantify as |boundary|/|U| uncertainty ratio",
      "5. Calculate approximation quality = |lower|/|upper|; if < threshold, seek additional features",
      "6. Identify reducts: find minimal feature subsets that preserve the original partition granularity",
      "7. Extract decision rules: certain rules from lower (no exceptions), possible rules from boundary (may have exceptions)"
    ],
    "check": [
      "Equivalence classes derived from actual feature values, not assumed similarity",
      "Lower approximation membership is provable from features, not stipulated",
      "Boundary region explicitly quantified and reported, never silently collapsed",
      "Approximation quality ratio computed and compared to domain-appropriate threshold",
      "Feature set adequacy assessed: would adding features shrink boundary?",
      "Reducts identified to reveal which features are dispensable vs essential"
    ],
    "quick_checklist": [
      "Did I partition by observed features, not intuited similarity?",
      "Is my lower approximation truly certain (all class members in target)?",
      "Have I reported boundary size as explicit uncertainty?",
      "Did I compute approximation quality ratio?",
      "Have I considered whether more features would reduce boundary?"
    ],
    "diff": {
      "fuzzy-logic": {
        "boundary": "Rough sets: uncertainty from feature granularity (epistemic) | Fuzzy: graded membership from vague predicates (semantic)",
        "mechanism": "Rough: equivalence classes from discrete features | Fuzzy: membership function assigning degree 0-1",
        "output": "Rough: three regions (lower/boundary/upper) | Fuzzy: continuous membership grade",
        "choose_rough_when": "Uncertainty stems from limited observation, not inherent vagueness of concept"
      },
      "imprecise-probability": {
        "boundary": "Rough sets: bounds on set membership | Imprecise prob: bounds on probability values",
        "mechanism": "Rough: partition-based from features | Imprecise: interval [p_lower, p_upper] from incomplete elicitation",
        "output": "Rough: definite/possible/excluded | Imprecise: probability interval",
        "choose_rough_when": "Question is 'which set?' not 'how likely?'"
      },
      "prototype-similarity-based": {
        "boundary": "Rough: equivalence classes from identical feature values | Prototype: distance to exemplar",
        "mechanism": "Rough: crisp partition into classes | Prototype: graded similarity metric",
        "output": "Rough: class membership certain/uncertain/excluded | Prototype: similarity score to each prototype",
        "choose_rough_when": "Features are discrete/categorical; no meaningful distance metric exists"
      },
      "evidential-dempster-shafer": {
        "boundary": "Rough: boundary from feature indiscernibility | DS: belief/plausibility gap from evidence combination",
        "mechanism": "Rough: partition by features | DS: mass functions combined via Dempster's rule",
        "output": "Rough: three-region membership | DS: belief ≤ probability ≤ plausibility interval",
        "choose_rough_when": "Working with classification from features, not combining independent evidence sources"
      }
    },
    "common_confusions": [
      {
        "confusion": "Using rough sets when concept is inherently vague (e.g., 'tall')",
        "problem": "Rough sets model epistemic uncertainty from limited features, not semantic vagueness",
        "correct_mode": "fuzzy-logic for predicates with graded truth"
      },
      {
        "confusion": "Treating boundary region as 'probably in' vs 'probably out'",
        "problem": "Boundary means genuinely undecidable given features, not probabilistic",
        "correct_mode": "Use imprecise-probability or Bayesian if you need probability estimates"
      },
      {
        "confusion": "Computing distance between objects to form equivalence classes",
        "problem": "Rough sets require identical feature values, not similarity",
        "correct_mode": "prototype-similarity-based for distance/similarity metrics"
      }
    ],
    "fail": {
      "mode": "approximation_overconfidence",
      "desc": "Treating weak feature approximations as definitive classifications; claiming small boundary without justifying feature adequacy",
      "signals": [
        "Small boundary claimed despite few features or coarse feature granularity",
        "Lower approximation asserted without verifying all equivalence class members satisfy target",
        "Boundary region collapsed into lower or upper without additional evidence",
        "Approximation quality not computed or reported",
        "Feature limitations not disclosed when presenting classifications"
      ],
      "mit": [
        {
          "mitigation": "Compute and report approximation quality ratio |lower|/|upper|",
          "test": "Ratio explicitly stated; if < 0.8, uncertainty prominently flagged"
        },
        {
          "mitigation": "Perform reduct analysis to identify minimal sufficient features",
          "test": "Reducts enumerated; dispensable features identified"
        },
        {
          "mitigation": "Report boundary size as percentage of universe",
          "test": "|boundary|/|U| ratio stated; > 20% triggers explicit uncertainty warning"
        },
        {
          "mitigation": "List features that would reduce boundary if available",
          "test": "At least one potential discriminating feature identified when boundary > 10%"
        },
        {
          "mitigation": "Distinguish certain rules (from lower) vs possible rules (from boundary)",
          "test": "Each decision rule tagged as 'certain' or 'possible'; no unlabeled rules"
        }
      ]
    },
    "use": [
      "Interpretable classification when features are categorical or discretized",
      "Rule extraction from decision tables with incomplete information",
      "Feature reduction: finding minimal feature sets (reducts) preserving classification",
      "Medical diagnosis with limited test results (features = available test values)",
      "Data mining when explicit uncertainty regions are valuable",
      "Situations where 'unknown' is a valid classification outcome"
    ],
    "rel": [
      "fuzzy-logic",
      "imprecise-probability",
      "prototype-similarity-based",
      "inductive",
      "evidential-dempster-shafer",
      "many-valued-partial-logics"
    ],
    "micro_example": {
      "scenario": "Classify loan applications as Approve/Reject given features: Income={High,Med,Low}, History={Good,Bad}",
      "universe": ["A1(High,Good,Approve)", "A2(High,Good,Approve)", "A3(Med,Good,Approve)", "A4(Med,Bad,Reject)", "A5(Low,Bad,Reject)", "A6(Med,Bad,Approve)"],
      "equivalence_classes": {
        "(High,Good)": ["A1", "A2"],
        "(Med,Good)": ["A3"],
        "(Med,Bad)": ["A4", "A6"],
        "(Low,Bad)": ["A5"]
      },
      "target_approve": ["A1", "A2", "A3", "A6"],
      "lower_approximation": ["A1", "A2", "A3"],
      "lower_explanation": "(High,Good) and (Med,Good) classes entirely in Approve",
      "upper_approximation": ["A1", "A2", "A3", "A4", "A6"],
      "upper_explanation": "(Med,Bad) overlaps Approve (A6), so included",
      "boundary": ["A4", "A6"],
      "boundary_explanation": "(Med,Bad) class has both Approve and Reject; cannot classify with certainty",
      "approximation_quality": "3/5 = 0.6 (rough concept; 2 of 6 objects uncertain)",
      "decision_rules": [
        "IF Income=High AND History=Good THEN Approve [certain]",
        "IF Income=Med AND History=Good THEN Approve [certain]",
        "IF Income=Low AND History=Bad THEN Reject [certain]",
        "IF Income=Med AND History=Bad THEN ? [boundary - need more features]"
      ]
    }
  }
}
