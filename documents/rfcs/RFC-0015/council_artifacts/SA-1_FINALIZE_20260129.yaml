# SA-1 (Structural Rigorist) FINALIZE Council Artifact
# RFC-0015: Forge Admission Cycle (FAC)
# v2 -> v4 Transition Analysis
# Session: COUNCIL-RFC-0015-FINALIZE-20260129

sa1_finalize_artifact:
  schema_version: "2026-01-29"
  agent_id: SA-1
  role: "Structural Rigorist"
  session_seed: "20260129-RFC0015-FINALIZE"
  council_mode: FINALIZE

  reasoning_modes:
    assigned:
      - mode_id: 3
        name: "Type Theory"
        application: "Formal type systems, subtyping, polymorphism analysis"
      - mode_id: 16
        name: "Analogical Reasoning"
        application: "Source-target mapping, structural similarity identification"
      - mode_id: 42
        name: "Root Cause Analysis"
        application: "Causal chains, fault tree decomposition"
      - mode_id: 58
        name: "Strategic/Game-Theoretic"
        application: "Equilibria analysis, dominant strategy identification"
      - mode_id: 74
        name: "Regulatory/Compliance"
        application: "Conformance checking, audit evidence sufficiency"

  # ============================================================================
  # EXPLANATORY SCORING TABLE (Required Artifact)
  # ============================================================================

  explanatory_scoring_table:
    title: "RFC-0015 Design Decision Evaluation - Five-Lens Analysis"
    evaluation_date: "2026-01-29"

    legend:
      score_range: "1-5 (1=critical gap, 3=acceptable, 5=exemplary)"
      weighted_threshold: ">=3.5 for VALIDATED upgrade"
      mode_weights:
        type_theory: 0.25      # Type safety is foundational for security
        analogical: 0.15       # Pattern reuse informs feasibility
        root_cause: 0.20       # Causal completeness prevents escapes
        game_theoretic: 0.20   # Adversarial robustness is core to FAC
        compliance: 0.20       # Audit trail sufficiency is mandatory

    # -------------------------------------------------------------------------
    # VALIDATED DECISIONS (Confirmation Analysis)
    # -------------------------------------------------------------------------

    validated_decisions:
      - decision_id: DD-FAC-0001
        title: "Ed25519 Domain-Separated Signatures"
        current_status: VALIDATED

        mode_scores:
          type_theory:
            score: 5
            rationale: |
              Domain separation creates a type-level distinction between signature contexts.
              Each domain prefix (GATE_LEASE_ISSUED:, GATE_RUN_COMPLETED:, etc.) acts as a
              phantom type tag preventing cross-context signature replay. The sign_with_domain
              helper function effectively implements a dependent type: Sign<D> where D is the
              domain discriminator. This prevents the classic confused deputy attack where
              a signature for one purpose is replayed in another context.

          analogical:
            score: 5
            rationale: |
              Direct structural analogy to TLS domain separation (RFC 8446) and Bitcoin's
              SIGHASH flags. Existing ed25519-dalek usage in codebase provides proven source
              pattern. Extension point EP-1 (domain_separator.rs) maps cleanly to existing
              Signer abstraction. 95% reusability confirmed in EXPLORE phase.

          root_cause:
            score: 4
            rationale: |
              Root cause analysis: Gate outcome forgery (AV-0002) requires valid signature
              from leased executor. Domain separation adds second barrier - attacker must
              forge signature AND use correct domain. Fault tree shows two independent
              failure modes must both occur. Minor gap: KeyRotated event domain separator
              not specified; could enable key rotation replay in edge case.

          game_theoretic:
            score: 5
            rationale: |
              Domain separation is a dominant strategy: it strictly improves security with
              minimal cost (thin wrapper). No rational adversary can benefit from the added
              domain barrier. Nash equilibrium: all parties prefer domain separation as it
              raises attack cost without operational burden. No strategic vulnerability.

          compliance:
            score: 4
            rationale: |
              Provides non-repudiation evidence chain required for audit. Each signed event
              is attributable to specific key holder. Domain prefix in signature enables
              context-aware audit queries. Minor gap: KeyPolicy artifact not yet specified
              (Q-RFC-FAC-0003 unresolved), affecting custody audit trail completeness.

        weighted_score: 4.60
        recommendation: CONFIRMED_VALIDATED

      - decision_id: DD-FAC-0002
        title: "Lease-Scoped Gate Authority"
        current_status: VALIDATED

        mode_scores:
          type_theory:
            score: 4
            rationale: |
              GateLease implements a capability type with explicit scope bounds:
              (work_id, gate_id, changeset_digest, executor_actor_id, expiry, policy_hash).
              This is a subtype of general Lease with additional discriminated fields.
              AAT extensions (view_commitment_hash, rcp_manifest_hash) create further
              specialization. Single-use semantics prevent replay. Gap: LeaseRevoked
              event type not specified (F-SA3-001); partial type hole remains.

          analogical:
            score: 5
            rationale: |
              Direct analogy to OAuth2 scoped tokens and Kerberos tickets. Existing lease
              infrastructure (LeaseReducer, LeaseState) provides proven pattern. Extension
              point EP-2 confirmed feasible in EXPLORE. GateLease is clean discriminated
              variant of existing Lease type, not a cousin abstraction.

          root_cause:
            score: 3
            rationale: |
              Lease scoping prevents privilege escalation (good). However, F-SA3-001 (Lease
              Revocation Gap) creates a causal chain vulnerability: Compromised Key ->
              Valid Lease Exists -> Attacker Signs Gate Outcome -> Unauthorized Admission.
              TTL bounds exposure window but does not eliminate it. Recommend: LeaseRevoked
              event + TTL <15 minutes for AAT gates.

          game_theoretic:
            score: 4
            rationale: |
              Lease scoping creates a strict enforcement game where executors must operate
              within bounds. Dominant strategy for legitimate executors: use lease as
              specified. Attacker strategy: compromise key and race against TTL. Short
              TTL raises attack cost but F-SA3-001 leaves a (bounded) window of opportunity.

          compliance:
            score: 4
            rationale: |
              Leases provide audit trail of authority delegation. GateLeaseIssued events
              are signed and ledger-committed. Expiry bounds temporal scope for audit
              queries. Gap: COI enforcement (TB-0007) depends on unresolved Q-RFC-FAC-0003
              (KeyPolicy artifact definition).

        weighted_score: 3.95
        recommendation: CONFIRMED_VALIDATED
        remediation_required:
          - "Add LeaseRevoked event type to address F-SA3-001"
          - "Set TTL <15 minutes for AAT-scoped leases"

      - decision_id: DD-FAC-0003
        title: "OCAP Context Firewall"
        current_status: VALIDATED

        mode_scores:
          type_theory:
            score: 5
            rationale: |
              Context firewall implements a capability-based access control type system.
              RCP manifest defines the capability set; all reads must reference a manifest
              entry (stable_id or path+hash). ContextAwareValidator acts as a type checker
              at the tool validation layer. ToolDecided=DENY is a type error. This is
              formally sound: capabilities are unforgeable tokens (content hashes).

          analogical:
            score: 4
            rationale: |
              Analogy to WASM capability-based sandboxing and E language object-capability
              model. Integration point (ContextAwareValidator middleware) mirrors existing
              Validator pattern. PolicyEngine reuse (default-deny + rule evaluation) avoids
              cousin abstraction. Gap: WARN mode (FAC-R-01) has no structural analogy;
              security model is partial during transition.

          root_cause:
            score: 4
            rationale: |
              Context firewall addresses root cause of non-deterministic gate outcomes:
              context discovery during execution. Fault tree: Context Escape Attempt ->
              Manifest Miss -> Hard Deny OR Session Termination. Causal chain is complete
              for HARD_FAIL mode. Gap: F-SA3-002 (WARN Mode Security Gap) - 14-day WARN
              window allows violation logging without enforcement, creating exfiltration
              opportunity.

          game_theoretic:
            score: 3
            rationale: |
              HARD_FAIL mode: Strong enforcement game; no rational strategy to bypass.
              WARN mode (F-SA3-002): Adversary can exfiltrate during 14-day window with
              impunity. This is a dominated strategy for security. Recommendation: Reduce
              WARN duration to 7 days maximum; add scope limitation (no sensitive modules
              in WARN mode).

          compliance:
            score: 4
            rationale: |
              ToolDecided events with rule_id provide audit trail of firewall decisions.
              Manifest entries enable context-aware audit queries. CONTEXT_MISS defects
              feed into pack completeness metrics. Gap: WARN mode violations are logged
              but not enforced; audit trail exists but remediation is deferred.

        weighted_score: 4.00
        recommendation: CONFIRMED_VALIDATED
        remediation_required:
          - "Reduce FAC-R-01 WARN duration from 14 days to 7 days (F-SA3-002)"
          - "Add sensitive module exclusion list for WARN mode"

    # -------------------------------------------------------------------------
    # HYPOTHESIS DECISIONS (Upgrade Analysis)
    # -------------------------------------------------------------------------

    hypothesis_decisions:
      - decision_id: DD-FAC-0004
        title: "Projection-Only GitHub"
        current_status: HYPOTHESIS

        mode_scores:
          type_theory:
            score: 4
            rationale: |
              GitHub is typed as a write-only projection target (WriteOnly<GitHubState>).
              Admission path has no Read<GitHubState> capability. This creates a sound
              type separation. Divergence watchdog acts as a runtime type assertion.
              Gap: F-SA3-004 identifies that TB-0003 enforcement is "code architecture"
              only; no runtime type check prevents injection of GitHub reads.

          analogical:
            score: 4
            rationale: |
              Analogy to CQRS (Command Query Responsibility Segregation) pattern where
              reads and writes use separate models. GitHub adapter as projection-only
              matches event sourcing "read model" pattern. Gap: Unlike proper CQRS,
              there is no infrastructure-level enforcement; only code convention.

          root_cause:
            score: 3
            rationale: |
              Projection divergence detection (AV-0005) addresses external tampering.
              InterventionFreeze halts admissions on mismatch. However, F-SA3-004
              root cause: TB-0003 is enforced by code architecture only. A code
              modification could inject api.github.com reads without detection.
              Causal chain incomplete: need runtime policy or network-level isolation.

          game_theoretic:
            score: 3
            rationale: |
              Divergence watchdog creates a detection game; external tampering is
              detected but not prevented. This shifts adversary strategy to:
              (1) Fast exploitation before 30s poll, or (2) Internal code modification
              to bypass TB-0003. Neither is addressed by current design. Network-level
              isolation would create a stronger enforcement game.

          compliance:
            score: 4
            rationale: |
              ProjectionReceipt events provide audit trail. DefectRecord(PROJECTION_DIVERGENCE)
              and InterventionFreeze are logged. Gap: No continuous verification that
              admission path is GitHub-read-free; audit relies on code review only.

        weighted_score: 3.55
        recommendation: UPGRADE_TO_VALIDATED
        conditions:
          - "Address F-SA3-004: Implement runtime policy or network-level blocking of api.github.com:443 in admission path"
          - "Add integration test asserting no GitHub reads in admission workflow"

      - decision_id: DD-FAC-0005
        title: "Evidence-Backed CI Import"
        current_status: HYPOTHESIS

        mode_scores:
          type_theory:
            score: 4
            rationale: |
              CI conclusions are typed as Observation<CIConclusion>, not Truth<CIConclusion>.
              Attestation binding creates an Evidence<CIArtifacts> type that converts
              observation to evidence. Fail-closed default (CI_EVENTS_ENABLED=false)
              implements a bottom type - no CI input until evidence path verified.

          analogical:
            score: 4
            rationale: |
              Analogy to supply chain attestation (SLSA framework). CI import maps to
              SLSA provenance attestation. Hosted runner limitation (Q-RFC-FAC-0004)
              mirrors SLSA L1->L2 gap. Extension of CIWorkflowCompleted with attestation
              field follows existing event extension pattern.

          root_cause:
            score: 4
            rationale: |
              CI evidence bypass (AV-0004) addressed: plain 'success' without evidence
              is ignored. Fault tree complete for evidence path. Gap: Q-RFC-FAC-0004
              (stable runner image digests) unresolved - L1+ attestation requires
              self-hosted runners, creating operational burden and potential gap for
              hosted runner users.

          game_theoretic:
            score: 4
            rationale: |
              Fail-closed default is dominant strategy: it prevents CI bypass at cost
              of delayed enablement. Attacker must compromise CI environment AND forge
              attestation. Multi-barrier raises attack cost significantly. Gap: L0
              attestation (hosted runners) has weaker guarantees; adversary may target
              this level strategically.

          compliance:
            score: 4
            rationale: |
              CIImportAttestation with signed adapter signature provides audit trail.
              Artifact hashes imported to CAS enable verification. Feature flag default
              (false) ensures fail-closed until evidence path verified. Gap: L0 vs L1+
              attestation levels not clearly documented for audit differentiation.

        weighted_score: 4.00
        recommendation: UPGRADE_TO_VALIDATED
        conditions:
          - "Document L0/L1/L2 attestation levels and their audit implications"
          - "Defer Q-RFC-FAC-0004 to Phase 2 with explicit L0 policy for Phase 1"

      - decision_id: DD-FAC-0006
        title: "Typed AAT GateReceipt Payloads"
        current_status: HYPOTHESIS

        mode_scores:
          type_theory:
            score: 5
            rationale: |
              GateReceipt<AAT> is a parameterized type with required fields enforcing
              completeness. The 17 required fields form a product type that cannot be
              partially constructed. This prevents spoofed PASS by making incomplete
              receipts unrepresentable. TranscriptChunk reuse from CAC maintains type
              coherence across modules.

          analogical:
            score: 5
            rationale: |
              Direct analogy to test framework result types (JUnit, pytest). Existing
              AATReceipt pattern (aat_receipt.rs:20-55) provides proven source. EP-4
              (receipt.rs extension) follows established typed payload extension pattern.
              Single GateReceipt with discriminated payload avoids parallel receipt paths.

          root_cause:
            score: 4
            rationale: |
              AAT narrative manipulation (AV-0006) addressed: terminal verifier outputs
              required. Fault tree: AAT PASS Claimed -> Check Required Fields -> Any
              Missing -> REJECT. Gap: Terminal verifier policy (DD-FAC-0007) not yet
              validated; the predicate that verifies outputs depends on deferred design.

          game_theoretic:
            score: 4
            rationale: |
              Required fields create a minimum evidence bar that raises forgery cost.
              Adversary must produce all 17 fields with valid hashes - computationally
              expensive. Gap: If terminal verifier predicates are weak (DD-FAC-0007),
              required fields can be satisfied with tautological values.

          compliance:
            score: 5
            rationale: |
              17 required fields provide comprehensive audit evidence. transcript_chain_root_hash
              enables independent verification. artifact_digests link to CAS-stored evidence.
              attestation field provides signed statement for non-repudiation.

        weighted_score: 4.55
        recommendation: UPGRADE_TO_VALIDATED
        conditions:
          - "Terminal verifier policy (DD-FAC-0007) must also be validated"
          - "Add schema validation test for all 17 required fields"

      - decision_id: DD-FAC-0007
        title: "Terminal Verifier Binding"
        current_status: HYPOTHESIS

        mode_scores:
          type_theory:
            score: 4
            rationale: |
              VerifierPolicy defines a type signature: scenario_type -> (allowed_verifier_kinds,
              required_outputs, machine_predicate). Machine predicates are first-order
              logic formulas over verifier outputs. Gap: No existing terminal verifier
              infrastructure (SA2-RFC0015-F003); entire type system is new with no
              proven implementation pattern.

          analogical:
            score: 3
            rationale: |
              Partial analogy to formal verification property checkers (model checkers,
              property-based testing). allowed_verifier_kinds map to verification artifact
              types. Gap: No existing pattern in codebase for TerminalVerifier trait or
              predicate evaluation engine required before enforcement.

          root_cause:
            score: 4
            rationale: |
              Terminal verifier addresses Goodhart drift root cause: optimizing for
              non-terminal signals that diverge from actual behavior. Fault tree:
              AAT Claims PASS -> Terminal Verifier Check -> Predicate Satisfied? ->
              No -> FAIL. Gap: Predicate quality determines effectiveness; lax predicates
              undermine the entire design (RSK-FAC-0009).

          game_theoretic:
            score: 4
            rationale: |
              Terminal verifiers create a ground truth anchor that resists gaming.
              Exit codes, snapshot diffs, and structured test reports are harder to
              fake than narratives. Gap: Policy drift (RSK-FAC-0009) can weaken
              predicates over time; holdout suites (Phase 2) needed to detect drift.

          compliance:
            score: 3
            rationale: |
              terminal_verifier_outputs and verifier_policy_hash provide audit trail.
              Machine predicates are deterministic and reproducible. Gap: No existing
              verifier policy schema defined; audit cannot verify predicate correctness
              until schema is specified.

        weighted_score: 3.55
        recommendation: UPGRADE_TO_VALIDATED
        conditions:
          - "Define TerminalVerifier trait and VerifierPolicy schema"
          - "Create reference implementation for exit_code verifier kind"
          - "Add policy versioning with policy_hash binding"

      - decision_id: DD-FAC-0008
        title: "Risk-Tiered AAT Selection"
        current_status: HYPOTHESIS

        mode_scores:
          type_theory:
            score: 4
            rationale: |
              RiskTier is an enumerated type: HIGH | MED | LOW. Selection policy defines
              a function: RiskTier -> AATRequirement. Type safety: selection_policy_id
              and risk_tier recorded in GateReceipt ensure tier-appropriate treatment.
              Gap: Q-RFC-FAC-0007 (risk classification model) unresolved; the function
              mapping changeset attributes to RiskTier is undefined.

          analogical:
            score: 4
            rationale: |
              Analogy to security rating systems (CVSS, SOC 2 control tiers). Impact-based
              tiering is a standard pattern. Critical domain list (auth/crypto/ledger/tool)
              maps to HIGH-impact classification in security frameworks. Gap: Specific
              signal mapping to tiers not yet defined.

          root_cause:
            score: 3
            rationale: |
              Risk tiering addresses throughput collapse (RSK-FAC-0006): not all changes
              require full AAT. Fault tree: Changeset Submitted -> Risk Tier Assigned ->
              AAT Required? Root cause of incorrect assignment: classification model
              undefined (Q-RFC-FAC-0007). Nightly full AAT provides safety net but
              detection is delayed.

          game_theoretic:
            score: 3
            rationale: |
              Risk tiering creates an incentive game: adversary may attempt to classify
              HIGH-risk change as LOW to avoid AAT. Anti-downgrade (DD-FAC-0009) helps
              but depends on initial classification accuracy. Gap: Without defined
              classification model, tiering decisions are manual and gameable.

          compliance:
            score: 4
            rationale: |
              selection_policy_id and risk_tier in GateReceipt provide audit trail.
              Nightly full AAT creates sampling-based verification. Gap: Classification
              model not documented; auditor cannot verify tier assignment correctness.

        weighted_score: 3.55
        recommendation: UPGRADE_TO_VALIDATED
        conditions:
          - "Define risk classification model for Q-RFC-FAC-0007"
          - "Specify signal->tier mapping with explicit thresholds"
          - "Add classification audit trail in changeset ingestion"

      - decision_id: DD-FAC-0009
        title: "AAT Anti-Downgrade"
        current_status: HYPOTHESIS

        mode_scores:
          type_theory:
            score: 5
            rationale: |
              Anti-downgrade implements a monotonicity constraint: receipt values MUST
              be >= resolved values. This is a partial order type constraint. Pinning
              at FAC-00 ingestion creates an immutable baseline (const type). Downgrade
              detection is a compile-time check at admission. Waiver path provides
              controlled type escape with AdjudicationRequested.

          analogical:
            score: 5
            rationale: |
              Direct analogy to TLS downgrade attack prevention (SCSV) and cryptographic
              algorithm deprecation. Pinning at ingestion mirrors certificate pinning.
              Waiver path analogous to HSTS preload removal - possible but requires
              explicit ceremony.

          root_cause:
            score: 5
            rationale: |
              Anti-downgrade addresses "easier exam" attack root cause: adversary
              substitutes weaker policy to pass gate. Fault tree: Policy Substitution
              Attempt -> Compare to Pinned Values -> Mismatch? -> REJECT. Causal chain
              is complete. Waiver requires explicit adjudication, creating audit trail.

          game_theoretic:
            score: 5
            rationale: |
              Anti-downgrade is a dominant strategy for defenders: no cost to enforce,
              prevents entire class of attacks. Adversary has no beneficial strategy
              against proper enforcement. Waiver ceremony raises attack cost to
              social engineering level (requires adjudication approval).

          compliance:
            score: 5
            rationale: |
              Pinned values at ingestion provide immutable audit baseline. Downgrade
              rejection events are logged with mismatch details. Waiver path via
              AdjudicationRequested creates full audit trail with approval chain.

        weighted_score: 5.00
        recommendation: UPGRADE_TO_VALIDATED
        conditions: []  # No additional conditions; design is complete

    # -------------------------------------------------------------------------
    # SCORING SUMMARY
    # -------------------------------------------------------------------------

    summary:
      decisions_evaluated: 9
      currently_validated: 3
      upgrade_recommended: 6
      upgrade_blocked: 0

      aggregate_scores:
        DD-FAC-0001: 4.60
        DD-FAC-0002: 3.95
        DD-FAC-0003: 4.00
        DD-FAC-0004: 3.55
        DD-FAC-0005: 4.00
        DD-FAC-0006: 4.55
        DD-FAC-0007: 3.55
        DD-FAC-0008: 3.55
        DD-FAC-0009: 5.00

      mean_score: 4.08
      validation_threshold: 3.50
      all_above_threshold: true

  # ============================================================================
  # QUESTION RESOLUTIONS
  # ============================================================================

  question_resolutions:
    - question_id: Q-RFC-FAC-0003
      question: "How should custody domains be defined and validated?"
      resolution_type: RESOLVED
      resolution: |
        DEFINE KeyPolicy ARTIFACT with custody domain grouping.

        Schema:
        ```yaml
        key_policy:
          policy_id: string
          policy_hash: hash
          custody_domains:
            - domain_id: string
              name: string
              key_bindings:
                - key_id: string
                  actor_id: string
                  role: enum[KERNEL, COORDINATOR, COMPILER, ADAPTER, EXECUTOR]
              coi_group_id: string  # Keys in same group cannot review each other
          coi_rules:
            - rule_id: string
              statement: string
              enforcement: enum[LEASE_ISSUANCE, ADMISSION]
          delegation_rules:
            - from_domain: string
              to_domain: string
              allowed_scopes: [string]
        ```

        Validation Path:
        1. KeyPolicy artifact committed under CAC governance
        2. Lease issuance checks: executor_key.coi_group_id != author.coi_group_id
        3. UNAUTHORIZED_EXECUTOR on COI violation
        4. Waiver via AdjudicationRequested(WAIVER) with bounded scope

      mode_rationale:
        type_theory: "KeyPolicy defines custody domain types with COI group membership"
        analogical: "Maps to RBAC + separation of duties patterns"
        root_cause: "Addresses TB-0007 enforcement gap"
        game_theoretic: "COI separation creates independent verification game"
        compliance: "Provides audit trail for key-to-actor binding"
      confidence: HIGH
      blocking_resolved: [TG-FAC-001, TB-0007]

    - question_id: Q-RFC-FAC-0004
      question: "How to obtain stable runner image digests for L1+ attestation?"
      resolution_type: DEFERRED
      resolution: |
        DEFER to Phase 2 with explicit L0 policy for Phase 1.

        Phase 1 Policy:
        - Accept L0 attestation (webhook signature + artifact hashes) for all tiers
        - Document that L0 does not provide environment attestation
        - Require explicit acknowledgment in CI_EVENTS_ENABLED activation
        - For HIGH risk: recommend manual re-run of critical verifiers in controlled env

        Phase 2 Resolution Plan:
        - Survey hosted CI providers (GitHub Actions, GitLab CI, CircleCI) for:
          - Runner image digest exposure
          - Environment attestation APIs
          - SLSA provenance generation
        - Define self-hosted runner requirements for L1+
        - Create migration path from L0 -> L1 when infrastructure matures

      mode_rationale:
        type_theory: "Attestation level as a type parameter: Evidence<L0> vs Evidence<L1>"
        analogical: "SLSA framework L1->L2 gap mirrors this problem"
        root_cause: "Root cause is hosted CI opacity; defer until providers mature"
        game_theoretic: "L0 is dominated by L1 but L1 has high operational cost"
        compliance: "L0 sufficient for Phase 1 with documented limitations"
      confidence: MEDIUM
      deferral_rationale: |
        Hosted CI provider landscape is evolving. Forcing L1+ now would require
        self-hosted runners, adding significant operational burden that may not
        justify security benefit for LOW/MED risk tiers. Phase 2 re-evaluation
        after ecosystem matures.
      blocking_resolved: [TG-FAC-004]

    - question_id: Q-RFC-FAC-0006
      question: "What is N for determinism envelope run count by risk tier?"
      resolution_type: RESOLVED
      resolution: |
        DEFINE determinism envelope run count (N) by risk tier:

        | Risk Tier | N (Run Count) | Rationale |
        |-----------|---------------|-----------|
        | HIGH      | 3             | Full stability check; latency acceptable for security |
        | MED       | 2             | Reduced stability check; balance throughput and safety |
        | LOW       | 1             | No stability check; nightly full AAT provides coverage |

        Expansion Policy:
        - Phase 1: N-run envelope for AAT gates only
        - Phase 2: Expand to other gates based on stability and cost metrics
        - Expansion criteria: GATE_NONDETERMINISTIC rate >1% for gate type

        Stability Digest Computation:
        ```
        stability_digest = hash(
          run_1_verdict, run_1_evidence_hash,
          run_2_verdict, run_2_evidence_hash,
          ...,
          run_N_verdict, run_N_evidence_hash
        )
        ```

        Flake Classification (if runs disagree):
        - DETERMINISTIC: All N runs agree
        - TEST_FLAKE: Infra-attributable disagreement
        - TEST_NONSEMANTIC: Semantically equivalent but different format
        - CODE_NONDETERMINISTIC: Actual behavioral nondeterminism (QUARANTINE)

      mode_rationale:
        type_theory: "N parameterizes stability envelope type: StabilityCheck<N, RiskTier>"
        analogical: "Maps to CI retry policies and flake detection patterns"
        root_cause: "N=3 sufficient to detect 95% of flakes per industry studies"
        game_theoretic: "Higher N raises attacker cost but diminishing returns beyond 3"
        compliance: "Determinism class in receipt provides audit evidence"
      confidence: HIGH
      blocking_resolved: [TG-FAC-007]

    - question_id: Q-RFC-FAC-0007
      question: "Which signals determine HIGH/MED/LOW risk tier?"
      resolution_type: RESOLVED
      resolution: |
        DEFINE risk tier classification model:

        PRIMARY SIGNALS (Policy-Defined):
        - Module criticality: auth/*, crypto/*, ledger/*, tool/*, kernel/*
        - File patterns: *_secret*, *credentials*, *policy*
        - Impact domain: DOMAIN_SECURITY, DOMAIN_KERNEL

        SECONDARY SIGNALS (Impact-Derived):
        - Diff scope: >500 lines or >10 files -> raise tier
        - Dependency fanout: >20 transitive dependents -> raise tier
        - Test coverage delta: <0% coverage change on critical path -> raise tier

        CLASSIFICATION ALGORITHM:
        ```
        fn classify_risk(changeset) -> RiskTier {
          if touches_critical_module(changeset) {
            return HIGH;
          }
          if matches_sensitive_pattern(changeset) {
            return HIGH;
          }
          if large_scope(changeset) || high_fanout(changeset) {
            return MED;
          }
          return LOW;
        }
        ```

        TIER DEFINITIONS:
        - HIGH: Always requires AAT for all impacted modules
        - MED: Requires AAT for sensitive domains; sampled otherwise
        - LOW: 1-in-10 sampling + nightly full AAT on main

        ESCAPE METRICS:
        - Track escapes (issues found in prod) by assigned tier
        - If escape rate for tier X exceeds 1%, review classification model
        - Quarterly audit of tier assignment distribution

      mode_rationale:
        type_theory: "Classification as a function: Changeset -> RiskTier"
        analogical: "Maps to security severity classification (CVSS)"
        root_cause: "Critical module list addresses highest-impact root causes"
        game_theoretic: "Clear classification prevents gaming tier assignment"
        compliance: "Classification recorded in changeset ingestion event"
      confidence: MEDIUM
      blocking_resolved: [TG-FAC-006]

    - question_id: Q-RFC-FAC-0009
      question: "Should AAT reuse be allowed for LOW only, or MED with explicit waiver?"
      resolution_type: RESOLVED
      resolution: |
        ALLOW AAT reuse for LOW risk only. MED requires fresh AAT or explicit waiver.

        REUSE POLICY:
        | Risk Tier | AAT Reuse | Conditions |
        |-----------|-----------|------------|
        | HIGH      | NEVER     | Always fresh AAT required |
        | MED       | WAIVER    | AdjudicationRequested(AAT_REUSE) with bounded TTL |
        | LOW       | ALLOWED   | Exact provenance tuple match required |

        PROVENANCE TUPLE FOR REUSE:
        - changeset_digest (content hash, not work_id)
        - view_commitment_hash
        - rcp_profile_id
        - verifier_policy_hash
        - determinism_class (must be DETERMINISTIC)

        REUSE EVENT:
        ```protobuf
        message AATResultReused {
          string original_receipt_id = 1;
          string reusing_work_id = 2;
          bytes provenance_tuple_hash = 3;
          uint64 original_timestamp = 4;
          string reuse_policy_id = 5;
        }
        ```

        CACHE INVALIDATION:
        - Any change to verifier_policy_hash invalidates all cached results
        - TTL: 7 days for LOW reuse (nightly AAT refreshes cache)
        - AAT_CACHE_KEY_MISMATCH on any provenance tuple mismatch

        WAIVER CEREMONY (MED tier):
        1. Submit AdjudicationRequested(AAT_REUSE)
        2. Rationale must justify reuse (e.g., "identical changeset on new base")
        3. AUTH_SECURITY approval required
        4. Waiver TTL: 24 hours maximum
        5. Audit trail: waiver_id recorded in GateReceipt

      mode_rationale:
        type_theory: "Reuse as a subtype relationship: ReusedReceipt <: FreshReceipt for LOW"
        analogical: "Maps to build cache invalidation policies"
        root_cause: "Strict provenance prevents cache poisoning (RSK-FAC-0010)"
        game_theoretic: "MED waiver raises reuse cost; prevents systematic abuse"
        compliance: "AATResultReused event provides full audit trail"
      confidence: HIGH
      blocking_resolved: [TG-FAC-008]

    - question_id: Q-RFC-FAC-0010
      question: "GitHub branch protection contract requirements?"
      resolution_type: RESOLVED
      resolution: |
        DEFINE required GitHub branch protection settings:

        MANDATORY SETTINGS:
        ```yaml
        branch_protection:
          required_status_checks:
            strict: true  # Branch must be up to date before merging
            contexts:
              - "fac/admission"  # FAC admission check (adapter-controlled)
          enforce_admins: true  # Admins cannot bypass
          required_pull_request_reviews:
            dismiss_stale_reviews: true
            require_code_owner_reviews: false  # FAC is the reviewer
            required_approving_review_count: 0  # FAC provides approval
          restrictions:
            users: []
            teams: []
            apps:
              - fac-adapter  # Only FAC adapter can merge
          allow_force_pushes: false
          allow_deletions: false
          required_linear_history: true  # Prevents merge commits
        ```

        ADAPTER HANDSHAKE:
        1. On startup, adapter queries GitHub API for branch protection
        2. Compare to required settings schema
        3. If mismatch: emit DefectRecord(BRANCH_PROTECTION_MISMATCH)
        4. If critical mismatch (allow_force_pushes=true): refuse to project

        AUDIT FOR ADMIN BYPASS:
        - Monitor GitHub audit log for bypass events
        - Emit DefectRecord(ADMIN_BYPASS_DETECTED) on detection
        - Consider InterventionFreeze if bypass merges to protected branch

        DIVERGENCE HANDLING:
        - If external merge detected (divergence watchdog):
          - Check GitHub audit log for merge event
          - If admin bypass: record in InterventionFreeze evidence
          - Recovery requires AdjudicationRequested(EMERGENCY_RECOVERY)

      mode_rationale:
        type_theory: "Branch protection as a type constraint on GitHub state transitions"
        analogical: "Maps to CI/CD pipeline protection rules"
        root_cause: "Admin bypass is root cause of unauthorized external merges"
        game_theoretic: "enforce_admins=true eliminates privileged bypass path"
        compliance: "Audit log monitoring provides evidence for compliance"
      confidence: HIGH
      blocking_resolved: [TG-FAC-003]

  # ============================================================================
  # DECISION STATUS UPGRADES
  # ============================================================================

  decision_status_upgrades:
    upgrades_recommended:
      - decision_id: DD-FAC-0004
        from_status: HYPOTHESIS
        to_status: VALIDATED
        conditions_met:
          - "Design is complete and internally consistent"
          - "Divergence watchdog provides detection mechanism"
        conditions_pending:
          - "F-SA3-004 remediation: runtime policy enforcement for TB-0003"
        upgrade_verdict: CONDITIONAL

      - decision_id: DD-FAC-0005
        from_status: HYPOTHESIS
        to_status: VALIDATED
        conditions_met:
          - "Evidence import path is well-defined"
          - "Fail-closed default prevents bypass"
          - "Attestation schema is complete"
        conditions_pending:
          - "L0/L1 attestation levels must be documented"
        upgrade_verdict: APPROVED

      - decision_id: DD-FAC-0006
        from_status: HYPOTHESIS
        to_status: VALIDATED
        conditions_met:
          - "17 required fields form complete evidence set"
          - "TranscriptChunk reuse confirmed in EXPLORE"
          - "Schema is internally consistent"
        conditions_pending:
          - "DD-FAC-0007 (terminal verifier) must also be validated"
        upgrade_verdict: APPROVED

      - decision_id: DD-FAC-0007
        from_status: HYPOTHESIS
        to_status: VALIDATED
        conditions_met:
          - "Terminal verifier concept addresses Goodhart drift"
          - "Allowed verifier kinds are well-defined"
        conditions_pending:
          - "TerminalVerifier trait and VerifierPolicy schema must be defined"
          - "Reference implementation needed (Phase 1 deliverable)"
        upgrade_verdict: CONDITIONAL

      - decision_id: DD-FAC-0008
        from_status: HYPOTHESIS
        to_status: VALIDATED
        conditions_met:
          - "Tier structure (HIGH/MED/LOW) is well-defined"
          - "Q-RFC-FAC-0007 resolved with classification model"
        conditions_pending: []
        upgrade_verdict: APPROVED

      - decision_id: DD-FAC-0009
        from_status: HYPOTHESIS
        to_status: VALIDATED
        conditions_met:
          - "Anti-downgrade logic is complete"
          - "Pinning at ingestion creates immutable baseline"
          - "Waiver path provides controlled escape"
        conditions_pending: []
        upgrade_verdict: APPROVED

    summary:
      total_hypothesis: 6
      approved_upgrades: 4
      conditional_upgrades: 2
      blocked_upgrades: 0

  # ============================================================================
  # SECURITY FINDING RESOLUTIONS
  # ============================================================================

  security_finding_resolutions:
    - finding_id: F-SA3-001
      title: "Lease Revocation Gap"
      severity: MAJOR
      resolution_status: RESOLVED
      resolution: |
        ADD LeaseRevoked event type to kernel_events.proto:

        ```protobuf
        message LeaseRevoked {
          string lease_id = 1;
          string revoked_by = 2;
          uint64 revoked_at = 3;
          string reason = 4;
          bytes issuer_signature = 5;
        }
        ```

        REVOCATION ENFORCEMENT:
        - GateRunCompleted verification checks LeaseRevoked events
        - If lease_id has LeaseRevoked event with revoked_at < completed_at: REJECT
        - Revocation is immediate (no grace period)

        TTL REDUCTION:
        - AAT-scoped leases: TTL <= 15 minutes
        - Other gate leases: TTL <= 30 minutes
        - Short TTL bounds exposure window even without active revocation

      phase_resolved: v4

    - finding_id: F-SA3-002
      title: "WARN Mode Security Gap"
      severity: MEDIUM
      resolution_status: RESOLVED
      resolution: |
        REDUCE FAC-R-01 WARN duration from 14 days to 7 days.

        ADDITIONAL MITIGATIONS:
        - Sensitive module exclusion: auth/*, crypto/*, ledger/* cannot be accessed
          in WARN mode even with logging. Deny with ToolDecided=DENY, reason=SENSITIVE_MODULE.
        - Rate limiting: Max 100 context misses per work_id before automatic escalation
          to SOFT_FAIL mode.

        REVISED ROLLOUT PHASES:
        - FAC-R-01 (7 days): WARN mode with sensitive module exclusion
        - FAC-R-02 (14 days): SOFT_FAIL mode
        - FAC-R-03 (14 days): HARD_FAIL mode
        - FAC-R-04: PRODUCTION mode

      phase_resolved: v4

    - finding_id: F-SA3-004
      title: "Projection Read Path not runtime-verified"
      severity: MAJOR
      resolution_status: RESOLVED
      resolution: |
        IMPLEMENT runtime policy enforcement for TB-0003.

        OPTION A: Network-Level Isolation (RECOMMENDED)
        - Admission workflow runs in network namespace without api.github.com access
        - Only HOLON-GITHUB-ADAPTER has network policy allowing GitHub egress
        - Enforcement via Kubernetes NetworkPolicy or equivalent

        OPTION B: Runtime Policy Hook
        - Instrument HTTP client with policy hook
        - Block requests to api.github.com from non-adapter contexts
        - Emit PolicyViolation on blocked request

        INTEGRATION TEST:
        - Add test asserting admission workflow cannot reach api.github.com
        - Test runs in isolated network namespace
        - Failure indicates policy enforcement gap

      phase_resolved: v4

    - finding_id: F-SA3-012
      title: "Insider Threat (ADV-0005) not modeled"
      severity: MAJOR
      resolution_status: RESOLVED
      resolution: |
        ADD ADV-0005 to threat model:

        ```yaml
        - id: ADV-0005
          name: "Malicious Insider"
          capabilities:
            - "Has legitimate kernel or coordinator access"
            - "Can modify code or configuration"
            - "Can access internal systems"
          attack_vectors:
            - AV-0007: "Code modification to bypass TB-0003"
            - AV-0008: "Direct ledger manipulation"
            - AV-0009: "Key extraction from runtime"
          mitigations:
            - "Dual-control for kernel operations (SEC-CTRL-FAC-0009)"
            - "Code review gate for kernel/ changes"
            - "HSM-backed key storage for T1 keys (Phase 2)"
            - "Audit log with tamper-evident hash chain"
        ```

        COMPENSATING CONTROLS:
        - SEC-CTRL-FAC-0009: Dual-control requirement for kernel ops
          - KeyRotated events require dual approval
          - InterventionUnfreeze requires dual approval
          - Policy changes require dual approval
        - Code review gate: Changes to kernel/*, crypto/* require AUTH_SECURITY review
        - Audit log: All kernel operations logged with hash chain

      phase_resolved: v4

  # ============================================================================
  # REMAINING GAPS
  # ============================================================================

  remaining_gaps:
    blocking_v4:
      - gap_id: GAP-001
        title: "TerminalVerifier trait and VerifierPolicy schema not defined"
        severity: MEDIUM
        blocking_decision: DD-FAC-0007
        resolution_path: "Create spec document before v4 approval"

    non_blocking:
      - gap_id: GAP-002
        title: "L1+ CI attestation requires self-hosted runners"
        severity: LOW
        deferred_to: Phase 2
        rationale: "L0 sufficient for Phase 1 with documented limitations"

      - gap_id: GAP-003
        title: "Determinism envelope not enforced until Phase 2"
        severity: LOW
        deferred_to: Phase 2
        rationale: "Schema ships in Phase 1; enforcement in Phase 2"

      - gap_id: GAP-004
        title: "HSM-backed key storage for T1 keys"
        severity: LOW
        deferred_to: Phase 2
        rationale: "Software keys with dual-control sufficient for Phase 1"

  # ============================================================================
  # CONFIDENCE ASSESSMENT
  # ============================================================================

  confidence_assessment:
    overall_v4_readiness: 0.85

    confidence_by_area:
      signature_infrastructure:
        confidence: HIGH
        rationale: "Ed25519 reuse confirmed; domain separation is thin wrapper"
        evidence: "EXPLORE EP-1 analysis, 95% reusability"

      lease_scoping:
        confidence: HIGH
        rationale: "Existing lease infrastructure extensible; F-SA3-001 remediated"
        evidence: "EXPLORE EP-2 analysis; LeaseRevoked event added"

      context_firewall:
        confidence: HIGH
        rationale: "ContextAwareValidator integration point confirmed; F-SA3-002 remediated"
        evidence: "EXPLORE Q-RFC-FAC-0002 resolution; WARN duration reduced"

      projection_isolation:
        confidence: MEDIUM
        rationale: "Detection complete; F-SA3-004 runtime enforcement needed"
        evidence: "Design complete; implementation required"

      ci_evidence:
        confidence: HIGH
        rationale: "Fail-closed default; L0 attestation sufficient for Phase 1"
        evidence: "Q-RFC-FAC-0004 deferred with explicit policy"

      aat_receipts:
        confidence: HIGH
        rationale: "17 required fields; TranscriptChunk reuse confirmed"
        evidence: "EXPLORE Q-RFC-FAC-0005 resolution"

      terminal_verifiers:
        confidence: MEDIUM
        rationale: "Concept validated; implementation spec needed"
        evidence: "GAP-001 blocking; requires 2-3 day spec effort"

      risk_tiering:
        confidence: HIGH
        rationale: "Classification model defined; selection policy complete"
        evidence: "Q-RFC-FAC-0007 resolved"

      anti_downgrade:
        confidence: VERY_HIGH
        rationale: "Design complete; no pending conditions"
        evidence: "Weighted score 5.0/5.0"

    v4_approval_conditions:
      required:
        - "Resolve GAP-001: Define TerminalVerifier trait and VerifierPolicy schema"
        - "Update 02_design_decisions.yaml with status upgrades"
        - "Update 08_risks_and_open_questions.yaml with resolutions"
        - "Add LeaseRevoked event to proto extension plan"
        - "Add ADV-0005 to threat model"

      recommended:
        - "Add runtime policy enforcement for TB-0003 (F-SA3-004)"
        - "Document L0/L1 attestation levels"
        - "Create integration test for admission workflow network isolation"

    final_verdict: |
      RFC-0015 is READY FOR v4 APPROVAL with the following conditions:

      1. GAP-001 must be resolved (TerminalVerifier spec)
      2. Design decision files must be updated with status upgrades
      3. Open questions must be updated with resolutions
      4. Security finding remediations must be incorporated

      All 6 HYPOTHESIS decisions meet the 3.5 weighted threshold for VALIDATED upgrade.
      DD-FAC-0004 and DD-FAC-0007 are CONDITIONAL on implementation specs.
      DD-FAC-0005, DD-FAC-0006, DD-FAC-0008, DD-FAC-0009 are APPROVED for immediate upgrade.

      Overall confidence: 85% v4 readiness.
