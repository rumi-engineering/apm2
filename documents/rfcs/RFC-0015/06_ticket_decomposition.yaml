rfc_ticket_decomposition:
  schema_version: "2026-01-29"

  status: POPULATED
  # Generated by DECOMPOSE mode from v4.1 RFC

  description: |
    Ticket decomposition for RFC-0015 (FAC - Forge Admission Cycle).
    34 atomic tickets organized into 12 ticket groups with explicit dependencies.
    Each ticket is completable in a single PR.

  planned_ticket_structure:
    # Preserved from v0 for reference
    ticket_groups:
      - group_id: TG-FAC-001
        name: "Gate Event Infrastructure"
        requirements:
          - FAC-REQ-0017
          - FAC-REQ-0018
        dependencies: []

      - group_id: TG-FAC-002
        name: "OCAP Context Firewall"
        requirements:
          - FAC-REQ-0001
        dependencies:
          - TG-FAC-001

      - group_id: TG-FAC-003
        name: "Projection and Divergence Watchdog"
        requirements:
          - FAC-REQ-0002
          - FAC-REQ-0019
        dependencies:
          - TG-FAC-001

      - group_id: TG-FAC-004
        name: "CI Evidence Import"
        requirements:
          - FAC-REQ-0003
        dependencies:
          - TG-FAC-001

      - group_id: TG-FAC-005
        name: "Typed AAT GateReceipt"
        requirements:
          - FAC-REQ-0004
          - FAC-REQ-0006
          - FAC-REQ-0007
        dependencies:
          - TG-FAC-001

      - group_id: TG-FAC-006
        name: "Risk-Tiered AAT Selection"
        requirements:
          - FAC-REQ-0009
          - FAC-REQ-0010
          - FAC-REQ-0012
        dependencies:
          - TG-FAC-005

      - group_id: TG-FAC-007
        name: "Determinism Envelope (Phase 2)"
        requirements:
          - FAC-REQ-0005
          - FAC-REQ-0008
        dependencies:
          - TG-FAC-005
        phase: PHASE-2

      - group_id: TG-FAC-008
        name: "AAT Reuse and Evidence Hygiene"
        requirements:
          - FAC-REQ-0013
          - FAC-REQ-0014
        dependencies:
          - TG-FAC-005

      - group_id: TG-FAC-009
        name: "AAT Quorum and Harness Sandboxing"
        requirements:
          - FAC-REQ-0015
          - FAC-REQ-0016
        dependencies:
          - TG-FAC-006
        phase: PHASE-2

      - group_id: TG-FAC-010
        name: "Invariant-First AAT Specs"
        requirements:
          - FAC-REQ-0011
        dependencies:
          - TG-FAC-005

      - group_id: TG-FAC-011
        name: "Atomic Merge Receipt"
        requirements:
          - FAC-REQ-0020
        dependencies:
          - TG-FAC-001

      - group_id: TG-FAC-012
        name: "Bounded Retries and Echo-Trap"
        requirements:
          - FAC-REQ-0021
        dependencies:
          - TG-FAC-001

  # =============================================================================
  # TICKETS
  # =============================================================================

  tickets:
    # =========================================================================
    # TG-FAC-001: Gate Event Infrastructure
    # =========================================================================

    - ticket_id: TCK-00202
      title: "FAC: Domain separator module and sign_with_domain helper"
      group_id: TG-FAC-001
      requirement_ids:
        - FAC-REQ-0017
      depends_on: []
      phase: PHASE-1
      clarifications:
        - "Domain separator format is strict concatenation of prefix bytes + canonical_bytes (no length prefix)."
        - "Domain prefixes are ASCII, all caps, trailing colon; mismatch is INVALID_SIGNATURE."

      files_to_create:
        - path: "crates/apm2-core/src/fac/mod.rs"
          purpose: "FAC module root with re-exports"
        - path: "crates/apm2-core/src/fac/domain_separator.rs"
          purpose: "Domain separator constants and sign_with_domain helper"

      files_to_modify:
        - path: "crates/apm2-core/src/lib.rs"
          changes: "Add pub mod fac;"

      implementation_steps:
        - step: 1
          action: "Create fac module directory"
          details: |
            mkdir -p crates/apm2-core/src/fac/
            Create mod.rs with module structure.

        - step: 2
          action: "Define domain separator constants"
          details: |
            pub const GATE_LEASE_ISSUED_PREFIX: &[u8] = b"GATE_LEASE_ISSUED:";
            pub const LEASE_REVOKED_PREFIX: &[u8] = b"LEASE_REVOKED:";
            pub const GATE_RUN_COMPLETED_PREFIX: &[u8] = b"GATE_RUN_COMPLETED:";
            pub const MERGE_RECEIPT_PREFIX: &[u8] = b"MERGE_RECEIPT:";
            pub const CI_IMPORT_ATTESTATION_PREFIX: &[u8] = b"CI_IMPORT_ATTESTATION:";
            pub const PROJECTION_RECEIPT_PREFIX: &[u8] = b"PROJECTION_RECEIPT:";
            pub const AAT_RESULT_REUSED_PREFIX: &[u8] = b"AAT_RESULT_REUSED:";
            pub const POLICY_RESOLVED_PREFIX: &[u8] = b"POLICY_RESOLVED_FOR_CHANGESET:";
            pub const GATE_RECEIPT_PREFIX: &[u8] = b"GATE_RECEIPT:";
            pub const QUARANTINE_EVENT_PREFIX: &[u8] = b"QUARANTINE_EVENT:";

        - step: 3
          action: "Implement sign_with_domain helper"
          details: |
            pub fn sign_with_domain(
                signer: &dyn Signer,
                domain_prefix: &[u8],
                canonical_bytes: &[u8],
            ) -> Result<Signature, SignError> {
                let mut message = Vec::with_capacity(domain_prefix.len() + canonical_bytes.len());
                message.extend_from_slice(domain_prefix);
                message.extend_from_slice(canonical_bytes);
                signer.sign(&message)
            }

            pub fn verify_with_domain(
                verifier: &dyn Verifier,
                domain_prefix: &[u8],
                canonical_bytes: &[u8],
                signature: &Signature,
            ) -> Result<(), VerifyError> {
                let mut message = Vec::with_capacity(domain_prefix.len() + canonical_bytes.len());
                message.extend_from_slice(domain_prefix);
                message.extend_from_slice(canonical_bytes);
                verifier.verify(&message, signature)
            }

        - step: 4
          action: "Add unit tests"
          details: |
            Test that signing with domain separator produces different signature than without.
            Test that verification fails with wrong domain prefix.
            Test round-trip sign/verify.

      acceptance_criteria:
        - criterion: "Domain separator constants are defined for all critical event types"
          verification: "Check that all 10 domain separators exist in domain_separator.rs"
        - criterion: "sign_with_domain helper produces domain-separated signatures"
          verification: "cargo test -p apm2-core domain_separator"
        - criterion: "Verification fails with wrong domain prefix"
          verification: "Unit test for cross-domain rejection"

      test_requirements:
        - test_id: UT-FAC-001-001
          description: "Test sign_with_domain produces valid signatures"
          verification_command: "cargo test -p apm2-core fac::domain_separator::tests"
        - test_id: UT-FAC-001-002
          description: "Test cross-domain signatures are rejected"
          verification_command: "cargo test -p apm2-core fac::domain_separator::tests::cross_domain"

    - ticket_id: TCK-00203
      title: "FAC: GateLease proto message and Rust types"
      group_id: TG-FAC-001
      requirement_ids:
        - FAC-REQ-0018
      depends_on:
        - TCK-00202
      phase: PHASE-1
      clarifications:
        - "issued_at/expires_at are observational only; time_envelope_ref is authoritative (HTF)."
        - "aat_extension is required iff gate_id==\"aat\"; otherwise MUST be None."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add GateLease and AatLeaseExtension messages to LeaseEvent oneof"

      files_to_create:
        - path: "crates/apm2-core/src/fac/lease.rs"
          purpose: "GateLease Rust types and validation"

      implementation_steps:
        - step: 1
          action: "Extend kernel_events.proto with GateLease"
          details: |
            message GateLease {
              string lease_id = 1;
              string work_id = 2;
              string gate_id = 3;
              bytes changeset_digest = 4;
              string executor_actor_id = 5;
              google.protobuf.Timestamp issued_at = 6;
              google.protobuf.Timestamp expires_at = 7;
              bytes policy_hash = 8;
              string issuer_actor_id = 9;
              bytes issuer_signature = 10;
              bytes time_envelope_ref = 11;
              AatLeaseExtension aat_extension = 12;
            }

            message AatLeaseExtension {
              bytes view_commitment_hash = 1;
              bytes rcp_manifest_hash = 2;
              string rcp_profile_id = 3;
              string selection_policy_id = 4;
            }

        - step: 2
          action: "Add GateLease to LeaseEvent oneof"
          details: |
            Extend existing LeaseEvent oneof with:
            GateLeaseIssued gate_lease_issued = 6;

        - step: 3
          action: "Create Rust types in fac/lease.rs"
          details: |
            pub struct GateLease {
                pub lease_id: LeaseId,
                pub work_id: WorkId,
                pub gate_id: GateId,
                pub changeset_digest: Hash,
                pub executor_actor_id: ActorId,
                pub issued_at: Timestamp,
                pub expires_at: Timestamp,
                pub policy_hash: Hash,
                pub issuer_actor_id: ActorId,
                pub issuer_signature: Signature,
                pub time_envelope_ref: TimeEnvelopeRef,
                pub aat_extension: Option<AatLeaseExtension>,
            }

        - step: 4
          action: "Implement Canonicalize trait for GateLease"
          details: |
            Implement canonical_bytes() for signing.
            Use deterministic field ordering.

        - step: 5
          action: "Add validation logic"
          details: |
            impl GateLease {
                pub fn validate_signature(&self, verifier: &dyn Verifier) -> Result<(), VerifyError> {
                    verify_with_domain(verifier, GATE_LEASE_ISSUED_PREFIX, &self.canonical_bytes(), &self.issuer_signature)
                }

                pub fn validate_scope(&self, parent: &GateLease) -> Result<(), ScopeError> {
                    // Subset rule: child cannot broaden scope
                }
            }

      acceptance_criteria:
        - criterion: "GateLease proto compiles without errors"
          verification: "cargo build -p apm2-core"
        - criterion: "GateLease Rust types match proto schema"
          verification: "Check struct fields match proto message"
        - criterion: "Signature validation uses domain separator"
          verification: "Unit test for validate_signature"

      test_requirements:
        - test_id: UT-FAC-002-001
          description: "Test GateLease serialization roundtrip"
          verification_command: "cargo test -p apm2-core fac::lease::tests"
        - test_id: UT-FAC-002-002
          description: "Test scope subset rule enforcement"
          verification_command: "cargo test -p apm2-core fac::lease::tests::scope"

    - ticket_id: TCK-00204
      title: "FAC: LeaseRevoked event type and enforcement"
      group_id: TG-FAC-001
      requirement_ids:
        - FAC-REQ-0018
      depends_on:
        - TCK-00203
      phase: PHASE-1
      clarifications:
        - "revoked_at is observational only; revocation is immediate per time_envelope_ref (HTF)."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add LeaseRevoked message"
        - path: "crates/apm2-core/src/fac/lease.rs"
          changes: "Add LeaseRevoked type and revocation checking"

      implementation_steps:
        - step: 1
          action: "Add LeaseRevoked proto message"
          details: |
            message LeaseRevoked {
              string lease_id = 1;
              string revoked_by = 2;
              google.protobuf.Timestamp revoked_at = 3;
              string reason = 4;
              bytes issuer_signature = 5;
              bytes time_envelope_ref = 6;
            }

        - step: 2
          action: "Create LeaseRevoked Rust type"
          details: |
            pub struct LeaseRevoked {
                pub lease_id: LeaseId,
                pub revoked_by: ActorId,
                pub revoked_at: Timestamp,
                pub reason: String,
                pub issuer_signature: Signature,
                pub time_envelope_ref: TimeEnvelopeRef,
            }

        - step: 3
          action: "Implement revocation checking"
          details: |
            pub fn is_lease_revoked(lease_id: &LeaseId, revocations: &[LeaseRevoked], at_tick: HtfTick) -> bool {
                revocations.iter().any(|r| r.lease_id == *lease_id && r.time_envelope_ref.tick() <= at_tick)
            }

      acceptance_criteria:
        - criterion: "LeaseRevoked event can be created and signed"
          verification: "Unit test for LeaseRevoked creation"
        - criterion: "Revocation lookup correctly identifies revoked leases"
          verification: "Unit test for is_lease_revoked"

      test_requirements:
        - test_id: UT-FAC-003-001
          description: "Test LeaseRevoked signature verification"
          verification_command: "cargo test -p apm2-core fac::lease::tests::revoked"

    - ticket_id: TCK-00205
      title: "FAC: GateRunCompleted event with signature verification"
      group_id: TG-FAC-001
      requirement_ids:
        - FAC-REQ-0017
      depends_on:
        - TCK-00202
        - TCK-00203
      phase: PHASE-1
      clarifications:
        - "completed_at is observational only; HTF time_envelope_ref governs expiry checks."
        - "gate_receipt_payload_type MUST be canonical: \"{payload_kind}:{payload_schema_version}\"."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add GateRunCompleted message to EvidenceEvent oneof"

      files_to_create:
        - path: "crates/apm2-core/src/fac/gate_run.rs"
          purpose: "GateRunCompleted type and admission verification"

      implementation_steps:
        - step: 1
          action: "Add GateRunCompleted proto message"
          details: |
            message GateRunCompleted {
              string gate_id = 1;
              string lease_id = 2;
              bytes changeset_digest = 3;
              string executor_actor_id = 4;
              bytes evidence_bundle_hash = 5;
              string gate_receipt_id = 6;
              google.protobuf.Timestamp completed_at = 7;
              bytes executor_signature = 8;
              bytes gate_receipt_payload_hash = 9;
              string gate_receipt_payload_type = 10;
            }

        - step: 2
          action: "Create GateRunCompleted Rust type"
          details: |
            pub struct GateRunCompleted {
                pub gate_id: GateId,
                pub lease_id: LeaseId,
                pub changeset_digest: Hash,
                pub executor_actor_id: ActorId,
                pub evidence_bundle_hash: Hash,
                pub gate_receipt_id: ReceiptId,
                pub completed_at: Timestamp,
                pub executor_signature: Signature,
                pub gate_receipt_payload_hash: Hash,
                pub gate_receipt_payload_type: String,
            }

        - step: 3
          action: "Implement admission verification"
          details: |
            impl GateRunCompleted {
                pub fn verify_for_admission(
                    &self,
                    lease: &GateLease,
                    revocations: &[LeaseRevoked],
                    verifier: &dyn Verifier,
                    completion_tick: HtfTick,
                ) -> Result<(), AdmissionError> {
                    // 1. Verify signature with domain separator
                    verify_with_domain(verifier, GATE_RUN_COMPLETED_PREFIX, &self.canonical_bytes(), &self.executor_signature)?;

                    // 2. Check lease_id matches
                    if self.lease_id != lease.lease_id {
                        return Err(AdmissionError::LeaseMismatch);
                    }

                    // 3. Check changeset_digest matches lease
                    if self.changeset_digest != lease.changeset_digest {
                        return Err(AdmissionError::ChangesetMismatch);
                    }

                    // 4. Check executor matches lease
                    if self.executor_actor_id != lease.executor_actor_id {
                        return Err(AdmissionError::UnauthorizedExecutor);
                    }

                    // 5. Check lease not revoked
                    if is_lease_revoked(&self.lease_id, revocations, completion_tick) {
                        return Err(AdmissionError::LeaseRevoked);
                    }

                    // 6. Check completion within lease expiry (HTF-based)
                    if !lease.time_envelope_ref.contains(completion_tick) {
                        return Err(AdmissionError::LeaseExpired);
                    }

                    Ok(())
                }
            }

      acceptance_criteria:
        - criterion: "GateRunCompleted signature verification uses domain separator"
          verification: "Unit test for verify_for_admission with valid signature"
        - criterion: "Invalid signatures are rejected with INVALID_SIGNATURE"
          verification: "Unit test for signature rejection"
        - criterion: "Expired leases are rejected"
          verification: "Unit test for lease expiry checking"
        - criterion: "Revoked leases are rejected"
          verification: "Unit test for revocation checking"

      test_requirements:
        - test_id: UT-FAC-004-001
          description: "Test GateRunCompleted admission verification happy path"
          verification_command: "cargo test -p apm2-core fac::gate_run::tests::admission"
        - test_id: UT-FAC-004-002
          description: "Test invalid signature rejection"
          verification_command: "cargo test -p apm2-core fac::gate_run::tests::invalid_sig"

    - ticket_id: TCK-00206
      title: "FAC: PolicyResolvedForChangeSet event"
      group_id: TG-FAC-001
      requirement_ids:
        - FAC-REQ-0116
      depends_on:
        - TCK-00202
      phase: PHASE-1
      clarifications:
        - "resolved_rcp_profile_ids are lexicographically sorted; resolved_rcp_manifest_hashes align by index."
        - "resolved_verifier_policy_hashes are sorted lexicographically for canonicalization."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add PolicyResolvedForChangeSet message"

      files_to_create:
        - path: "crates/apm2-core/src/fac/policy_resolution.rs"
          purpose: "Policy resolution anchor event"

      implementation_steps:
        - step: 1
          action: "Add PolicyResolvedForChangeSet proto message"
          details: |
            message PolicyResolvedForChangeSet {
              string work_id = 1;
              bytes changeset_digest = 2;
              bytes resolved_policy_hash = 3;
              string resolved_risk_tier = 4;
              uint32 resolved_determinism_class = 5;
              repeated string resolved_rcp_profile_ids = 6;
              repeated bytes resolved_rcp_manifest_hashes = 7;
              repeated bytes resolved_verifier_policy_hashes = 8;
              string resolver_actor_id = 9;
              string resolver_version = 10;
              bytes resolver_signature = 11;
            }

        - step: 2
          action: "Create Rust type and validation"
          details: |
            pub struct PolicyResolvedForChangeSet { ... }

            impl PolicyResolvedForChangeSet {
                pub fn verify_lease_match(&self, lease: &GateLease) -> Result<(), PolicyMismatchError> {
                    if lease.policy_hash != self.resolved_policy_hash {
                        return Err(PolicyMismatchError::PolicyHashMismatch);
                    }
                    // Verify rcp_manifest_hash is in resolved list for AAT leases
                    Ok(())
                }

                pub fn verify_receipt_match(&self, receipt: &AatGateReceipt) -> Result<(), PolicyMismatchError> {
                    // Anti-downgrade checks
                }
            }

      acceptance_criteria:
        - criterion: "PolicyResolvedForChangeSet binds resolved policy tuple"
          verification: "Unit test for creation and signing"
        - criterion: "Lease policy hash mismatch is detected"
          verification: "Unit test for verify_lease_match"

      test_requirements:
        - test_id: UT-FAC-005-001
          description: "Test policy resolution anchor creation"
          verification_command: "cargo test -p apm2-core fac::policy_resolution::tests"

    - ticket_id: TCK-00207
      title: "FAC: GateReceipt envelope with versioning"
      group_id: TG-FAC-001
      requirement_ids:
        - FAC-REQ-0119
      depends_on:
        - TCK-00202
      phase: PHASE-1
      clarifications:
        - "canonical_bytes uses deterministic ordering, no maps; unknown versions rejected in enforce mode only."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add GateReceipt envelope message"

      files_to_create:
        - path: "crates/apm2-core/src/fac/receipt.rs"
          purpose: "GateReceipt envelope types and versioning"

      implementation_steps:
        - step: 1
          action: "Add GateReceipt proto message"
          details: |
            message GateReceipt {
              string receipt_id = 1;
              string gate_id = 2;
              string lease_id = 3;
              bytes changeset_digest = 4;
              string executor_actor_id = 5;
              uint32 receipt_version = 6;
              string payload_kind = 7;
              string payload_schema_version = 8;
              bytes payload_hash = 9;
              bytes evidence_bundle_hash = 10;
              bytes receipt_signature = 11;
            }

        - step: 2
          action: "Create GateReceipt Rust type"
          details: |
            pub struct GateReceipt {
                pub receipt_id: ReceiptId,
                pub gate_id: GateId,
                pub lease_id: LeaseId,
                pub changeset_digest: Hash,
                pub executor_actor_id: ActorId,
                pub receipt_version: u32,
                pub payload_kind: String,
                pub payload_schema_version: String,
                pub payload_hash: Hash,
                pub evidence_bundle_hash: Hash,
                pub receipt_signature: Signature,
            }

        - step: 3
          action: "Implement version validation"
          details: |
            const SUPPORTED_RECEIPT_VERSIONS: &[u32] = &[1];
            const SUPPORTED_PAYLOAD_KINDS: &[&str] = &["aat", "quality", "security"];

            pub fn validate_version(&self, enforce_mode: bool) -> Result<(), VersionError> {
                if enforce_mode && !SUPPORTED_RECEIPT_VERSIONS.contains(&self.receipt_version) {
                    return Err(VersionError::UnknownReceiptVersion(self.receipt_version));
                }
                Ok(())
            }

      acceptance_criteria:
        - criterion: "GateReceipt envelope includes versioning fields"
          verification: "Check struct has receipt_version, payload_kind, payload_schema_version"
        - criterion: "Unknown versions rejected in enforce mode"
          verification: "Unit test for version validation"

      test_requirements:
        - test_id: UT-FAC-006-001
          description: "Test GateReceipt version validation"
          verification_command: "cargo test -p apm2-core fac::receipt::tests"

    - ticket_id: TCK-00208
      title: "FAC: KeyPolicy artifact types for COI enforcement"
      group_id: TG-FAC-001
      requirement_ids:
        - FAC-REQ-0010
      depends_on:
        - TCK-00202
      phase: PHASE-1
      clarifications:
        - "KeyPolicy artifact is stored in CAS; policy_hash is blake3 of canonical bytes."
        - "author_actor_id comes from ChangeSetIngested metadata; COI checks use that binding."

      files_to_create:
        - path: "crates/apm2-core/src/fac/key_policy.rs"
          purpose: "KeyPolicy artifact for custody domains and COI"

      implementation_steps:
        - step: 1
          action: "Define KeyPolicy types"
          details: |
            pub struct KeyPolicy {
                pub policy_id: String,
                pub policy_hash: Hash,
                pub schema_version: String,
                pub custody_domains: Vec<CustodyDomain>,
                pub coi_rules: Vec<CoiRule>,
                pub delegation_rules: Vec<DelegationRule>,
            }

            pub struct CustodyDomain {
                pub domain_id: String,
                pub coi_group_id: String,
                pub key_bindings: Vec<KeyBinding>,
            }

            pub struct KeyBinding {
                pub key_id: String,
                pub actor_id: ActorId,
                pub role_ids: Vec<String>,
            }

            pub struct CoiRule {
                pub rule_id: String,
                pub statement: String,
                pub enforcement: CoiEnforcement,
            }

        - step: 2
          action: "Implement COI validation at lease issuance"
          details: |
            impl KeyPolicy {
                pub fn validate_coi(
                    &self,
                    executor_key_id: &str,
                    author_actor_id: &ActorId,
                ) -> Result<(), CoiViolationError> {
                    let executor_group = self.get_coi_group(executor_key_id)?;
                    let author_group = self.get_coi_group_for_actor(author_actor_id)?;
                    if executor_group == author_group {
                        return Err(CoiViolationError::SameCoiGroup);
                    }
                    Ok(())
                }
            }

      acceptance_criteria:
        - criterion: "KeyPolicy defines custody domains with COI groups"
          verification: "Check KeyPolicy struct has custody_domains field"
        - criterion: "COI validation prevents executor from reviewing own changeset"
          verification: "Unit test for validate_coi"

      test_requirements:
        - test_id: UT-FAC-007-001
          description: "Test COI validation"
          verification_command: "cargo test -p apm2-core fac::key_policy::tests"

    # =========================================================================
    # TG-FAC-002: OCAP Context Firewall
    # =========================================================================

    - ticket_id: TCK-00209
      title: "FAC: ContextPackManifest types and allowlist matching"
      group_id: TG-FAC-002
      requirement_ids:
        - FAC-REQ-0001
      depends_on: []
      phase: PHASE-1
      clarifications:
        - "Paths are normalized (no '..', no symlink traversal) before allowlist match."
        - "ReadWithZoom requires content_hash match; Read may omit content_hash."

      files_to_create:
        - path: "crates/apm2-core/src/context/manifest.rs"
          purpose: "ContextPackManifest for OCAP allowlist"
        - path: "crates/apm2-core/src/context/mod.rs"
          purpose: "Context module root"

      files_to_modify:
        - path: "crates/apm2-core/src/lib.rs"
          changes: "Add pub mod context;"

      implementation_steps:
        - step: 1
          action: "Define ContextPackManifest types"
          details: |
            pub struct ContextPackManifest {
                pub manifest_id: String,
                pub manifest_hash: Hash,
                pub profile_id: String,
                pub entries: Vec<ManifestEntry>,
            }

            pub struct ManifestEntry {
                pub stable_id: Option<String>,
                pub path: String,
                pub content_hash: Hash,
                pub access_level: AccessLevel,
            }

            pub enum AccessLevel {
                Read,
                ReadWithZoom,
            }

        - step: 2
          action: "Implement allowlist checking"
          details: |
            impl ContextPackManifest {
                pub fn is_allowed(&self, path: &str, content_hash: Option<&Hash>) -> bool {
                    self.entries.iter().any(|e| {
                        e.path == path && content_hash.map_or(true, |h| e.content_hash == *h)
                    })
                }

                pub fn get_entry(&self, path: &str) -> Option<&ManifestEntry> {
                    self.entries.iter().find(|e| e.path == path)
                }
            }

      acceptance_criteria:
        - criterion: "ContextPackManifest defines allowlist entries"
          verification: "Check struct has entries field"
        - criterion: "is_allowed correctly matches paths and hashes"
          verification: "Unit test for allowlist matching"

      test_requirements:
        - test_id: UT-FAC-008-001
          description: "Test allowlist matching"
          verification_command: "cargo test -p apm2-core context::manifest::tests"

    - ticket_id: TCK-00210
      title: "FAC: ContextAwareValidator middleware"
      group_id: TG-FAC-002
      requirement_ids:
        - FAC-REQ-0001
      depends_on:
        - TCK-00209
      phase: PHASE-1
      clarifications:
        - "WARN mode allowed only for LOW risk and sterile runner pool; otherwise SOFT_FAIL+."
        - "ToolDecided=DENY includes rule_id, manifest_id, and path."

      files_to_create:
        - path: "crates/apm2-core/src/context/firewall.rs"
          purpose: "ContextAwareValidator for OCAP enforcement"

      files_to_modify:
        - path: "crates/apm2-core/src/tool/mod.rs"
          changes: "Integrate ContextAwareValidator into tool validation path"

      implementation_steps:
        - step: 1
          action: "Define ContextAwareValidator trait"
          details: |
            pub trait ContextAwareValidator {
                fn validate_read(
                    &self,
                    manifest: &ContextPackManifest,
                    path: &str,
                    content_hash: Option<&Hash>,
                ) -> Result<(), ContextFirewallError>;
            }

        - step: 2
          action: "Implement default validator"
          details: |
            pub struct DefaultContextFirewall {
                pub mode: FirewallMode,
            }

            pub enum FirewallMode {
                Warn,
                SoftFail,
                HardFail,
            }

            impl ContextAwareValidator for DefaultContextFirewall {
                fn validate_read(
                    &self,
                    manifest: &ContextPackManifest,
                    path: &str,
                    content_hash: Option<&Hash>,
                ) -> Result<(), ContextFirewallError> {
                    if !manifest.is_allowed(path, content_hash) {
                        match self.mode {
                            FirewallMode::Warn => {
                                // Log warning, allow read
                                Ok(())
                            }
                            FirewallMode::SoftFail | FirewallMode::HardFail => {
                                Err(ContextFirewallError::NotInAllowlist {
                                    path: path.to_string(),
                                    rule_id: "CTX-ALLOWLIST-001".to_string(),
                                })
                            }
                        }
                    } else {
                        Ok(())
                    }
                }
            }

        - step: 3
          action: "Emit ToolDecided=DENY events"
          details: |
            On firewall denial, emit ToolDecided event with:
            - decision: DENY
            - rule_id: "CTX-ALLOWLIST-001"
            - path: attempted path
            - reason: "Not in allowlist"

      acceptance_criteria:
        - criterion: "Reads outside allowlist emit ToolDecided=DENY"
          verification: "Unit test for denied read"
        - criterion: "Reads inside allowlist succeed"
          verification: "Unit test for allowed read"
        - criterion: "FirewallMode controls enforcement level"
          verification: "Unit test for mode behavior"

      test_requirements:
        - test_id: UT-FAC-009-001
          description: "Test context firewall allowlist enforcement"
          verification_command: "cargo test -p apm2-core context::firewall::tests"

    - ticket_id: TCK-00211
      title: "FAC: Context firewall integration with PolicyEngine"
      group_id: TG-FAC-002
      requirement_ids:
        - FAC-REQ-0001
      depends_on:
        - TCK-00210
      phase: PHASE-1
      clarifications:
        - "Missing manifest => fail-closed CONTEXT_MISS; no fallback reads."

      files_to_modify:
        - path: "crates/apm2-core/src/policy/engine.rs"
          changes: "Add manifest-aware rule evaluation"
        - path: "crates/apm2-daemon/src/session/consume.rs"
          changes: "Wire firewall into CONSUME mode session handling"

      implementation_steps:
        - step: 1
          action: "Add context firewall rule to PolicyEngine"
          details: |
            Add default-deny rule for CONSUME mode sessions:
            - If session mode is CONSUME and no manifest entry matches, DENY

        - step: 2
          action: "Integrate into session handling"
          details: |
            In CONSUME mode session:
            - Load manifest from RCP
            - Pass to ContextAwareValidator
            - On DENY, terminate session with CONTEXT_MISS rationale

        - step: 3
          action: "Implement context miss termination"
          details: |
            On CONTEXT_MISS:
            - Emit SessionTerminated with rationale=CONTEXT_MISS
            - Trigger ContextRefinementRequest to coordinator
            - Coordinator reissues with refined pack

      acceptance_criteria:
        - criterion: "CONSUME mode sessions use manifest allowlist"
          verification: "Integration test for CONSUME mode"
        - criterion: "Context miss terminates session"
          verification: "Integration test for CONTEXT_MISS"

      test_requirements:
        - test_id: IT-FAC-001-001
          description: "Test CONSUME mode context firewall"
          verification_command: "cargo test -p apm2-daemon session::consume::tests"

    # =========================================================================
    # TG-FAC-003: Projection and Divergence Watchdog
    # =========================================================================

    - ticket_id: TCK-00212
      title: "FAC: GitHub projection adapter (write-only)"
      group_id: TG-FAC-003
      requirement_ids:
        - FAC-REQ-0019
      depends_on:
        - TCK-00202
      phase: PHASE-1
      clarifications:
        - "GitHub reads are allowed only inside projection adapter; admission holons must not read GitHub."

      files_to_create:
        - path: "crates/apm2-daemon/src/projection/mod.rs"
          purpose: "Projection module root"
        - path: "crates/apm2-daemon/src/projection/github_sync.rs"
          purpose: "GitHub projection sync (write-only)"
        - path: "crates/apm2-daemon/src/projection/projection_receipt.rs"
          purpose: "ProjectionReceipt for audit trail"

      implementation_steps:
        - step: 1
          action: "Define ProjectionAdapter trait"
          details: |
            pub trait ProjectionAdapter {
                async fn project_status(
                    &self,
                    work_id: &WorkId,
                    changeset_digest: &Hash,
                    ledger_head: &Hash,
                    status: &ProjectionStatus,
                ) -> Result<ProjectionReceipt, ProjectionError>;
            }

        - step: 2
          action: "Implement GitHubProjectionAdapter"
          details: |
            pub struct GitHubProjectionAdapter {
                client: GitHubClient,
            }

            impl ProjectionAdapter for GitHubProjectionAdapter {
                async fn project_status(&self, ...) -> Result<ProjectionReceipt, ProjectionError> {
                    // Idempotent projection keyed by (work_id, changeset_digest, ledger_head)
                    let idempotence_key = format!("{}:{}:{}", work_id, changeset_digest, ledger_head);

                    // Write status check to GitHub
                    self.client.create_status(...).await?;

                    // Create signed projection receipt
                    let receipt = ProjectionReceipt { ... };
                    Ok(receipt)
                }
            }

        - step: 3
          action: "Define ProjectionReceipt"
          details: |
            pub struct ProjectionReceipt {
                pub receipt_id: String,
                pub work_id: WorkId,
                pub changeset_digest: Hash,
                pub ledger_head: Hash,
                pub projected_status: String,
                pub projected_at: Timestamp,
                pub adapter_signature: Signature,
            }

      acceptance_criteria:
        - criterion: "Projection is idempotent with (work_id, changeset_digest, ledger_head) key"
          verification: "Unit test for idempotent projection"
        - criterion: "ProjectionReceipt is signed by adapter"
          verification: "Unit test for receipt signature"

      test_requirements:
        - test_id: UT-FAC-010-001
          description: "Test idempotent projection"
          verification_command: "cargo test -p apm2-daemon projection::github_sync::tests"

    - ticket_id: TCK-00213
      title: "FAC: Divergence watchdog with InterventionFreeze"
      group_id: TG-FAC-003
      requirement_ids:
        - FAC-REQ-0002
      depends_on:
        - TCK-00212
      phase: PHASE-1
      clarifications:
        - "frozen_at/unfrozen_at are observational only; time_envelope_ref is authoritative (HTF)."

      files_to_create:
        - path: "crates/apm2-daemon/src/projection/divergence_watchdog.rs"
          purpose: "Divergence detection and InterventionFreeze"

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add InterventionFreeze and InterventionUnfreeze messages"

      implementation_steps:
        - step: 1
          action: "Define InterventionFreeze proto"
          details: |
            message InterventionFreeze {
              string scope = 1;
              string scope_value = 2;
              string trigger_defect_id = 3;
              google.protobuf.Timestamp frozen_at = 4;
              string gate_actor_id = 5;
              bytes gate_signature = 6;
              bytes time_envelope_ref = 7;
            }

            message InterventionUnfreeze {
              string freeze_id = 1;
              string resolution_type = 2;
              string adjudication_id = 3;
              google.protobuf.Timestamp unfrozen_at = 4;
              string gate_actor_id = 5;
              bytes gate_signature = 6;
              bytes time_envelope_ref = 7;
            }

        - step: 2
          action: "Implement DivergenceWatchdog"
          details: |
            pub struct DivergenceWatchdog {
                poll_interval_htf_ticks: u64,
            }

            impl DivergenceWatchdog {
                pub async fn check_divergence(
                    &self,
                    latest_merge_receipt: &MergeReceipt,
                    external_trunk_head: &Hash,
                ) -> Option<DivergenceEvent> {
                    if latest_merge_receipt.result_selector != *external_trunk_head {
                        Some(DivergenceEvent {
                            expected: latest_merge_receipt.result_selector.clone(),
                            actual: external_trunk_head.clone(),
                        })
                    } else {
                        None
                    }
                }

                pub async fn on_divergence(&self, event: DivergenceEvent) -> InterventionFreeze {
                    // 1. Emit DefectRecord(PROJECTION_DIVERGENCE)
                    // 2. Create InterventionFreeze(scope=repo)
                    // 3. Halt new FAC admissions
                    InterventionFreeze { ... }
                }
            }

        - step: 3
          action: "Add freeze checking to admission path"
          details: |
            In admission decision logic:
            - Check for active InterventionFreeze for repo
            - If frozen, reject admission with REPO_FROZEN error

      acceptance_criteria:
        - criterion: "Divergence between trunk HEAD and MergeReceipt triggers freeze"
          verification: "Integration test for divergence detection"
        - criterion: "InterventionFreeze halts new admissions"
          verification: "Integration test for frozen repo rejection"
        - criterion: "Unfreeze requires adjudication"
          verification: "Integration test for unfreeze ceremony"

      test_requirements:
        - test_id: IT-FAC-002-001
          description: "Test divergence detection and freeze"
          verification_command: "cargo test -p apm2-daemon projection::divergence_watchdog::tests"

    - ticket_id: TCK-00214
      title: "FAC: Tamper detection and overwrite"
      group_id: TG-FAC-003
      requirement_ids:
        - FAC-REQ-0019
      depends_on:
        - TCK-00212
      phase: PHASE-1
      clarifications:
        - "Tamper detection emits DefectRecord(PROJECTION_TAMPER); overwrite is idempotent."

      files_to_modify:
        - path: "crates/apm2-daemon/src/projection/github_sync.rs"
          changes: "Add tamper detection and overwrite logic"

      implementation_steps:
        - step: 1
          action: "Implement tamper detection"
          details: |
            pub async fn detect_tamper(
                &self,
                expected_status: &ProjectionStatus,
                actual_status: &GitHubStatus,
            ) -> Option<TamperEvent> {
                // Compare expected (from ledger) to actual (from GitHub)
                if expected_status != actual_status {
                    Some(TamperEvent { ... })
                } else {
                    None
                }
            }

        - step: 2
          action: "Implement overwrite on tamper"
          details: |
            pub async fn on_tamper(&self, event: TamperEvent) {
                // 1. Emit DefectRecord(PROJECTION_TAMPER)
                // 2. Overwrite GitHub status to match ledger truth
                self.project_status(...).await?;
            }

      acceptance_criteria:
        - criterion: "Tamper is detected when GitHub status differs from ledger"
          verification: "Unit test for tamper detection"
        - criterion: "Tampered status is overwritten"
          verification: "Unit test for overwrite"

      test_requirements:
        - test_id: UT-FAC-011-001
          description: "Test tamper detection and overwrite"
          verification_command: "cargo test -p apm2-daemon projection::github_sync::tests::tamper"

    # =========================================================================
    # TG-FAC-004: CI Evidence Import
    # =========================================================================

    - ticket_id: TCK-00215
      title: "FAC: CI attestation types (L0/L1 levels)"
      group_id: TG-FAC-004
      requirement_ids:
        - FAC-REQ-0118
      depends_on: []
      phase: PHASE-1
      clarifications:
        - "L1 requires workflow_run_id + downloaded_artifact_hashes + adapter signature."
        - "Level comparison uses explicit rank mapping (L0<L1<L2<L3), not enum ordinal."

      files_to_create:
        - path: "crates/apm2-core/src/fac/ci_attestation.rs"
          purpose: "CI attestation level types"

      implementation_steps:
        - step: 1
          action: "Define CI attestation levels"
          details: |
            pub enum CiAttestationLevel {
                L0, // Status-only (insufficient for gating)
                L1, // Signed adapter attestation + CAS artifact digests
                L2, // Replayable verifier proof (Phase 2)
                L3, // Measured boot/TPM-backed (Phase 2)
            }

            pub struct CiAttestation {
                pub level: CiAttestationLevel,
                pub workflow_run_id: String,
                pub downloaded_artifact_hashes: Vec<Hash>,
                pub runner_image_digest: Option<Hash>,
                pub toolchain: Option<String>,
                pub command_transcript_hash: Option<Hash>,
                pub adapter_signature: Signature,
            }

        - step: 2
          action: "Implement level validation"
          details: |
            impl CiAttestation {
                pub fn meets_minimum(&self, required: CiAttestationLevel) -> bool {
                    self.level as u8 >= required as u8
                }
            }

      acceptance_criteria:
        - criterion: "CI attestation levels L0/L1/L2/L3 are defined"
          verification: "Check CiAttestationLevel enum"
        - criterion: "Level comparison is correct"
          verification: "Unit test for meets_minimum"

      test_requirements:
        - test_id: UT-FAC-012-001
          description: "Test CI attestation level validation"
          verification_command: "cargo test -p apm2-core fac::ci_attestation::tests"

    - ticket_id: TCK-00216
      title: "FAC: CI evidence import with CAS integration"
      group_id: TG-FAC-004
      requirement_ids:
        - FAC-REQ-0003
      depends_on:
        - TCK-00215
        - TCK-00202
      phase: PHASE-1
      clarifications:
        - "CiImportAttestation is signed with CI_IMPORT_ATTESTATION domain prefix."
        - "imported_at is observational only."

      files_to_create:
        - path: "crates/apm2-core/src/fac/ci_import.rs"
          purpose: "CI evidence import adapter"

      implementation_steps:
        - step: 1
          action: "Define CiEvidenceImport"
          details: |
            pub struct CiEvidenceImport {
                pub workflow_run_id: String,
                pub webhook_signature_verified: bool,
                pub artifact_digests: Vec<CasDigest>,
                pub attestation: CiAttestation,
            }

            pub struct CiImportAttestation {
                pub import_id: String,
                pub workflow_run_id: String,
                pub artifact_digests: Vec<Hash>,
                pub imported_at: Timestamp,
                pub adapter_signature: Signature,
            }

        - step: 2
          action: "Implement import validation"
          details: |
            pub fn validate_ci_import(import: &CiEvidenceImport, policy: &CiGatingPolicy) -> Result<(), CiImportError> {
                // 1. Check webhook signature verified
                if !import.webhook_signature_verified {
                    return Err(CiImportError::WebhookSignatureNotVerified);
                }

                // 2. Check artifact digests in CAS
                for digest in &import.artifact_digests {
                    if !cas.exists(digest) {
                        return Err(CiImportError::ArtifactNotInCas(digest.clone()));
                    }
                }

                // 3. Check attestation level meets policy
                if !import.attestation.meets_minimum(policy.minimum_level) {
                    return Err(CiImportError::InsufficientAttestationLevel);
                }

                Ok(())
            }

      acceptance_criteria:
        - criterion: "Webhook signature must be verified"
          verification: "Unit test for webhook signature check"
        - criterion: "Artifact digests must be in CAS"
          verification: "Unit test for CAS verification"
        - criterion: "L0 attestation is rejected when CI gating enabled"
          verification: "Unit test for attestation level enforcement"

      test_requirements:
        - test_id: UT-FAC-013-001
          description: "Test CI evidence import validation"
          verification_command: "cargo test -p apm2-core fac::ci_import::tests"

    - ticket_id: TCK-00217
      title: "FAC: READY_FOR_REVIEW transition gate"
      group_id: TG-FAC-004
      requirement_ids:
        - FAC-REQ-0003
      depends_on:
        - TCK-00216
      phase: PHASE-1
      clarifications:
        - "Use CiGatingPolicy.minimum_level; never hard-code L0/L1 checks."

      files_to_modify:
        - path: "crates/apm2-core/src/fac/ci_import.rs"
          changes: "Add READY_FOR_REVIEW transition logic"

      implementation_steps:
        - step: 1
          action: "Implement transition gate"
          details: |
            pub fn can_transition_to_ready_for_review(
                ci_enabled: bool,
                import: Option<&CiEvidenceImport>,
            ) -> Result<(), TransitionError> {
                if !ci_enabled {
                    // CI gating disabled - transition allowed
                    return Ok(());
                }

                match import {
                    None => Err(TransitionError::CiEvidenceMissing),
                    Some(import) => {
                        if import.attestation.level == CiAttestationLevel::L0 {
                            Err(TransitionError::InsufficientAttestationLevel)
                        } else {
                            Ok(())
                        }
                    }
                }
            }

      acceptance_criteria:
        - criterion: "READY_FOR_REVIEW requires CI evidence when gating enabled"
          verification: "Unit test for transition gate"
        - criterion: "Plain 'success' without evidence is rejected"
          verification: "Unit test for L0 rejection"

      test_requirements:
        - test_id: UT-FAC-014-001
          description: "Test READY_FOR_REVIEW transition gate"
          verification_command: "cargo test -p apm2-core fac::ci_import::tests::transition"

    # =========================================================================
    # TG-FAC-005: Typed AAT GateReceipt
    # =========================================================================

    - ticket_id: TCK-00218
      title: "FAC: AatGateReceipt typed payload schema"
      group_id: TG-FAC-005
      requirement_ids:
        - FAC-REQ-0004
        - FAC-REQ-0006
      depends_on:
        - TCK-00207
      phase: PHASE-1
      clarifications:
        - "flake_class required when verdict=FAIL or determinism_status=MISMATCH; may be omitted for PASS+STABLE."
        - "flake_class enum is canonical; unknown values rejected in enforce mode."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add AatGateReceipt message"

      files_to_create:
        - path: "crates/apm2-core/src/fac/aat_receipt.rs"
          purpose: "Typed AAT GateReceipt payload"

      implementation_steps:
        - step: 1
          action: "Add AatGateReceipt proto message"
          details: |
            message AatGateReceipt {
              bytes view_commitment_hash = 1;
              bytes rcp_manifest_hash = 2;
              string rcp_profile_id = 3;
              bytes policy_hash = 4;
              uint32 determinism_class = 5;
              string determinism_status = 6;
              string flake_class = 7;
              uint32 run_count = 8;
              repeated bytes run_receipt_hashes = 9;
              bytes terminal_evidence_digest = 10;
              bytes observational_evidence_digest = 11;
              bytes terminal_verifier_outputs_digest = 12;
              bytes stability_digest = 13;
              string verdict = 14;
              bytes transcript_chain_root_hash = 15;
              bytes transcript_bundle_hash = 16;
              bytes artifact_manifest_hash = 17;
              repeated TerminalVerifierOutput terminal_verifier_outputs = 18;
              bytes verifier_policy_hash = 19;
              string selection_policy_id = 20;
              string risk_tier = 21;
              AatAttestation attestation = 22;
            }

        - step: 2
          action: "Create Rust types"
          details: |
            pub struct AatGateReceipt {
                pub view_commitment_hash: Hash,
                pub rcp_manifest_hash: Hash,
                pub rcp_profile_id: String,
                pub policy_hash: Hash,
                pub determinism_class: u32,
                pub determinism_status: DeterminismStatus,
                pub flake_class: FlakeClass,
                pub run_count: u32,
                pub run_receipt_hashes: Vec<Hash>,
                pub terminal_evidence_digest: Hash,
                pub observational_evidence_digest: Hash,
                pub terminal_verifier_outputs_digest: Hash,
                pub stability_digest: Hash,
                pub verdict: AatVerdict,
                pub transcript_chain_root_hash: Hash,
                pub transcript_bundle_hash: Hash,
                pub artifact_manifest_hash: Hash,
                pub terminal_verifier_outputs: Vec<TerminalVerifierOutput>,
                pub verifier_policy_hash: Hash,
                pub selection_policy_id: String,
                pub risk_tier: RiskTier,
                pub attestation: AatAttestation,
            }

        - step: 3
          action: "Implement required field validation"
          details: |
            impl AatGateReceipt {
                pub fn validate_required_fields(&self) -> Result<(), ValidationError> {
                    // All 22 fields must be present and non-default
                    // run_receipt_hashes.len() must equal run_count
                    if self.run_receipt_hashes.len() as u32 != self.run_count {
                        return Err(ValidationError::RunCountMismatch);
                    }
                    Ok(())
                }
            }

      acceptance_criteria:
        - criterion: "AatGateReceipt has all 22 required fields"
          verification: "Check struct definition"
        - criterion: "Missing fields are rejected"
          verification: "Unit test for validation"
        - criterion: "run_receipt_hashes.len() must equal run_count"
          verification: "Unit test for run count matching"

      test_requirements:
        - test_id: UT-FAC-015-001
          description: "Test AatGateReceipt required field validation"
          verification_command: "cargo test -p apm2-core fac::aat_receipt::tests"

    - ticket_id: TCK-00219
      title: "FAC: Terminal verifier types and VerifierPolicy"
      group_id: TG-FAC-005
      requirement_ids:
        - FAC-REQ-0007
      depends_on:
        - TCK-00218
      phase: PHASE-1
      clarifications:
        - "predicate_lang is fac_predicate_v1; unknown ops => fail-closed."

      files_to_create:
        - path: "crates/apm2-core/src/fac/terminal_verifier.rs"
          purpose: "Terminal verifier trait and policy types"

      implementation_steps:
        - step: 1
          action: "Define TerminalVerifier trait"
          details: |
            pub trait TerminalVerifier {
                fn kind(&self) -> VerifierKind;
                fn evaluate(&self, output: &VerifierOutput, policy: &VerifierPolicy) -> VerifierVerdict;
            }

            pub enum VerifierKind {
                ExitCode,
                SnapshotDiff,
                StructuredTestReport,
                InvariantCheck,
            }

            pub struct VerifierOutput {
                pub verifier_kind: VerifierKind,
                pub output_digest: Hash,
                pub predicate_satisfied: bool,
            }

        - step: 2
          action: "Define VerifierPolicy"
          details: |
            pub struct VerifierPolicy {
                pub policy_id: String,
                pub policy_hash: Hash,
                pub schema_version: String,
                pub scenario_type: String,
                pub allowed_verifier_kinds: Vec<VerifierKind>,
                pub required_outputs: HashMap<VerifierKind, Vec<String>>,
                pub machine_predicate: String,
                pub predicate_lang: String,
            }

        - step: 3
          action: "Implement predicate evaluation"
          details: |
            impl VerifierPolicy {
                pub fn evaluate_predicate(&self, outputs: &[VerifierOutput]) -> Result<bool, PredicateError> {
                    // Parse and evaluate machine_predicate against outputs
                    // Supported ops: ==, !=, <, <=, >, >=, AND, OR, NOT
                    // Supported value types: int, bool, string
                }
            }

      acceptance_criteria:
        - criterion: "TerminalVerifier trait defines kind and evaluate methods"
          verification: "Check trait definition"
        - criterion: "VerifierPolicy defines allowed_verifier_kinds and machine_predicate"
          verification: "Check struct definition"
        - criterion: "Predicate evaluation is deterministic"
          verification: "Unit test for predicate evaluation"

      test_requirements:
        - test_id: UT-FAC-016-001
          description: "Test terminal verifier predicate evaluation"
          verification_command: "cargo test -p apm2-core fac::terminal_verifier::tests"

    - ticket_id: TCK-00220
      title: "FAC: Transcript chain binding (reuse TranscriptChunk)"
      group_id: TG-FAC-005
      requirement_ids:
        - FAC-REQ-0006
      depends_on:
        - TCK-00218
      phase: PHASE-1
      clarifications:
        - "Transcript chunks are ordered by sequence index; chain root uses blake3 over canonical chunk bytes."

      files_to_create:
        - path: "crates/apm2-core/src/fac/transcript_binding.rs"
          purpose: "AAT transcript binding wrapper"

      files_to_modify:
        - path: "crates/apm2-core/src/cac/mod.rs"
          changes: "Re-export TranscriptChunk for FAC use"

      implementation_steps:
        - step: 1
          action: "Create AATTranscriptBinding"
          details: |
            use crate::cac::pack_spec::TranscriptChunk;

            pub struct AATTranscriptBinding {
                pub transcript_chunks: Vec<TranscriptChunk>,
                pub transcript_chain_root_hash: Hash,
                pub run_transcript_hashes: Vec<Hash>,
            }

            impl AATTranscriptBinding {
                pub fn compute_chain_root(&self) -> Hash {
                    // Merkle root of transcript_chunks
                }

                pub fn validate(&self) -> Result<(), TranscriptError> {
                    let computed_root = self.compute_chain_root();
                    if computed_root != self.transcript_chain_root_hash {
                        return Err(TranscriptError::ChainRootMismatch);
                    }
                    Ok(())
                }
            }

      acceptance_criteria:
        - criterion: "TranscriptChunk from CAC is reused"
          verification: "Check import from cac module"
        - criterion: "transcript_chain_root_hash is derivable from chunks"
          verification: "Unit test for chain root computation"

      test_requirements:
        - test_id: UT-FAC-017-001
          description: "Test transcript chain validation"
          verification_command: "cargo test -p apm2-core fac::transcript_binding::tests"

    - ticket_id: TCK-00221
      title: "FAC: Artifact manifest and evidence binding"
      group_id: TG-FAC-005
      requirement_ids:
        - FAC-REQ-0006
      depends_on:
        - TCK-00218
      phase: PHASE-1
      clarifications:
        - "retention_window_ref is HTF; required for non-public artifacts."
        - "redaction_profile_hash required when redaction_applied==true."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add ArtifactManifest message"

      files_to_create:
        - path: "crates/apm2-core/src/fac/artifact_manifest.rs"
          purpose: "Artifact manifest for evidence binding"

      implementation_steps:
        - step: 1
          action: "Define ArtifactManifest"
          details: |
            pub struct ArtifactManifest {
                pub artifacts: Vec<ArtifactDigest>,
            }

            pub struct ArtifactDigest {
                pub artifact_type: ArtifactType,
                pub digest: Hash,
                pub data_classification: DataClassification,
                pub redaction_applied: bool,
                pub redaction_profile_hash: Option<Hash>,
                pub retention_window_ref: Option<TimeEnvelopeRef>,
            }

            pub enum ArtifactType {
                Log,
                Junit,
                Coverage,
                Snapshot,
                Binary,
            }

            pub enum DataClassification {
                Public,
                Internal,
                Confidential,
                Restricted,
            }

        - step: 2
          action: "Implement evidence hygiene validation"
          details: |
            impl ArtifactManifest {
                pub fn validate_hygiene(&self) -> Result<(), HygieneError> {
                    for artifact in &self.artifacts {
                        // All artifacts must have data_classification
                        // Retention window must be present for non-public artifacts
                    }
                    Ok(())
                }
            }

      acceptance_criteria:
        - criterion: "ArtifactManifest includes data_classification for all artifacts"
          verification: "Check ArtifactDigest has data_classification field"
        - criterion: "Evidence hygiene validation enforces classification"
          verification: "Unit test for hygiene validation"

      test_requirements:
        - test_id: UT-FAC-018-001
          description: "Test artifact manifest evidence hygiene"
          verification_command: "cargo test -p apm2-core fac::artifact_manifest::tests"

    # =========================================================================
    # TG-FAC-006: Risk-Tiered AAT Selection
    # =========================================================================

    - ticket_id: TCK-00222
      title: "FAC: Risk tier classification model"
      group_id: TG-FAC-006
      requirement_ids:
        - FAC-REQ-0009
      depends_on: []
      phase: PHASE-1
      clarifications:
        - "Classification must be deterministic and policy-configurable; resolved tier is pinned in PolicyResolvedForChangeSet."

      files_to_create:
        - path: "crates/apm2-core/src/fac/risk_tier.rs"
          purpose: "Risk tier classification types and model"

      implementation_steps:
        - step: 1
          action: "Define RiskTier enum"
          details: |
            pub enum RiskTier {
                High,
                Med,
                Low,
            }

        - step: 2
          action: "Implement classification model"
          details: |
            const CRITICAL_MODULES: &[&str] = &["auth", "crypto", "ledger", "tool", "kernel"];
            const SENSITIVE_PATTERNS: &[&str] = &["secret", "credentials", "policy"];

            pub fn classify_risk(changeset: &ChangesetInfo) -> RiskTier {
                // PRIMARY SIGNALS
                if touches_critical_module(changeset) {
                    return RiskTier::High;
                }
                if matches_sensitive_pattern(changeset) {
                    return RiskTier::High;
                }

                // SECONDARY SIGNALS
                if changeset.lines_changed > 500 || changeset.files_changed > 10 {
                    return RiskTier::Med;
                }
                if changeset.dependency_fanout > 20 {
                    return RiskTier::Med;
                }

                RiskTier::Low
            }

      acceptance_criteria:
        - criterion: "RiskTier enum has High, Med, Low variants"
          verification: "Check enum definition"
        - criterion: "Classification model uses primary and secondary signals"
          verification: "Unit test for classification"
        - criterion: "Critical modules are classified as HIGH"
          verification: "Unit test for critical module detection"

      test_requirements:
        - test_id: UT-FAC-019-001
          description: "Test risk tier classification"
          verification_command: "cargo test -p apm2-core fac::risk_tier::tests"

    - ticket_id: TCK-00223
      title: "FAC: AAT selection policy engine"
      group_id: TG-FAC-006
      requirement_ids:
        - FAC-REQ-0009
      depends_on:
        - TCK-00222
      phase: PHASE-1
      clarifications:
        - "Sampling uses blake3(work_id) for determinism; sample_rate must be in [0,1]."

      files_to_create:
        - path: "crates/apm2-core/src/fac/selection_policy.rs"
          purpose: "AAT selection policy engine"

      implementation_steps:
        - step: 1
          action: "Define SelectionPolicy"
          details: |
            pub struct SelectionPolicy {
                pub policy_id: String,
                pub policy_hash: Hash,
                pub high_tier_config: TierConfig,
                pub med_tier_config: TierConfig,
                pub low_tier_config: TierConfig,
            }

            pub struct TierConfig {
                pub aat_required: AatRequirement,
                pub sample_rate: Option<f64>,
            }

            pub enum AatRequirement {
                Always,
                Conditional,
                Sampled,
            }

        - step: 2
          action: "Implement selection logic"
          details: |
            impl SelectionPolicy {
                pub fn should_run_aat(&self, risk_tier: RiskTier, context: &SelectionContext) -> bool {
                    match risk_tier {
                        RiskTier::High => true, // Always
                        RiskTier::Med => context.is_sensitive_domain,
                        RiskTier::Low => self.sample(&context.work_id),
                    }
                }

                fn sample(&self, work_id: &WorkId) -> bool {
                    // Deterministic sampling based on work_id hash
                    let hash = work_id.hash();
                    (hash[0] as f64 / 255.0) < self.low_tier_config.sample_rate.unwrap_or(0.1)
                }
            }

      acceptance_criteria:
        - criterion: "HIGH tier always requires AAT"
          verification: "Unit test for HIGH tier"
        - criterion: "MED tier requires AAT for sensitive domains"
          verification: "Unit test for MED tier"
        - criterion: "LOW tier uses sampling"
          verification: "Unit test for sampling"

      test_requirements:
        - test_id: UT-FAC-020-001
          description: "Test AAT selection policy"
          verification_command: "cargo test -p apm2-core fac::selection_policy::tests"

    - ticket_id: TCK-00224
      title: "FAC: Anti-downgrade enforcement at admission"
      group_id: TG-FAC-006
      requirement_ids:
        - FAC-REQ-0012
      depends_on:
        - TCK-00206
        - TCK-00218
      phase: PHASE-1
      clarifications:
        - "Verify PolicyResolvedForChangeSet exists before evaluating downgrades."
        - "rcp_profile_id must match resolved_rcp_profile_ids and rcp_manifest_hash must match resolved_rcp_manifest_hashes."

      files_to_create:
        - path: "crates/apm2-core/src/fac/anti_downgrade.rs"
          purpose: "Anti-downgrade enforcement"

      implementation_steps:
        - step: 1
          action: "Implement anti-downgrade checks"
          details: |
            pub fn verify_no_downgrade(
                resolved: &PolicyResolvedForChangeSet,
                receipt: &AatGateReceipt,
            ) -> Result<(), DowngradeError> {
                // 1. policy_hash must match
                if receipt.policy_hash != resolved.resolved_policy_hash {
                    return Err(DowngradeError::PolicyHashMismatch);
                }

                // 2. risk_tier must not be lower
                if receipt.risk_tier < resolved.resolved_risk_tier {
                    return Err(DowngradeError::RiskTierDowngrade);
                }

                // 3. verifier_policy_hash must be in resolved list
                if !resolved.resolved_verifier_policy_hashes.contains(&receipt.verifier_policy_hash) {
                    return Err(DowngradeError::VerifierPolicyNotResolved);
                }

                // 4. rcp_profile_id must be in resolved list
                if !resolved.resolved_rcp_profile_ids.contains(&receipt.rcp_profile_id) {
                    return Err(DowngradeError::RcpProfileNotResolved);
                }

                Ok(())
            }

      acceptance_criteria:
        - criterion: "Policy hash mismatch is rejected"
          verification: "Unit test for policy hash check"
        - criterion: "Lowered risk tier is rejected"
          verification: "Unit test for risk tier check"
        - criterion: "Unresolved verifier policy is rejected"
          verification: "Unit test for verifier policy check"

      test_requirements:
        - test_id: UT-FAC-021-001
          description: "Test anti-downgrade enforcement"
          verification_command: "cargo test -p apm2-core fac::anti_downgrade::tests"

    - ticket_id: TCK-00225
      title: "FAC: AAT lease binding with custody domain validation"
      group_id: TG-FAC-006
      requirement_ids:
        - FAC-REQ-0010
      depends_on:
        - TCK-00203
        - TCK-00208
      phase: PHASE-1
      clarifications:
        - "Bind selection_policy_id and rcp_profile_id in addition to view_commitment_hash/rcp_manifest_hash."

      files_to_modify:
        - path: "crates/apm2-core/src/fac/lease.rs"
          changes: "Add AAT lease binding and custody validation"

      implementation_steps:
        - step: 1
          action: "Implement AAT lease binding validation"
          details: |
            impl GateLease {
                pub fn validate_aat_binding(
                    &self,
                    receipt: &AatGateReceipt,
                ) -> Result<(), BindingError> {
                    let ext = self.aat_extension.as_ref()
                        .ok_or(BindingError::NotAatLease)?;

                    if receipt.view_commitment_hash != ext.view_commitment_hash {
                        return Err(BindingError::ViewCommitmentMismatch);
                    }
                    if receipt.rcp_manifest_hash != ext.rcp_manifest_hash {
                        return Err(BindingError::RcpManifestMismatch);
                    }
                    Ok(())
                }
            }

        - step: 2
          action: "Add custody domain validation at issuance"
          details: |
            pub fn validate_custody_for_aat_lease(
                key_policy: &KeyPolicy,
                executor_key_id: &str,
                author_actor_id: &ActorId,
            ) -> Result<(), CustodyError> {
                // AAT executor must be in different custody domain
                let executor_domain = key_policy.get_custody_domain(executor_key_id)?;
                let author_domain = key_policy.get_custody_domain_for_actor(author_actor_id)?;

                if executor_domain == author_domain {
                    return Err(CustodyError::SameCustodyDomain);
                }
                Ok(())
            }

      acceptance_criteria:
        - criterion: "AAT lease binds view_commitment_hash and rcp_manifest_hash"
          verification: "Unit test for binding validation"
        - criterion: "AAT executor must be in different custody domain"
          verification: "Unit test for custody domain check"

      test_requirements:
        - test_id: UT-FAC-022-001
          description: "Test AAT lease binding validation"
          verification_command: "cargo test -p apm2-core fac::lease::tests::aat"

    # =========================================================================
    # TG-FAC-007: Determinism Envelope (Phase 2)
    # =========================================================================

    - ticket_id: TCK-00226
      title: "FAC: Determinism envelope schema (Phase 1 - schema only)"
      group_id: TG-FAC-007
      requirement_ids:
        - FAC-REQ-0005
      depends_on:
        - TCK-00218
      phase: PHASE-1
      clarifications:
        - "stability_digest inputs are verdict + terminal_evidence_digest + terminal_verifier_outputs_digest."
        - "observational evidence is excluded from stability digest."

      files_to_create:
        - path: "crates/apm2-core/src/fac/determinism.rs"
          purpose: "Determinism envelope types (Phase 1 schema only)"

      implementation_steps:
        - step: 1
          action: "Define determinism types"
          details: |
            pub enum DeterminismStatus {
                Stable,
                Mismatch,
            }

            pub struct DeterminismEnvelope {
                pub determinism_class: u32,
                pub run_count: u32,
                pub run_receipt_hashes: Vec<Hash>,
                pub terminal_evidence_digest: Hash,
                pub terminal_verifier_outputs_digest: Hash,
                pub stability_digest: Hash,
            }

            impl DeterminismEnvelope {
                pub fn compute_stability_digest(&self) -> Hash {
                    // hash(verdict, terminal_evidence_digest, terminal_verifier_outputs_digest)
                }

                pub fn check_stability(&self) -> DeterminismStatus {
                    // Compare all run terminal evidence digests
                    // If all equal -> Stable, else -> Mismatch
                }
            }

        - step: 2
          action: "Add run count by tier"
          details: |
            pub fn required_run_count(risk_tier: RiskTier) -> u32 {
                match risk_tier {
                    RiskTier::High => 3,
                    RiskTier::Med => 2,
                    RiskTier::Low => 1,
                }
            }

      acceptance_criteria:
        - criterion: "DeterminismEnvelope schema is defined"
          verification: "Check struct definition"
        - criterion: "Run count by tier: HIGH=3, MED=2, LOW=1"
          verification: "Unit test for required_run_count"
        - criterion: "Phase 1 records metadata without enforcement"
          verification: "No enforcement errors in Phase 1"

      test_requirements:
        - test_id: UT-FAC-023-001
          description: "Test determinism envelope schema"
          verification_command: "cargo test -p apm2-core fac::determinism::tests"

    - ticket_id: TCK-00227
      title: "FAC: Flake classification types and routing"
      group_id: TG-FAC-007
      requirement_ids:
        - FAC-REQ-0008
      depends_on:
        - TCK-00226
      phase: PHASE-1
      clarifications:
        - "flake_class is canonical; determinism_status=MISMATCH restricts allowed values."

      files_to_create:
        - path: "crates/apm2-core/src/fac/flake_class.rs"
          purpose: "Flake classification types"

      implementation_steps:
        - step: 1
          action: "Define FlakeClass enum"
          details: |
            pub enum FlakeClass {
                DeterministicFail,   // Not a mismatch; stable FAIL
                HarnessFlake,        // Runner/infra nondeterminism
                EnvironmentDrift,    // Toolchain/runner environment drift
                TestNonsemantic,     // Semantically equivalent but different format
                CodeNonsemantic,     // Non-semantic diff due to tooling
                Unknown,             // Unclassified mismatch
            }

        - step: 2
          action: "Define routing actions"
          details: |
            impl FlakeClass {
                pub fn routing_action(&self) -> FlakeRouting {
                    match self {
                        FlakeClass::DeterministicFail => FlakeRouting::Fail,
                        FlakeClass::HarnessFlake => FlakeRouting::QuarantineRunnerPool,
                        FlakeClass::EnvironmentDrift => FlakeRouting::InvalidateAttestation,
                        FlakeClass::TestNonsemantic => FlakeRouting::QuarantineSpec,
                        FlakeClass::CodeNonsemantic => FlakeRouting::QuarantineSpec,
                        FlakeClass::Unknown => FlakeRouting::NeedsInput,
                    }
                }
            }

      acceptance_criteria:
        - criterion: "FlakeClass has 6 canonical enum values"
          verification: "Check enum definition"
        - criterion: "UNKNOWN cannot convert to PASS via retries"
          verification: "Check routing_action for Unknown"
        - criterion: "HARNESS_FLAKE routes to runner pool quarantine"
          verification: "Unit test for routing"

      test_requirements:
        - test_id: UT-FAC-024-001
          description: "Test flake classification routing"
          verification_command: "cargo test -p apm2-core fac::flake_class::tests"

    # =========================================================================
    # TG-FAC-008: AAT Reuse and Evidence Hygiene
    # =========================================================================

    - ticket_id: TCK-00228
      title: "FAC: AAT reuse provenance validation"
      group_id: TG-FAC-008
      requirement_ids:
        - FAC-REQ-0013
      depends_on:
        - TCK-00218
        - TCK-00222
      phase: PHASE-1
      clarifications:
        - "Reuse window is HTF time_envelope_ref governed by policy; wall-clock not authoritative."
        - "determinism_class must indicate deterministic (e.g., class=0) for reuse."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add AATResultReused message"

      files_to_create:
        - path: "crates/apm2-core/src/fac/aat_reuse.rs"
          purpose: "AAT reuse validation"

      implementation_steps:
        - step: 1
          action: "Define AATResultReused event"
          details: |
            pub struct AATResultReused {
                pub from_receipt_hash: Hash,
                pub provenance: AatProvenanceTuple,
                pub policy_hash: Hash,
                pub justification: String,
                pub gate_signature: Signature,
            }

            pub struct AatProvenanceTuple {
                pub changeset_digest: Hash,
                pub view_commitment_hash: Hash,
                pub rcp_profile_id: String,
                pub verifier_policy_hash: Hash,
                pub determinism_class: u32,
            }

        - step: 2
          action: "Implement reuse validation"
          details: |
            pub fn can_reuse_aat_result(
                risk_tier: RiskTier,
                original: &AatGateReceipt,
                current: &AatProvenanceTuple,
            ) -> Result<(), ReuseError> {
                match risk_tier {
                    RiskTier::High => Err(ReuseError::HighTierNoReuse),
                    RiskTier::Med => Err(ReuseError::MedTierRequiresWaiver),
                    RiskTier::Low => {
                        // Exact provenance tuple match required
                        if original.changeset_digest != current.changeset_digest {
                            return Err(ReuseError::ChangesetMismatch);
                        }
                        if original.view_commitment_hash != current.view_commitment_hash {
                            return Err(ReuseError::ViewCommitmentMismatch);
                        }
                        // ... check all fields
                        Ok(())
                    }
                }
            }

      acceptance_criteria:
        - criterion: "HIGH tier never reuses AAT results"
          verification: "Unit test for HIGH tier rejection"
        - criterion: "MED tier requires waiver for reuse"
          verification: "Unit test for MED tier"
        - criterion: "LOW tier requires exact provenance match"
          verification: "Unit test for provenance validation"

      test_requirements:
        - test_id: UT-FAC-025-001
          description: "Test AAT reuse validation"
          verification_command: "cargo test -p apm2-core fac::aat_reuse::tests"

    - ticket_id: TCK-00229
      title: "FAC: Evidence hygiene enforcement"
      group_id: TG-FAC-008
      requirement_ids:
        - FAC-REQ-0014
      depends_on:
        - TCK-00221
      phase: PHASE-1
      clarifications:
        - "redaction_profile_hash required when redaction_applied==true."

      files_to_modify:
        - path: "crates/apm2-core/src/fac/artifact_manifest.rs"
          changes: "Add evidence hygiene enforcement"

      implementation_steps:
        - step: 1
          action: "Implement admission-time hygiene validation"
          details: |
            pub fn validate_evidence_hygiene_for_admission(
                manifest: &ArtifactManifest,
            ) -> Result<(), HygieneError> {
                for artifact in &manifest.artifacts {
                    // 1. data_classification is required
                    // (enforced by struct definition)

                    // 2. Confidential/Restricted require retention_window
                    if matches!(artifact.data_classification, DataClassification::Confidential | DataClassification::Restricted) {
                        if artifact.retention_window_ref.is_none() {
                            return Err(HygieneError::MissingRetentionWindow(artifact.digest.clone()));
                        }
                    }

                    // 3. Redaction profile required for non-public
                    if artifact.data_classification != DataClassification::Public && artifact.redaction_applied {
                        if artifact.redaction_profile_hash.is_none() {
                            return Err(HygieneError::MissingRedactionProfile(artifact.digest.clone()));
                        }
                    }
                }
                Ok(())
            }

      acceptance_criteria:
        - criterion: "Confidential artifacts require retention_window"
          verification: "Unit test for retention requirement"
        - criterion: "Redacted artifacts require redaction_profile_hash"
          verification: "Unit test for redaction profile"
        - criterion: "Evidence hygiene violations block admission"
          verification: "Unit test for admission blocking"

      test_requirements:
        - test_id: UT-FAC-026-001
          description: "Test evidence hygiene enforcement"
          verification_command: "cargo test -p apm2-core fac::artifact_manifest::tests::hygiene"

    # =========================================================================
    # TG-FAC-009: AAT Quorum and Harness Sandboxing (Phase 2)
    # =========================================================================

    - ticket_id: TCK-00230
      title: "FAC: AAT harness sandboxing schema (Phase 1 - schema only)"
      group_id: TG-FAC-009
      requirement_ids:
        - FAC-REQ-0016
      depends_on:
        - TCK-00218
      phase: PHASE-1
      clarifications:
        - "NetworkPolicyProfile hash is bound into AatAttestation and GateReceipt payload."

      files_to_create:
        - path: "crates/apm2-core/src/fac/harness_sandbox.rs"
          purpose: "AAT harness sandboxing schema"

      implementation_steps:
        - step: 1
          action: "Define sandbox attestation types"
          details: |
            pub struct AatAttestation {
                pub container_image_digest: Hash,
                pub toolchain_digests: Vec<Hash>,
                pub runner_identity_key_id: String,
                pub network_policy_profile_hash: Hash,
            }

            pub struct NetworkPolicyProfile {
                pub profile_id: String,
                pub profile_hash: Hash,
                pub allowed_egress: Vec<EgressRule>,
                pub deny_by_default: bool,
            }

            pub struct EgressRule {
                pub host: String,
                pub port: u16,
                pub protocol: String,
            }

      acceptance_criteria:
        - criterion: "AatAttestation includes container_image_digest"
          verification: "Check struct definition"
        - criterion: "NetworkPolicyProfile has deny_by_default"
          verification: "Check struct definition"

      test_requirements:
        - test_id: UT-FAC-027-001
          description: "Test harness sandbox schema"
          verification_command: "cargo test -p apm2-core fac::harness_sandbox::tests"

    # =========================================================================
    # TG-FAC-010: Invariant-First AAT Specs
    # =========================================================================

    - ticket_id: TCK-00231
      title: "FAC: AAT spec validation requiring invariants"
      group_id: TG-FAC-010
      requirement_ids:
        - FAC-REQ-0011
      depends_on:
        - TCK-00219
      phase: PHASE-1
      clarifications:
        - "At least one invariant must map to a terminal verifier kind."

      files_to_create:
        - path: "crates/apm2-core/src/fac/aat_spec.rs"
          purpose: "AAT spec validation"

      implementation_steps:
        - step: 1
          action: "Define AAT spec types"
          details: |
            pub struct AatSpec {
                pub spec_id: String,
                pub scenario_type: String,
                pub invariants: Vec<Invariant>,
                pub steps: Vec<AatStep>, // Observational only
            }

            pub struct Invariant {
                pub invariant_id: String,
                pub statement: String,
                pub verifier_kind: VerifierKind,
                pub machine_predicate: String,
            }

            pub struct AatStep {
                pub step_id: String,
                pub action: String,
                pub observational: bool, // Must be true
            }

        - step: 2
          action: "Implement spec validation"
          details: |
            impl AatSpec {
                pub fn validate(&self) -> Result<(), SpecValidationError> {
                    // 1. Must have at least one invariant
                    if self.invariants.is_empty() {
                        return Err(SpecValidationError::NoInvariants);
                    }

                    // 2. All invariants must have machine predicates
                    for inv in &self.invariants {
                        if inv.machine_predicate.is_empty() {
                            return Err(SpecValidationError::InvariantMissingPredicate(inv.invariant_id.clone()));
                        }
                    }

                    // 3. Steps are observational only
                    for step in &self.steps {
                        if !step.observational {
                            return Err(SpecValidationError::StepNotObservational(step.step_id.clone()));
                        }
                    }

                    Ok(())
                }
            }

      acceptance_criteria:
        - criterion: "AAT specs require at least one invariant"
          verification: "Unit test for no invariants rejection"
        - criterion: "Step-only specs are rejected"
          verification: "Unit test for observational enforcement"
        - criterion: "Invariants must have machine predicates"
          verification: "Unit test for predicate requirement"

      test_requirements:
        - test_id: UT-FAC-028-001
          description: "Test AAT spec validation"
          verification_command: "cargo test -p apm2-core fac::aat_spec::tests"

    # =========================================================================
    # TG-FAC-011: Atomic Merge Receipt
    # =========================================================================

    - ticket_id: TCK-00232
      title: "FAC: MergeReceipt event with atomic binding"
      group_id: TG-FAC-011
      requirement_ids:
        - FAC-REQ-0020
      depends_on:
        - TCK-00202
        - TCK-00205
      phase: PHASE-1
      clarifications:
        - "merged_at is observational only; result_selector must be observed from external trunk."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add MergeReceipt message"

      files_to_create:
        - path: "crates/apm2-core/src/fac/merge_receipt.rs"
          purpose: "MergeReceipt for atomic merge binding"

      implementation_steps:
        - step: 1
          action: "Add MergeReceipt proto message"
          details: |
            message MergeReceipt {
              bytes base_selector = 1;
              bytes changeset_digest = 2;
              repeated string gate_receipt_ids = 3;
              bytes policy_hash = 4;
              bytes result_selector = 5;
              google.protobuf.Timestamp merged_at = 6;
              string gate_actor_id = 7;
              bytes gate_signature = 8;
            }

        - step: 2
          action: "Create MergeReceipt Rust type"
          details: |
            pub struct MergeReceipt {
                pub base_selector: Hash,
                pub changeset_digest: Hash,
                pub gate_receipt_ids: Vec<ReceiptId>,
                pub policy_hash: Hash,
                pub result_selector: Hash,
                pub merged_at: Timestamp,
                pub gate_actor_id: ActorId,
                pub gate_signature: Signature,
            }

        - step: 3
          action: "Implement atomic merge semantics"
          details: |
            impl MergeReceipt {
                /// Create receipt only after result_selector is observed
                pub fn create_after_observation(
                    inputs: MergeInputs,
                    observed_result: Hash,
                    signer: &dyn Signer,
                ) -> Result<Self, MergeError> {
                    let receipt = MergeReceipt {
                        base_selector: inputs.base_selector,
                        changeset_digest: inputs.changeset_digest,
                        gate_receipt_ids: inputs.gate_receipt_ids,
                        policy_hash: inputs.policy_hash,
                        result_selector: observed_result,
                        merged_at: Timestamp::now(),
                        gate_actor_id: inputs.gate_actor_id,
                        gate_signature: Signature::default(),
                    };

                    // Sign with domain separator
                    let signature = sign_with_domain(
                        signer,
                        MERGE_RECEIPT_PREFIX,
                        &receipt.canonical_bytes(),
                    )?;

                    Ok(MergeReceipt { gate_signature: signature, ..receipt })
                }
            }

      acceptance_criteria:
        - criterion: "MergeReceipt is emitted only after result_selector observed"
          verification: "Unit test for observation requirement"
        - criterion: "Receipt binds (base, changeset, gate_receipts, policy) -> result"
          verification: "Check struct fields"
        - criterion: "Receipt is signed with MERGE_RECEIPT domain separator"
          verification: "Unit test for signature"

      test_requirements:
        - test_id: UT-FAC-029-001
          description: "Test MergeReceipt atomic creation"
          verification_command: "cargo test -p apm2-core fac::merge_receipt::tests"

    # =========================================================================
    # TG-FAC-012: Bounded Retries and Echo-Trap
    # =========================================================================

    - ticket_id: TCK-00233
      title: "FAC: Bounded retry manager"
      group_id: TG-FAC-012
      requirement_ids:
        - FAC-REQ-0021
      depends_on: []
      phase: PHASE-1
      clarifications:
        - "Retry counters reset after successful gate completion or new work_id."

      files_to_create:
        - path: "crates/apm2-core/src/fac/retry_manager.rs"
          purpose: "Bounded retry management"

      implementation_steps:
        - step: 1
          action: "Define retry limits"
          details: |
            pub const MAX_GATE_ATTEMPTS: u32 = 3;
            pub const MAX_GLOBAL_EPISODES: u32 = 50;

            pub struct RetryManager {
                gate_attempts: HashMap<GateId, u32>,
                global_episodes: u32,
            }

        - step: 2
          action: "Implement retry tracking"
          details: |
            impl RetryManager {
                pub fn can_retry(&self, gate_id: &GateId) -> bool {
                    let attempts = self.gate_attempts.get(gate_id).copied().unwrap_or(0);
                    attempts < MAX_GATE_ATTEMPTS && self.global_episodes < MAX_GLOBAL_EPISODES
                }

                pub fn record_attempt(&mut self, gate_id: GateId) -> Result<(), RetryError> {
                    let attempts = self.gate_attempts.entry(gate_id).or_insert(0);
                    *attempts += 1;
                    self.global_episodes += 1;

                    if *attempts > MAX_GATE_ATTEMPTS {
                        return Err(RetryError::GateMaxAttemptsExceeded);
                    }
                    if self.global_episodes > MAX_GLOBAL_EPISODES {
                        return Err(RetryError::GlobalMaxEpisodesExceeded);
                    }
                    Ok(())
                }
            }

      acceptance_criteria:
        - criterion: "Per-gate max attempts is 3"
          verification: "Check MAX_GATE_ATTEMPTS constant"
        - criterion: "Global max episodes is 50"
          verification: "Check MAX_GLOBAL_EPISODES constant"
        - criterion: "Exceeding limits returns error"
          verification: "Unit test for limit enforcement"

      test_requirements:
        - test_id: UT-FAC-030-001
          description: "Test bounded retry enforcement"
          verification_command: "cargo test -p apm2-core fac::retry_manager::tests"

    - ticket_id: TCK-00234
      title: "FAC: Echo-trap detection and escalation"
      group_id: TG-FAC-012
      requirement_ids:
        - FAC-REQ-0021
      depends_on:
        - TCK-00233
      phase: PHASE-1
      clarifications:
        - "Echo-trap window is single GateRun; reset on new GateRun."

      files_to_create:
        - path: "crates/apm2-core/src/fac/echo_trap.rs"
          purpose: "Echo-trap detection"

      implementation_steps:
        - step: 1
          action: "Define echo-trap detection"
          details: |
            pub const ECHO_TRAP_THRESHOLD: usize = 3;

            pub struct EchoTrapDetector {
                finding_signatures: Vec<FindingSignature>,
            }

            impl EchoTrapDetector {
                pub fn record_finding(&mut self, signature: FindingSignature) -> Option<EchoTrapEvent> {
                    self.finding_signatures.push(signature.clone());

                    // Count occurrences of this signature
                    let count = self.finding_signatures.iter()
                        .filter(|s| *s == &signature)
                        .count();

                    if count >= ECHO_TRAP_THRESHOLD {
                        Some(EchoTrapEvent {
                            repeated_signature: signature,
                            occurrence_count: count,
                        })
                    } else {
                        None
                    }
                }
            }

        - step: 2
          action: "Implement escalation on echo-trap"
          details: |
            pub fn on_echo_trap(event: EchoTrapEvent, session: &mut Session) -> SessionTermination {
                // 1. Emit DefectRecord(ECHO_TRAP)
                let defect = DefectRecord::new(DefectType::EchoTrap, &event);

                // 2. Terminate session with REASONING_DEGENERATION
                SessionTermination {
                    rationale: TerminationRationale::ReasoningDegeneration,
                    defect_record: Some(defect),
                    escalate_to_oracle: true,
                }
            }

      acceptance_criteria:
        - criterion: "Echo-trap detected after 3 repeated findings"
          verification: "Check ECHO_TRAP_THRESHOLD constant"
        - criterion: "Session terminated with REASONING_DEGENERATION"
          verification: "Unit test for termination"
        - criterion: "Escalation to oracle is triggered"
          verification: "Unit test for escalation"

      test_requirements:
        - test_id: UT-FAC-031-001
          description: "Test echo-trap detection"
          verification_command: "cargo test -p apm2-core fac::echo_trap::tests"

    # =========================================================================
    # Additional: Quarantine
    # =========================================================================

    - ticket_id: TCK-00235
      title: "FAC: Quarantine events and QuarantineProjection"
      group_id: TG-FAC-003
      requirement_ids:
        - FAC-REQ-0117
      depends_on:
        - TCK-00202
      phase: PHASE-1
      clarifications:
        - "reason is a closed enum (HARNESS_FLAKE, TEST_NONSEMANTIC, ENVIRONMENT_DRIFT, POLICY_VIOLATION, UNKNOWN)."
        - "time_envelope_ref is HTF; wall-clock timestamps are observational only."

      files_to_modify:
        - path: "proto/kernel_events.proto"
          changes: "Add quarantine event messages"

      files_to_create:
        - path: "crates/apm2-core/src/fac/quarantine.rs"
          purpose: "Quarantine events and projection"

      implementation_steps:
        - step: 1
          action: "Add quarantine proto messages"
          details: |
            message RunnerPoolQuarantined {
              string quarantine_id = 1;
              string pool_id = 2;
              string reason = 3;
              repeated bytes evidence_refs = 4;
              bytes time_envelope_ref = 5;
              string issuer_actor_id = 6;
              bytes issuer_signature = 7;
            }

            message AATSpecQuarantined {
              string quarantine_id = 1;
              string spec_id = 2;
              string reason = 3;
              repeated bytes evidence_refs = 4;
              bytes time_envelope_ref = 5;
              string issuer_actor_id = 6;
              bytes issuer_signature = 7;
            }

            message QuarantineCleared {
              string quarantine_id = 1;
              string target_id = 2;
              string cleared_reason = 3;
              string issuer_actor_id = 4;
              bytes issuer_signature = 5;
            }

        - step: 2
          action: "Implement QuarantineProjection"
          details: |
            pub struct QuarantineProjection {
                quarantined_pools: HashSet<String>,
                quarantined_specs: HashSet<String>,
            }

            impl QuarantineProjection {
                pub fn apply(&mut self, event: QuarantineEvent) {
                    match event {
                        QuarantineEvent::RunnerPoolQuarantined(e) => {
                            self.quarantined_pools.insert(e.pool_id);
                        }
                        QuarantineEvent::AATSpecQuarantined(e) => {
                            self.quarantined_specs.insert(e.spec_id);
                        }
                        QuarantineEvent::QuarantineCleared(e) => {
                            self.quarantined_pools.remove(&e.target_id);
                            self.quarantined_specs.remove(&e.target_id);
                        }
                    }
                }

                pub fn is_pool_quarantined(&self, pool_id: &str) -> bool {
                    self.quarantined_pools.contains(pool_id)
                }

                pub fn is_spec_quarantined(&self, spec_id: &str) -> bool {
                    self.quarantined_specs.contains(spec_id)
                }
            }

      acceptance_criteria:
        - criterion: "Quarantine events update QuarantineProjection"
          verification: "Unit test for projection updates"
        - criterion: "Selection excludes quarantined pools/specs"
          verification: "Unit test for exclusion"
        - criterion: "QuarantineCleared re-enables targets"
          verification: "Unit test for clearing"

      test_requirements:
        - test_id: UT-FAC-032-001
          description: "Test quarantine projection"
          verification_command: "cargo test -p apm2-core fac::quarantine::tests"

  # =============================================================================
  # DECOMPOSITION SUMMARY
  # =============================================================================

  summary:
    total_tickets: 34
    phase_1_tickets: 34
    phase_2_deferred: 0

    by_group:
      TG-FAC-001: 7
      TG-FAC-002: 3
      TG-FAC-003: 4
      TG-FAC-004: 3
      TG-FAC-005: 4
      TG-FAC-006: 4
      TG-FAC-007: 2
      TG-FAC-008: 2
      TG-FAC-009: 1
      TG-FAC-010: 1
      TG-FAC-011: 1
      TG-FAC-012: 2

    dependency_depth: 3
    parallelization_opportunities:
      - "TCK-00202, TCK-00209, TCK-00215, TCK-00218, TCK-00222 can run in parallel (no dependencies)"
      - "After foundation layer, most tickets can proceed in parallel within their groups"

    critical_path:
      - TCK-00202  # Domain separator
      - TCK-00203  # GateLease
      - TCK-00205  # GateRunCompleted
      - TCK-00218  # AatGateReceipt
      - TCK-00224  # Anti-downgrade

  open_questions_for_decomposition:
    - id: Q-DECOMP-0001
      question: "Proto placement for FAC events: extend kernel_events.proto or create fac_events.proto?"
      status: RESOLVED
      resolution: "Extend kernel_events.proto (Q-RFC-FAC-0001)"

    - id: Q-DECOMP-0002
      question: "Context firewall integration point: daemon protocol layer or core library?"
      status: RESOLVED
      resolution: "Core library via ContextAwareValidator (Q-RFC-FAC-0002)"

    - id: Q-DECOMP-0003
      question: "AAT transcript schema: existing TranscriptChunk or new FAC-specific type?"
      status: RESOLVED
      resolution: "Reuse TranscriptChunk from CAC (Q-RFC-FAC-0005)"
