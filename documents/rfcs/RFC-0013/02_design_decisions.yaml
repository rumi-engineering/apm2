rfc_design_decisions:
  schema_version: "2026-01-27"
  template_version: "2026-01-27"

  design_space_exploration:
    doctrine_ref: "documents/theory/unified-theory-v2.json"
    options:
      - option_id: OPT-A
        name: "External process manager (systemd/supervisord)"
        description: |
          Use external process managers to spawn and supervise agent processes.
          APM2 coordinates via file-based or socket IPC.
        evaluation:
          strengths:
            - "Mature tools with built-in restart policies"
            - "Well-understood operational model"
          weaknesses:
            - "No OCAP enforcement at process boundary"
            - "Budget enforcement requires custom wrappers"
            - "Evidence binding is ad-hoc"
            - "Telemetry integration fragmented"

      - option_id: OPT-B
        name: "Embedded daemon with protocol server"
        description: |
          Implement kernel daemon (apm2d) with UDS-based protocol server.
          Daemon owns episode lifecycle, tool mediation, telemetry, and evidence.
          Harness processes spawned as child processes with PTY capture.
        evaluation:
          strengths:
            - "Full control over episode lifecycle"
            - "OCAP enforcement at tool mediation layer"
            - "Unified budget tracking and enforcement"
            - "Evidence binding at receipt emission"
            - "Single authority for ledger events"
          weaknesses:
            - "More implementation complexity"
            - "Daemon availability becomes critical"

      - option_id: OPT-C
        name: "Container-based isolation (Docker/Podman)"
        description: |
          Run each episode in a container with resource limits via cgroups.
          APM2 CLI orchestrates container lifecycle.
        evaluation:
          strengths:
            - "Strong isolation by default"
            - "Resource limits via container runtime"
          weaknesses:
            - "Container overhead per episode"
            - "Latency for spawn/teardown"
            - "Tool mediation still requires custom layer"
            - "Evidence binding not solved by containers"

    selected_approach:
      choice: OPT-B
      rationale: |
        Doctrine requires: (1) OCAP enforcement, (2) budget tracking, (3) receipt
        binding, (4) telemetry integration, (5) evidence economics. Only OPT-B
        provides unified control over all these concerns.

        Container isolation (OPT-C) can be a future enhancement for sandbox tiering
        but is not required for v1. The protocol invariant (envelope + receipts)
        is preserved regardless of sandbox implementation.

        External managers (OPT-A) lack the authority boundaries required for
        holonic operation.

  architecture_decisions:
    - decision_id: AD-DAEMON-001
      title: "Six-plane system architecture"
      description: |
        System organized into six planes:
        1. Control Plane (CP): Low-rate authoritative commands; receipt-producing
        2. I/O Plane (IOP): PTY/stdin/stdout/stderr streaming; bounded buffers
        3. Tool Plane (TP): Mediated actuation via requests/responses; dedupe; receipts
        4. Telemetry Plane (TEL): High-rate metrics frames; lossy aggregation
        5. Evidence Plane (EV): Content-addressed artifacts + retention policy
        6. Ledger Plane (LDG): Append-only event store; reducers rebuild projections
      rationale: |
        Explicit plane separation enables: clear trust boundaries per channel,
        independent scaling/optimization, targeted backpressure, and retention
        policies per plane.
      doctrine_ref: "unified-theory.md#channel-classes"

    - decision_id: AD-DAEMON-002
      title: "UDS as default transport with length-prefixed framing"
      description: |
        Default transport: Unix domain socket (UDS), framed binary messages.
        Framing: length-prefixed frames; no newline framing; bounded max frame size.
        TCP with auth is optional and out of scope for v1.
      rationale: |
        UDS provides: low latency, no network exposure by default, credential
        passing via SO_PEERCRED for client identity. Length-prefix framing is
        simpler and faster than text-based framing.
      transport_details:
        socket_path: "${XDG_RUNTIME_DIR}/apm2/apm2d.sock"
        max_frame_size_bytes: 16777216
        protocol_version: 1

    - decision_id: AD-DAEMON-003
      title: "Protobuf as primary wire encoding"
      description: |
        Primary on-wire encoding: protobuf for CP/TP/TEL frames.
        Canonicalization: all signed/hashed structures MUST define versioned
        canonical_bytes() with deterministic encoding rules and golden vectors.
        JSON via JCS (RFC 8785) only for derived ABI or human-facing artifacts.
      rationale: |
        Protobuf provides: compact encoding, schema evolution, language-agnostic
        tooling. Deterministic encoding required for stable digests.
      canonicalization_rules:
        - "Signature field excluded from canonical bytes"
        - "Maps forbidden in signed messages"
        - "Repeated fields sorted for set semantics where required"
        - "Golden vectors maintained in kernel-testkit"

    - decision_id: AD-EPISODE-001
      title: "Immutable episode envelope"
      description: |
        Episode created with single immutable envelope object. Envelope is
        referenced by digest and bound into all receipts.

        Required fields:
        - episode_id: stable UUID or digest
        - actor_id: caller identity
        - work_id: optional but recommended
        - lease_id: required for actuation
        - budget: {tokens, tool_calls, wall_ms, cpu_ms, bytes_io, evidence_bytes}
        - stop_conditions: success/fail/escalate predicates
        - pinned_snapshot: digests of repo/locks/policy/toolchain/model profile
        - capability_manifest_hash: OCAP tool handles and scope
        - risk_tier: drives mandatory gates and evidence strength
        - determinism_class: declared (verified by receipts)

        Optional fields (v1):
        - context_refs: context_pack_hash, dcp_refs[]
      rationale: |
        Immutable envelope enables: reproducibility (pinned inputs), audit trail
        (digest binding), OCAP enforcement (capability manifest), and budget
        governance (explicit limits).
      doctrine_ref: "unified-theory.md#episode-envelope"

    - decision_id: AD-EPISODE-002
      title: "Session state machine"
      description: |
        States: CREATED -> RUNNING -> (TERMINATED | QUARANTINED)
        Transitions emit kernel events and receipts.
        State is reconstructible from ledger.

        CREATED: Envelope accepted; resources not yet allocated
        RUNNING: Harness process spawned; I/O streaming active
        TERMINATED: Normal completion (success or failure); evidence finalized
        QUARANTINED: Abnormal termination; evidence pinned for investigation
      rationale: |
        Three-state model is minimal for episode lifecycle. QUARANTINED separates
        normal failure from incidents requiring investigation.
      invariants:
        - "No transition from TERMINATED or QUARANTINED"
        - "All transitions emit events"
        - "RUNNING requires valid lease"

    - decision_id: AD-TOOL-001
      title: "Tool execution as receipted actuation"
      description: |
        Tool actuation is the only permitted effect path. Each tool execution
        produces three events:
        1. ToolRequested: args hash, dedupe key
        2. ToolDecided: ALLOW/DENY, policy hash, charged budgets
        3. ToolExecuted: result hash, duration, outcome

        Tool args/results stored in CAS; small payloads may be inlined below
        strict threshold (4KB default).
      rationale: |
        Event triple provides: complete audit trail, replay safety via dedupe,
        budget attribution per tool, and evidence binding.
      dedupe_semantics: |
        Dedupe keys mandatory for idempotent tools. Repeated ToolRequest with
        same dedupe key MUST return cached result or stable denial.

    - decision_id: AD-TOOL-002
      title: "Capability manifests as sealed references"
      description: |
        Capability handles are sealed references to tool classes with scoped
        parameters: roots, paths, network policy, max sizes.
        Capabilities MUST NOT be discoverable; only explicit delegation creates
        capabilities.

        Manifest structure:
        - capability_id: unique identifier
        - tool_class: Read | Write | Execute | Network | ...
        - scope: root paths, allowed patterns, size limits
        - risk_tier_required: minimum tier for this capability
        - delegator_id: who granted this capability
      rationale: |
        OCAP prevents ambient authority. Sealed references ensure capabilities
        cannot be forged or escalated.
      doctrine_ref: "unified-theory.md#ocap"

    - decision_id: AD-TEL-001
      title: "Telemetry collection via cgroups v2"
      description: |
        Collection mechanisms (Ubuntu 24.04):
        - CPU/memory: cgroups v2 + /proc/<pid>; RSS, page faults, cpu time, threads
        - Disk I/O: cgroup io.stat + process fd stats
        - Network (v1): coarse (host interface deltas)
        - Network (v2): eBPF per cgroup/pid (future)

        TelemetryFrame structure:
        - episode_id, seq, ts_mono
        - cpu_ns, cpu_user_ns, cpu_system_ns
        - mem_rss_bytes, mem_peak_bytes, page_faults_major, page_faults_minor
        - io_read_bytes, io_write_bytes, io_read_ops, io_write_ops
        - net_rx_bytes, net_tx_bytes (when available)
        - o11y_flags (sampling mode indicators)
      rationale: |
        cgroups v2 is standard on modern Linux. Telemetry frames provide evidence
        of consumption when signed and bound to episode.
      accounting_semantics: |
        Telemetry frames are evidence when collected via trusted probes.
        Otherwise advisory only; should not be used for high-risk enforcement.

    - decision_id: AD-EVID-001
      title: "Flight recorder with trigger-based persistence"
      description: |
        Per-episode ring buffers for:
        - PTY transcript
        - Tool I/O details
        - High-rate telemetry

        Persist full-fidelity buffers ONLY on triggers:
        - Gate failure
        - Policy violation
        - Budget exhaustion
        - Crash/kill
        - Explicit pin request

        Ring buffer sizes configurable per risk tier.
      rationale: |
        Evidence must not scale linearly with runtime duration. Ring buffers
        provide always-on observability with bounded storage; triggers escalate
        to full fidelity when needed.
      retention_policy:
        always_on: "receipts, digests, counters, minimal summaries"
        conditional: "raw transcripts, verbose logs, high-rate telemetry"

    - decision_id: AD-EVID-002
      title: "Evidence TTL and pinning"
      description: |
        Every evidence artifact has: ttl, class, pin_state.
        - ttl: time-to-live for unpinned artifacts
        - class: ephemeral | standard | archival
        - pin_state: unpinned | pinned(reason, expires)

        Pinning triggered by DefectRecords and incidents; pinned evidence
        retained until closure. Compaction produces summary receipts referencing
        dropped raw artifacts by digest (tombstoned pointers).
      rationale: |
        Storage costs scale with retention. TTL + pinning enables automatic
        cleanup while preserving evidence needed for investigation.

    - decision_id: AD-RECEIPT-001
      title: "Receipt kinds and binding"
      description: |
        Receipt kinds:
        - tool_execution.receipt
        - episode.receipt (start/stop, envelope binding)
        - gate.receipt
        - telemetry.receipt (aggregates or trigger-pinned raw)
        - compaction.receipt (optional)
        - stop_order.receipt (emergency stop)

        Each receipt MUST bind:
        - envelope_hash (EpisodeEnvelope)
        - policy_hash (PolicyLoaded)
        - canonicalizer_id and version
        - evidence_refs (CAS hashes)
        - unsigned_bytes_hash
        - signer_identity
      rationale: |
        Receipt binding enables verification via doctrine predicate. All receipts
        trace to envelope for episode attribution.
      verification_predicate: |
        Valid(Output, Receipt, Evidence) :=
          VerifyReceipt(receipt) AND
          EvidenceSatisfies(contract, evidence) AND
          DigestBindingsHold(output, evidence)

    - decision_id: AD-SEC-001
      title: "Baseline security controls"
      description: |
        V1 baseline controls:
        - UDS-only default; no network exposure
        - Default deny tool capabilities; read-only by default
        - No ambient credentials in harness environment
        - Session sandboxing: filesystem confinement + network namespace isolation
          (REQUIRED for tier 3+; OPTIONAL for tier 1-2)
        - Stop-state check before any actuation; fail closed on unverifiable stop

        Threat classes addressed:
        - Prompt injection via tool output (untrusted observations)
        - Confused deputy via overbroad capabilities
        - Uncontrolled side effects outside tool plane
        - Evidence tampering / receipt forgery
        - Data exfiltration via logs/evidence
      rationale: |
        Defense in depth with fail-closed defaults. Network exposure and
        broader capabilities require explicit risk tier elevation.

    - decision_id: AD-BACK-001
      title: "Bounded channels with explicit backpressure"
      description: |
        All streaming channels are bounded; memory growth is prohibited.
        Backpressure strategy must be explicit:
        - Default: block producers on full buffers
        - Optional: drop low-priority telemetry frames first

        Per-client quotas:
        - max_concurrent_sessions
        - max_streams
        - max_telemetry_rate
      rationale: |
        Unbounded channels lead to OOM. Explicit backpressure prevents
        cascading failures.

  # v2 Architecture Decisions (2026-01-27)
  # These decisions resolve v0 council findings and open questions

  v2_architecture_decisions:
    - decision_id: AD-LAYER-001
      title: "EpisodeRuntime extends (not replaces) EpisodeController"
      description: |
        **v0 Finding Resolved:** SA3-F-011 COUSIN VIOLATION

        The daemon EpisodeRuntime operates at a different abstraction layer than
        apm2-holon EpisodeController. They are complementary, not competing:

        **EpisodeController (apm2-holon):**
        - In-process episode loop manager for bounded holon execution
        - Manages Holon trait implementations
        - Enforces logical budgets (tokens, episodes, time)
        - Produces RunReceipt with pack sufficiency

        **EpisodeRuntime (apm2-daemon):**
        - Daemon-hosted process lifetime manager
        - Wraps HarnessAdapter as Holon implementation
        - Enforces resource budgets via cgroups (CPU, memory, I/O)
        - Collects telemetry and manages evidence economics

        **Layering Model (Normative):**
        1. **EpisodeRuntime (apm2-daemon)** is the **Authoritative Plant Controller**. It 
           owns the process lifetime, enforces resource budgets via cgroups, and 
           is the single source of truth for kernel events and receipts.
        2. **EpisodeController (apm2-holon)** is an **Orchestration Algorithm**. It
           consumes services provided by the daemon and provides an in-process
           execution loop for Holon traits. It is **NOT authoritative**; its 
           outputs (like RunReceipt) are advisory and must be bound into 
           authoritative daemon receipts to be meaningful.

        ```
        EpisodeRuntime (Authoritative Plant Controller)
            └── EpisodeController (Orchestration Algorithm)
                    └── HarnessAdapter implements Holon trait
        ```

        **Key Invariants:**
        1. EpisodeRuntime uses EpisodeController internally for harness holons
        2. HarnessAdapter implements Holon trait for seamless integration
        3. Logical budgets (EpisodeController) and resource budgets (EpisodeRuntime) are orthogonal
        4. Receipts: RunReceipt (pack) embedded in daemon receipts (envelope binding)
      rationale: |
        This design eliminates cousin violation by establishing clear responsibility boundaries.
        EpisodeController remains the canonical in-process loop; daemon wraps it for
        out-of-process harness execution. No code duplication; clean extension.
      evidence_refs:
        - "crates/apm2-holon/src/episode/controller.rs"
        - "crates/apm2-holon/src/traits.rs (Holon trait)"
      traces_to: [REQ-EPISODE-001, REQ-ADAPTER-001]

    - decision_id: AD-CGROUP-001
      title: "Per-episode cgroup hierarchy with systemd transient API"
      description: |
        **v0 Question Resolved:** OQ-DAEMON-002

        Each episode executes in an isolated cgroup scope under the daemon slice:

        **Hierarchy:**
        ```
        /sys/fs/cgroup/apm2.slice/
        ├── daemon.service/           # Daemon process
        └── episode-<uuid>.scope/     # Per-episode isolation
            ├── memory.max
            ├── cpu.max
            └── memory.oom.group
        ```

        **Creation Strategy:**
        1. Primary: systemd transient API (DBus: org.freedesktop.systemd1)
           - Requires `zbus` crate for DBus communication.
        2. Fallback: Direct cgroup v2 writes via nix crate
           - Mitigation: create frozen cgroup, assign PID, then unfreeze to prevent
             escape/race between creation and process assignment.

        **Budget Mapping:**
        - episode_budget.memory_bytes → cgroup memory.max
        - episode_budget.cpu_ms → cgroup cpu.max (calculated percentage)

        **Degraded Mode:**
        If cgroup v2 unavailable, fall back to /proc/<pid>/stat for basic metrics.
        Telemetry accuracy reduced but functional.
      rationale: |
        Systemd integration provides automatic cleanup and better ecosystem alignment.
        Direct fallback ensures operation on non-systemd systems.
      evidence_refs:
        - "No existing cgroup code - implementation required"
        - "Cargo.toml: nix = 0.30 with signal/process/fs/pty features"
        - "Cargo.toml: zbus = 4.4"
      traces_to: [REQ-TEL-001, REQ-DAEMON-001]

    - decision_id: AD-ADAPT-001
      title: "HarnessAdapter implements Holon trait"
      description: |
        **v0 Question Resolved:** OQ-DAEMON-001

        HarnessAdapter becomes the concrete Holon implementation for daemon-hosted
        harnesses. This enables EpisodeController integration:

        **Trait Mapping:**
        ```rust
        impl Holon for HarnessAdapter {
            type Input = HarnessConfig;
            type Output = EpisodeReceipt;
            type State = AdapterState;

            fn execute_episode(&mut self, ctx: &EpisodeContext) -> EpisodeResult {
                // PTY I/O becomes episode work
                // Tool requests become artifact side-effects
                // Telemetry flows through progress updates
            }

            fn should_stop(&self, ctx: &EpisodeContext) -> StopCondition {
                // Evaluate harness-specific stop conditions
                // Check for tool completion signals
            }
        }
        ```

        **Composition Pattern:**
        `HarnessAdapter` (daemon) acts as a wrapper around existing `Adapter` trait
        implementations (core), normalizing vendor-specific PTY output into
        structured `HarnessEvent` streams consumed by the `Holon` execution loop.

        **Parser Architecture:**
        - Each vendor adapter implements deterministic parser state machine
        - Parser emits HarnessEvent::ToolRequest on detection
        - Parsing failures emit DefectRecord, never crash
        - Test fixtures from real harness sessions required
      rationale: |
        Using existing Holon trait enables code reuse and consistent lifecycle semantics.
        Parser state machine ensures deterministic behavior for evidence integrity.
      evidence_refs:
        - "crates/apm2-core/src/adapter/black_box.rs"
        - "crates/apm2-core/src/adapter/claude_code.rs"
      traces_to: [REQ-ADAPTER-001]

    - decision_id: AD-FAIL-001
      title: "Adapter failure handling with circuit breaker pattern"
      description: |
        **v0 Question Resolved:** OQ-DAEMON-003

        Adapter failures handled via existing apm2-core infrastructure:

        **State Machine:**
        ```
        Running --timeout--> HealthCheck
        HealthCheck --fail--> FailureCount++
        FailureCount >= 3 --> Quarantine
        Running --crash--> RestartCoordinator
        RestartCoordinator --retry--> Running (with resume_cursor)
        RestartCoordinator --exhausted--> Quarantine
        ```

        **Evidence Promotion:**
        All failures trigger evidence promotion:
        - Flight recorder (PTY, tool I/O, telemetry) → CAS
        - Evidence category: AdapterFailure
        - Link to episode receipts

        **Restart Recovery:**
        - Use resume_cursor from last checkpoint
        - Increment restart_attempt (monotonicity enforced by SessionReducer)
        - Apply backoff delay from RestartCoordinator
      rationale: |
        Leveraging existing crash detection and restart infrastructure reduces
        implementation complexity and ensures consistent behavior across session types.
      evidence_refs:
        - "crates/apm2-core/src/session/crash.rs"
        - "crates/apm2-core/src/session/restart_coordinator.rs"
        - "crates/apm2-core/src/health/mod.rs"
      traces_to: [REQ-DAEMON-001, REQ-ADAPTER-001]

    - decision_id: AD-CAC-001
      title: "Dual-layer CAC ContextPack enforcement"
      description: |
        **v0 Question Resolved:** OQ-DAEMON-004

        Context Access Control operates at two integration points:

        **Layer 1: apm2-daemon (Pre-Execution)**
        - ToolBroker validates Read requests against context pack manifest
        - Unmapped paths: DENY by default, emit context miss defect
        - Policy tier determines enforcement strictness

        **Layer 2: apm2-holon (Post-Execution Audit)**
        - EpisodeController tracks pack misses in RunReceipt
        - record_pack_miss() already exists (currently dead code)
        - Enables pack sufficiency analysis

        **Policy Tier Matrix:**
        | Tier | Behavior | Rationale |
        |------|----------|-----------|
        | 1 | Warn only | Development flexibility |
        | 2 | Deny, log | Production safety |
        | 3+ | Deny, quarantine | Maximum security |

        **Protocol Flow:**
        1. context_pack_hash in EpisodeEnvelope.context_refs
        2. ToolBroker loads manifest from CAS
        3. Validate path against allowed patterns
        4. Emit ToolRequested event with context_miss flag if denied
        5. Post-episode: RunReceipt includes pack_sufficiency_score
      rationale: |
        Dual-layer enforcement provides defense in depth: real-time blocking
        (daemon) plus audit trail (holon). Both use DefectRecord (moved to apm2-core)
        for consistency.
      evidence_refs:
        - "crates/apm2-holon/src/episode/controller.rs:record_pack_miss"
        - "crates/apm2-core/src/cac/defect.rs (DefectRecord)"
      traces_to: [REQ-TOOL-001, REQ-EVID-001]

    - decision_id: AD-EVID-003
      title: "Evidence economics as ledger events + reducers"
      description: |
        **Core Architectural Principle:**

        Evidence economics operates through the existing reducer pattern. The ledger
        IS the substrate; metrics are reducers over the ledger. There are no parallel
        pipelines (e.g., Prometheus scrape) that bypass receipts/evidence.

        **Architecture:**
        ```
        [Daemon Process]                    [Ledger/Reducers]

        Ring Buffers (transient)            EvidenceReducer (processes evidence.* events)
          - PTY transcript                  MetricsReducer (computes scorecard)
          - Tool I/O                        CompactionReducer (processes compaction.* events)
          - Telemetry frames                        ↓
                ↓                           All metrics derived from ledger events
          Trigger fires                     Evidence-backed, versioned, deterministic
                ↓                           All metrics derived from events, versioned
          Emit events to ledger
        ```

        **Key Invariants:**
        1. **Ring buffers** = daemon-local transient capture (NOT the ledger)
        2. **On trigger** → emit events to ledger (event vocabulary TBD in v4)
        3. **Reducers compute all metrics** from ledger events (no parallel pipelines)
        4. **TTL/pinning** = ledger events processed by EvidenceReducer
        5. **MetricsReducer** derives scorecard from event stream
        6. **Metrics must be evidence-backed**, derived from events, versioned

        **Existing Infrastructure (extend, not replace):**
        - Reducer trait: `crates/apm2-core/src/reducer/traits.rs`
        - EvidenceReducer: `crates/apm2-core/src/evidence/reducer.rs`
        - DefectRecord: `crates/apm2-core/src/cac/defect.rs` (Moved from apm2-holon)
        - ContentAddressedStore: `crates/apm2-core/src/evidence/cas.rs`

        **v4 Finalization Required:**
        - Event vocabulary: `telemetry.frame`, `evidence.pinned`, `evidence.ttl_expired`, `compaction.completed`
        - EvidenceReducer extensions for pin_state/TTL event handling (TODO: TCK-PEND-014)
        - MetricsReducer state schema and projections
        - DefectRecord → evidence.pinned event wiring
      rationale: |
        This design prevents Goodharting by ensuring all metrics derive from the
        auditable event stream. Parallel pipelines that bypass the ledger would
        create unverifiable telemetry. The reducer pattern ensures deterministic,
        checkpointable metric computation that can be verified against receipts.

        Ring buffers serve as transient capture (bounded memory, recent history).
        On triggers (failure, policy violation, explicit pin), buffers emit events
        to the ledger where reducers process them into durable state.
      evidence_refs:
        - "crates/apm2-core/src/reducer/traits.rs (Reducer trait)"
        - "crates/apm2-core/src/evidence/reducer.rs (EvidenceReducer)"
        - "crates/apm2-core/src/cac/defect.rs (DefectRecord)"
        - "crates/apm2-core/src/evidence/cas.rs (ContentAddressedStore)"
        - "crates/apm2-core/src/evidence/state.rs (needs pin_state field in v4)"
      traces_to: [REQ-EVID-001, REQ-TEL-001]

    - decision_id: AD-KEY-001
      title: "Signing key lifecycle and rotation"
      description: |
        **v0 Finding Resolved:** SA3-F-001

        Daemon signing keys follow a strict lifecycle to mitigate compromise risk:

        **Lifecycle Phases:**
        1. **Generation**: Keys generated in OS-protected keychain (Secret Service API
           or Apple Keychain) using Ed25519.
        2. **Versioning**: Each key has a `key_id` and `version` (monotonic).
        3. **Rotation**: Scheduled rotation every 90 days. New key generated; old
           key preserved for verification of historical receipts for 1 year.
        4. **Compromise Recovery**: If compromise detected, revoke key in policy,
           quarantine affected episodes, and rotate immediately.

        **HSM Guidance**:
        Production deployments SHOULD use hardware-backed keys (TPM/YubiKey)
        where available via PKCS#11 or equivalent.
      rationale: |
        Cryptographic integrity requires managed key lifecycles. 90-day rotation
        limits the blast radius of any undetected compromise.
      traces_to: [REQ-RECEIPT-001]

    - decision_id: AD-VERIFY-001
      title: "Deterministic Protobuf serialization (canonical_bytes)"
      description: |
        **v0 Finding Resolved:** SA2-F-008, SA3-F-003

        To ensure stable digests for signing, all Protobuf messages bound into
        receipts MUST use deterministic serialization.

        **The Unsigned Canonical Bytes Rule:**
        Authoritative signing is performed over the "Unsigned Canonical Bytes" of 
        a message. This is defined as the Protobuf-encoded bytes of the message 
        where the `signature` and any `issuer_signature` fields are set to their 
        default (empty) values. This ensures the signature does not attempt to 
        sign itself, creating a stable fixpoint for verification.

        **Deterministic Rules:**
        1. **Field Order**: Fields MUST be serialized in tag number order (standard).
        2. **Maps**: Maps are forbidden in signed messages (use repeated entries).
        3. **Repeated Fields**: Order must be stable (sorted by content hash if
           representing a set).
        4. **Unknown Fields**: Unknown fields MUST be dropped before serialization.
        5. **Default Values**: Explicitly serialized; no implicit default skipping.

        **Verification**:
        `canonical_bytes()` implementation must pass `kernel-testkit` golden
        vector suite for each message type.
      rationale: |
        Non-deterministic serialization would result in signature verification
        failures across platforms or library versions.
      traces_to: [REQ-RECEIPT-001, REQ-EPISODE-001]

  # Original v0 open questions (now resolved, preserved for history)
  open_questions_v0:
    - id: OQ-DAEMON-001
      question: "How should harness adapter detect tool calls from PTY output?"
      context: |
        Black-box mode requires parsing harness PTY output to identify tool calls.
        Vendor CLIs may have different output formats.
      status: RESOLVED_V2
      resolution_ref: AD-ADAPT-001
      owner: AUTH_ARCHITECTURE

    - id: OQ-DAEMON-002
      question: "What is the exact cgroup hierarchy for episode isolation?"
      context: |
        Episodes need cgroup isolation for telemetry and resource limits.
        Need to determine: per-episode cgroups vs shared pool.
      status: RESOLVED_V2
      resolution_ref: AD-CGROUP-001
      owner: AUTH_ARCHITECTURE

    - id: OQ-DAEMON-003
      question: "How should daemon handle adapter failures during episode?"
      context: |
        Adapter may crash or become unresponsive. Need recovery strategy
        that preserves evidence and emits proper termination events.
      status: RESOLVED_V2
      resolution_ref: AD-FAIL-001
      owner: AUTH_ARCHITECTURE

    - id: OQ-DAEMON-004
      question: "What is the protocol for CAC ContextPack enforcement?"
      context: |
        Weak local models may need deny-by-default read restrictions.
        How is this integrated into tool plane?
      status: RESOLVED_V2
      resolution_ref: AD-CAC-001
      owner: AUTH_ARCHITECTURE

  crate_boundaries:
    - crate: apm2-core
      purpose: "Canonical types, ledger/CAS, reducers, canonicalization, receipts"
      extends: true

    - crate: apm2-daemon
      purpose: "Protocol server, PTY runner, telemetry collectors, tool broker wiring"
      extends: true

    - crate: apm2-cli
      purpose: "Thin client; role commands; attaches to I/O streams"
      extends: true

    - crate: kernel-testkit
      purpose: "Canonical bytes golden vectors, conformance tests, fuzz harness"
      new: true
