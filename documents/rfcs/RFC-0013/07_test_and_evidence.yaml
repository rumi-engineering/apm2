rfc_test_and_evidence:
  schema_version: "2026-01-27"
  template_version: "2026-01-27"

  test_strategy:
    overview: |
      The kernel daemon is mission-critical infrastructure. Testing emphasizes:
      1. Correctness via property-based testing
      2. Stability via golden vector testing
      3. Reliability via fault injection
      4. Performance via load testing

      All receipt and canonicalization logic requires golden vectors to
      ensure determinism across implementations.

    test_categories:
      - category: UNIT_TESTS
        description: "Component-level tests for types, serialization, and logic"
        coverage_targets:
          - target: "EpisodeEnvelope canonicalization"
            verification: "Golden vectors match expected digests"
          - target: "Episode state machine transitions"
            verification: "All transitions emit correct events"
          - target: "Capability validation"
            verification: "Unauthorized requests denied"
          - target: "Dedupe cache semantics"
            verification: "Repeated requests return cached results"
          - target: "Receipt binding"
            verification: "All fields bound correctly"

      - category: GOLDEN_VECTORS
        description: "Deterministic test vectors for canonicalization and receipts"
        vectors:
          - name: "episode_envelope_canonical"
            description: "EpisodeEnvelope serialization vectors"
            format: "JSON -> canonical bytes -> BLAKE3 hash"
            count_minimum: 10

          - name: "tool_receipt_canonical"
            description: "ToolReceipt serialization vectors"
            format: "Struct -> unsigned bytes -> signature"
            count_minimum: 10

          - name: "protocol_framing"
            description: "Length-prefix framing vectors"
            format: "Message bytes -> framed bytes"
            count_minimum: 5

          - name: "telemetry_frame_canonical"
            description: "TelemetryFrame serialization"
            format: "Struct -> protobuf bytes"
            count_minimum: 5

      - category: PROPERTY_TESTS
        description: "Invariant verification via property-based testing"
        properties:
          - property: "Episode state machine validity"
            description: "No invalid state transitions possible"
            verification: "Proptest with arbitrary event sequences"

          - property: "Budget monotonicity"
            description: "Budget consumption never decreases"
            verification: "Proptest budget updates"

          - property: "Evidence digest stability"
            description: "Same content always produces same digest"
            verification: "Proptest content variations"

          - property: "Receipt verification round-trip"
            description: "Signed receipts always verify"
            verification: "Proptest arbitrary receipts"

          - property: "Canonicalization determinism"
            description: "Same input always produces same canonical bytes"
            verification: "Proptest serialization"

      - category: INTEGRATION_TESTS
        description: "Multi-component tests with real daemon"
        scenarios:
          - scenario: "Episode lifecycle happy path"
            description: "Create, start, run, terminate episode"
            verification: "Receipt produced, evidence stored"

          - scenario: "Budget exhaustion termination"
            description: "Episode terminated on budget limit"
            verification: "BUDGET_EXHAUSTED event emitted"

          - scenario: "Tool mediation flow"
            description: "Tool request -> decision -> execution -> receipt"
            verification: "Complete event chain, receipt verifies"

          - scenario: "Telemetry collection accuracy"
            description: "Telemetry matches actual consumption"
            verification: "Within 5% of cgroup values"

          - scenario: "Flight recorder trigger"
            description: "Failure triggers evidence promotion"
            verification: "Full transcript persisted"

      - category: FAULT_INJECTION
        description: "Reliability testing via failure simulation"
        scenarios:
          - scenario: "Harness crash during execution"
            description: "Child process crashes unexpectedly"
            verification: "Episode quarantined, evidence pinned"

          - scenario: "Daemon restart during episode"
            description: "Daemon crashes while episode running"
            verification: "Episode state recoverable from ledger"

          - scenario: "CAS write failure"
            description: "Evidence storage fails"
            verification: "Episode terminates with storage error"

          - scenario: "Protocol connection drop"
            description: "Client disconnects mid-stream"
            verification: "Episode continues or graceful cleanup"

      - category: LOAD_TESTS
        description: "Performance and scalability testing"
        scenarios:
          - scenario: "Concurrent episodes"
            description: "10 episodes running simultaneously"
            verification: "No resource leaks, < 5% CPU overhead per episode"

          - scenario: "High-rate tool requests"
            description: "100 tool requests per second"
            verification: "< 10ms median latency"

          - scenario: "Large telemetry volume"
            description: "1000 telemetry frames per second"
            verification: "No frame loss, bounded memory"

          - scenario: "Large evidence artifacts"
            description: "10MB tool result storage"
            verification: "< 100ms write latency"

      - category: CONFORMANCE_TESTS
        description: "Protocol and behavior conformance"
        scenarios:
          - scenario: "Protocol version negotiation"
            description: "Client and server agree on version"
            verification: "Version mismatch handled gracefully"

          - scenario: "Canonicalizer versioning"
            description: "Golden vectors pass for each version"
            verification: "All vectors pass"

          - scenario: "Receipt verification predicate"
            description: "Verification follows doctrine formula"
            verification: "Tampered receipts rejected"

  evidence_requirements:
    doctrine_evidence_refs:
      - id: EVID-TRUTH-001
        description: "Ledger events correctly capture all state transitions"
        verification: "Replay from genesis produces identical state"

      - id: EVID-BOUNDARY-001
        description: "Channel classification is complete"
        verification: "No unclassified I/O observed in integration tests"

      - id: EVID-OCAP-001
        description: "Capabilities prevent unauthorized access"
        verification: "All unauthorized requests denied in test suite"

      - id: EVID-LEASE-001
        description: "Budget enforcement terminates episodes"
        verification: "Budget exhaustion tests pass"

      - id: EVID-MEASURE-001
        description: "Receipts satisfy verification predicate"
        verification: "All receipt tests include verification check"

      - id: EVID-BOUNDED-001
        description: "Evidence storage is bounded"
        verification: "Load tests show bounded memory growth"

  test_infrastructure:
    dependencies:
      - name: proptest
        purpose: "Property-based testing for invariants"

      - name: criterion
        purpose: "Benchmark framework for performance tests"

      - name: tokio-test
        purpose: "Async test utilities"

      - name: tempfile
        purpose: "Isolated test directories"

      - name: nix
        purpose: "PTY and signal handling in tests"

      - name: insta
        purpose: "Snapshot testing for golden vectors"

    mock_requirements:
      - name: MockHarness
        purpose: "Controlled harness behavior for testing"
        interface: "Configurable output patterns, tool calls, exit codes"

      - name: MockCAS
        purpose: "In-memory content store for tests"
        interface: "ContentAddressedStore trait implementation"

      - name: MockCgroup
        purpose: "Simulated cgroup metrics"
        interface: "CgroupReader trait with configurable values"

      - name: FaultInjector
        purpose: "Controlled failure injection"
        interface: "fail_next(component, error_type)"

  coverage_requirements:
    minimum_line_coverage: 80
    minimum_branch_coverage: 70
    critical_paths:
      - path: "episode/runtime.rs"
        minimum_coverage: 95
        rationale: "Episode lifecycle is critical path"

      - path: "tool/broker.rs"
        minimum_coverage: 95
        rationale: "Tool mediation is security-critical"

      - path: "protocol/framing.rs"
        minimum_coverage: 90
        rationale: "Protocol correctness essential"

      - path: "evidence/recorder.rs"
        minimum_coverage: 90
        rationale: "Evidence capture for audit trail"
