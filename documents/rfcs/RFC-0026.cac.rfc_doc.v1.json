{
  "schema": "cac.rfc_doc.v1",
  "schema_version": "1.0.0",
  "kind": "rfc.document",
  "meta": {
    "stable_id": "dcp://apm2.rfcs/RFC-0026@seed",
    "status": "SEED",
    "classification": "INTERNAL",
    "replaces": "documents/rfcs/RFC-0026/seed.md",
    "canonicalizer": {
      "canonicalizer_id": "apm2.canonicalizer.jcs",
      "canonicalizer_version": "1.0.0",
      "vectors_ref": "dcp://apm2.cac/canonicalizer/vectors@v1"
    },
    "provenance": {
      "actor_id": "HOLON-RFC-GOVERNANCE",
      "work_id": "TCK-00680-docs-overhaul"
    }
  },
  "payload": {
    "rfc_id": "RFC-0026",
    "title": "Recursive Self-Modification Protocol",
    "seed_content": "# RFC-0026: Recursive Self-Modification Protocol \u2014 Seed\n\n## Required context files\n\nRead all of these before generating output:\n\n- documents/theory/unified-theory-v2.json\n- documents/theory/unified-theory-v2.json\n- documents/theory/unified-theory-v2.json\n- documents/theory/unified-theory-v2.json\n- documents/strategy/MASTER_STRATEGY.json\n- documents/rfcs/RFC-0020/HOLONIC_SUBSTRATE_INTERFACE.md\n- documents/rfcs/RFC-0022/PRINCIPAL_SOVEREIGNTY_INTERFACE.md\n- documents/rfcs/RFC-0023/INSTRUCTION_LIFECYCLE.md\n- documents/rfcs/RFC-0024/RESOURCE_PROVISIONING.md\n- proto/kernel_events.proto\n\n## Why this RFC matters\n\nThis is the capstone and the most dangerous RFC in the series. A system that can modify itself can improve itself \u2014 but it can also corrupt itself, drift from alignment, or amplify errors. This RFC must define the governance protocol for self-modification: how the system proposes changes to its own code, policies, and architecture; how those proposals are contained, reviewed, and approved; how modifications are verified during and after execution; and how alignment is continuously monitored. The key constraint is that self-modification must be strictly less powerful than principal sovereignty (RFC-0022) \u2014 the system can never modify away the principal's ability to control it. Draw from formal verification, proof-carrying code, sandboxed execution, and alignment research.\n\n## Priority innovation vectors\n\n- **Containment before modification**: every self-modification proposal must come with a containment proof bounding what it can affect \u2014 think capability-based sandboxing applied to the modification process itself.\n- **Alignment as invariant preservation**: formalize alignment as a set of invariants (derived from theory/unified-theory-v2.json and theory/unified-theory-v2.json) that must be preserved across any modification, verified mechanically.\n- **Modification as episode**: treat each self-modification as a contained episode with its own capability manifest, budget, stop conditions, and evidence trail \u2014 reuse the HSI substrate.\n- **Anti-drift via bisimulation**: continuously verify that the post-modification system is bisimilar to the pre-modification system on all safety-critical behaviors.\n- **Recursive modification governance**: self-modification of the self-modification protocol itself must require strictly higher authority than normal modifications \u2014 preventing the system from loosening its own constraints.\n\n## Problem (PHY-05, PHY-06, PHY-07, INV-F-14)\n\nThe system's stated goal is recursive self-improvement (AEP GOAL_EVERGREEN). AEP_04 (Compounding Closure) mandates every subsystem feeds the recursive improvement loop. The FAC (RFC-0015, RFC-0019) gates code admission. The instruction lifecycle (RFC-0023) governs the system's governing rules. RFC-0022 gives the principal sovereignty.\n\nBut there is no normative protocol that defines the boundaries of permissible self-modification, proves modifications cannot compromise containment, establishes the modification loop itself, or provides continuous verification that the system's alignment constraints remain intact. Without this, the system's recursive improvement is either unconstrained (existential risk) or ad-hoc (no compounding guarantee).\n\nThis is the capstone RFC. It depends on all four preceding RFCs and must be the last to ship.\n\n## What already exists\n\n| Artifact | Provides | Gap |\n|---|---|---|\n| AEP_04 (Compounding Closure) | Axiom: every subsystem feeds recursive improvement | No protocol for HOW |\n| FAC (RFC-0015, RFC-0019) | Code admission gating | Gates individual changes, doesn't model the modification loop as a whole |\n| VPHI (RFC-0021) | Strategy verification | Verifies business alignment, not self-modification safety |\n| MECH-REPETITION-DETECTION | Detect repetitive agent behavior | Detects loops, doesn't govern intentional self-modification |\n| MECH-MONITOR-ISOLATION | Isolated monitoring | Monitors separately, not applied to self-modification verification |\n| MECH-EVALUATOR-AUDIT | Evaluator auditing | Audits evaluators, doesn't cover self-modification scope |\n| INV-F-14 | containment > verification > liveness | The constraint, not its enforcement during self-modification |\n| RFC-0022 (this batch) | Principal sovereignty + containment proof | Provides the outer containment; this RFC defines the inner loop |\n| RFC-0023 (this batch) | Instruction lifecycle | Governs instruction modification; this RFC governs ALL self-modification |\n\n## Machine-checkable objectives\n\n**OBJ-RSM-01**: Modification scope is declared: Every self-modification must declare its scope \u2014 which components it modifies, which invariants it preserves, and which invariants it cannot affect. Undeclared modifications are S0 defects.\n- Predicate: `\u2200 modification: modification.scope \u2260 {} \u2227 modification.preserved_invariants \u2260 {}`\n\n**OBJ-RSM-02**: Sovereignty invariants are immutable: The set of invariants protecting principal sovereignty (RFC-0022) must not be modifiable by the system. Any modification attempt is an S0 defect triggering immediate freeze.\n- Predicate: `\u2200 modification: modification.scope \u2229 SOVEREIGNTY_INVARIANTS = {} \u2228 system.state = FROZEN`\n\n**OBJ-RSM-03**: Containment monotonicity: Self-modification must not weaken containment. Formally: the capability set after modification must be a subset of or equal to the capability set before, unless the principal explicitly approves expansion.\n- Predicate: `\u2200 modification: post_capabilities \u2286 pre_capabilities \u2228 principal_approval.present = true`\n\n**OBJ-RSM-04**: Modification loop is gated: Each iteration of the self-modification loop must pass: (a) FAC admission for code changes, (b) instruction lifecycle gates for instruction changes, (c) containment proof renewal, (d) principal sovereignty proof verification. All four gates must pass; any failure halts the loop.\n- Predicate: `\u2200 iteration: fac_gate \u2227 instruction_gate \u2227 containment_gate \u2227 sovereignty_gate`\n\n**OBJ-RSM-05**: Alignment binding is continuous: The system must continuously verify its alignment with declared goals (AEP GOAL_EVERGREEN + extropian principles). Alignment is measured, not assumed. Drift beyond a threshold triggers escalation to the principal.\n- Predicate: `\u2200 epoch: alignment_score(epoch) \u2265 threshold \u2228 escalation.sent = true`\n\n**OBJ-RSM-06**: Independent verification: Self-modification results must be verified by a process that was NOT modified in the same iteration. The verifier and the modified component must be in separate trust domains.\n- Predicate: `\u2200 modification: verifier \u2229 modified_components = {} \u2227 verifier.trust_domain \u2260 modified.trust_domain`\n\n**OBJ-RSM-07**: Termination guarantee: The self-modification loop must have a declared termination condition. Infinite loops of self-modification are forbidden (LAW-12, INV-F-09).\n- Predicate: `\u2200 loop: \u2203 termination_condition: reachable(termination_condition) = true`\n\n**OBJ-RSM-08**: Rollback to last-known-good: If any gate fails during self-modification, the system must be able to rollback to the state before the modification began. This rollback must be tested (not just theoretically possible).\n- Predicate: `\u2200 modification: \u2203 rollback_test: rollback_test.passed = true \u2227 rollback_test.epoch = modification.start_epoch`\n\n## Protocol objects (seed schemas)\n\nThese are starting points \u2014 refine, extend, or restructure as your analysis requires.\n\n```\nSelfModificationProposalV1 {\n    proposal_id: CasDigest,\n    proposing_holon: HolonIdV1,\n    modification_scope: ModificationScopeV1,\n    motivation: CasDigest,\n    expected_invariant_impact: InvariantImpactV1,\n    termination_condition: TerminationConditionV1,\n    rollback_plan: RollbackPlanV1,\n    proposed_at: TimeEnvelopeRef,\n}\n\nModificationScopeV1 {\n    modified_components: Vec<ComponentRefV1>,\n    preserved_invariants: Vec<InvariantRefV1>,\n    immutable_invariants: Vec<InvariantRefV1>,\n    capability_delta: CapabilityDeltaV1,\n    instruction_spec_changes: Vec<CasDigest>,\n    code_changes: Vec<CasDigest>,\n}\n\nInvariantImpactV1 {\n    invariant_id: str,\n    pre_modification_status: InvariantStatus,\n    expected_post_status: InvariantStatus,\n    verification_method: VerificationMethod,\n    goodhart_surface: str,\n}\n\nModificationIterationReceiptV1 {\n    proposal_digest: CasDigest,\n    iteration_number: u32,\n    fac_gate_result: GateReceiptV1,\n    instruction_gate_result: GateReceiptV1,\n    containment_proof: ContainmentProofV1,\n    sovereignty_proof: HaltPathLivenessProofV1,\n    independent_verification: IndependentVerificationV1,\n    alignment_measurement: AlignmentMeasurementV1,\n    rollback_test_result: GateReceiptV1,\n    iteration_verdict: IterationVerdict,\n    completed_at: TimeEnvelopeRef,\n}\n\nIndependentVerificationV1 {\n    verifier_holon: HolonIdV1,\n    verifier_trust_domain: str,\n    modified_components: Vec<ComponentRefV1>,\n    verification_results: Vec<VerificationResultV1>,\n    verifier_seal: AuthoritySealV1,\n    verified_at: TimeEnvelopeRef,\n}\n\nAlignmentMeasurementV1 {\n    epoch: TimeEnvelopeRef,\n    goal_alignment_scores: Vec<GoalAlignmentScoreV1>,\n    aggregate_score: Quantity,\n    drift_detected: bool,\n    drift_magnitude: Option<Quantity>,\n    measurement_method: str,\n    goodhart_surface: str,\n    measurement_seal: AuthoritySealV1,\n}\n\nGoalAlignmentScoreV1 {\n    goal_ref: str,\n    score: Quantity,\n    evidence: Vec<CasDigest>,\n    last_measured: TimeEnvelopeRef,\n}\n\nTerminationConditionV1 {\n    max_iterations: u32,\n    max_duration: Duration,\n    success_predicate: str,\n    failure_predicate: str,\n    budget: ResourceBudgetV1,\n}\n\nRollbackPlanV1 {\n    rollback_target: CasDigest,\n    rollback_verification: str,\n    last_tested: TimeEnvelopeRef,\n    test_receipt: CasDigest,\n}\n\nModificationLoopSummaryV1 {\n    proposal_digest: CasDigest,\n    total_iterations: u32,\n    final_verdict: LoopVerdict,\n    invariants_preserved: Vec<InvariantRefV1>,\n    capability_delta_actual: CapabilityDeltaV1,\n    alignment_trajectory: Vec<AlignmentMeasurementV1>,\n    evidence_chain: Vec<CasDigest>,\n    principal_review_required: bool,\n    completed_at: TimeEnvelopeRef,\n}\n\nIterationVerdict { PROCEED | HALT | ROLLBACK | ESCALATE_TO_PRINCIPAL }\nLoopVerdict { COMPLETED | HALTED_BY_GATE | ROLLED_BACK | TERMINATED_BY_PRINCIPAL | BUDGET_EXHAUSTED }\n```\n\n## Trust boundaries and threat model\n\nTrust boundary: The self-modification loop runs within the system, but its verification runs OUTSIDE the modified component's trust domain (OBJ-RSM-06). The sovereignty invariants (RFC-0022) are in a strictly higher trust domain that the modification loop cannot reach. The principal stands above all of it.\n\n```\nPRINCIPAL (supreme authority, hardware-rooted)\n  \u2514\u2500\u2500 SOVEREIGNTY DOMAIN (RFC-0022, immutable by system)\n       \u2514\u2500\u2500 VERIFICATION DOMAIN (independent verifiers, RFC-0022 external verifier)\n            \u2514\u2500\u2500 MODIFICATION DOMAIN (where self-modification happens)\n                 \u2514\u2500\u2500 OPERATIONAL DOMAIN (where modified code runs)\n```\n\nThreats:\n1. **Containment erosion (PHY-05, PHY-06)**: Individually-safe modifications that compose to weaken containment. Mitigation: containment monotonicity (OBJ-RSM-03) \u2014 the capability set can only shrink or stay equal without principal approval.\n2. **Verifier capture (PHY-05)**: Modified system co-opts its own verifier. Mitigation: independent verification in separate trust domains; verifier cannot be modified in the same iteration it verifies.\n3. **Alignment drift (PHY-03)**: Gradual drift from extropian goals through individually-aligned steps. Mitigation: continuous alignment measurement with aggregate scoring and drift detection.\n4. **Infinite modification loop (PHY-06, PHY-07)**: System enters unbounded self-improvement loop. Mitigation: explicit termination conditions with max iterations, max duration, and budget (OBJ-RSM-07).\n5. **Sovereignty invariant tampering (PHY-05)**: System modifies the rules that protect the principal. Mitigation: sovereignty invariants are immutable (OBJ-RSM-02); any attempt triggers immediate freeze.\n6. **Rollback infeasibility (PHY-04)**: System state diverges so far that rollback is impossible. Mitigation: rollback is continuously tested, not just planned (OBJ-RSM-08).\n\n## Dependency chain\n\n```\nRFC-0026 depends on:\n  \u251c\u2500\u2500 RFC-0022 (Principal Sovereignty) \u2014 provides ContainmentProofV1, HaltPathLivenessProofV1, AutonomyLevel\n  \u251c\u2500\u2500 RFC-0023 (Instruction Lifecycle) \u2014 provides SpecPromotionReceiptV1 for instruction modifications\n  \u251c\u2500\u2500 RFC-0024 (Resource Provisioning) \u2014 provides ResourceBudgetV1 for modification budgets\n  \u2514\u2500\u2500 RFC-0025 (Service Operation) \u2014 provides DeploymentReceiptV1 for deploying modified components\n```\n\n## Theory bindings\n\n- LAW-01 (Loop Closure): The modification loop IS a gated promotion loop\n- LAW-05 (Dual-Axis Containment): Modification is contained along both integrity (what can change) and authority (who can approve) axes\n- LAW-08 (Verifier Economics): Independent verification is economically separated\n- LAW-12 (Bounded Search): Termination conditions bound the modification search space\n- LAW-14 (Proportionality): Modification scope must be proportional to the evidence supporting it\n- LAW-16 (Closure Under Composition): Modified components must still compose holonically\n- INV-F-02 (No transition without gate receipt): Every modification iteration produces receipts\n- INV-F-05 (Default-deny, time-bounded): Modifications are time-bounded, budget-bounded\n- INV-F-09 (Budgets mandatory): The modification loop has a budget\n- INV-F-10 (Only gate what you can defend): Alignment measurement declares its Goodhart surface\n- INV-F-11 (All paths check stop): Modification loop checks sovereignty at every iteration\n- INV-F-14 (containment > verification > liveness): The modification loop must not compromise containment to achieve improvement\n\n## Rollout\n\n- S0: ModificationScopeV1 and InvariantImpactV1 \u2014 declare modification boundaries (code-only modifications)\n- S1: Four-gate verification loop \u2014 FAC + instruction lifecycle + containment proof + sovereignty check\n- S2: Independent verification in separate trust domains\n- S3: AlignmentMeasurementV1 with continuous scoring and drift detection\n- S4: Rollback plan testing \u2014 automated rollback drills\n- S5: Sovereignty invariant immutability enforcement \u2014 any attempt to modify sovereignty set triggers freeze\n- S6: Full recursive self-modification loop with all 8 objectives enforced\n- S7: Formal methods integration \u2014 TLA+/PlusCal specifications for the modification loop state machine\n- S8: Multi-iteration optimization \u2014 the system can plan multi-step modification sequences with pre-verified invariant preservation\n",
    "notes": ""
  }
}