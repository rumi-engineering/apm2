rfc_trust_boundaries:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"

  trust_model:
    description: |
      This RFC introduces build tooling configuration changes. The trust
      boundaries are minimal as these are developer workstation configurations
      that do not affect production systems or handle sensitive data.

    boundaries:
      - id: TB-001
        name: "Local Development Environment"
        description: "Build optimization tools run on developer workstations"
        trust_level: HIGH
        entities:
          - "Developer workstation"
          - "Local git repository"
          - "Cargo build system"

      - id: TB-002
        name: "Compilation Cache (sccache)"
        description: "Cached compilation artifacts stored locally"
        trust_level: CONDITIONAL
        entities:
          - "~/.cache/sccache directory"
          - "Compiled object files"
          - "sccache daemon process"
        notes: |
          sccache stores compiled artifacts locally by default. These are
          trusted as they are generated by the local compiler. The cache
          does not cross trust boundaries unless configured for remote
          storage (which is not recommended by this RFC).
        containment_constraints: |
          FESv1 AMENDMENT (RFC-0019 A1): sccache is DISABLED in default
          FAC execution mode. The sccache daemon process model violates
          FESv1 containment invariants:

          1. The sccache daemon runs as a long-lived background process
             outside the per-job cgroup boundary, meaning compiler work
             performed by the daemon is not bounded by lane resource
             limits (MemoryMax, CPUQuota, TasksMax).

          2. Resource accounting for the bounded test gate becomes
             incorrect when compilation work is shifted from the cgroup-
             bounded job process to the unbounded daemon process.

          3. Any helper that can spawn compilers/tests outside the bounded
             cgroup is treated as an integrity regression per FESv1
             section 2.3.2 item 4.

          sccache MAY be re-enabled only after proving that all child
          processes remain inside the job cgroup. Potential approaches:
          - sccache --no-daemon mode (if supported)
          - systemd slice inheritance with explicit cgroup membership
          - Verification via cgroup.procs accounting during test runs

          The primary accelerator for cross-worktree build reuse in FESv1
          is lane-scoped CARGO_TARGET_DIR (target pool per lane, per
          toolchain fingerprint), not sccache.

      - id: TB-004
        name: "FAC Execution Lane Containment Boundary"
        description: "Each FAC execution lane is a bounded cgroup unit enforcing resource limits"
        trust_level: HIGH
        entities:
          - "systemd-run --user transient scope/service"
          - "Lane workspace ($APM2_HOME/private/fac/lanes/<lane_id>/)"
          - "Lane-scoped target directory"
          - "Lane-scoped log directory"
        notes: |
          FESv1 AMENDMENT (RFC-0019 A1): Every FAC evidence gate execution
          MUST run inside a bounded cgroup unit with explicit resource limits
          derived from the lane profile. The containment boundary ensures:

          1. MemoryMax: prevents OOM from unbounded compilation/test (default 24G)
          2. CPUQuota: prevents CPU monopolization across concurrent lanes
          3. TasksMax/PIDsMax: prevents PID exhaustion (default 1536)
          4. TimeoutStopSec: hard kill after wall-time expiry (default 240s)

          No process spawned by the job (cargo, rustc, nextest, build scripts)
          may escape this boundary. Tools that maintain long-lived daemons
          (e.g., sccache) are disabled by default unless proven to preserve
          cgroup membership.

          If bounded execution cannot be proven available (e.g., no user bus,
          no cgroup v2), FAC MUST fail closed with actionable remediation.

      - id: TB-003
        name: "External Tool Installation"
        description: "Tools installed via cargo or system package managers"
        trust_level: DELEGATED
        entities:
          - "crates.io (sccache, cargo-nextest)"
          - "System package manager (mold)"
        notes: |
          Tools are installed via standard package managers which have their
          own trust verification mechanisms. cargo install uses crates.io;
          system packages use distribution repositories.

  data_flows:
    - flow_id: DF-001
      description: "Source code to compilation cache"
      from: "Rust source files"
      to: "sccache local cache"
      data: "Compiled object files"
      sensitivity: LOW
      notes: "Object files are derived from source code already in repository"

    - flow_id: DF-002
      description: "Compilation cache to build output"
      from: "sccache local cache"
      to: "target/ directory"
      data: "Cached object files"
      sensitivity: LOW
      notes: "Cache hits avoid recompilation"

  security_considerations: |
    This RFC introduces build tooling optimizations with the following
    security considerations:

    1. **mold linker**: System tool, installed via package manager. No
       additional attack surface beyond existing linker.

    2. **sccache**: Stores compiled artifacts locally. Default configuration
       does not use remote storage. Cache contents are derived from local
       source code and trusted compiler.
       **FESv1 CONSTRAINT**: sccache is DISABLED in default FAC execution
       mode because the daemon process model violates cgroup containment
       invariants (see TB-002 containment_constraints and DD-005). For
       manual developer builds outside FAC, sccache remains a recommended
       optimization with no containment concern.

    3. **cargo-nextest**: Mandatory test runner for FAC evidence gates
       (see DD-003). nextest MUST be installed for FAC gate execution;
       FAC fails closed if nextest is missing. For manual developer
       testing, cargo test remains available but nextest is recommended.

    4. **Configuration files**: .cargo/config.toml is checked into the
       repository and subject to code review. No secrets stored.
       **FESv1 CONSTRAINT**: FAC MUST NOT depend on ambient
       ~/.cargo/config.toml; FAC sets CARGO_HOME under $APM2_HOME and
       treats only the in-repo .cargo/config.toml as policy input. This
       prevents ambient user configuration from affecting attestation
       correctness.

    5. **Tool installation security**: Tools are installed via trusted sources:
       - mold: System package manager (apt/dnf/pacman) or Homebrew
       - sccache: crates.io via cargo install (verified checksums)
       - cargo-nextest: crates.io via cargo install (verified checksums)
       All installations use standard package verification mechanisms.

    6. **Containment invariants (FESv1)**: All compilation and test
       processes spawned by FAC MUST remain inside the bounded cgroup
       unit for the execution lane. No helper daemon, compiler wrapper,
       or background process may escape the resource boundary. This is
       enforced by systemd-run transient scopes with explicit MemoryMax,
       CPUQuota, and TasksMax. Violation of this invariant is treated as
       a containment regression per RFC-0019 Amendment A1.

    No credentials are involved. No network services are exposed. All tools
    operate within the developer's local environment with the same
    permissions as the developer.
