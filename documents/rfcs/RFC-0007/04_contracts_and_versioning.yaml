rfc_contracts_and_versioning:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"

  contracts:
    - id: CONTRACT-001
      name: ".cargo/config.toml linker configuration"
      description: |
        The project's .cargo/config.toml configures the mold linker for
        Linux x86_64 builds.
      interface:
        file: ".cargo/config.toml"
        configuration: |
          [target.x86_64-unknown-linux-gnu]
          linker = "clang"
          rustflags = ["-C", "link-arg=-fuse-ld=mold"]
        requirements:
          - "mold must be installed (typically at /usr/bin/mold)"
          - "clang must be installed (provides linker driver)"
        fallback: |
          If mold is not installed, cargo will fail with a clear error
          about the missing linker. Developer can either:
          1. Install mold: apt install mold (Ubuntu) or brew install mold (macOS)
          2. Comment out the configuration to use the default linker
      backward_compatible: true
      notes: |
        Configuration only affects Linux x86_64 target. Other platforms
        (macOS, Windows) continue using their default linkers.

    - id: CONTRACT-002
      name: "RUSTC_WRAPPER environment variable"
      description: |
        Developers MAY set RUSTC_WRAPPER=sccache in their shell profile
        to enable compilation caching for manual builds outside FAC.
      interface:
        variable: "RUSTC_WRAPPER"
        value: "sccache"
        scope: "Developer shell profile (optional, manual builds only)"
      backward_compatible: true
      notes: |
        This is a recommendation for manual developer builds, not a
        requirement. The project builds correctly without sccache.
        FESv1 CONSTRAINT: RUSTC_WRAPPER is NOT set in FAC execution
        mode. FAC uses lane-scoped CARGO_TARGET_DIR for build reuse
        and disables sccache to preserve cgroup containment. See
        DD-005 and TB-002 containment_constraints.

    - id: CONTRACT-003
      name: "CARGO_INCREMENTAL environment variable"
      description: |
        Local development SHOULD use CARGO_INCREMENTAL=1 for faster
        incremental builds. CI uses CARGO_INCREMENTAL=0 for reproducibility.
      interface:
        variable: "CARGO_INCREMENTAL"
        valid_values:
          - "0 - Disable incremental compilation"
          - "1 - Enable incremental compilation (default when unset)"
        local_value: "1 (recommended, also the default)"
        ci_value: "0 (set in ci.yml for reproducibility)"
      backward_compatible: true
      notes: |
        Default Cargo behavior is incremental=1, so this only matters if
        developers have explicitly set it to 0 in their environment.
        Setting CARGO_INCREMENTAL=1 explicitly documents the intent.

    - id: CONTRACT-004
      name: "cargo nextest run command (preferred for FAC)"
      description: |
        FAC evidence gate execution SHOULD use `cargo nextest run` as the
        test runner via the bounded test gate (cgroup v2 +
        run_bounded_tests.sh). The current implementation falls back to
        `cargo test --workspace` when the bounded runner inputs are absent.
        For manual developer testing, cargo test remains available but
        nextest is recommended.
      interface:
        command: "cargo nextest run"
        equivalent_to: "cargo test (fallback when bounded runner unavailable)"
        flags: "Most cargo test flags supported"
        fac_requirement: "PREFERRED â€” bounded gate uses nextest; fallback to cargo test exists"
      backward_compatible: true
      notes: |
        FESv1 AMENDMENT: nextest is the preferred and recommended test
        runner for FAC. The bounded test gate uses `cargo nextest run`
        inside a cgroup unit. When bounded execution is unavailable
        (no cgroup v2, no run_bounded_tests.sh), the current
        implementation falls back to `cargo test --workspace`
        (evidence.rs:430-435, evidence.rs:596-604, gates.rs:204-218).
        Fail-closed enforcement (rejecting execution without nextest)
        is planned as future work. Install nextest for best results:
        `cargo install cargo-nextest`.

    - id: CONTRACT-005
      name: "FAC execution containment boundary"
      description: |
        All FAC evidence gate execution MUST run inside a bounded
        cgroup unit with explicit resource limits. No process spawned
        by the job may escape the containment boundary.
      interface:
        mechanism: "systemd-run --user transient scope/service"
        resource_limits:
          - "MemoryMax: default 24G"
          - "CPUQuota: configurable"
          - "TasksMax: default 1536"
          - "TimeoutStopSec: default 240s"
        escape_prevention:
          - "sccache disabled in default FAC mode"
          - "PLANNED: set CARGO_HOME under $APM2_HOME (not yet enforced in local fallback)"
          - "PLANNED: ignore ambient ~/.cargo/config.toml during FAC execution (not yet enforced)"
          - "Current local-mode execution inherits ambient environment, including cargo/rust wrapper settings"
      backward_compatible: true
      notes: |
        If bounded execution cannot be proven available (the bounded runner script is
        missing or cgroup v2 is unavailable), the current implementation falls back
        to running evidence gates without cgroup resource limits and uses
        `cargo test --workspace` instead of `cargo nextest run`. Bounded execution
        still requires a reachable user bus; if preflight user bus checks fail, the
        fallback does not occur and bounded execution hard-fails.
        Fail-closed enforcement (rejecting execution when bounded
        execution is unavailable) is planned as future work. Operators
        are strongly encouraged to enable bounded execution by
        configuring a systemd user session (enable linger, or run via
        systemd-managed apm2-daemon).

  versioning:
    strategy: "No version bump required for configuration changes"
    rationale: |
      These are developer tooling configurations, not API changes. The
      changes improve developer experience without affecting the crates'
      public interfaces or functionality. Users of the published crates
      are unaffected.
