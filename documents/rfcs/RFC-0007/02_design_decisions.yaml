rfc_design_decisions:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"
  decisions:
  - id: DD-001
    title: "Use mold Linker via .cargo/config.toml"
    statement: |
      Configure the mold linker as the default for x86_64-unknown-linux-gnu
      builds by adding configuration to .cargo/config.toml.
    context: |
      Linking is often the bottleneck in Rust builds, especially for debug
      builds with many dependencies. The mold linker is already installed
      on the development system (/usr/bin/mold) and provides significant
      speedups over the default GNU ld linker.
    alternatives:
    - id: ALT-0001
      name: "Use RUSTFLAGS environment variable"
      pros:
      - "No project file changes"
      - "Easy to toggle on/off"
      cons:
      - "Must be set in every terminal session"
      - "Easy to forget"
      - "Not discoverable by new team members"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Inconsistent builds if forgotten"
    - id: ALT-0002
      name: "Configure in .cargo/config.toml (chosen)"
      pros:
      - "Automatic for all developers"
      - "Checked into repository"
      - "Discoverable and documented"
      - "Works immediately after clone"
      cons:
      - "Requires mold to be installed"
      - "Linux-specific configuration"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Developers on other platforms unaffected"
    - id: ALT-0003
      name: "Use lld linker instead of mold"
      pros:
      - "More widely available (comes with LLVM)"
      - "Cross-platform support"
      cons:
      - "Slower than mold"
      - "Still requires LLVM installation"
      security_tradeoffs: []
      operability_tradeoffs: []
    chosen_rationale: |
      Project-level configuration in .cargo/config.toml ensures all developers
      benefit from the optimization automatically. The configuration is
      target-specific (x86_64-unknown-linux-gnu) so it doesn't affect other
      platforms. mold is preferred over lld for its superior performance.
    impacted_requirement_ids:
    - PERF-001
    evidence_ids:
    - EVID-7001

  - id: DD-002
    title: "Use sccache Instead of Shared CARGO_TARGET_DIR"
    statement: |
      Document sccache as the recommended approach for sharing compilation
      artifacts across worktrees, rather than using a shared CARGO_TARGET_DIR.
    context: |
      Developers using multiple git worktrees face redundant compilation of
      dependencies. Two approaches exist:
      1. Shared CARGO_TARGET_DIR - all worktrees use one target/ directory
      2. sccache - cache compilation artifacts separately from target/

      The shared target directory approach has significant drawbacks: Cargo
      uses file locks on the target directory, preventing parallel builds
      across worktrees. sccache avoids this by caching at the compiler level.
    alternatives:
    - id: ALT-0001
      name: "Use shared CARGO_TARGET_DIR"
      pros:
      - "Maximum artifact reuse"
      - "Simple configuration"
      cons:
      - "File locking prevents parallel builds"
      - "Cannot build in two worktrees simultaneously"
      - "Cargo.lock conflicts"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Blocks multi-worktree parallel development"
    - id: ALT-0002
      name: "Use sccache (chosen)"
      pros:
      - "Shared cache without file locking"
      - "Parallel builds in multiple worktrees"
      - "Automatic cache management"
      - "Works with Cargo's normal target/ structure"
      cons:
      - "Requires sccache installation"
      - "Small overhead for cache lookups"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Additional tool to install"
    chosen_rationale: |
      sccache provides the benefits of shared compilation artifacts without
      the file locking drawbacks of a shared target directory. This is
      critical for the worktree-based development model where developers
      may build in multiple worktrees simultaneously.
    impacted_requirement_ids:
    - PERF-002
    evidence_ids:
    - EVID-7002

  - id: DD-003
    title: "Mandate cargo-nextest as FAC Test Runner"
    statement: |
      Mandate cargo-nextest as the preferred and recommended test runner for
      FAC evidence gate execution. The FAC bounded test gate uses explicit
      `cargo nextest run` invocation when cgroup v2 and the bounded runner
      script are available. The current implementation falls back to
      `cargo test --workspace` when the bounded runner inputs are absent.
      Fail-closed enforcement (rejecting execution without nextest) is
      planned as future work.
    context: |
      cargo-nextest provides significantly faster test execution through
      process-level parallelism and is already the default test runner
      in the FAC bounded test gate when cgroup v2 is available. However,
      two fallback paths currently degrade to `cargo test`:
      (1) the pipeline path when the bounded runner is unavailable
      (evidence.rs:430-435), and
      (2) the local `apm2 fac gates` path when EvidenceGateOptions.test_command
      is unset (evidence.rs:596-604, gates.rs:204-218).

      RFC-0019 Amendment A1 (FESv1) mandates nextest as a substrate
      requirement. This decision captures the design intent; full
      fail-closed enforcement is tracked as future work.
    alternatives:
    - id: ALT-0001
      name: "Mandate cargo-nextest in all FAC paths (chosen)"
      pros:
      - "Consistent test execution across pipeline and local gates"
      - "Faster test execution (2-3x)"
      - "Reliable attestation (nextest version is already captured)"
      - "Required by FESv1 substrate contract"
      cons:
      - "nextest must be installed (fail-closed if missing)"
      - "Additional tool dependency"
      security_tradeoffs:
      - "Eliminates silent degradation to cargo test (fail-closed improvement)"
      operability_tradeoffs:
      - "Operators must install nextest before running FAC gates"
    - id: ALT-0002
      name: "Keep as optional recommendation"
      pros:
      - "No installation requirement"
      - "Backward compatible"
      cons:
      - "Inconsistent execution semantics between environments"
      - "Silent fallback to cargo test defeats attestation correctness"
      - "Conflicts with FESv1 substrate requirements"
      security_tradeoffs:
      - "Fail-open: silent degradation to different test runner"
      operability_tradeoffs:
      - "Cannot guarantee test-gate reproducibility"
    chosen_rationale: |
      FESv1 (RFC-0019 Amendment A1) requires nextest as a substrate
      invariant. The bounded test gate (cgroup v2 + run_bounded_tests.sh)
      uses `cargo nextest run`. When bounded execution is unavailable,
      the current implementation falls back to `cargo test --workspace`.
      Full fail-closed enforcement (rejecting execution without nextest)
      is planned as future work. This captures the design intent while
      accurately reflecting the current fallback behavior.
    impacted_requirement_ids:
    - PERF-003
    evidence_ids:
    - EVID-7003

  - id: DD-004
    title: "Document Local vs CI Build Settings Differences"
    statement: |
      Explicitly document the difference between CI build settings
      (CARGO_INCREMENTAL=0) and recommended local settings (CARGO_INCREMENTAL=1).
    context: |
      The CI workflow sets CARGO_INCREMENTAL=0 for reproducible builds.
      This is correct for CI but suboptimal for local development where
      incremental compilation provides significant speedups. Developers
      may inadvertently copy CI settings, degrading their local experience.
    alternatives:
    - id: ALT-0001
      name: "Change CI to use incremental builds"
      pros:
      - "Consistent settings"
      cons:
      - "Non-reproducible CI builds"
      - "Cache invalidation issues"
      - "Against Rust best practices for CI"
      security_tradeoffs: []
      operability_tradeoffs:
      - "CI reproducibility compromised"
    - id: ALT-0002
      name: "Document the difference clearly (chosen)"
      pros:
      - "CI remains reproducible"
      - "Local development optimized"
      - "Developers understand the tradeoffs"
      cons:
      - "Requires developers to read documentation"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Potential for confusion if undocumented"
    chosen_rationale: |
      CI and local development have fundamentally different goals.
      CI prioritizes reproducibility; local development prioritizes speed.
      Clear documentation helps developers understand why the settings
      differ and configure their environment appropriately.
    impacted_requirement_ids:
    - PERF-004
    - PERF-005
    evidence_ids:
    - EVID-7004

  - id: DD-005
    title: "Containment Constraints for Compilation Caching"
    statement: |
      Compilation caching (sccache) MUST NOT be enabled in default FAC
      execution mode because it can spawn compiler processes outside the
      bounded cgroup unit, violating containment invariants. sccache MAY
      be enabled only after explicit verification that it preserves cgroup
      membership for all child processes.
    context: |
      FESv1 (RFC-0019 Amendment A1) requires that all compilers, tests,
      and helper processes spawned by a FAC job remain inside the intended
      cgroup boundary for the execution lane. sccache acts as a compiler
      wrapper (RUSTC_WRAPPER) that can:
      (1) spawn rustc processes that may inherit different cgroup membership,
      (2) maintain a long-lived daemon that compiles outside the job cgroup,
      (3) break resource accounting by shifting compilation work to the
          daemon process.

      The primary accelerator for cross-worktree build reuse in FESv1 is
      lane-scoped CARGO_TARGET_DIR (target pool per lane per toolchain
      fingerprint), which provides artifact reuse without containment risk.

      Additionally, FAC MUST NOT depend on ambient user configuration
      (~/.cargo/config.toml). FAC sets CARGO_HOME under $APM2_HOME for
      isolation, and .cargo/config.toml in the repo is the only cargo
      config treated as policy input.
    alternatives:
    - id: ALT-0001
      name: "Disable sccache in default FAC mode (chosen)"
      pros:
      - "Preserves cgroup containment invariants"
      - "No risk of compiler escape"
      - "Lane-scoped target pool provides sufficient reuse"
      cons:
      - "No cross-lane compilation cache"
      - "Cold-start in new lanes requires full dependency build"
      security_tradeoffs:
      - "Eliminates containment bypass via compiler wrapper daemon"
      operability_tradeoffs:
      - "Operators use `apm2 fac warm` to pre-populate lane targets"
    - id: ALT-0002
      name: "Allow sccache unconditionally"
      pros:
      - "Maximum compilation reuse across lanes"
      cons:
      - "sccache daemon runs outside cgroup boundary"
      - "Resource accounting is broken"
      - "Containment violation in FESv1 threat model"
      security_tradeoffs:
      - "Fail-open: compiler processes escape containment"
      operability_tradeoffs:
      - "Unpredictable resource consumption from daemon"
    chosen_rationale: |
      Host safety is a non-negotiable FESv1 requirement. The sccache
      daemon process model is incompatible with per-lane cgroup isolation.
      Lane-scoped target directories plus `apm2 fac warm` provide
      sufficient build reuse for the current host class without violating
      containment. sccache MAY be re-evaluated after proving that its
      processes remain inside the job cgroup (e.g., via --no-daemon mode
      or systemd slice inheritance).
    impacted_requirement_ids:
    - PERF-002
    evidence_ids:
    - EVID-7002
