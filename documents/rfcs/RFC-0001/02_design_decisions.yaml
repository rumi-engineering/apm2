rfc_design_decisions:
  schema_version: "2026-01-23"
  template_version: "2026-01-23"
  decisions:
  - id: DEC-RFC-0001
    title: "Kernel Module Architecture"
    statement: |
      Structure the kernel as five isolated modules (Supervisor, Ledger, PolicyEngine,
      Reducers, Adapters) with trait-based interfaces and dependency injection.
    context: |
      The kernel must be testable in isolation, allow independent evolution of
      components, and support future replacement (e.g., swapping SQLite for a
      different storage backend). Rust's trait system enables this naturally.
    alternatives:
    - id: ALT-0001
      name: "Monolithic kernel with internal modules"
      pros:
      - "Simpler initial implementation"
      - "No serialization overhead between components"
      cons:
      - "Harder to test in isolation"
      - "Tight coupling makes replacement difficult"
      - "Changes ripple across codebase"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Debugging requires understanding full system"
    - id: ALT-0002
      name: "Microservice architecture with separate processes"
      pros:
      - "Maximum isolation and independent deployment"
      - "Language flexibility per service"
      cons:
      - "Significant operational complexity"
      - "Network serialization overhead"
      - "Distributed system failure modes"
      security_tradeoffs:
      - "Additional attack surface at service boundaries"
      operability_tradeoffs:
      - "Requires orchestration infrastructure"
    - id: ALT-0003
      name: "Trait-based modules in single process (chosen)"
      pros:
      - "Clean interfaces enable isolated testing"
      - "No serialization overhead"
      - "Dependency injection supports mocking"
      - "Single deployment artifact"
      cons:
      - "Must maintain interface discipline"
      - "Module boundaries are conventions, not process isolation"
      security_tradeoffs: []
      operability_tradeoffs:
      - "All modules share fate (single process crash)"
    chosen_rationale: |
      Trait-based modules provide the testing and replacement benefits without
      the operational complexity of separate processes. The kernel is a single
      trust domain; internal module isolation is for engineering, not security.
    impacted_requirement_ids:
    - REQ-0007
    - REQ-1001
    evidence_ids:
    - EVID-1001

  - id: DEC-RFC-0002
    title: "Ledger Storage with SQLite WAL"
    statement: |
      Use SQLite in WAL (Write-Ahead Logging) mode for ledger storage with an
      append-only table design. Hash-chaining and signatures are computed in
      application code before insertion.
    context: |
      The ledger stores signed kernel events and must be append-only, durable,
      and queryable for projection computation. PRD DEC-0003 selected SQLite.
    alternatives:
    - id: ALT-0001
      name: "Raw append-only files (JSONL or binary)"
      pros:
      - "Simple implementation"
      - "Trivial append semantics"
      cons:
      - "No indexing; O(n) queries"
      - "Harder to implement cursors"
      - "No atomic multi-row operations"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Manual compaction and cleanup required"
    - id: ALT-0002
      name: "Embedded key-value store (RocksDB/LMDB)"
      pros:
      - "High write throughput"
      - "Efficient range queries"
      cons:
      - "More complex dependency"
      - "Less portable than SQLite"
      - "Still need indexing layer"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Different operational characteristics per engine"
    - id: ALT-0003
      name: "SQLite with WAL mode (chosen)"
      pros:
      - "ACID transactions"
      - "Rich indexing for projections"
      - "Single-file database, portable"
      - "Mature, well-understood"
      cons:
      - "Not designed for append-only (must enforce in code)"
      - "WAL can grow large under write load"
      security_tradeoffs: []
      operability_tradeoffs:
      - "WAL checkpointing may cause latency spikes"
    chosen_rationale: |
      SQLite provides atomic commits, indexing, and operational simplicity.
      Append-only semantics are enforced by the ledger module; SQLite handles
      durability and query performance. WAL mode enables concurrent reads.
    impacted_requirement_ids:
    - REQ-0006
    - REQ-0007
    - REQ-0008
    evidence_ids:
    - EVID-0004
    - EVID-0005

  - id: DEC-RFC-0003
    title: "Event Schema with Protobuf Canonical Encoding"
    statement: |
      Define kernel events using Protocol Buffers with deterministic field ordering
      and explicit rules forbidding nondeterministic features (maps in signed payloads).
      Events are signed over canonical protobuf bytes.
    context: |
      Events must be signable, verifiable across implementations, and evolvable.
      PRD DEC-0002 selected protobuf. Canonical encoding is critical for signatures.
    alternatives:
    - id: ALT-0001
      name: "JSON with JCS (JSON Canonicalization Scheme)"
      pros:
      - "Human readable"
      - "JCS provides canonical form"
      cons:
      - "Larger wire size"
      - "JCS implementations vary"
      - "Schema evolution less explicit"
      security_tradeoffs:
      - "Canonicalization bugs could break signature verification"
      operability_tradeoffs:
      - "More verbose logs"
    - id: ALT-0002
      name: "CBOR with deterministic encoding"
      pros:
      - "Compact binary format"
      - "RFC 8949 defines deterministic encoding"
      cons:
      - "Fewer mature libraries"
      - "Cross-language canonicalization concerns"
      security_tradeoffs:
      - "Deterministic CBOR implementations vary"
      operability_tradeoffs: []
    - id: ALT-0003
      name: "Protobuf with canonical rules (chosen)"
      pros:
      - "Compact binary format"
      - "Excellent tooling (prost)"
      - "Strong schema evolution"
      - "Field ordering is deterministic"
      cons:
      - "Must forbid maps in signed messages"
      - "Not human readable"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Requires protoc tooling for schema changes"
    chosen_rationale: |
      Protobuf provides compact encoding, strong schema evolution, and mature
      Rust tooling (prost). Determinism is achieved by forbidding maps in signed
      payloads and using sorted repeated fields where order matters.
    impacted_requirement_ids:
    - REQ-0006
    - REQ-0012
    evidence_ids:
    - EVID-0008

  - id: DEC-RFC-0004
    title: "Syscall Mediation Architecture"
    statement: |
      Implement syscall mediation as a request/response protocol where agents
      submit ToolRequest messages, the PolicyEngine evaluates allow/deny, and
      the Supervisor executes allowed requests and returns ToolResponse messages.
    context: |
      Agents must not have direct access to side effects. All tool execution
      flows through the kernel. This is the core security boundary.
    alternatives:
    - id: ALT-0001
      name: "LD_PRELOAD interception"
      pros:
      - "Transparent to agent code"
      - "Catches all syscalls"
      cons:
      - "Platform-specific"
      - "Complex to implement correctly"
      - "Performance overhead"
      security_tradeoffs:
      - "Bypass risk if not all paths intercepted"
      operability_tradeoffs:
      - "Debugging intercepted calls is hard"
    - id: ALT-0002
      name: "Seccomp/sandbox with allowed syscalls"
      pros:
      - "Kernel-enforced"
      - "Strong isolation"
      cons:
      - "Coarse-grained (syscall level, not tool level)"
      - "Doesn't provide tool-level policy"
      - "Agent must still communicate requests"
      security_tradeoffs:
      - "Complements but doesn't replace tool mediation"
      operability_tradeoffs:
      - "Requires privileged setup"
    - id: ALT-0003
      name: "Request/response protocol (chosen)"
      pros:
      - "Explicit tool-level policy"
      - "Full audit trail"
      - "Budget tracking per request"
      - "Works across adapter types"
      cons:
      - "Requires agent cooperation"
      - "Determined adversary could bypass (defense in depth needed)"
      security_tradeoffs:
      - "Relies on adapter boundary; add seccomp for defense in depth"
      operability_tradeoffs:
      - "Request latency added to tool execution"
    chosen_rationale: |
      Request/response mediation provides tool-level policy, budget tracking,
      and full auditability. Seccomp can be added as defense in depth. The
      adapter boundary ensures agents only communicate via the protocol.
    impacted_requirement_ids:
    - REQ-0004
    - REQ-0005
    - REQ-0019
    evidence_ids:
    - EVID-0003

  - id: DEC-RFC-0005
    title: "Adapter Interface Contract"
    statement: |
      Define an Adapter trait that normalizes agent communication into a standard
      event stream (lifecycle, tool requests, progress signals). Support both
      black-box adapters (observation-based) and instrumented adapters (native events).
    context: |
      The kernel must support heterogeneous agents (vendor CLIs, local models,
      custom loops) without coupling to any specific API.
    alternatives:
    - id: ALT-0001
      name: "Single adapter type (instrumented only)"
      pros:
      - "Simpler implementation"
      - "Richer event stream"
      cons:
      - "Excludes black-box agents"
      - "Requires agent modification"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Limited agent compatibility"
    - id: ALT-0002
      name: "Black-box only (filesystem observation)"
      pros:
      - "Works with any agent"
      - "No agent modification needed"
      cons:
      - "Less precise event detection"
      - "Harder to detect stalls"
      - "No native progress signals"
      security_tradeoffs:
      - "Side-effect detection may miss transient states"
      operability_tradeoffs:
      - "Higher latency for event detection"
    - id: ALT-0003
      name: "Dual adapter modes (chosen)"
      pros:
      - "Maximum agent compatibility"
      - "Rich events when available"
      - "Graceful degradation"
      cons:
      - "Two code paths to maintain"
      - "Event normalization complexity"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Different observability depending on adapter"
    chosen_rationale: |
      Supporting both black-box and instrumented adapters maximizes compatibility.
      Instrumented adapters provide richer events; black-box adapters enable
      integration with any agent. The adapter trait normalizes both into a
      common event stream.
    impacted_requirement_ids:
    - REQ-0010
    - REQ-0017
    evidence_ids:
    - EVID-0001
    - EVID-0002

  - id: DEC-RFC-0006
    title: "Session Lifecycle with Crash-Only Design"
    statement: |
      Implement sessions as crash-only processes with no graceful shutdown path.
      Sessions track an entropy budget (errors, stalls, violations). Exceeding
      the budget triggers termination. Recovery always replays from ledger state.
    context: |
      Long-running agent sessions accumulate state drift. Crash-only design
      ensures recovery is always from the source of truth (ledger).
    alternatives:
    - id: ALT-0001
      name: "Graceful shutdown with state persistence"
      pros:
      - "Faster restart (no replay)"
      - "Preserves in-flight work"
      cons:
      - "State corruption risk"
      - "Shutdown logic is a failure mode"
      - "Persisted state may diverge from ledger"
      security_tradeoffs:
      - "Persisted state could be tampered"
      operability_tradeoffs:
      - "Debugging requires understanding two state sources"
    - id: ALT-0002
      name: "Checkpoint-based recovery"
      pros:
      - "Faster recovery than full replay"
      - "Periodic consistency points"
      cons:
      - "Checkpoint logic is complex"
      - "Partial replay still needed"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Checkpoint storage and validation overhead"
    - id: ALT-0003
      name: "Crash-only with entropy budgets (chosen)"
      pros:
      - "Simple recovery model"
      - "Ledger is always source of truth"
      - "Entropy budget prevents slow degradation"
      - "Deterministic termination criteria"
      cons:
      - "Restart cost for long-running sessions"
      - "Must design for frequent restarts"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Higher baseline resource usage from restarts"
    chosen_rationale: |
      Crash-only design with entropy budgets ensures sessions don't accumulate
      hidden state issues. The ledger is always authoritative. Entropy budgets
      provide deterministic termination before sessions degrade significantly.
    impacted_requirement_ids:
    - REQ-0013
    - REQ-0018
    - REQ-0035
    evidence_ids:
    - EVID-0006
