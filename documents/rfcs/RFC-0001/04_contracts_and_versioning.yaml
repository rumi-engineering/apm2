rfc_contracts_and_versioning:
  schema_version: "2026-01-23"
  template_version: "2026-01-23"
  contracts:
  - id: CTR-0001
    name: "Kernel Event Schema"
    type: EVENT_SCHEMA
    versioning:
      scheme: SEMVER
      current_version: "0.1.0"
      compatibility_rules:
      - "Minor versions add optional fields only"
      - "Breaking changes require major version bump"
      - "Signed payloads use deterministic protobuf encoding (prost v0 deterministic bytes)"
      - "Hashing/Signing policy: Hash unsigned message form excluding signature field"
      - "Payload fields (actor_id, session_id) MUST match envelope; mismatch is a schema violation"
      - "Maps are forbidden in signed messages"
    schemas:
    - id: SCH-0001
      path: "proto/kernel_events.proto"
      format: PROTOBUF
      description: "Core kernel event definitions"
      inline_schema: |
        syntax = "proto3";
        package apm2.kernel.v1;

        import "google/protobuf/timestamp.proto";

        // Common envelope for all kernel events
        message KernelEvent {
          // Monotonic sequence number within this ledger
          uint64 sequence = 1;
          // Hash of the previous event (empty for genesis)
          bytes previous_hash = 2;
          // Timestamp when event was created
          google.protobuf.Timestamp timestamp = 3;
          // Actor ID that produced this event
          string actor_id = 4;
          // Session ID (if applicable)
          string session_id = 5;
          // Ed25519 signature over canonical bytes of this message
          bytes signature = 6;
          // Event payload (oneof)
          oneof payload {
            SessionEvent session = 10;
            WorkEvent work = 11;
            ToolEvent tool = 12;
            LeaseEvent lease = 13;
            PolicyEvent policy = 14;
            AdjudicationEvent adjudication = 15;
            EvidenceEvent evidence = 16;
          }
        }

        // ============================================================
        // SESSION EVENTS
        // ============================================================
        message SessionEvent {
          oneof event {
            SessionStarted started = 1;
            SessionProgress progress = 2;
            SessionTerminated terminated = 3;
            SessionQuarantined quarantined = 4;
          }
        }

        message SessionStarted {
          string adapter_type = 1;
          string work_id = 2;
          string lease_id = 3;
          uint64 entropy_budget = 4;
        }

        message SessionProgress {
          string session_id = 1;
          uint64 progress_sequence = 2;
          string progress_type = 3;  // HEARTBEAT, TOOL_COMPLETE, MILESTONE
          uint64 entropy_consumed = 4;
        }

        message SessionTerminated {
          string session_id = 1;
          string exit_classification = 2;  // SUCCESS, FAILURE, TIMEOUT, ENTROPY_EXCEEDED
          string rationale_code = 3;
          uint64 final_entropy = 4;
        }

        message SessionQuarantined {
          string session_id = 1;
          string reason = 2;
          uint64 quarantine_until = 3;
        }

        // ============================================================
        // WORK EVENTS
        // ============================================================
        message WorkEvent {
          oneof event {
            WorkOpened opened = 1;
            WorkTransitioned transitioned = 2;
            WorkCompleted completed = 3;
            WorkAborted aborted = 4;
          }
        }

        message WorkOpened {
          string work_id = 1;
          string work_type = 2;  // TICKET, PRD_REFINEMENT, RFC_REFINEMENT, REVIEW
          bytes spec_snapshot_hash = 3;
          repeated string requirement_ids = 4;
          repeated string parent_work_ids = 5;
        }

        message WorkTransitioned {
          string work_id = 1;
          string from_state = 2;
          string to_state = 3;  // OPEN, CLAIMED, IN_PROGRESS, REVIEW, NEEDS_INPUT, NEEDS_ADJUDICATION
          string rationale_code = 4;
        }

        message WorkCompleted {
          string work_id = 1;
          bytes evidence_bundle_hash = 2;
          repeated string evidence_ids = 3;
          string gate_receipt_id = 4;
        }

        message WorkAborted {
          string work_id = 1;
          string abort_reason = 2;  // POLICY_DENY, TIMEOUT, ENTROPY_EXCEEDED, MANUAL
          string rationale_code = 3;
        }

        // ============================================================
        // TOOL EVENTS
        // ============================================================
        message ToolEvent {
          oneof event {
            ToolRequested requested = 1;
            ToolDecided decided = 2;
            ToolExecuted executed = 3;
          }
        }

        message ToolRequested {
          string request_id = 1;
          string session_id = 2;
          string tool_name = 3;
          bytes tool_args_hash = 4;  // Hash of arguments (full args stored in CAS)
          string dedupe_key = 5;
        }

        message ToolDecided {
          string request_id = 1;
          string decision = 2;  // ALLOW, DENY
          string rule_id = 3;
          bytes policy_hash = 4;
          string rationale_code = 5;
          uint64 budget_consumed = 6;
        }

        message ToolExecuted {
          string request_id = 1;
          string outcome = 2;  // SUCCESS, FAILURE, TIMEOUT
          bytes result_hash = 3;  // Hash of result (full result stored in CAS)
          uint64 duration_ms = 4;
        }

        // ============================================================
        // LEASE EVENTS
        // ============================================================
        message LeaseEvent {
          oneof event {
            LeaseIssued issued = 1;
            LeaseRenewed renewed = 2;
            LeaseReleased released = 3;
            LeaseExpired expired = 4;
            LeaseConflict conflict = 5;
          }
        }

        message LeaseIssued {
          string lease_id = 1;
          string work_id = 2;
          string actor_id = 3;
          uint64 issued_at = 4;
          uint64 expires_at = 5;
          bytes registrar_signature = 6;
        }

        message LeaseRenewed {
          string lease_id = 1;
          uint64 new_expires_at = 2;
          bytes registrar_signature = 3;
        }

        message LeaseReleased {
          string lease_id = 1;
          string release_reason = 2;  // COMPLETED, ABORTED, VOLUNTARY
        }

        message LeaseExpired {
          string lease_id = 1;
          uint64 expired_at = 2;
        }

        message LeaseConflict {
          string work_id = 1;
          repeated string conflicting_lease_ids = 2;
          string resolution = 3;  // CANONICAL_ROOT, ADJUDICATION_REQUIRED
        }

        // ============================================================
        // POLICY EVENTS
        // ============================================================
        message PolicyEvent {
          oneof event {
            PolicyLoaded loaded = 1;
            PolicyViolation violation = 2;
            BudgetExceeded budget_exceeded = 3;
          }
        }

        message PolicyLoaded {
          bytes policy_hash = 1;
          string policy_version = 2;
          uint64 rule_count = 3;
        }

        message PolicyViolation {
          string session_id = 1;
          string violation_type = 2;
          string rule_id = 3;
          string details = 4;
        }

        message BudgetExceeded {
          string session_id = 1;
          string budget_type = 2;  // TOKEN, TIME, TOOL_CALLS
          uint64 limit = 3;
          uint64 consumed = 4;
        }

        // ============================================================
        // ADJUDICATION EVENTS
        // ============================================================
        message AdjudicationEvent {
          oneof event {
            AdjudicationRequested requested = 1;
            AdjudicationVote vote = 2;
            AdjudicationResolved resolved = 3;
            AdjudicationTimeout timeout = 4;
          }
        }

        message AdjudicationRequested {
          string adjudication_id = 1;
          string work_id = 2;
          string request_type = 3;  // BOUNDED_CHOICE, WAIVER, GATE_REVIEW
          repeated string options = 4;
          uint64 deadline = 5;
          string fallback_policy = 6;
        }

        message AdjudicationVote {
          string adjudication_id = 1;
          string voter_actor_id = 2;
          string chosen_option = 3;
          bytes voter_signature = 4;
        }

        message AdjudicationResolved {
          string adjudication_id = 1;
          string chosen_option = 2;
          uint64 votes_for = 3;
          uint64 votes_against = 4;
          bytes quorum_signature = 5;
        }

        message AdjudicationTimeout {
          string adjudication_id = 1;
          string applied_fallback = 2;
        }

        // ============================================================
        // EVIDENCE EVENTS
        // ============================================================
        message EvidenceEvent {
          oneof event {
            EvidencePublished published = 1;
            GateReceiptGenerated gate_receipt = 2;
          }
        }

        message EvidencePublished {
          string evidence_id = 1;
          string work_id = 2;
          string category = 3;
          bytes artifact_hash = 4;
          repeated string verification_command_ids = 5;
        }

        message GateReceiptGenerated {
          string receipt_id = 1;
          string gate_id = 2;
          string work_id = 3;
          string result = 4;  // PASS, FAIL
          repeated string evidence_ids = 5;
          bytes receipt_signature = 6;
        }

    - id: SCH-0002
      path: "proto/tool_protocol.proto"
      format: PROTOBUF
      description: "Agent-to-kernel tool request/response protocol"
      inline_schema: |
        syntax = "proto3";
        package apm2.tool.v1;

        // Tool request from agent to kernel
        message ToolRequest {
          string request_id = 1;
          string session_token = 2;
          string dedupe_key = 3;
          oneof tool {
            FileRead file_read = 10;
            FileWrite file_write = 11;
            FileEdit file_edit = 12;
            ShellExec shell_exec = 13;
            GitOperation git_op = 14;
            InferenceCall inference = 15;
            ArtifactPublish artifact_publish = 16;
          }
        }

        message FileRead {
          string path = 1;
          uint64 offset = 2;
          uint64 limit = 3;
        }

        message FileWrite {
          string path = 1;
          bytes content_hash = 2; // Full content stored in CAS
          uint64 size = 3;
          bytes inline_content = 4; // Optional for small payloads (< 4KB)
        }

        message FileEdit {
          string path = 1;
          bytes old_content_hash = 2;
          bytes new_content_hash = 3;
        }

        message ShellExec {
          string command = 1;
          string cwd = 2;
          uint64 timeout_ms = 3;
          bool network_access = 4;
        }

        message GitOperation {
          string operation = 1;  // CLONE, FETCH, DIFF, COMMIT, PUSH
          repeated string args = 2;
        }

        message InferenceCall {
          string provider = 1;
          string model = 2;
          bytes prompt_hash = 3;  // Full prompt stored in CAS
          uint64 max_tokens = 4;
        }

        message ArtifactPublish {
          string artifact_id = 1;
          bytes content_hash = 2;
          string category = 3;
        }

        // Tool response from kernel to agent
        message ToolResponse {
          string request_id = 1;
          oneof result {
            ToolSuccess success = 2;
            ToolDenied denied = 3;
            ToolError error = 4;
          }
        }

        message ToolSuccess {
          bytes result_hash = 1;  // Full result stored in CAS if large
          bytes inline_result = 2;  // Small results inline
          uint64 budget_consumed = 3;
        }

        message ToolDenied {
          string rule_id = 1;
          string rationale_code = 2;
          string message = 3;
        }

        message ToolError {
          string error_code = 1;
          string message = 2;
        }

    evidence_ids:
    - EVID-0008

  - id: CTR-0002
    name: "Adapter Interface Contract"
    type: API
    versioning:
      scheme: SEMVER
      current_version: "0.1.0"
      compatibility_rules:
      - "Adapters implement the Adapter trait"
      - "Event stream uses normalized KernelEvent messages"
      - "Black-box and instrumented adapters share the same interface"
    schemas:
    - id: SCH-0001
      path: "src/adapter/mod.rs"
      format: RUST_TRAIT
      description: "Rust trait definition for adapters"
      inline_schema: |
        /// Adapter trait for normalizing agent communication.
        ///
        /// Adapters wrap heterogeneous agent runtimes and emit a normalized
        /// event stream. Both black-box (observation) and instrumented
        /// (native) adapters implement this trait.
        #[async_trait]
        pub trait Adapter: Send + Sync {
            /// Start the agent session with the given context.
            async fn start(
                &self,
                context: SessionContext,
                cancellation: CancellationToken,
            ) -> Result<SessionHandle, AdapterError>;

            /// Send a tool response to the agent.
            async fn send_response(
                &self,
                handle: &SessionHandle,
                response: ToolResponse,
            ) -> Result<(), AdapterError>;

            /// Receive the next event from the agent.
            /// Returns None when the session terminates.
            async fn recv_event(
                &self,
                handle: &SessionHandle,
            ) -> Result<Option<AdapterEvent>, AdapterError>;

            /// Forcefully terminate the session.
            async fn terminate(
                &self,
                handle: &SessionHandle,
                reason: TerminationReason,
            ) -> Result<(), AdapterError>;
        }

        /// Events emitted by adapters (normalized from agent behavior).
        pub enum AdapterEvent {
            ToolRequest(ToolRequest),
            Progress(ProgressSignal),
            Terminated(TerminationInfo),
            Error(AdapterError),
        }

        /// Session context provided to adapters at startup.
        pub struct SessionContext {
            pub session_id: String,
            pub actor_id: String,
            pub work_id: String,
            pub lease_id: String,
            pub spec_snapshot: SpecSnapshot,
            pub policy_context: PolicyContext,
            pub entropy_budget: u64,
            /// Context as Code (DCP) hooks.
            pub context_pack_hash: Option<Vec<u8>>,
            pub dcp_refs: Vec<String>,
            pub pinned_snapshot_hash: Option<Vec<u8>>,
        }

    evidence_ids:
    - EVID-0001
    - EVID-0002

  - id: CTR-0003
    name: "Ledger Storage Contract"
    type: STORAGE
    versioning:
      scheme: SEMVER
      current_version: "0.1.0"
      compatibility_rules:
      - "Events are stored in insertion order"
      - "Hash chain must be verifiable from any cursor"
      - "Schema migrations use explicit version markers"
    schemas:
    - id: SCH-0001
      path: "src/ledger/schema.sql"
      format: SQL
      description: "SQLite schema for ledger storage"
      inline_schema: |
        -- Ledger schema for APM2 kernel events
        -- Version: 0.1.0

        PRAGMA journal_mode = WAL;
        PRAGMA foreign_keys = ON;

        -- Main event table (append-only)
        CREATE TABLE IF NOT EXISTS events (
            sequence INTEGER PRIMARY KEY,
            previous_hash BLOB NOT NULL,
            timestamp INTEGER NOT NULL,
            actor_id TEXT NOT NULL,
            session_id TEXT,
            signature BLOB NOT NULL,
            payload_type TEXT NOT NULL,
            payload BLOB NOT NULL,
            event_hash BLOB NOT NULL UNIQUE
        );

        -- Index for actor queries
        CREATE INDEX IF NOT EXISTS idx_events_actor ON events(actor_id);

        -- Index for session queries
        CREATE INDEX IF NOT EXISTS idx_events_session ON events(session_id);

        -- Index for payload type queries (for projection efficiency)
        CREATE INDEX IF NOT EXISTS idx_events_type ON events(payload_type);

        -- Projection checkpoints
        CREATE TABLE IF NOT EXISTS projection_checkpoints (
            projection_name TEXT PRIMARY KEY,
            last_sequence INTEGER NOT NULL,
            checkpoint_data BLOB NOT NULL,
            updated_at INTEGER NOT NULL
        );

        -- Content-addressed artifact references
        CREATE TABLE IF NOT EXISTS artifact_refs (
            content_hash BLOB PRIMARY KEY,
            size INTEGER NOT NULL,
            created_at INTEGER NOT NULL,
            storage_path TEXT NOT NULL
        );

        -- Active leases projection (materialized for performance)
        CREATE TABLE IF NOT EXISTS active_leases (
            lease_id TEXT PRIMARY KEY,
            work_id TEXT NOT NULL UNIQUE,
            actor_id TEXT NOT NULL,
            issued_at INTEGER NOT NULL,
            expires_at INTEGER NOT NULL,
            registrar_signature BLOB NOT NULL
        );

        -- Session health projection
        CREATE TABLE IF NOT EXISTS session_health (
            session_id TEXT PRIMARY KEY,
            actor_id TEXT NOT NULL,
            state TEXT NOT NULL,
            entropy_consumed INTEGER NOT NULL,
            entropy_budget INTEGER NOT NULL,
            last_progress_at INTEGER NOT NULL
        );

    evidence_ids:
    - EVID-0004
    - EVID-0005

  outputs:
    artifacts_produced:
    - id: OUT-0001
      name: "Compiled kernel binary"
      path: "target/release/apm2"
      format: "ELF executable"
    - id: OUT-0002
      name: "Protobuf definitions"
      path: "proto/"
      format: ".proto files"
    - id: OUT-0003
      name: "SQLite database"
      path: "$APM2_DATA_DIR/ledger.db"
      format: "SQLite 3 database"
    failure_modes:
    - id: FM-0001
      condition: "Ledger database corrupted"
      detection: "Hash chain verification fails on startup"
      recovery: "Restore from backup or replay from peer"
    - id: FM-0002
      condition: "Protobuf schema mismatch"
      detection: "Decode error with unknown field"
      recovery: "Check version compatibility; upgrade if within window"
