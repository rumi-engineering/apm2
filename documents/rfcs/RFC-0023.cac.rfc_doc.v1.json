{
  "schema": "cac.rfc_doc.v1",
  "schema_version": "1.0.0",
  "kind": "rfc.document",
  "meta": {
    "stable_id": "dcp://apm2.rfcs/RFC-0023@seed",
    "status": "SEED",
    "classification": "INTERNAL",
    "replaces": "documents/rfcs/RFC-0023/seed.md",
    "canonicalizer": {
      "canonicalizer_id": "apm2.canonicalizer.jcs",
      "canonicalizer_version": "1.0.0",
      "vectors_ref": "dcp://apm2.cac/canonicalizer/vectors@v1"
    },
    "provenance": {
      "actor_id": "HOLON-RFC-GOVERNANCE",
      "work_id": "TCK-00680-docs-overhaul"
    }
  },
  "payload": {
    "rfc_id": "RFC-0023",
    "title": "Instruction Lifecycle and Deployment Protocol",
    "seed_content": "# RFC-0023: Instruction Lifecycle & Deployment Protocol \u2014 Seed\n\n## Required context files\n\nRead all of these before generating output:\n\n- documents/theory/unified-theory-v2.json\n- documents/theory/unified-theory-v2.json\n- documents/theory/unified-theory-v2.json\n- documents/theory/unified-theory-v2.json\n- documents/strategy/MASTER_STRATEGY.json\n- documents/rfcs/RFC-0020/HOLONIC_SUBSTRATE_INTERFACE.md\n- documents/rfcs/RFC-0021/HOLONIC_VENTURE_PROVING_INTERFACE.md\n- documents/rfcs/RFC-0022/PRINCIPAL_SOVEREIGNTY_INTERFACE.md\n- proto/kernel_events.proto\n\n## Why this RFC matters\n\nInstructions \u2014 policies, directives, configurations, behavioral constraints \u2014 are the governance layer that shapes what agents do. Today these are scattered, implicitly versioned, and resolved through ad-hoc mechanisms. This RFC must formalize the full lifecycle: how instructions are born, signed, deployed, resolved at runtime, composed under holonic recursion, rolled back, and retired. The key insight is that instruction management is itself a distributed systems problem with consistency, availability, and partition tolerance tradeoffs. Draw from CRDTs, content-addressed storage, capability-based security, and formal verification of policy languages to build something that scales to civilizational coordination.\n\n## Priority innovation vectors\n\n- **Instruction CRDTs**: conflict-free replicated instruction sets that converge deterministically under concurrent updates from multiple principals at different hierarchy levels.\n- **Content-addressed policy graphs**: instructions as a Merkle DAG where lineage is cryptographically verifiable and forks are detectable.\n- **Categorical composition**: model instruction scoping as a functor from the holon hierarchy to the instruction lattice, ensuring composition preserves semantics.\n- **Atomic rollback via checkpoints**: leverage CAS to make rollback a pointer swap rather than a state reconstruction, achieving O(1) rollback latency.\n- **Runtime resolution as proof search**: deterministic instruction resolution that produces a verifiable proof of which instructions apply and why.\n\n## Problem (PHY-03, PHY-05, INV-F-02)\n\nThree instruction specs exist (AEP, BSP, RFC-0021 refinement) as static JSON files under documents/prompts/. The CAC schema (cac.instruction_spec.v1) validates their structure. RFC-0011 (CAC v1) defines the context-as-code pipeline. The schema_registry module exists in apm2-core.\n\nBut there is no normative protocol for how instruction specs are versioned, deployed, resolved at runtime, signed by the principal, rolled back, or retired. The instruction specs are the system's DNA \u2014 they govern what every agent does. Without lifecycle governance, the system has no way to:\n\n1. Prove which instruction spec version was active during a given episode\n2. Prevent an agent from loading a tampered or outdated instruction spec\n3. Roll back a bad instruction spec deployment without losing evidence\n4. Track dependencies between instruction specs (BSP references AEP axioms)\n5. Ensure the principal has approved every active instruction spec\n\nThis is a verification-tier concern (INV-F-02: no authoritative state transition without required gate receipt). Instruction deployment IS a state transition.\n\n## What already exists\n\n| Artifact | Provides | Gap |\n|---|---|---|\n| cac.instruction_spec.v1.schema.json | Structural validation | No lifecycle states, no deployment protocol |\n| schema_registry module in apm2-core | Schema registration infrastructure | Not wired to instruction spec deployment |\n| CAC v1 (RFC-0011) | Context compilation pipeline | Compiles context, doesn't deploy/version instruction specs |\n| EpisodeEnvelopeV1 (HSI \u00a73) | Immutable execution commitment | Contains instruction_spec_ref field but no normative binding |\n| Evidence CAS (BLAKE3) | Content-addressed storage | Instruction specs aren't CAS-addressed today |\n\n## Machine-checkable objectives\n\n**OBJ-ILD-01**: CAS-addressed instruction specs: Every instruction spec must be identified by its BLAKE3 content hash. Name+version are convenience aliases.\n- Predicate: `\u2200 spec: spec.id = blake3(canonical(spec.payload))`\n\n**OBJ-ILD-02**: Principal-signed promotion: No instruction spec enters ACTIVE state without principal's AuthoritySealV1.\n- Predicate: `\u2200 spec \u2208 ACTIVE: \u2203 seal \u2208 spec.promotion_receipt: seal.principal = true`\n\n**OBJ-ILD-03**: Episode binding: Every EpisodeEnvelopeV1 must reference the exact CAS digest of every instruction spec that governed it.\n- Predicate: `\u2200 episode: episode.instruction_spec_refs \u2282 CAS \u2227 \u2200 ref: verify(ref) = true`\n\n**OBJ-ILD-04**: Dependency closure: If instruction spec A references axioms from spec B, the deployment of A must require B to be in ACTIVE state at a compatible version.\n- Predicate: `\u2200 spec: spec.dependencies \u2282 registry.active_specs`\n\n**OBJ-ILD-05**: Rollback without evidence loss: Rolling back an instruction spec must not invalidate evidence produced under the previous version. Evidence retains its original spec binding.\n- Predicate: `\u2200 evidence \u2208 ledger: rollback(spec) \u2192 evidence.spec_ref unchanged`\n\n**OBJ-ILD-06**: Runtime resolution is deterministic: Given an episode's time envelope and holon identity, the set of active instruction specs must be uniquely determined.\n- Predicate: `\u2200 (time, holon): resolve(time, holon) = deterministic_set`\n\n## Protocol objects (seed schemas)\n\nThese are starting points \u2014 refine, extend, or restructure as your analysis requires.\n\n```\nInstructionSpecRegistryEntryV1 {\n    content_digest: CasDigest,\n    schema_ref: str,\n    schema_version: SemVer,\n    kind: str,\n    name: str,\n    version: SemVer,\n    lifecycle_state: SpecLifecycleState,\n    dependencies: Vec<SpecDependencyV1>,\n    promotion_receipt: Option<SpecPromotionReceiptV1>,\n    retirement_receipt: Option<SpecRetirementReceiptV1>,\n    created_at: TimeEnvelopeRef,\n    state_transitions: Vec<SpecTransitionReceiptV1>,\n}\n\nSpecLifecycleState { DRAFT | STAGED | ACTIVE | DEPRECATED | RETIRED }\n\nSpecDependencyV1 {\n    spec_kind: str,\n    version_constraint: VersionConstraint,\n    required_axiom_ids: Vec<str>,\n    binding_type: DependencyBinding,\n}\n\nSpecPromotionReceiptV1 {\n    spec_digest: CasDigest,\n    from_state: SpecLifecycleState,\n    to_state: SpecLifecycleState,\n    principal_seal: AuthoritySealV1,\n    validation_evidence: Vec<CasDigest>,\n    promoted_at: TimeEnvelopeRef,\n}\n\nSpecResolutionContextV1 {\n    holon_id: HolonIdV1,\n    time_envelope: TimeEnvelopeRef,\n    requested_kinds: Vec<str>,\n}\n\nSpecResolutionResultV1 {\n    context: SpecResolutionContextV1,\n    resolved_specs: Vec<(str, CasDigest)>,\n    resolution_proof: CasDigest,\n}\n\nSpecRollbackReceiptV1 {\n    spec_digest: CasDigest,\n    rollback_to: CasDigest,\n    reason: str,\n    principal_seal: AuthoritySealV1,\n    evidence_preservation_attestation: CasDigest,\n    rolled_back_at: TimeEnvelopeRef,\n}\n```\n\n## Trust boundaries and threat model\n\nTrust boundary: The instruction registry is a kernel-level service. Agents are UNTRUSTED consumers \u2014 they request resolution but cannot modify registry state. Only the principal (via AuthoritySealV1) and the kernel (for lifecycle bookkeeping) write to the registry.\n\nThreats:\n1. **Instruction tampering (PHY-05)**: Agent modifies an instruction spec after promotion. Mitigation: CAS-addressing \u2014 any modification changes the digest, breaking all references.\n2. **Stale instruction resolution (PHY-03)**: Agent operates under an outdated spec. Mitigation: deterministic resolution bound to time envelopes; episodes commit their spec refs.\n3. **Dependency confusion**: Spec A claims to depend on Spec B but actually uses a different version. Mitigation: dependency closure check at promotion time; axiom-level granularity in dependency tracking.\n4. **Rollback-induced evidence orphaning**: Evidence produced under Spec v2 becomes uninterpretable after rollback to v1. Mitigation: evidence retains its original spec binding (OBJ-ILD-05); the spec version is part of the evidence's immutable metadata.\n\n## Theory bindings\n\n- LAW-01 (Loop Closure): Spec lifecycle is a gated promotion loop (DRAFT -> STAGED -> ACTIVE -> DEPRECATED -> RETIRED)\n- LAW-03 (Monotone Ledger): Spec transitions are append-only; previous states are never overwritten\n- LAW-09 (Temporal Pinning): Spec resolution is pinned to time envelopes, not wall-clock\n- LAW-13 (Semantic Contracting): Each spec is a semantic contract; resolution is contract fulfillment\n- INV-F-01 (Append-only truth): The spec registry is an append-only ledger\n- INV-F-02 (No transition without gate receipt): Promotion requires principal seal + validation evidence\n- INV-F-08 (Freshness is explicit): Spec resolution carries a freshness proof\n\n## Rollout\n\n- S0: CAS-address all existing instruction specs; create InstructionSpecRegistryEntryV1 for each\n- S1: Wire registry into EpisodeEnvelopeV1 \u2014 every episode records its resolved specs\n- S2: Principal-signed promotion gate \u2014 no spec reaches ACTIVE without seal\n- S3: Dependency closure validation at promotion time\n- S4: Deterministic runtime resolution with proof generation\n- S5: Rollback protocol with evidence preservation attestation\n- S6: Multi-holon resolution \u2014 federated registry heads with consensus\n",
    "notes": ""
  }
}