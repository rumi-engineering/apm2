rfc_design_decisions:
  schema_version: "2026-01-24"
  template_version: "2026-01-24"
  decisions:
  - id: DD-001
    title: "AAT Implementation as cargo xtask Extension"
    statement: |
      Implement Agent Acceptance Testing (AAT) as a subcommand of cargo xtask
      (e.g., `cargo xtask aat <PR_URL>`) rather than a separate crate or external tool.
      AAT reuses the xtask infrastructure established by existing review commands
      (security-review, quality-review).
    context: |
      The APM2 project uses cargo xtask as the standard development task runner.
      Existing patterns for code review (review-security, review-quality) demonstrate
      the effectiveness of this approach. AAT is a similar verification workflow that
      benefits from the same infrastructure: working directory management, logging,
      error handling, and process lifecycle.
    alternatives:
    - id: ALT-0001
      name: "Separate Rust crate (apm2-aat)"
      pros:
      - "Independent versioning"
      - "Distributable as standalone binary"
      cons:
      - "Duplicates dependencies from main crate"
      - "Requires separate release process"
      - "Adds operational complexity"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Two build artifacts to maintain"
      - "Different upgrade paths for main vs AAT"
    - id: ALT-0002
      name: "External shell script wrapper"
      pros:
      - "Minimal code duplication"
      - "Quick to prototype"
      cons:
      - "Harder to maintain; error handling less rigorous"
      - "Shell portability issues (Windows, Mac)"
      - "No access to Rust type system for safety"
      security_tradeoffs:
      - "Shell injection risks if not careful with quoting"
      operability_tradeoffs:
      - "Debugging requires switching between Rust and shell contexts"
    - id: ALT-0003
      name: "Extend cargo xtask (chosen)"
      pros:
      - "Consistent with existing review commands"
      - "Reuses build infrastructure and error handling"
      - "Same working directory and environment as other tasks"
      - "Type-safe argument handling via Rust CLI parsing"
      - "Single codebase; single release cycle"
      cons:
      - "xtask binary slightly larger"
      - "AAT command only available during development (intended)"
      security_tradeoffs: []
      operability_tradeoffs:
      - "All tasks share the same entry point; requires clear command routing"
    chosen_rationale: |
      Extending cargo xtask follows established APM2 patterns. The review commands
      (review-security, review-quality) demonstrate that xtask is the right place for
      verification workflows that need subprocess management, GitHub API integration,
      and structured logging. AAT benefits from the same infrastructure without
      introducing a new tool category.
    impacted_requirement_ids:
    - REQ-0002
    - REQ-0007
    evidence_ids:
    - EVID-4001

  - id: DD-002
    title: "GitHub API Integration via gh CLI"
    statement: |
      Use the gh (GitHub CLI) command-line tool for all GitHub API interactions
      (fetching PR metadata, setting commit status checks, reading comments).
      Do not use the octocrab Rust library.
    context: |
      The gh CLI is already available in GitHub Actions environments and developer
      workstations. It handles authentication via credential helpers; credentials
      are never exposed to the AAT process. Existing xtask commands (review-security,
      review-quality) already use gh for status checks, proving this pattern.
    alternatives:
    - id: ALT-0001
      name: "Octocrab Rust library"
      pros:
      - "Type-safe API; compile-time verification"
      - "No subprocess overhead"
      cons:
      - "Adds dependency to xtask"
      - "Requires explicit token management in process"
      - "Credentials potentially exposed in memory"
      security_tradeoffs:
      - "Process memory could be interrogated; tokens could be extracted"
      - "Token must be injected at process start"
      operability_tradeoffs:
      - "Token rotation more complex"
    - id: ALT-0002
      name: "curl/HTTP calls with manual JSON parsing"
      pros:
      - "Minimal dependencies"
      cons:
      - "Error-prone; manual JSON parsing complex"
      - "No structured error handling"
      - "Raw HTTP calls more fragile"
      security_tradeoffs:
      - "Manual credential handling higher risk"
      operability_tradeoffs:
      - "Debugging requires understanding GitHub API details"
    - id: ALT-0003
      name: "gh CLI via subprocess (chosen)"
      pros:
      - "Credentials managed by gh helper; never in AAT process memory"
      - "Proven pattern from review-security/quality commands"
      - "No new dependencies for xtask"
      - "Subprocess sandboxing limits blast radius"
      cons:
      - "Subprocess overhead for each API call"
      - "Requires gh to be installed and configured"
      security_tradeoffs:
      - "Subprocess isolation reduces credential exposure"
      operability_tradeoffs:
      - "Requires gh credential helper setup in CI/CD"
    chosen_rationale: |
      gh CLI provides credential management via helpers and has proven successful
      in existing review commands. Subprocess isolation means tokens are never in
      the AAT process memory. The performance cost (subprocess overhead) is
      acceptable for a batch verification tool.
    impacted_requirement_ids:
    - REQ-0002
    - REQ-0008
    evidence_ids:
    - EVID-4002

  - id: DD-003
    title: "Pure Rust PR Parser with Regex"
    statement: |
      Parse PR descriptions (Usage, Expected Outcomes, Evidence Script, Known Limitations
      sections) using regular expressions in Rust, not LLM-based parsing.
      The parser extracts and validates the four required sections; malformed PRs are
      rejected early with actionable error messages.
    context: |
      PR description parsing must be deterministic and reproducible across runs.
      Regular expressions are fast, deterministic, and require no external service calls.
      The PR format is constrained by the requirements (specific section headers, markdown
      code blocks), making regex-based extraction reliable.
    alternatives:
    - id: ALT-0001
      name: "LLM-based parsing (invoke Claude for understanding)"
      pros:
      - "Flexible to malformed or creative PR descriptions"
      - "Can infer intent if sections are loosely structured"
      cons:
      - "Non-deterministic; same PR might parse differently"
      - "Adds latency and cost (LLM API calls)"
      - "Failure if LLM service unavailable"
      - "Difficult to reproduce parse results for debugging"
      security_tradeoffs:
      - "LLM could misinterpret malicious section content"
      operability_tradeoffs:
      - "Debugging parsing failures requires access to LLM internals"
    - id: ALT-0002
      name: "Tree-sitter markdown parsing"
      pros:
      - "Structured; understands markdown AST"
      - "More robust to formatting variations"
      cons:
      - "Additional tree-sitter dependency"
      - "Over-engineered for simple section extraction"
      - "More complex error messages"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Debugging tree-sitter AST traversal more complex"
    - id: ALT-0003
      name: "Regex-based extraction (chosen)"
      pros:
      - "Fast and deterministic"
      - "No external dependencies (Rust stdlib regex)"
      - "Clear, testable error messages"
      - "Reproducible across runs and machines"
      cons:
      - "Fragile if PR format deviates significantly"
      - "Cannot infer structure from malformed descriptions"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Requires clear format documentation for PR authors"
    chosen_rationale: |
      Regex parsing is deterministic, fast, and sufficient for extracting well-defined
      sections. The PR format is constrained by requirements; strict parsing enforces
      this discipline. Rejected PRs get clear errors guiding authors to fix their
      descriptions. This is better than silently misinterpreting a creative but
      non-compliant PR.
    impacted_requirement_ids:
    - REQ-0001
    - REQ-0003
    evidence_ids:
    - EVID-4003

  - id: DD-004
    title: "Invoke AAT Skill for Hypothesis Generation"
    statement: |
      After parsing the PR description, invoke the AAT skill (defined in documents/skills/aat/SKILL.md)
      to generate hypotheses, execute verification, perform anti-gaming checks, and produce the
      evidence bundle. The skill carries out all LLM-driven reasoning and decision-making.
    context: |
      Hypothesis formation requires understanding PR intent, Expected Outcomes semantics,
      and test strategy. This is cognitive work best suited to LLM reasoning.
      The AAT skill encapsulates this reasoning in a reusable protocol with clear
      input/output contracts. The xtask command orchestrates the workflow but delegates
      the verification logic to the skill.
    alternatives:
    - id: ALT-0001
      name: "Implement hypothesis generation in Rust"
      pros:
      - "No inter-process communication overhead"
      - "Direct access to parsed PR structure"
      cons:
      - "Duplicates LLM reasoning; hard to maintain"
      - "Brittle heuristics for hypothesis formation"
      - "Cannot adapt to new PR patterns"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Changes to hypothesis logic require code changes and redeploy"
    - id: ALT-0002
      name: "Always invoke Claude API directly from xtask"
      pros:
      - "Simple; no skill abstraction"
      cons:
      - "Bypasses skill routing/gating mechanism"
      - "Token tracking not unified"
      - "Different from other skill invocations in APM2"
      security_tradeoffs:
      - "API keys embedded in xtask; harder to rotate"
      operability_tradeoffs:
      - "AAT not discoverable via skill list"
    - id: ALT-0003
      name: "Delegate to AAT skill via skill subsystem (chosen)"
      pros:
      - "Unified skill invocation; consistent with APM2 architecture"
      - "Skill carries all domain logic; xtask is thin orchestrator"
      - "Skills can be composed with other agents"
      - "Token tracking and budgeting via kernel"
      cons:
      - "Requires inter-process skill invocation"
      - "Evidence bundle must be transferred from skill to xtask"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Debugging requires understanding skill protocol"
    chosen_rationale: |
      Delegating hypothesis formation to the AAT skill keeps LLM reasoning centralized
      and reusable. The skill can be invoked by any agent (humans, other agents), not
      just from xtask. This follows APM2's architecture where skills are the unit of
      reusable, verifiable logic.
    impacted_requirement_ids:
    - REQ-0003
    - REQ-0004
    - REQ-0005
    evidence_ids:
    - EVID-4004

  - id: DD-005
    title: "Evidence Bundle as JSON with Skill Schema"
    statement: |
      The evidence bundle produced by the AAT skill is structured as JSON and conforms
      to the schema defined in the skill specification (documents/skills/aat/SKILL.md).
      The bundle includes hypotheses, execution results, anti-gaming analysis, and verdict.
      Bundles are stored in evidence/aat/PR-{number}_{timestamp}.json.
    context: |
      The skill specification defines the evidence bundle structure for determinism
      and auditability. Using JSON (not YAML or tarball) provides machine-readable
      output suitable for parsing by review tools, dashboards, and audit processes.
      The structured format enables automated analysis and rollup of pass rates.
    alternatives:
    - id: ALT-0001
      name: "Tarball with manifest.yaml and artifacts"
      pros:
      - "Self-contained; includes all logs and outputs"
      - "Versionable as single archive"
      cons:
      - "Harder to parse; requires extraction"
      - "Not directly queryable"
      - "Larger storage footprint"
      security_tradeoffs: []
      operability_tradeoffs:
      - "Integration with dashboards requires extraction pipeline"
    - id: ALT-0002
      name: "YAML single-file bundle"
      pros:
      - "Human readable"
      - "Direct text parsing"
      cons:
      - "YAML parsing less consistent than JSON"
      - "Comments in YAML can leak sensitive info"
      - "Verbose for large stdout/stderr captures"
      security_tradeoffs:
      - "YAML anchors/aliases could hide duplication"
      operability_tradeoffs:
      - "YAML parser differences across tools"
    - id: ALT-0003
      name: "JSON bundle per skill schema (chosen)"
      pros:
      - "Machine-readable; consistent parsing"
      - "Matches skill output schema exactly"
      - "Compact; suitable for storage and transmission"
      - "Directly queryable via jq"
      - "Schema validation via JSON Schema"
      cons:
      - "Not human-readable without formatting"
      - "Requires JSON pretty-printing for display"
      security_tradeoffs:
      - "JSON spec prevents encoding issues"
      operability_tradeoffs:
      - "Standard JSON tooling widely available"
    chosen_rationale: |
      JSON bundles conform to the skill schema and are machine-readable. This enables
      automation of evidence analysis, audit reports, and integration with review
      dashboards. The skill specification defines the JSON structure; the evidence
      bundle is simply serialized output.
    impacted_requirement_ids:
    - REQ-0006
    - REQ-0009
    evidence_ids:
    - EVID-4005
