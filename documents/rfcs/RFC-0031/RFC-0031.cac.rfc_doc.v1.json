{
  "schema": "cac.rfc_doc.v1",
  "schema_version": "1.0.0",
  "kind": "rfc.document",
  "meta": {
    "id": "RFC-0031",
    "title": "Adopt single-file CAC RFC JSON format (v1)",
    "labels": [
      "cac",
      "rfc",
      "tooling",
      "phase1",
      "migration",
      "fac"
    ],
    "relationships": [
      {
        "kind": "SUPERSEDES",
        "ref": "documents/rfcs/template/* (multi-YAML RFC template)"
      },
      {
        "kind": "AFFECTS",
        "ref": "crates/apm2-core/src/rfc_framer/*"
      },
      {
        "kind": "AFFECTS",
        "ref": "crates/apm2-cli/src/commands/factory/rfc.rs"
      },
      {
        "kind": "AFFECTS",
        "ref": "crates/apm2-cli/src/commands/factory/compile.rs"
      }
    ],
    "provenance": {
      "actor_id": "APM2-DOC-GOV",
      "work_id": "RFC-0031-CAC-RFC-JSON"
    }
  },
  "payload": {
    "root": {
      "type": "rfc",
      "title": "RFC-0031: Adopt single-file CAC RFC JSON format (v1)",
      "data": {
        "summary": "Replace the current multi-YAML RFC format with a single, JSON-parseable, Context-as-Code RFC document that can be (1) linted for closure-completeness and in-place migrations, and (2) compiled into WorkObjects for FAC consumption.",
        "target_outcomes": [
          "Each RFC has exactly one canonical RFC JSON file under its RFC directory.",
          "RFC JSON can be JSON-Schema validated and CAC-canonicalized (no floats, no duplicate keys).",
          "RFC tasks compile deterministically into WorkObjects (id/title/requirement bindings).",
          "RFC lints enforce: explicit migration plan (IN_PLACE + legacy removals) and explicit validation plan (replayable checks).",
          "Remove or quarantine legacy RFC framer outputs and PRD coupling to prevent documentation rot."
        ],
        "non_goals": [
          "Define a global metrics system (explicitly out of scope).",
          "Redesign FAC, PCAC, or cryptographic semantics as part of this RFC."
        ]
      },
      "children": [
        {
          "type": "section",
          "title": "1. Problem",
          "data": {
            "semantic": "problem"
          },
          "body": "APM2 RFCs currently exist as a directory of loosely coupled YAML sections (00_meta.yaml … 09_governance_and_gates.yaml) plus ad-hoc Markdown amendments. This structure is hard to parse, hard to slice, and easy to let rot: content drifts across files, tooling only partially consumes it, and mechanization stops at the boundaries of YAML fragments.\n\nThe failure mode is visible in practice:\n- RFC-0019 required multiple amendment Markdown docs to capture operational reality.\n- RFC-0028/0029 achieved high detail, but many fields (notably evidence IDs and roles) add overhead without being executed by tooling.\n\nWe need an RFC representation that is simultaneously:\n- one canonical file per RFC,\n- recursively structured for editing and slicing,\n- machine-validated (schema + lints), and\n- directly compilable into WorkObjects for FAC."
        },
        {
          "type": "section",
          "title": "2. Constraints and design principles",
          "data": {
            "semantic": "principles",
            "normative": true
          },
          "children": [
            {
              "type": "requirement",
              "id": "RFC-0031::REQ-0001",
              "title": "Single canonical RFC file",
              "data": {
                "level": "MUST",
                "statement": "Each RFC MUST have exactly one canonical JSON RFC file (CAC RFC Doc) as the source of truth.",
                "acceptance": [
                  "Repo linter rejects RFC directories with multiple candidate canonical RFC JSON files.",
                  "Repo linter rejects RFC directories whose canonical RFC JSON does not validate against the RFC JSON Schema."
                ]
              }
            },
            {
              "type": "requirement",
              "id": "RFC-0031::REQ-0002",
              "title": "Recursive document structure",
              "data": {
                "level": "MUST",
                "statement": "The RFC format MUST support arbitrarily nested sections/subsections and typed nodes (requirements, tasks, plans) within the same recursive structure.",
                "acceptance": [
                  "Schema supports recursive nodes with children.",
                  "Tooling can extract nodes by type (e.g., all tasks, all requirements) regardless of nesting depth."
                ]
              }
            },
            {
              "type": "requirement",
              "id": "RFC-0031::REQ-0003",
              "title": "Closure-complete by lint, not by field explosion",
              "data": {
                "level": "MUST",
                "statement": "RFCs MUST be closure-complete (integration + validation) enforced by lints and required plan nodes, not by a proliferation of bespoke top-level fields.",
                "acceptance": [
                  "Lint rule requires at least one migration plan (plan_kind=migration) and one validation plan (plan_kind=validation).",
                  "Lint rule requires at least one task node and at least one requirement node for implementation-track RFCs."
                ],
                "rationale": "Closure completeness is a project invariant, but forcing it into dozens of brittle schema fields makes the document harder to write and harder to evolve."
              }
            },
            {
              "type": "requirement",
              "id": "RFC-0031::REQ-0004",
              "title": "Arduous in-place migration with legacy removal",
              "data": {
                "level": "MUST",
                "statement": "RFCs that change code MUST include an in-place migration plan that explicitly deletes or deprecates legacy code/paths (no 'we'll keep both forever').",
                "acceptance": [
                  "Lint rule requires migration plan upgrade_style=IN_PLACE.",
                  "Lint rule requires non-empty legacy_removals for any RFC with non-empty touched surfaces.",
                  "Lint rule requires rollback steps per phase."
                ]
              }
            },
            {
              "type": "requirement",
              "id": "RFC-0031::REQ-0005",
              "title": "No DocStatus / Classification / Roles / Evidence IDs / PRDs in RFC schema",
              "data": {
                "level": "MUST",
                "statement": "The RFC schema MUST NOT include DocStatus, Classification, AuthorityRole, AgentRole, evidence_ids, or PRD bindings.",
                "acceptance": [
                  "Schema contains no such fields.",
                  "Migration plan includes removal of legacy RFC template fields that encode these concepts."
                ]
              }
            }
          ]
        },
        {
          "type": "section",
          "title": "3. Proposed RFC JSON schema",
          "data": {
            "semantic": "design"
          },
          "children": [
            {
              "type": "decision",
              "id": "RFC-0031::DEC-0001",
              "title": "Use a single recursive node tree",
              "data": {
                "decision": "Represent RFC content as a single recursive tree of typed nodes (rfc/section/requirement/task/plan/...).",
                "rationale": "This matches how engineers actually edit specs (outline-first), enables arbitrary nesting, and allows tooling to slice by node type without imposing a rigid fixed section list.",
                "tradeoffs": [
                  "Requires a linter to enforce project invariants (migration/validation presence, uniqueness of ids).",
                  "Node typing must be kept small and extensible to avoid schema ossification."
                ],
                "alternatives": [
                  "Flat registries for requirements/tasks with separate outline referencing ids (more complex authoring).",
                  "Pure Markdown (easy to write but hard to mechanize reliably)."
                ]
              }
            },
            {
              "type": "decision",
              "id": "RFC-0031::DEC-0002",
              "title": "Replace evidence IDs with replayable verification checks",
              "data": {
                "decision": "Do not model evidence as predeclared evidence_ids. Instead, model validation as replayable checks (commands/procedures + expected predicates) inside plan/task nodes.",
                "rationale": "In the current repo, evidence artifacts are often 'planned' YAML stubs that tooling does not execute, so they create overhead without increasing assurance. Replayable checks align better with CAC and FAC: the system can run the checks and produce receipts/artifacts automatically.",
                "tradeoffs": [
                  "We lose a simple static ID mapping unless checks produce stable receipt handles (recommended future extension).",
                  "Requires discipline to keep checks deterministic and bounded."
                ],
                "alternatives": [
                  "Keep evidence_ids but auto-generate them from receipts (still introduces an indirection layer)."
                ]
              }
            },
            {
              "type": "section",
              "title": "3.1 Steelman: why evidence IDs might still matter",
              "data": {
                "semantic": "analysis"
              },
              "body": "If APM2 later enforces promotion-critical claims across a distributed holarchy, having a stable, addressable evidence namespace can be useful:\n- It enables traceability graphs (REQ → CHECK → RECEIPT) without parsing prose.\n- It supports caching and de-duplication of verification work across RFCs.\n- It can reduce Goodhart pressure by requiring receipt-anchored proof objects instead of narrative claims.\n\nThe strongest version of 'evidence IDs' is not manual YAML stubs; it is *auto-derived receipt families* where the ID is a hash of (check spec + canonicalizer + inputs). This RFC chooses to remove evidence_ids from author-written RFCs, while leaving the door open to tooling that emits stable receipt identifiers."
            }
          ]
        },
        {
          "type": "section",
          "title": "4. WorkObject compilation contract",
          "data": {
            "semantic": "fac"
          },
          "children": [
            {
              "type": "interface",
              "id": "RFC-0031::INT-0001",
              "title": "RFC task → WorkObject mapping",
              "data": {
                "surface": "crates/apm2-holon/src/work.rs::WorkObject",
                "inputs": [
                  {
                    "name": "task.id",
                    "type": "string",
                    "description": "Stable task identifier (e.g., TCK-xxxxx or RFC-0031::TASK-xx).",
                    "required": true
                  },
                  {
                    "name": "task.title",
                    "type": "string",
                    "description": "Human readable title.",
                    "required": true
                  },
                  {
                    "name": "task.binds.requirements[]",
                    "type": "string[]",
                    "description": "Optional requirement ids.",
                    "required": false
                  }
                ],
                "outputs": [
                  {
                    "name": "WorkObject.id",
                    "type": "WorkId",
                    "description": "Derived from task.id (lossless mapping).",
                    "required": true
                  },
                  {
                    "name": "WorkObject.title",
                    "type": "string",
                    "description": "From task.title.",
                    "required": true
                  },
                  {
                    "name": "WorkObject.requirement_ids",
                    "type": "RequirementId[]",
                    "description": "From task.binds.requirements.",
                    "required": false
                  }
                ],
                "compatibility": "The compiler MUST be deterministic. If a task lacks binds.requirements, WorkObject.requirement_ids is empty. WorkObject state/artifact_ids are runtime-owned and are not specified by the RFC."
              }
            },
            {
              "type": "task",
              "id": "RFC-0031::TASK-0001",
              "title": "Implement RFC→WorkObject compiler",
              "data": {
                "outcome": "A CLI subcommand can read an RFC JSON file and emit deterministic WorkObject JSON (or write to a work staging directory) for FAC ingestion.",
                "steps": [
                  "Define a Rust struct model for cac.rfc_doc.v1 nodes (serde).",
                  "Traverse RFC payload.root recursively; collect nodes of type 'task'.",
                  "Validate task ids are unique; validate required fields exist.",
                  "Map each task to WorkObject fields (id/title/requirement_ids).",
                  "Emit JSON to stdout and/or write to documents/work/work_objects/<id>.json."
                ],
                "touches": [
                  "crates/apm2-core (new module: rfc_cac)",
                  "crates/apm2-cli (new command: apm2 rfc work emit)"
                ],
                "definition_of_done": [
                  {
                    "name": "Unit tests: stable compilation",
                    "run": "cargo test -p apm2-core rfc_cac",
                    "expect": "Compiler output is deterministic and rejects duplicate task ids."
                  },
                  {
                    "name": "Golden test: compile RFC-0031",
                    "run": "apm2 rfc work emit --rfc documents/rfcs/RFC-0031/RFC-0031.cac.json",
                    "expect": "Outputs WorkObjects for all task nodes with correct ids/titles/bindings."
                  }
                ],
                "binds": {
                  "requirements": [
                    "RFC-0031::REQ-0002"
                  ]
                }
              }
            }
          ]
        },
        {
          "type": "section",
          "title": "5. Tooling: schema validation + lints",
          "data": {
            "semantic": "tooling"
          },
          "children": [
            {
              "type": "task",
              "id": "RFC-0031::TASK-0002",
              "title": "Add RFC JSON schema + validator",
              "data": {
                "outcome": "Repo includes the JSON Schema for cac.rfc_doc.v1 and CLI can validate RFC documents against it.",
                "steps": [
                  "Add schemas/cac/rfc_doc_v1.schema.json to repo.",
                  "Implement apm2-core JSON schema validation for RFC docs (draft 2020-12).",
                  "Add CLI: apm2 rfc validate --rfc <path>."
                ],
                "touches": [
                  "schemas/cac/rfc_doc_v1.schema.json",
                  "crates/apm2-core/src (new validator module)",
                  "crates/apm2-cli/src/commands/factory/rfc.rs (extend or replace)"
                ],
                "definition_of_done": [
                  {
                    "name": "Schema file present",
                    "run": "test -f schemas/cac/rfc_doc_v1.schema.json",
                    "expect": "File exists and is committed."
                  },
                  {
                    "name": "Validator works",
                    "run": "apm2 rfc validate --rfc documents/rfcs/RFC-0031/RFC-0031.cac.json",
                    "expect": "Validation succeeds; invalid docs fail with actionable errors."
                  }
                ],
                "binds": {
                  "requirements": [
                    "RFC-0031::REQ-0001",
                    "RFC-0031::REQ-0002"
                  ]
                }
              }
            },
            {
              "type": "task",
              "id": "RFC-0031::TASK-0003",
              "title": "Implement closure-completeness and migration lints",
              "data": {
                "outcome": "RFC validation includes project-specific lints enforcing closure completeness (migration+validation plans) and in-place migrations with legacy removals.",
                "steps": [
                  "Lint: at least one plan node with plan_kind=migration.",
                  "Lint: migration plans require upgrade_style=IN_PLACE when RFC touches code.",
                  "Lint: migration plans require non-empty legacy_removals when RFC touches code.",
                  "Lint: at least one plan node with plan_kind=validation and at least one check/scenario.",
                  "Lint: forbid PRD bindings (legacy fields) and forbid evidence_ids fields anywhere under data (best-effort structural scan)."
                ],
                "touches": [
                  "crates/apm2-core/src (new rfc lint module)",
                  "crates/apm2-cli/src/commands/factory/rfc.rs"
                ],
                "definition_of_done": [
                  {
                    "name": "Lint passes RFC-0031",
                    "run": "apm2 rfc validate --rfc documents/rfcs/RFC-0031/RFC-0031.cac.json --lint",
                    "expect": "All lints pass."
                  },
                  {
                    "name": "Lint fails missing migration",
                    "run": "apm2 rfc validate --rfc <broken_fixture> --lint",
                    "expect": "Fails with a message naming missing migration plan."
                  }
                ],
                "binds": {
                  "requirements": [
                    "RFC-0031::REQ-0003",
                    "RFC-0031::REQ-0004",
                    "RFC-0031::REQ-0005"
                  ]
                }
              }
            }
          ]
        },
        {
          "type": "section",
          "title": "6. Migration plan",
          "data": {
            "semantic": "migration",
            "normative": true
          },
          "children": [
            {
              "type": "plan",
              "id": "RFC-0031::PLAN-MIGRATION",
              "title": "In-place migration from multi-YAML RFCs to CAC RFC JSON",
              "data": {
                "plan_kind": "migration",
                "upgrade_style": "IN_PLACE",
                "principles": [
                  "Do not fork the RFC system; migrate in-place and delete legacy machinery as soon as replacement exists.",
                  "Keep existing RFC numbers and git history; do not introduce parallel timestamp tracking fields.",
                  "Prefer mechanical conversion first, then iterative editorial improvement."
                ],
                "phases": [
                  {
                    "name": "Phase 0: Introduce schema + validator alongside legacy",
                    "goal": "Land schema and validation tooling without breaking existing RFCs.",
                    "steps": [
                      "Add schemas/cac/rfc_doc_v1.schema.json.",
                      "Add apm2 rfc validate that understands CAC RFC JSON.",
                      "Add a repo lint target (CI) that is opt-in for initial RFCs."
                    ],
                    "rollback": [
                      "Disable CAC RFC lint in CI if blocking; keep schema and validator but do not require."
                    ],
                    "checks": [
                      {
                        "name": "Validator runs in CI",
                        "run": "cargo test -p apm2-core && apm2 rfc validate --help",
                        "expect": "CI passes and validator is available."
                      }
                    ]
                  },
                  {
                    "name": "Phase 1: Convert template + new RFCs",
                    "goal": "New RFCs are authored only in CAC RFC JSON; template is updated.",
                    "steps": [
                      "Replace documents/rfcs/template/* with a single template RFC JSON file.",
                      "Update apm2 rfc frame / factory compile to emit RFC JSON (or deprecate these commands if PRDs are removed).",
                      "Document authoring guidance in documents/skills/implementor-default/SKILL.md (or RFC authoring skill doc)."
                    ],
                    "rollback": [
                      "Keep legacy template read-only for reference while converting docs."
                    ],
                    "checks": [
                      {
                        "name": "Template exists",
                        "run": "test -f documents/rfcs/template/RFC-TEMPLATE.cac.json",
                        "expect": "Template RFC JSON exists and validates."
                      }
                    ]
                  },
                  {
                    "name": "Phase 2: Convert existing RFCs (mechanical pass)",
                    "goal": "Every RFC directory gains exactly one canonical RFC JSON file; legacy YAML remains temporarily but is no longer authoritative.",
                    "steps": [
                      "Write a conversion script that reads 00-09 YAML files and emits a structured node tree.",
                      "For Markdown amendment docs (e.g., RFC-0019 addenda), embed them as section bodies or as linked artifacts.",
                      "Commit conversion per RFC, preserving paths and references as links."
                    ],
                    "rollback": [
                      "If conversion is lossy, keep legacy YAML as non-authoritative reference until fixed."
                    ],
                    "checks": [
                      {
                        "name": "Spot-check converted RFCs",
                        "run": "apm2 rfc validate --rfc documents/rfcs/RFC-0029/RFC-0029.cac.json --lint",
                        "expect": "Converted RFC validates and passes lints (after manual tune-ups as needed)."
                      }
                    ]
                  },
                  {
                    "name": "Phase 3: Remove legacy RFC framer + YAML standards coupling",
                    "goal": "Delete code paths that generate/expect multi-YAML RFC sections and PRD bindings.",
                    "steps": [
                      "Remove crates/apm2-core/src/rfc_framer/* or repurpose to emit CAC RFC JSON.",
                      "Remove apm2 factory compile stage dependencies on PRD/impact-map for RFC framing if PRDs are removed.",
                      "Remove documents/standards/schemas/08_rfc_meta.schema.yaml usage for RFCs (keep for historical archive if needed)."
                    ],
                    "rollback": [
                      "Temporary: keep a read-only 'legacy_rfc_framer' behind a feature flag if absolutely required."
                    ],
                    "checks": [
                      {
                        "name": "No legacy framer references",
                        "run": "grep -R \"rfc_framer\" -n crates/apm2-* || true",
                        "expect": "Either no hits, or hits are in archived/legacy modules behind a feature flag."
                      }
                    ]
                  }
                ],
                "legacy_removals": [
                  {
                    "paths": [
                      "documents/rfcs/template/00_meta.yaml",
                      "documents/rfcs/template/01_problem_and_imports.yaml",
                      "documents/rfcs/template/02_design_decisions.yaml",
                      "documents/rfcs/template/03_trust_boundaries.yaml",
                      "documents/rfcs/template/04_contracts_and_versioning.yaml",
                      "documents/rfcs/template/05_rollout_and_ops.yaml",
                      "documents/rfcs/template/06_ticket_decomposition.yaml",
                      "documents/rfcs/template/07_test_and_evidence.yaml",
                      "documents/rfcs/template/08_risks_and_open_questions.yaml",
                      "documents/rfcs/template/09_governance_and_gates.yaml"
                    ],
                    "why": "Legacy multi-YAML RFC template encourages drift and is not machine-compilable as a single unit.",
                    "how_verified": [
                      {
                        "name": "Template removed",
                        "run": "test ! -f documents/rfcs/template/00_meta.yaml",
                        "expect": "Legacy template files are deleted or moved to an explicit archive directory."
                      }
                    ]
                  },
                  {
                    "paths": [
                      "crates/apm2-core/src/rfc_framer/*",
                      "crates/apm2-cli/src/commands/factory/rfc.rs"
                    ],
                    "why": "Legacy RFC framer is PRD-coupled and emits multi-YAML RFC sections. It must be deleted or refactored to emit CAC RFC JSON.",
                    "how_verified": [
                      {
                        "name": "No PRD-coupled RFC framing remains",
                        "run": "cargo test -p apm2-cli && cargo test -p apm2-core",
                        "expect": "Build passes without the legacy framer, or with it behind a non-default feature flag."
                      }
                    ]
                  }
                ]
              }
            }
          ]
        },
        {
          "type": "section",
          "title": "7. Validation plan",
          "data": {
            "semantic": "validation",
            "normative": true
          },
          "children": [
            {
              "type": "plan",
              "id": "RFC-0031::PLAN-VALIDATION",
              "title": "Validation of the new RFC format",
              "data": {
                "plan_kind": "validation",
                "principles": [
                  "Validation is replayable and local-first (no reliance on external dashboards).",
                  "Prefer bounded, deterministic checks (CAC canonicalization, schema validation, lints)."
                ],
                "scenarios": [
                  {
                    "name": "Authoring: create a new RFC from template",
                    "steps": [
                      "Copy template RFC JSON file into a new RFC directory (RFC-XXXX).",
                      "Edit meta.id/meta.title and update root.title.",
                      "Add at least one requirement node, at least one task node, and migration/validation plan nodes."
                    ],
                    "expected": [
                      "apm2 rfc validate passes schema validation.",
                      "apm2 rfc validate --lint passes closure/migration lints."
                    ],
                    "checks": [
                      {
                        "name": "Schema validation",
                        "run": "apm2 rfc validate --rfc documents/rfcs/RFC-XXXX/RFC-XXXX.cac.json",
                        "expect": "Exit code 0."
                      }
                    ]
                  },
                  {
                    "name": "Compilation: tasks compile to WorkObjects",
                    "steps": [
                      "Run apm2 rfc work emit on RFC-0031.",
                      "Inspect output WorkObjects."
                    ],
                    "expected": [
                      "Each task node produces exactly one WorkObject.",
                      "WorkObject ids match task ids (lossless)."
                    ],
                    "checks": [
                      {
                        "name": "Compile RFC-0031",
                        "run": "apm2 rfc work emit --rfc documents/rfcs/RFC-0031/RFC-0031.cac.json",
                        "expect": "Emits valid JSON array of WorkObjects."
                      }
                    ]
                  }
                ],
                "checks": [
                  {
                    "name": "CAC canonicalization",
                    "run": "apm2 cac canonicalize --in documents/rfcs/RFC-0031/RFC-0031.cac.json",
                    "expect": "Canonicalization succeeds (no floats/duplicate keys)."
                  },
                  {
                    "name": "CI lint target",
                    "run": "scripts/ci/run_bounded_tests.sh",
                    "expect": "CI gates remain green after adoption tasks are implemented."
                  }
                ],
                "covers_requirements": [
                  "RFC-0031::REQ-0001",
                  "RFC-0031::REQ-0002",
                  "RFC-0031::REQ-0003",
                  "RFC-0031::REQ-0004",
                  "RFC-0031::REQ-0005"
                ]
              }
            }
          ]
        },
        {
          "type": "section",
          "title": "8. Risks and open questions",
          "data": {
            "semantic": "risks"
          },
          "children": [
            {
              "type": "risk",
              "id": "RFC-0031::RISK-0001",
              "title": "Schema ossification",
              "data": {
                "risk": "If we over-specify the RFC schema too early, authors will fight the format and create sidecar docs again.",
                "impact": "Return to drift and non-machine-readable specs.",
                "likelihood": "medium",
                "mitigation": [
                  "Keep node types small and extensible; allow unknown/custom node types.",
                  "Enforce invariants via lints, not by exploding the schema surface area."
                ]
              }
            },
            {
              "type": "risk",
              "id": "RFC-0031::RISK-0002",
              "title": "Lossy conversion of historical RFCs",
              "data": {
                "risk": "Mechanical conversion from YAML+Markdown into a node tree may lose nuance or references.",
                "impact": "Historical context lost; future changes become harder.",
                "likelihood": "medium",
                "mitigation": [
                  "Treat conversion as mechanical-first then iterative editorial improvement.",
                  "Preserve original files in an explicit archive directory until validated."
                ]
              }
            },
            {
              "type": "question",
              "id": "RFC-0031::Q-0001",
              "title": "What replaces PRD-driven factory compile?",
              "data": {
                "question": "If PRDs are removed, what is the new entrypoint for the factory pipeline (CCP build → impact mapping → RFC init → tickets)?",
                "options": [
                  "Option A: factory compile starts from RFC JSON directly (RFC contains requirements and impact mapping).",
                  "Option B: keep PRDs as optional inputs but stop binding RFC schema to them.",
                  "Option C: replace PRDs with a lightweight 'problem brief' CAC doc and keep the pipeline structure."
                ],
                "what_changes_answer": [
                  "How much of the existing PRD/impact-map tooling is valuable vs overhead in Phase 1.",
                  "Whether we need automated requirement→ticket mapping immediately or can do it manually."
                ]
              }
            }
          ]
        }
      ]
    }
  }
}