rfc_contracts_and_versioning:
  schema_version: "2026-01-26"
  template_version: "2026-01-26"

  interface_contracts:
    - contract_id: CTR-COORD-001
      name: "CoordinationReducer"
      type: rust_trait
      description: |
        Event-sourced reducer for coordination state projection.
        Follows established reducer patterns (SessionReducer, WorkReducer).
      interface: |
        pub struct CoordinationReducer {
            state: CoordinationState,
        }

        impl CoordinationReducer {
            pub fn new() -> Self;
            pub fn apply(&mut self, event: &EventRecord, ctx: &ReducerContext) -> Result<(), Error>;
            pub fn state(&self) -> &CoordinationState;
            pub fn checkpoint(&self) -> CoordinationCheckpoint;
            pub fn restore(checkpoint: CoordinationCheckpoint) -> Self;
        }
      stability: stable
      versioning_strategy: |
        Reducer interface follows existing patterns.
        State schema changes require migration events.

    - contract_id: CTR-COORD-002
      name: "CoordinationState"
      type: rust_struct
      description: |
        State structure maintained by CoordinationReducer.
      interface: |
        pub struct CoordinationState {
            pub coordinations: HashMap<CoordinationId, CoordinationSession>,
            pub bindings: HashMap<WorkId, BindingInfo>,
        }

        pub struct CoordinationSession {
            pub coordination_id: CoordinationId,
            pub work_queue: Vec<WorkId>,
            pub work_index: usize,
            pub budget: CoordinationBudget,
            pub budget_usage: BudgetUsage,
            pub consecutive_failures: u32,
            pub status: CoordinationStatus,
            pub started_at: Timestamp,
        }

        pub struct BindingInfo {
            pub session_id: SessionId,
            pub attempt_number: u32,
            pub bound_at: Timestamp,
        }

        pub struct CoordinationBudget {
            pub max_episodes: u32,
            pub max_duration_ms: u64,
            pub max_tokens: Option<u64>,
        }

        pub struct BudgetUsage {
            pub consumed_episodes: u32,
            pub elapsed_ms: u64,
            pub consumed_tokens: u64,
        }

        pub enum CoordinationStatus {
            Initializing,
            Running,
            Completed(StopCondition),
            Aborted(AbortReason),
        }
      stability: stable
      versioning_strategy: |
        Adding fields is backwards-compatible with serde defaults.
        Removing fields requires migration.

    - contract_id: CTR-COORD-003
      name: "Coordination Events"
      type: rust_enum
      description: |
        Event payloads for coordination state transitions.
      interface: |
        pub enum CoordinationEvent {
            Started {
                coordination_id: CoordinationId,
                work_queue: Vec<WorkId>,
                budget: CoordinationBudget,
                created_at: Timestamp,
            },
            SessionBound {
                coordination_id: CoordinationId,
                work_id: WorkId,
                session_id: SessionId,
                attempt_number: u32,
                /// Atomic check: binding only succeeds if work is still at this count.
                expected_transition_count: u32,
            },
            SessionUnbound {
                coordination_id: CoordinationId,
                work_id: WorkId,
                session_id: SessionId,
                outcome: SessionOutcome,
            },
            Completed {
                coordination_id: CoordinationId,
                stop_condition: StopCondition,
                receipt_hash: Hash,
            },
            Aborted {
                coordination_id: CoordinationId,
                reason: AbortReason,
                receipt_hash: Hash,
            },
        }

        pub enum SessionOutcome {
            Success,
            Failure(String),
            Timeout,
        }

        pub enum StopCondition {
            WorkCompleted,
            BudgetExhausted(BudgetType),
            MaxAttemptsExceeded(WorkId),
            CircuitBreakerTriggered,
        }

        pub enum AbortReason {
            UserCancelled,
            SystemError(String),
        }
      stability: stable
      versioning_strategy: |
        Events are append-only. New event types can be added.
        Existing event fields cannot be removed.

    - contract_id: CTR-COORD-004
      name: "CoordinationController"
      type: rust_struct
      description: |
        Implements serial execution loop.
      interface: |
        pub struct CoordinationController {
            ledger: Arc<Ledger>,
            work_reducer: Arc<RwLock<WorkReducer>>,
            session_reducer: Arc<RwLock<SessionReducer>>,
            cas: Arc<ContentAddressedStore>,
            /// Session spawner decoupling (AD-COORD-014).
            spawner: Arc<dyn SessionSpawner>,
        }

        impl CoordinationController {
            pub async fn start(&self, config: CoordinationConfig) -> Result<CoordinationId, Error>;
            pub async fn run_loop(&self, coordination_id: CoordinationId) -> Result<CoordinationReceipt, Error>;
            fn check_stop_condition(&self, state: &CoordinationState) -> Option<StopCondition>;
            fn check_work_freshness(&self, work_id: WorkId, expected_seq: u32) -> Result<(), Error>;
        }

        pub struct CoordinationConfig {
            pub work_ids: Vec<WorkId>,
            pub budget: CoordinationBudget,
            pub max_attempts_per_work: u32,        // Default: 3
            pub max_work_queue_size: Option<u32>,  // Default: 1000 (AD-COORD-008)
        }
      stability: stable

    - contract_id: CTR-COORD-005
      name: "SessionSpawner"
      type: rust_trait
      description: |
        Trait for decoupled session execution.
      interface: |
        #[async_trait]
        pub trait SessionSpawner: Send + Sync {
            /// Spawns a new session with the given ID and spec.
            async fn spawn(&self, session_id: SessionId, spec: SessionSpec) -> Result<(), Error>;
        }
      stability: stable


    - contract_id: CTR-COORD-006
      name: "CoordinationReceipt"
      type: rust_struct
      description: |
        Evidence artifact proving coordination execution.
      interface: |
        pub struct CoordinationReceipt {
            pub coordination_id: CoordinationId,
            pub work_outcomes: Vec<WorkOutcome>,
            pub budget_usage: BudgetUsage,
            pub budget_ceiling: CoordinationBudget,
            pub stop_condition: StopCondition,
            pub started_at: Timestamp,
            pub completed_at: Timestamp,
            pub total_sessions: u32,
            pub successful_sessions: u32,
            pub failed_sessions: u32,
        }

        pub struct WorkOutcome {
            pub work_id: WorkId,
            pub attempts: u32,
            pub final_outcome: SessionOutcome,
            pub session_ids: Vec<SessionId>,
        }
      stability: stable

    - contract_id: CTR-COORD-007
      name: "CLI Command (apm2 coordinate)"
      type: cli_command
      description: |
        Machine-readable CLI command for coordination.
      interface: |
        apm2 coordinate [OPTIONS]

        OPTIONS:
            --work-ids <ID,ID,...>    Work item IDs to process
            --work-query <FILTER>     Work query filter (alternative to --work-ids)
            --max-episodes <N>        Maximum sessions to spawn (required)
            --max-duration-ms <MS>    Maximum wall-clock time (required)
            --max-tokens <N>          Maximum tokens (optional)
            --max-attempts <N>        Max attempts per work item (default: 3)
            --max-work-queue <N>      Max work items in queue (default: 1000)
            --json                    Output as JSON (default)
            --quiet                   Suppress progress events

        EXIT CODES:
            0: Coordination completed (WORK_COMPLETED)
            1: Coordination aborted (any other stop condition)
            2: Invalid arguments
      stability: stable

  versioning_policy:
    strategy: "semantic_versioning"
    breaking_change_policy: |
      Breaking changes require RFC amendment and migration path.
      Event schema changes must be backwards-compatible (new fields with defaults).
      CLI option changes follow deprecation-before-removal pattern.
