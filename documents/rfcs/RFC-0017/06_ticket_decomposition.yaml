rfc_ticket_decomposition:
  schema_version: "2026-01-30"
  template_version: "2026-01-23"

  status: POPULATED
  notes: |
    RFC v4 (Standard phase) ticket decomposition completed via rfc-council DECOMPOSE mode.
    27 tickets generated across 9 groups following the planned_ticket_structure.
    All tickets trace to PRD-0010 requirements and leverage existing CCP components.
    Amendment A-001 (DD-009) cancels CLI migration + telemetry-gated xtask deprecation
    tickets (TCK-00270..TCK-00277) and adds a new Amendment Follow-ups group
    (TCK-00279..TCK-00284) focused on hard cutover enforcement.

  planned_ticket_structure:
    groups:
      - group_id: GRP-001
        name: "IPC Foundation"
        phase: PHASE-1
        requirements_covered:
          - REQ-DCP-0001
          - REQ-DCP-0008
        estimated_tickets:
          - title: "Implement Unix socket IPC handler with SO_PEERCRED"
            scope: "Socket setup, peer credential extraction, connection lifecycle"
          - title: "Add per-connection capability token issuance"
            scope: "Token generation, validation, session binding"
          - title: "Implement privileged endpoint handler"
            scope: "ClaimWork, SpawnEpisode, IssueCapability, Shutdown routing"
          - title: "Implement session-scoped endpoint handler"
            scope: "RequestTool, EmitEvent, PublishEvidence routing"

      - group_id: GRP-002
        name: "Work Orchestration"
        phase: PHASE-1
        requirements_covered:
          - REQ-DCP-0002
        estimated_tickets:
          - title: "Implement ClaimWork with governance policy resolution"
            scope: "Actor/role validation, governance query, capability minting"
          - title: "Implement capability manifest structure and sealing"
            scope: "Manifest schema, sealing, hash generation"
          - title: "Implement context pack sealing"
            scope: "Pack construction from policy, sealing, hash generation"

      - group_id: GRP-003
        name: "Episode Spawn"
        phase: PHASE-2
        requirements_covered:
          - REQ-DCP-0002
          - REQ-DCP-0003
          - REQ-DCP-0006
        estimated_tickets:
          - title: "Implement SpawnEpisode with PolicyResolvedForChangeSet check"
            scope: "Ledger query for policy resolution, validation"
          - title: "Add GateLeaseIssued validation for GATE_EXECUTOR"
            scope: "Lease binding validation, lease_id parameter"
          - title: "Implement SoD custody domain validation"
            scope: "Custody domain extraction, overlap detection, rejection"
          - title: "Implement ephemeral session handle generation"
            scope: "Handle generation, session registration, no credential exposure"

      - group_id: GRP-004
        name: "Tool Mediation"
        phase: PHASE-3
        requirements_covered:
          - REQ-DCP-0004
          - REQ-DCP-0005
          - REQ-DCP-0011
        estimated_tickets:
          - title: "Implement tool broker with capability validation"
            scope: "Tool allowlist check, argument validation"
          - title: "Implement context firewall with deny + terminate"
            scope: "Allowlist validation, denial event, session termination"
          - title: "Implement credential broker for GitHub operations"
            scope: "Token storage, mediated calls, no credential exposure"
          - title: "Implement credential broker for SSH operations"
            scope: "SSH agent integration, mediated git operations"

      - group_id: GRP-005
        name: "Event Signing"
        phase: PHASE-1
        requirements_covered:
          - REQ-DCP-0007
        estimated_tickets:
          - title: "Implement Ed25519 event signing with domain separation"
            scope: "Signing key management, domain prefix, signature generation"
          - title: "Add signature verification on ledger ingestion"
            scope: "Verification hook, rejection of unsigned events"

      - group_id: GRP-006
        name: "Session Lifecycle"
        phase: PHASE-3
        requirements_covered:
          - REQ-DCP-0013
        estimated_tickets:
          - title: "Implement session manager with persistent registry"
            scope: "Session tracking, state persistence, lifecycle hooks"
          - title: "Implement daemon crash recovery with LEASE_REVOKED"
            scope: "Recovery detection, signal broadcast, cleanup"

      - group_id: GRP-007
        name: "Metrics and Observability"
        phase: PHASE-4
        requirements_covered:
          - REQ-DCP-0012
        estimated_tickets:
          - title: "Add Prometheus metrics for daemon health"
            scope: "Metric registration, instrumentation, /metrics endpoint"
          - title: "Add latency benchmarks for spawn and mediation"
            scope: "Benchmark harness, REQ-0009/0010/0011 validation"

      - group_id: GRP-008
        name: "CLI Migration"
        phase: PHASE-4
        status: CANCELLED
        amendment_note: "Cancelled under DD-009 hard cutover (no CLI migration path)."
        requirements_covered: []
        estimated_tickets:
          - title: "Implement apm2 work claim command"
            scope: "CLI parsing, daemon IPC call, output formatting"
          - title: "Implement apm2 episode spawn command"
            scope: "CLI parsing, daemon IPC call, output formatting"
          - title: "Implement apm2 fac ingest command"
            scope: "CLI parsing, daemon IPC call, output formatting"
          - title: "Implement apm2 work status command"
            scope: "CLI parsing, daemon IPC call, output formatting"

      - group_id: GRP-009
        name: "xtask Deprecation"
        phase: PHASE-5
        status: CANCELLED
        amendment_note: "Cancelled under DD-009 hard cutover (telemetry gate removed)."
        requirements_covered: []
        estimated_tickets:
          - title: "Add deprecation warnings to xtask commands"
            scope: "Warning emission, migration guidance"
          - title: "Add --allow-deprecated flag"
            scope: "Flag parsing, gate logic"
          - title: "Add xtask usage telemetry"
            scope: "Telemetry emission, aggregation"
          - title: "Remove xtask crate"
            scope: "Crate deletion, Cargo.toml cleanup"

      - group_id: GRP-010
        name: "Amendment Follow-ups (DD-009 Hard Cutover)"
        phase: PHASE-1
        requirements_covered:
          - REQ-DCP-0001
          - REQ-DCP-0008
        estimated_tickets:
          - title: "ProtocolServer-only daemon entrypoint"
            scope: "Remove legacy ipc_server startup; dual sockets only"
          - title: "Config schema cutover (dual sockets only)"
            scope: "Reject legacy single-socket keys; update defaults"
          - title: "Delete legacy JSON IPC modules"
            scope: "Remove ipc_server.rs + JSON handler surface"
          - title: "CI guardrails for legacy IPC reintroduction"
            scope: "Fail builds on legacy IPC symbols/paths"
          - title: "ADV-012 legacy IPC bypass test"
            scope: "Adversarial downgrade test and evidence"
          - title: "xtask bypass closure"
            scope: "Remove direct external projection writes or hard-fail"

  dependencies_overview:
    critical_path:
      - "GRP-001 (IPC Foundation) -> GRP-002 (Work Orchestration)"
      - "GRP-001 -> GRP-005 (Event Signing)"
      - "GRP-001 -> GRP-010 (Hard Cutover Enforcement)"
      - "GRP-002 -> GRP-003 (Episode Spawn)"
      - "GRP-003 -> GRP-004 (Tool Mediation)"
      - "GRP-003 -> GRP-006 (Session Lifecycle)"
      - "GRP-004 -> GRP-007 (Metrics)"

    parallelizable:
      - "GRP-005 (Event Signing) can proceed in parallel with GRP-002, GRP-003"
      - "GRP-007 (Metrics) can proceed in parallel with GRP-006"

  # ============================================================================
  # TICKETS - Fully populated for apm2 factory tickets emit
  # ============================================================================
  tickets:
    # ==========================================================================
    # GRP-001: IPC Foundation (PHASE-1)
    # ==========================================================================
    - ticket_id: TCK-00248
      title: "Add SO_PEERCRED authentication to ProtocolServer"
      group_id: GRP-001
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0008
      depends_on: []
      files_to_modify:
        - path: "crates/apm2-daemon/src/protocol/server.rs"
          changes: |
            Add SO_PEERCRED extraction in accept() method.
            Extract peer UID/GID from UnixStream.
            Store credentials in ConnectionContext.
        - path: "crates/apm2-daemon/src/protocol/handshake.rs"
          changes: |
            Extend HandshakeState to include peer_credentials.
            Validate peer UID matches expected operator UID.
      files_to_create:
        - path: "crates/apm2-daemon/src/protocol/credentials.rs"
          purpose: "PeerCredentials struct and SO_PEERCRED extraction utilities"
      implementation_steps:
        - step: 1
          action: "Add libc dependency for SO_PEERCRED constants"
          details: |
            In apm2-daemon/Cargo.toml, add:
            libc = "0.2"
        - step: 2
          action: "Create PeerCredentials struct"
          details: |
            pub struct PeerCredentials {
                pub uid: u32,
                pub gid: u32,
                pub pid: i32,
            }
        - step: 3
          action: "Implement SO_PEERCRED extraction"
          details: |
            Use getsockopt with SOL_SOCKET and SO_PEERCRED to extract
            ucred from the Unix stream file descriptor.
        - step: 4
          action: "Integrate into ProtocolServer::accept()"
          details: |
            After accepting connection, extract peer credentials and
            store in ConnectionContext for downstream authorization.
      acceptance_criteria:
        - criterion: "SO_PEERCRED extracts valid UID/GID/PID from Unix socket"
          verification: "Unit test with mock Unix stream validates extraction"
        - criterion: "Connections without valid peer credentials are rejected"
          verification: "Integration test verifies rejection before handshake"
        - criterion: "Peer credentials available in ConnectionContext"
          verification: "Handler can access peer_credentials field"
      test_requirements:
        - test_id: UT-IPC-001
          description: "Peer credential extraction"
          verification_command: "cargo test -p apm2-daemon peer_creds"
      adversarial_tests:
        - ADV-009

    - ticket_id: TCK-00249
      title: "Implement dual-socket topology for privilege separation"
      group_id: GRP-001
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0001
        - REQ-DCP-0008
      depends_on:
        - TCK-00248
      files_to_modify:
        - path: "crates/apm2-daemon/src/protocol/server.rs"
          changes: |
            Create two listener sockets: operator.sock and session.sock.
            Route connections based on socket path.
        - path: "crates/apm2-daemon/src/main.rs"
          changes: |
            Configure socket paths from config.
            Set permissions: operator.sock (0600), session.sock (0660).
      files_to_create:
        - path: "crates/apm2-daemon/src/protocol/socket_manager.rs"
          purpose: "Manage dual-socket lifecycle and routing"
      implementation_steps:
        - step: 1
          action: "Define SocketManager struct"
          details: |
            pub struct SocketManager {
                operator_listener: UnixListener,
                session_listener: UnixListener,
            }
        - step: 2
          action: "Implement socket creation with permissions"
          details: |
            Create operator.sock with mode 0600 (owner only).
            Create session.sock with mode 0660 (owner + group).
            Use tokio-uds for async Unix socket handling.
        - step: 3
          action: "Route incoming connections"
          details: |
            Connections on operator_listener get is_privileged=true.
            Connections on session_listener get is_privileged=false.
        - step: 4
          action: "Update config for socket paths"
          details: |
            Add to ecosystem.toml:
            [daemon]
            operator_socket = "$XDG_RUNTIME_DIR/apm2/operator.sock"
            session_socket = "$XDG_RUNTIME_DIR/apm2/session.sock"
      acceptance_criteria:
        - criterion: "Two sockets created with correct permissions"
          verification: "stat shows 0600 for operator, 0660 for session"
        - criterion: "Connections routed based on socket path"
          verification: "Integration test connects to each socket, verifies routing"
        - criterion: "Session socket not in privileged handler namespace"
          verification: "Attempt to call ClaimWork from session socket fails"
      test_requirements:
        - test_id: UT-IPC-002
          description: "Dual socket routing"
          verification_command: "cargo test -p apm2-daemon socket_routing"
      adversarial_tests:
        - ADV-001
        - ADV-002

    - ticket_id: TCK-00250
      title: "Add per-connection session token issuance"
      group_id: GRP-001
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0008
      depends_on:
        - TCK-00248
      files_to_modify:
        - path: "crates/apm2-daemon/src/protocol/handshake.rs"
          changes: |
            After successful handshake, mint session token.
            Token binds (session_id, lease_id, spawn_time).
      files_to_create:
        - path: "crates/apm2-daemon/src/protocol/session_token.rs"
          purpose: "Session token generation and validation"
      implementation_steps:
        - step: 1
          action: "Define SessionToken struct"
          details: |
            pub struct SessionToken {
                session_id: SessionId,
                lease_id: LeaseId,
                spawn_time: SystemTime,
                mac: [u8; 32],
            }
        - step: 2
          action: "Implement token generation"
          details: |
            Token = HMAC-SHA256(daemon_secret, session_id || lease_id || spawn_time)
            Use ring or hmac crate for HMAC computation.
        - step: 3
          action: "Implement token validation"
          details: |
            On each session-scoped request:
            1. Verify HMAC
            2. Check session_id in active registry
            3. Verify lease not revoked
        - step: 4
          action: "Add TTL matching lease expiration"
          details: |
            Token expires when lease expires.
            Validation rejects expired tokens.
      acceptance_criteria:
        - criterion: "Tokens are unique per session"
          verification: "Two sessions get different tokens"
        - criterion: "Token validation rejects tampering"
          verification: "Modified token bytes rejected"
        - criterion: "Expired tokens rejected"
          verification: "Token past TTL returns EXPIRED error"
      test_requirements:
        - test_id: UT-IPC-003
          description: "Session token generation and validation"
          verification_command: "cargo test -p apm2-daemon session_token"

    - ticket_id: TCK-00251
      title: "Implement privileged endpoint dispatcher"
      group_id: GRP-001
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0001
      depends_on:
        - TCK-00249
        - TCK-00250
      files_to_modify:
        - path: "crates/apm2-daemon/src/protocol/messages.rs"
          changes: |
            Add ClaimWork, SpawnEpisode, IssueCapability, Shutdown message types.
        - path: "proto/apm2d_runtime_v1.proto"
          changes: |
            Add protobuf message definitions for privileged endpoints.
        - path: "crates/apm2-daemon/src/handlers.rs"
          changes: |
            Add privileged endpoint dispatch logic and handler stubs.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define privileged message types in proto"
          details: |
            message ClaimWorkRequest {
              string actor_id = 1;
              string role = 2;
              bytes credential_signature = 3;
            }
            message ClaimWorkResponse { ... }
            // Similar for SpawnEpisode, IssueCapability, Shutdown
        - step: 2
          action: "Implement dispatcher routing"
          details: |
            Match on message type, route to handler.
            Verify is_privileged=true before routing.
            Return PERMISSION_DENIED for session connections.
        - step: 3
          action: "Add stub handlers"
          details: |
            Each handler validates inputs and returns placeholder response.
            Full implementation in subsequent tickets.
      acceptance_criteria:
        - criterion: "Privileged messages only accepted on operator socket"
          verification: "Session socket returns PERMISSION_DENIED"
        - criterion: "All 4 privileged endpoints routed correctly"
          verification: "Integration test calls each endpoint"
      test_requirements:
        - test_id: INT-001
          description: "Privileged endpoint routing"
          verification_command: "cargo test -p apm2-daemon privileged_routing"
      adversarial_tests:
        - ADV-001
        - ADV-002
        - ADV-005

    - ticket_id: TCK-00252
      title: "Implement session-scoped endpoint dispatcher"
      group_id: GRP-001
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0001
      depends_on:
        - TCK-00250
      files_to_modify:
        - path: "crates/apm2-daemon/src/protocol/messages.rs"
          changes: |
            Add RequestTool, EmitEvent, PublishEvidence, StreamTelemetry types.
        - path: "proto/apm2d_runtime_v1.proto"
          changes: |
            Add protobuf message definitions for session-scoped endpoints.
        - path: "crates/apm2-daemon/src/handlers.rs"
          changes: |
            Add session-scoped endpoint dispatch logic and handler stubs.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define session-scoped message types in proto"
          details: |
            message RequestToolRequest {
              string tool_id = 1;
              bytes arguments = 2;
              string dedupe_key = 3;
            }
            message RequestToolResponse { ... }
            // Similar for EmitEvent, PublishEvidence, StreamTelemetry
        - step: 2
          action: "Implement dispatcher routing"
          details: |
            Validate session_token on every request.
            Route to appropriate handler.
            Return SESSION_INVALID for bad tokens.
        - step: 3
          action: "Add stub handlers"
          details: |
            Each handler validates session_id and returns placeholder.
            Full implementation in GRP-004 (Tool Mediation).
      acceptance_criteria:
        - criterion: "Session endpoints require valid session_token"
          verification: "Invalid token returns SESSION_INVALID"
        - criterion: "All 4 session endpoints routed correctly"
          verification: "Integration test calls each endpoint"
      test_requirements:
        - test_id: INT-002
          description: "Session endpoint routing"
          verification_command: "cargo test -p apm2-daemon session_routing"

    # ==========================================================================
    # GRP-002: Work Orchestration (PHASE-1)
    # ==========================================================================
    - ticket_id: TCK-00253
      title: "Implement ClaimWork handler with policy resolution"
      group_id: GRP-002
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0002
      depends_on:
        - TCK-00251
      files_to_modify:
        - path: "crates/apm2-daemon/src/handlers.rs"
          changes: |
            Implement ClaimWork handler logic.
            Query governance for policy resolution.
            Mint capability manifest.
        - path: "crates/apm2-daemon/src/episode/capability.rs"
          changes: |
            Wire PolicyEngine into capability minting.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Validate actor_id from credential"
          details: |
            Derive authoritative actor_id from credential signature.
            User-supplied actor_id is display hint only.
            Prevent impersonation via credential binding.
        - step: 2
          action: "Query PolicyEngine for policy resolution"
          details: |
            Call PolicyEngine::evaluate() with (actor_id, role, work_context).
            Receive PolicyResolvedForChangeSet reference.
        - step: 3
          action: "Mint capability manifest"
          details: |
            Based on policy resolution, construct CapabilityManifest:
            - tool_allowlist from policy
            - read_allowlist from ContextPack
            - budget from policy
        - step: 4
          action: "Emit WorkClaimed event"
          details: |
            Sign event with domain prefix "apm2.event.work_claimed:".
            Persist to ledger.
      acceptance_criteria:
        - criterion: "actor_id derived from credential, not user input"
          verification: "ADV-005 test passes"
        - criterion: "PolicyResolvedForChangeSet required for claim"
          verification: "Claim without policy resolution fails"
        - criterion: "WorkClaimed event signed and persisted"
          verification: "Ledger query returns signed event"
      test_requirements:
        - test_id: UT-WORK-001
          description: "ClaimWork policy resolution"
          verification_command: "cargo test -p apm2-daemon claim_work"
      adversarial_tests:
        - ADV-005

    - ticket_id: TCK-00254
      title: "Extend CapabilityManifest with tool and path allowlists"
      group_id: GRP-002
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0002
      depends_on:
        - TCK-00253
      files_to_modify:
        - path: "crates/apm2-daemon/src/episode/capability.rs"
          changes: |
            Extend CapabilityManifest struct with:
            - tool_allowlist: Vec<ToolClass>
            - write_allowlist: Vec<PathBuf>
            - shell_allowlist: Vec<String>
        - path: "crates/apm2-core/src/context/manifest.rs"
          changes: |
            Extend ContextPackManifest with tool_allowlist field.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Add tool_allowlist to CapabilityManifest"
          details: |
            pub struct CapabilityManifest {
                pub tool_allowlist: Vec<ToolClass>,
                pub read_allowlist: Vec<PathPattern>,
                pub write_allowlist: Vec<PathPattern>,
                pub shell_allowlist: Vec<ShellPattern>,
                pub budget: EpisodeBudget,
                pub dedupe_scope: String,
            }
        - step: 2
          action: "Implement manifest sealing"
          details: |
            Hash manifest content with Blake3.
            Store hash for validation during tool mediation.
        - step: 3
          action: "Wire manifest into SpawnEpisode flow"
          details: |
            Manifest created at ClaimWork, passed to SpawnEpisode.
            Session receives manifest_hash, not full manifest.
      acceptance_criteria:
        - criterion: "Manifest contains tool and path allowlists"
          verification: "Serialized manifest has all fields"
        - criterion: "Manifest hash is deterministic"
          verification: "Same inputs produce same hash"
      test_requirements:
        - test_id: UT-WORK-002
          description: "Capability manifest sealing"
          verification_command: "cargo test -p apm2-daemon capability_manifest"

    - ticket_id: TCK-00255
      title: "Implement ContextPack sealing with hash verification"
      group_id: GRP-002
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0002
      depends_on:
        - TCK-00254
      files_to_modify:
        - path: "crates/apm2-core/src/context/manifest.rs"
          changes: |
            Add seal() method to ContextPackManifest.
            Generate content hash over all entries.
        - path: "crates/apm2-daemon/src/handlers.rs"
          changes: |
            Call context_pack.seal() in ClaimWork flow.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Implement ContextPackManifest::seal()"
          details: |
            Sort entries by path for determinism.
            Hash all (path, content_hash, access_level) tuples.
            Return SealedContextPack with manifest_hash.
        - step: 2
          action: "Store sealed pack hash in work assignment"
          details: |
            WorkAssignment includes context_pack_hash.
            SpawnEpisode validates hash before proceeding.
      acceptance_criteria:
        - criterion: "Context pack hash is deterministic"
          verification: "Same entries produce same hash"
        - criterion: "Modification after sealing detected"
          verification: "Hash mismatch causes rejection"
      test_requirements:
        - test_id: UT-WORK-003
          description: "Context pack sealing"
          verification_command: "cargo test -p apm2-core context_pack_seal"

    # ==========================================================================
    # GRP-003: Episode Spawn (PHASE-2)
    # ==========================================================================
    - ticket_id: TCK-00256
      title: "Implement SpawnEpisode with PolicyResolvedForChangeSet check"
      group_id: GRP-003
      phase: PHASE-2
      requirement_ids:
        - REQ-DCP-0002
      depends_on:
        - TCK-00253
        - TCK-00255
      files_to_modify:
        - path: "crates/apm2-daemon/src/handlers.rs"
          changes: |
            Implement SpawnEpisode handler.
            Query ledger for PolicyResolvedForChangeSet.
            Reject spawn if policy resolution missing.
        - path: "crates/apm2-daemon/src/episode/runtime.rs"
          changes: |
            Add policy precondition validation to episode spawn flow.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Query ledger for PolicyResolvedForChangeSet"
          details: |
            SELECT * FROM events
            WHERE event_type = 'PolicyResolvedForChangeSet'
            AND work_id = ?
            ORDER BY timestamp DESC LIMIT 1
        - step: 2
          action: "Validate policy resolution exists"
          details: |
            If no PolicyResolvedForChangeSet found, return
            POLICY_RESOLUTION_MISSING error.
        - step: 3
          action: "Create episode with validated policy"
          details: |
            Pass policy_resolved_ref to EpisodeRuntime.
            Episode inherits policy constraints.
      acceptance_criteria:
        - criterion: "Spawn without policy resolution fails"
          verification: "ADV-004 test variant passes"
        - criterion: "Valid policy resolution allows spawn"
          verification: "Integration test with policy event succeeds"
      test_requirements:
        - test_id: UT-SPAWN-001
          description: "Policy resolution check"
          verification_command: "cargo test -p apm2-daemon spawn_policy"

    - ticket_id: TCK-00257
      title: "Add GateLeaseIssued validation for GATE_EXECUTOR spawn"
      group_id: GRP-003
      phase: PHASE-2
      requirement_ids:
        - REQ-DCP-0003
      depends_on:
        - TCK-00256
      files_to_modify:
        - path: "crates/apm2-daemon/src/episode/runtime.rs"
          changes: |
            Add lease validation for GATE_EXECUTOR role.
            Query ledger for GateLeaseIssued matching work_id, gate_id.
        - path: "crates/apm2-daemon/src/handlers.rs"
          changes: |
            Pass lease_id to spawn logic when role=GATE_EXECUTOR.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Check role for lease requirement"
          details: |
            if role == Role::GateExecutor {
                validate_gate_lease(work_id, gate_id, lease_id)?;
            }
        - step: 2
          action: "Query ledger for GateLeaseIssued"
          details: |
            Find GateLeaseIssued where:
            - work_id matches
            - gate_id matches
            - changeset_digest matches
            - executor_actor_id matches spawn request
        - step: 3
          action: "Reject on lease mismatch"
          details: |
            Return GATE_LEASE_MISSING if:
            - No matching lease found
            - Lease expired
            - Lease revoked
      acceptance_criteria:
        - criterion: "GATE_EXECUTOR spawn requires valid lease"
          verification: "ADV-004 passes"
        - criterion: "Non-GATE_EXECUTOR spawn doesn't require lease"
          verification: "IMPLEMENTER spawn without lease succeeds"
      test_requirements:
        - test_id: UT-SPAWN-002
          description: "Lease validation"
          verification_command: "cargo test -p apm2-daemon gate_lease"
      adversarial_tests:
        - ADV-004

    - ticket_id: TCK-00258
      title: "Implement SoD custody domain validation at spawn"
      group_id: GRP-003
      phase: PHASE-2
      requirement_ids:
        - REQ-DCP-0006
      depends_on:
        - TCK-00257
      files_to_modify:
        - path: "crates/apm2-daemon/src/episode/runtime.rs"
          changes: |
            Add custody domain overlap detection.
            Reject spawn if executor domain overlaps author domains.
        - path: "crates/apm2-daemon/src/episode/capability.rs"
          changes: |
            Add custody domain extraction helpers.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Extract author custody domains from changeset"
          details: |
            Query changeset for author actor_ids.
            Map actor_ids to custody domains.
        - step: 2
          action: "Extract executor custody domain"
          details: |
            Map executor_actor_id to custody domain.
        - step: 3
          action: "Check for domain overlap"
          details: |
            if author_domains.intersection(&executor_domain).is_empty() {
                // OK - no overlap
            } else {
                return Err(SpawnError::SodViolation { ... });
            }
        - step: 4
          action: "Emit LeaseIssueDenied event on violation"
          details: |
            Event includes reason=SOD_VIOLATION and diagnostic info.
      acceptance_criteria:
        - criterion: "Overlapping custody domains rejected"
          verification: "ADV-006 passes"
        - criterion: "Non-overlapping domains allowed"
          verification: "Different custody domains spawn succeeds"
        - criterion: "LeaseIssueDenied event emitted"
          verification: "Ledger contains diagnostic event"
      test_requirements:
        - test_id: UT-SPAWN-003
          description: "SoD domain check"
          verification_command: "cargo test -p apm2-daemon sod_custody"
      adversarial_tests:
        - ADV-006

    - ticket_id: TCK-00259
      title: "Implement ephemeral session handle generation"
      group_id: GRP-003
      phase: PHASE-2
      requirement_ids:
        - REQ-DCP-0004
      depends_on:
        - TCK-00256
      files_to_modify:
        - path: "crates/apm2-daemon/src/episode/runtime.rs"
          changes: |
            Generate ephemeral handle for session.
            Register session without exposing credentials.
        - path: "crates/apm2-daemon/src/session/mod.rs"
          changes: |
            Add session registration with ephemeral handle.
        - path: "crates/apm2-daemon/src/episode/registry.rs"
          changes: |
            Add session registry for tracking active sessions.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Generate ephemeral handle"
          details: |
            handle = random_bytes(32).to_hex()
            Handle is opaque identifier, not credential.
        - step: 2
          action: "Register session in registry"
          details: |
            SessionRegistry::register(session_id, Session {
                handle,
                work_id,
                lease_id,
                capability_manifest_hash,
                spawn_time,
            })
        - step: 3
          action: "Return handle in EpisodeSpawned response"
          details: |
            Response contains ephemeral_handle, not credentials.
            Session uses handle for identification only.
      acceptance_criteria:
        - criterion: "Handle does not contain credentials"
          verification: "Decode handle, verify no secrets"
        - criterion: "Session registered with metadata"
          verification: "Registry contains session entry"
      test_requirements:
        - test_id: INT-002
          description: "Full episode spawn flow"
          verification_command: "cargo test -p apm2-daemon episode_spawn_integration"

    # ==========================================================================
    # GRP-004: Tool Mediation (PHASE-3)
    # ==========================================================================
    - ticket_id: TCK-00260
      title: "Implement tool broker with capability manifest validation"
      group_id: GRP-004
      phase: PHASE-3
      requirement_ids:
        - REQ-DCP-0011
      depends_on:
        - TCK-00252
        - TCK-00254
      files_to_modify:
        - path: "crates/apm2-daemon/src/handlers.rs"
          changes: |
            Implement RequestTool handler.
            Validate tool_id against capability manifest.
        - path: "crates/apm2-daemon/src/session/consume.rs"
          changes: |
            Extend validate_tool_request for manifest validation.
        - path: "crates/apm2-daemon/src/episode/broker.rs"
          changes: |
            Add capability manifest validation to tool broker.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Load capability manifest for session"
          details: |
            let manifest = session_registry.get_manifest(session_id)?;
        - step: 2
          action: "Validate tool_id against tool_allowlist"
          details: |
            if !manifest.tool_allowlist.contains(&tool_class) {
                return Err(BrokerError::ToolNotAllowed { tool_id });
            }
        - step: 3
          action: "Validate arguments against path allowlists"
          details: |
            For FileRead: check path in read_allowlist.
            For FileWrite: check path in write_allowlist.
            For ShellExec: check command in shell_allowlist.
        - step: 4
          action: "Emit ToolDecided event"
          details: |
            Sign and emit ToolDecided with decision=ALLOW or DENY.
      acceptance_criteria:
        - criterion: "Tool not in allowlist rejected"
          verification: "Request for unlisted tool returns TOOL_NOT_ALLOWED"
        - criterion: "Validation overhead <5ms p50"
          verification: "Benchmark BENCH-003 passes"
      test_requirements:
        - test_id: UT-TOOL-001
          description: "Tool allowlist validation"
          verification_command: "cargo test -p apm2-daemon tool_broker"
        - test_id: BENCH-003
          description: "Tool mediation overhead"
          verification_command: "cargo bench -p apm2-daemon tool_mediation"

    - ticket_id: TCK-00261
      title: "Implement context firewall with deny + terminate semantics"
      group_id: GRP-004
      phase: PHASE-3
      requirement_ids:
        - REQ-DCP-0005
      depends_on:
        - TCK-00260
      files_to_modify:
        - path: "crates/apm2-daemon/src/episode/broker.rs"
          changes: |
            Add context firewall enforcement.
            Terminate session on violation.
        - path: "crates/apm2-daemon/src/session/consume.rs"
          changes: |
            Add terminate_session() method and firewall violation handling.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Detect context firewall violation"
          details: |
            if !context_pack.allows_read(&path) {
                firewall_violation = true;
            }
        - step: 2
          action: "Emit ToolDecided=DENY immediately"
          details: |
            emit_tool_decided(session_id, tool_id, Decision::Deny, rule_id);
        - step: 3
          action: "Terminate session"
          details: |
            session_registry.terminate(session_id, Rationale::ContextFirewallViolation);
            Send SIGTERM to session process.
        - step: 4
          action: "Emit SessionTerminated event"
          details: |
            Sign and emit SessionTerminated with rationale.
      acceptance_criteria:
        - criterion: "Reads outside allowlist trigger termination"
          verification: "ADV-003 passes"
        - criterion: "No requests processed after DENY"
          verification: "ADV-010 passes"
        - criterion: "SessionTerminated event emitted"
          verification: "Ledger contains termination event"
      test_requirements:
        - test_id: UT-TOOL-002
          description: "Context firewall deny"
          verification_command: "cargo test -p apm2-daemon context_firewall"
        - test_id: INT-004
          description: "Context firewall violation flow"
          verification_command: "cargo test -p apm2-daemon firewall_integration"
      adversarial_tests:
        - ADV-003
        - ADV-010

    - ticket_id: TCK-00262
      title: "Implement credential broker for GitHub operations"
      group_id: GRP-004
      phase: PHASE-3
      requirement_ids:
        - REQ-DCP-0004
      depends_on:
        - TCK-00260
      files_to_modify:
        - path: "crates/apm2-daemon/src/episode/broker.rs"
          changes: |
            Add credential broker for authenticated GitHub operations.
            Mediate GitHub token access via broker pattern.
        - path: "crates/apm2-daemon/src/evidence/keychain.rs"
          changes: |
            Add GitHub token retrieval for broker mediation.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Load GitHub token in daemon scope"
          details: |
            Token loaded from keychain at daemon startup.
            Never exposed to session processes.
        - step: 2
          action: "Implement mediated GitHub operations"
          details: |
            Session requests GitOp(operation, args).
            Broker executes with token in env.
            Result returned to session.
        - step: 3
          action: "Sanitize environment for sessions"
          details: |
            Session spawn removes: GITHUB_TOKEN, GH_TOKEN.
      acceptance_criteria:
        - criterion: "Sessions cannot access GitHub token directly"
          verification: "ADV-011 passes"
        - criterion: "GitHub operations work through broker"
          verification: "Integration test with GitHub API succeeds"
      test_requirements:
        - test_id: INT-003
          description: "GitHub broker mediation"
          verification_command: "cargo test -p apm2-daemon github_broker"
      adversarial_tests:
        - ADV-011

    - ticket_id: TCK-00263
      title: "Implement credential broker for SSH operations"
      group_id: GRP-004
      phase: PHASE-3
      requirement_ids:
        - REQ-DCP-0004
      depends_on:
        - TCK-00260
      files_to_modify:
        - path: "crates/apm2-daemon/src/episode/broker.rs"
          changes: |
            Add SSH credential broker with agent mediation.
            Manage SSH_AUTH_SOCK in daemon scope.
        - path: "crates/apm2-daemon/src/evidence/keychain.rs"
          changes: |
            Add SSH agent management for broker mediation.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Manage SSH agent in daemon scope"
          details: |
            Daemon holds SSH_AUTH_SOCK reference.
            Start internal ssh-agent if needed.
        - step: 2
          action: "Implement mediated git SSH operations"
          details: |
            Session requests GitOp with SSH remote.
            Broker sets SSH_AUTH_SOCK in subprocess env.
            Executes git command, returns result.
        - step: 3
          action: "Block direct SSH key access"
          details: |
            Context firewall blocks ~/.ssh/ reads.
            SSH_AUTH_SOCK not in session env.
      acceptance_criteria:
        - criterion: "Sessions cannot access SSH keys directly"
          verification: "ADV-011 SSH variant passes"
        - criterion: "Git SSH operations work through broker"
          verification: "Integration test with git clone succeeds"
      test_requirements:
        - test_id: INT-003
          description: "SSH broker mediation"
          verification_command: "cargo test -p apm2-daemon ssh_broker"
      adversarial_tests:
        - ADV-011

    # ==========================================================================
    # GRP-005: Event Signing (PHASE-1)
    # ==========================================================================
    - ticket_id: TCK-00264
      title: "Extend Canonicalize trait for RFC-0017 kernel events"
      group_id: GRP-005
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0007
      depends_on: []
      files_to_modify:
        - path: "crates/apm2-core/src/events/canonical.rs"
          changes: |
            Implement Canonicalize for:
            - WorkClaimed
            - EpisodeSpawned
            - ToolDecided
            - ToolExecuted
            - SessionTerminated
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define event structs"
          details: |
            pub struct WorkClaimed {
                pub work_id: WorkId,
                pub actor_id: ActorId,
                pub role: Role,
                pub capability_manifest_hash: String,
                pub policy_resolved_ref: String,
                pub timestamp: SystemTime,
            }
            // Similar for other events
        - step: 2
          action: "Implement Canonicalize trait"
          details: |
            impl Canonicalize for WorkClaimed {
                fn canonical_bytes(&self) -> Vec<u8> {
                    // Deterministic serialization
                }
            }
        - step: 3
          action: "Add domain separation prefixes"
          details: |
            const WORK_CLAIMED_PREFIX: &[u8] = b"apm2.event.work_claimed:";
            // Prepend prefix before signing
        - step: 4
          action: "Add golden test vectors"
          details: |
            Add tests in tests/canonical_golden_vectors.rs
            for each new event type.
      acceptance_criteria:
        - criterion: "Canonical bytes deterministic across runs"
          verification: "Golden vector tests pass"
        - criterion: "Domain prefixes prevent cross-context replay"
          verification: "Signature from one event type invalid for another"
      test_requirements:
        - test_id: UT-SIGN-001
          description: "Event signing"
          verification_command: "cargo test -p apm2-core canonical_golden"

    - ticket_id: TCK-00265
      title: "Implement signature verification on ledger ingestion"
      group_id: GRP-005
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0007
      depends_on:
        - TCK-00264
      files_to_modify:
        - path: "crates/apm2-core/src/ledger/storage.rs"
          changes: |
            Add signature verification on event ingestion.
            Reject unsigned events.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Add signature field to EventRecord"
          details: |
            pub struct EventRecord {
                // existing fields...
                pub signature: Option<Signature>,
            }
        - step: 2
          action: "Implement verification on insert"
          details: |
            fn insert_event(&self, event: EventRecord) -> Result<()> {
                if let Some(sig) = &event.signature {
                    verify_signature(&event.canonical_bytes(), sig)?;
                } else {
                    return Err(LedgerError::UnsignedEvent);
                }
                // proceed with insert
            }
        - step: 3
          action: "Add verification key management"
          details: |
            Ledger stores trusted signing key fingerprints.
            Verification uses matching key.
      acceptance_criteria:
        - criterion: "Unsigned events rejected"
          verification: "ADV-007 passes"
        - criterion: "Invalid signatures rejected"
          verification: "Tampered event rejected"
      test_requirements:
        - test_id: UT-SIGN-002
          description: "Signature verification"
          verification_command: "cargo test -p apm2-core ledger_sig_verify"
      adversarial_tests:
        - ADV-007

    # ==========================================================================
    # GRP-006: Session Lifecycle (PHASE-3)
    # ==========================================================================
    - ticket_id: TCK-00266
      title: "Implement session registry with persistent state file"
      group_id: GRP-006
      phase: PHASE-3
      requirement_ids:
        - REQ-DCP-0013
      depends_on:
        - TCK-00259
      files_to_modify:
        - path: "crates/apm2-daemon/src/episode/registry.rs"
          changes: |
            Add persistent state file for crash recovery.
            Atomic writes (write-to-temp + rename).
        - path: "ecosystem.example.toml"
          changes: |
            Wire state_file config option.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Implement state file format"
          details: |
            JSON file: { sessions: { session_id: { pid, work_id, lease_id, spawn_time } } }
        - step: 2
          action: "Write on session create/destroy"
          details: |
            Synchronous atomic write after registry mutation.
            write_to_temp() + rename() for atomicity.
        - step: 3
          action: "Load on daemon startup"
          details: |
            Read state file if exists.
            Mark all sessions as pending recovery.
      acceptance_criteria:
        - criterion: "State file contains active sessions"
          verification: "cat state_file shows session entries"
        - criterion: "State survives daemon restart"
          verification: "Restart preserves session knowledge"
      test_requirements:
        - test_id: UT-SESS-001
          description: "Session registry persistence"
          verification_command: "cargo test -p apm2-daemon session_persistence"

    - ticket_id: TCK-00267
      title: "Implement LEASE_REVOKED signal and crash recovery"
      group_id: GRP-006
      phase: PHASE-3
      requirement_ids:
        - REQ-DCP-0013
      depends_on:
        - TCK-00266
      files_to_modify:
        - path: "proto/apm2d_runtime_v1.proto"
          changes: |
            Add LeaseRevoked message type.
        - path: "crates/apm2-daemon/src/main.rs"
          changes: |
            Add recovery loop on startup.
        - path: "crates/apm2-daemon/src/episode/registry.rs"
          changes: |
            Add crash recovery logic for session restoration.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define LeaseRevoked message"
          details: |
            message LeaseRevoked {
              string session_id = 1;
              string reason = 2;
            }
        - step: 2
          action: "Implement recovery loop"
          details: |
            On startup:
            1. Load state file
            2. For each session: send LeaseRevoked
            3. Wait up to 5s for acknowledgment
            4. SIGKILL any remaining processes
        - step: 3
          action: "Implement session client handler"
          details: |
            On receiving LeaseRevoked:
            1. Log termination reason
            2. Cleanup resources
            3. Exit gracefully (exit 0)
        - step: 4
          action: "Emit SessionTerminated events"
          details: |
            rationale = DAEMON_RESTART for recovered sessions.
      acceptance_criteria:
        - criterion: "Sessions receive LEASE_REVOKED within 5s"
          verification: "Integration test measures timing"
        - criterion: "No orphaned processes after recovery"
          verification: "ps shows no session processes after recovery"
      test_requirements:
        - test_id: UT-SESS-002
          description: "LEASE_REVOKED signal"
          verification_command: "cargo test -p apm2-daemon lease_revoked"
        - test_id: INT-005
          description: "Daemon crash recovery flow"
          verification_command: "cargo test -p apm2-daemon crash_recovery_integration"

    # ==========================================================================
    # GRP-007: Metrics and Observability (PHASE-4)
    # ==========================================================================
    - ticket_id: TCK-00268
      title: "Add Prometheus metrics for daemon health"
      group_id: GRP-007
      phase: PHASE-4
      requirement_ids:
        - REQ-DCP-0012
      depends_on:
        - TCK-00260
        - TCK-00267
      files_to_modify:
        - path: "crates/apm2-daemon/src/main.rs"
          changes: |
            Add /metrics HTTP endpoint.
            Initialize metrics registry.
      files_to_create:
        - path: "crates/apm2-daemon/src/metrics.rs"
          purpose: "Prometheus metrics definitions"
      implementation_steps:
        - step: 1
          action: "Define metrics"
          details: |
            - apm2_daemon_sessions_active (gauge)
            - apm2_daemon_tool_mediation_latency_seconds (histogram)
            - apm2_daemon_ipc_requests_total (counter)
            - apm2_daemon_capability_grants_total (counter)
            - apm2_daemon_context_firewall_denials_total (counter)
            - apm2_daemon_session_terminations_total (counter)
        - step: 2
          action: "Instrument code paths"
          details: |
            Increment counters in handlers.
            Record latency histograms in broker.
        - step: 3
          action: "Expose /metrics endpoint"
          details: |
            Use prometheus crate to export metrics.
            HTTP server on configurable port (default 9100).
      acceptance_criteria:
        - criterion: "All REQ-0012 metrics exposed"
          verification: "curl /metrics shows all 6 metric families"
        - criterion: "Metrics update on events"
          verification: "Session spawn increments active gauge"
      test_requirements:
        - test_id: EVID-RFC-0017-005
          description: "Metrics endpoint verification"
          verification_command: "curl http://localhost:9100/metrics | grep apm2_daemon"

    - ticket_id: TCK-00269
      title: "Add latency benchmarks for spawn and mediation"
      group_id: GRP-007
      phase: PHASE-4
      requirement_ids:
        - REQ-DCP-0009
        - REQ-DCP-0010
        - REQ-DCP-0011
      depends_on:
        - TCK-00256
        - TCK-00260
      files_to_modify: []
      files_to_create:
        - path: "crates/apm2-daemon/benches/latency_benchmarks.rs"
          purpose: "Benchmark harness for latency requirements"
      implementation_steps:
        - step: 1
          action: "Implement spawn_ack_latency benchmark"
          details: |
            Warm daemon, local socket.
            1000 iterations.
            Measure time from SpawnEpisode to session_id return.
            Assert p99 < 100ms.
        - step: 2
          action: "Implement session_ready_latency benchmark"
          details: |
            100 iterations.
            Measure time from SpawnEpisode to sandbox_ready.
            Assert p99 < 2s.
        - step: 3
          action: "Implement tool_mediation_overhead benchmark"
          details: |
            10000 tool requests with no-op tool.
            Measure validation time only.
            Assert p50 < 5ms.
      acceptance_criteria:
        - criterion: "spawn_ack_latency <100ms p99"
          verification: "BENCH-001 passes"
        - criterion: "session_ready_latency <2s p99"
          verification: "BENCH-002 passes"
        - criterion: "tool_mediation_overhead <5ms p50"
          verification: "BENCH-003 passes"
      test_requirements:
        - test_id: BENCH-001
          description: "Spawn acknowledgment latency"
          verification_command: "cargo bench -p apm2-daemon spawn_ack"
        - test_id: BENCH-002
          description: "Session ready latency"
          verification_command: "cargo bench -p apm2-daemon session_ready"
        - test_id: BENCH-003
          description: "Tool mediation overhead"
          verification_command: "cargo bench -p apm2-daemon tool_mediation"

    # ==========================================================================
    # GRP-008: CLI Migration (PHASE-4)
    # ==========================================================================
    - ticket_id: TCK-00270
      title: "Implement apm2 work claim command"
      group_id: GRP-008
      phase: PHASE-4
      requirement_ids: []
      depends_on:
        - TCK-00253
      files_to_modify:
        - path: "crates/apm2-cli/src/main.rs"
          changes: |
            Add work subcommand with claim action.
        - path: "crates/apm2-cli/src/client/daemon.rs"
          changes: |
            Add ClaimWork IPC call.
        - path: "crates/apm2-cli/src/commands/mod.rs"
          changes: |
            Register work command module.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define CLI interface"
          details: |
            apm2 work claim --role=<implementer|gate_executor|reviewer>
        - step: 2
          action: "Connect to daemon IPC"
          details: |
            Connect to operator.sock.
            Send ClaimWork request.
        - step: 3
          action: "Format output"
          details: |
            Display work_id, lease_id, capability_manifest_hash.
            Include migration hint from xtask.
      acceptance_criteria:
        - criterion: "Command connects to daemon"
          verification: "apm2 work claim succeeds with running daemon"
        - criterion: "Output matches xtask equivalent"
          verification: "Compare with cargo xtask work claim"

    - ticket_id: TCK-00271
      title: "Implement apm2 episode spawn command"
      group_id: GRP-008
      phase: PHASE-4
      requirement_ids: []
      depends_on:
        - TCK-00256
        - TCK-00270
      files_to_modify:
        - path: "crates/apm2-cli/src/commands/episode.rs"
          changes: |
            Add episode spawn subcommand using daemon IPC.
        - path: "crates/apm2-cli/src/client/daemon.rs"
          changes: |
            Add SpawnEpisode IPC call.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define CLI interface"
          details: |
            apm2 episode spawn --work-id=<ID> --role=<ROLE> [--lease-id=<ID>]
        - step: 2
          action: "Send SpawnEpisode request"
          details: |
            Include lease_id if role=GATE_EXECUTOR.
        - step: 3
          action: "Format output"
          details: |
            Display session_id, ephemeral_handle.
      acceptance_criteria:
        - criterion: "Command spawns episode"
          verification: "Session registered after command"

    - ticket_id: TCK-00272
      title: "Implement apm2 fac ingest command"
      group_id: GRP-008
      phase: PHASE-4
      requirement_ids: []
      depends_on:
        - TCK-00253
        - TCK-00270
      files_to_modify:
        - path: "crates/apm2-cli/src/commands/coordinate.rs"
          changes: |
            Add fac ingest subcommand using daemon IPC.
        - path: "crates/apm2-cli/src/client/daemon.rs"
          changes: |
            Add FAC ingest IPC call.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define CLI interface"
          details: |
            apm2 fac ingest --work-id=<ID>
        - step: 2
          action: "Send FAC ingestion request"
          details: |
            Trigger policy resolution for work_id.
        - step: 3
          action: "Format output"
          details: |
            Display policy_resolved_ref.
      acceptance_criteria:
        - criterion: "Command triggers FAC ingestion"
          verification: "PolicyResolvedForChangeSet in ledger"

    - ticket_id: TCK-00273
      title: "Implement apm2 work status command"
      group_id: GRP-008
      phase: PHASE-4
      requirement_ids: []
      depends_on:
        - TCK-00253
        - TCK-00270
      files_to_modify:
        - path: "crates/apm2-cli/src/commands/coordinate.rs"
          changes: |
            Add work status subcommand using daemon IPC.
        - path: "crates/apm2-cli/src/client/daemon.rs"
          changes: |
            Add work status query IPC call.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define CLI interface"
          details: |
            apm2 work status --work-id=<ID>
        - step: 2
          action: "Query work status"
          details: |
            Fetch from daemon: sessions, policy state, lease state.
        - step: 3
          action: "Format output"
          details: |
            Human-readable status summary.
      acceptance_criteria:
        - criterion: "Command shows work status"
          verification: "Output includes session count and state"

    # ==========================================================================
    # GRP-009: xtask Deprecation (PHASE-5)
    # ==========================================================================
    - ticket_id: TCK-00274
      title: "Add deprecation warnings to xtask daemon commands"
      group_id: GRP-009
      phase: PHASE-5
      requirement_ids: []
      depends_on:
        - TCK-00270
        - TCK-00271
        - TCK-00272
        - TCK-00273
      files_to_modify:
        - path: "xtask/src/main.rs"
          changes: |
            Add deprecation warnings to work claim, work start,
            fac ingest, work status commands.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Add warning emission"
          details: |
            eprintln!("WARNING: 'cargo xtask work claim' is deprecated.");
            eprintln!("Use 'apm2 work claim --role=<ROLE>' instead.");
        - step: 2
          action: "Include migration guidance"
          details: |
            Show equivalent apm2 command for each deprecated xtask.
      acceptance_criteria:
        - criterion: "Warning printed on deprecated command use"
          verification: "stderr contains deprecation warning"
        - criterion: "Migration path documented"
          verification: "Warning includes apm2 equivalent"

    - ticket_id: TCK-00275
      title: "Add --allow-deprecated flag to xtask"
      group_id: GRP-009
      phase: PHASE-5
      requirement_ids: []
      depends_on:
        - TCK-00274
      files_to_modify:
        - path: "xtask/src/main.rs"
          changes: |
            Add --allow-deprecated global flag.
            Gate deprecated commands on flag.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Add global flag"
          details: |
            #[derive(clap::Args)]
            struct GlobalOpts {
                #[arg(long)]
                allow_deprecated: bool,
            }
        - step: 2
          action: "Gate execution on flag"
          details: |
            if is_deprecated && !opts.allow_deprecated {
                eprintln!("ERROR: Command deprecated. Use --allow-deprecated to run anyway.");
                exit(1);
            }
      acceptance_criteria:
        - criterion: "Deprecated commands require flag"
          verification: "Command fails without --allow-deprecated"
        - criterion: "Flag allows execution"
          verification: "Command succeeds with flag"

    - ticket_id: TCK-00276
      title: "Add xtask usage telemetry"
      group_id: GRP-009
      phase: PHASE-5
      requirement_ids: []
      depends_on:
        - TCK-00275
      files_to_modify:
        - path: "xtask/src/main.rs"
          changes: |
            Add telemetry emission for command invocations.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define telemetry event"
          details: |
            struct XtaskUsageEvent {
                command: String,
                deprecated: bool,
                allow_deprecated_flag: bool,
                timestamp: SystemTime,
            }
        - step: 2
          action: "Emit to local telemetry file"
          details: |
            Append JSON line to ~/.apm2/telemetry/xtask_usage.jsonl
        - step: 3
          action: "Add aggregation command"
          details: |
            apm2 telemetry xtask-usage shows percentage breakdown.
      acceptance_criteria:
        - criterion: "Usage events recorded"
          verification: "File contains usage events"
        - criterion: "Aggregation shows <5% threshold"
          verification: "apm2 telemetry xtask-usage works"

    - ticket_id: TCK-00277
      title: "Remove xtask crate after telemetry gate"
      group_id: GRP-009
      phase: PHASE-5
      requirement_ids: []
      depends_on:
        - TCK-00276
      files_to_modify:
        - path: "Cargo.toml"
          changes: |
            Remove xtask from workspace members.
        - path: ".cargo/config.toml"
          changes: |
            Remove xtask alias if present.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Verify telemetry gate"
          details: |
            apm2 telemetry xtask-usage must show <5% direct usage.
            If not met, defer removal.
        - step: 2
          action: "Remove xtask directory"
          details: |
            rm -rf xtask/
        - step: 3
          action: "Update workspace"
          details: |
            Remove from Cargo.toml [workspace] members.
        - step: 4
          action: "Update documentation"
          details: |
            Remove xtask references from README and docs.
      acceptance_criteria:
        - criterion: "Telemetry shows <5% xtask usage"
          verification: "Gate check passes"
        - criterion: "xtask crate removed"
          verification: "xtask/ directory does not exist"
        - criterion: "ADV-008 passes"
          verification: "cargo xtask returns command not found"
      adversarial_tests:
        - ADV-008

    # ==========================================================================
    # GRP-010: Amendment Follow-ups (DD-009 Hard Cutover)
    # ==========================================================================
    - ticket_id: TCK-00279
      title: "ProtocolServer-only daemon entrypoint"
      group_id: GRP-010
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0001
        - REQ-DCP-0008
      depends_on:
        - TCK-00248
        - TCK-00249
      files_to_modify:
        - path: "crates/apm2-daemon/src/main.rs"
          changes: |
            Start ProtocolServer listeners (operator.sock + session.sock).
            Remove ipc_server::run from default startup path.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Wire ProtocolServer into main entrypoint"
          details: "Bind operator/session sockets and accept connections."
        - step: 2
          action: "Remove legacy IPC startup"
          details: "Delete ipc_server::run spawn and legacy socket usage."
      acceptance_criteria:
        - criterion: "Daemon starts ProtocolServer-only control plane"
          verification: "Runtime logs + integration test show only operator/session sockets"
        - criterion: "Legacy JSON IPC listener is not started"
          verification: "ADV-012 cannot connect to legacy socket"
      test_requirements:
        - test_id: INT-IPC-010
          description: "ProtocolServer-only startup"
          verification_command: "cargo test -p apm2-daemon protocol_only_startup"

    - ticket_id: TCK-00280
      title: "Config schema cutover: dual sockets only"
      group_id: GRP-010
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0001
        - REQ-DCP-0008
      depends_on: []
      files_to_modify:
        - path: "crates/apm2-core/src/config/mod.rs"
          changes: |
            Replace daemon.socket with operator_socket + session_socket.
            Reject legacy single-socket keys (fail-closed).
        - path: "ecosystem.example.toml"
          changes: |
            Use operator_socket + session_socket keys.
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Define dual socket config keys"
          details: "Add operator_socket + session_socket fields."
        - step: 2
          action: "Fail-closed on legacy key"
          details: "Reject [daemon].socket if present."
      acceptance_criteria:
        - criterion: "Legacy single-socket config rejected"
          verification: "Unit test fails parsing with [daemon].socket"
        - criterion: "Dual sockets are required"
          verification: "Config validation fails without both operator/session sockets"
      test_requirements:
        - test_id: UT-CONFIG-010
          description: "Legacy socket key rejection"
          verification_command: "cargo test -p apm2-core config_reject_legacy_socket"

    - ticket_id: TCK-00281
      title: "Delete legacy JSON IPC modules"
      group_id: GRP-010
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0001
        - REQ-DCP-0008
      depends_on:
        - TCK-00279
      files_to_modify:
        - path: "crates/apm2-daemon/src/ipc_server.rs"
          changes: "Remove legacy JSON IPC server module."
        - path: "crates/apm2-daemon/src/handlers.rs"
          changes: "Remove or port legacy JSON handler surface."
        - path: "crates/apm2-core/src/ipc/mod.rs"
          changes: "Remove JSON IPC protocol types once unused."
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Remove legacy ipc_server module"
          details: "Delete JSON framing and dispatch loop."
        - step: 2
          action: "Remove legacy JSON protocol types"
          details: "Delete apm2_core::ipc once no call sites remain."
      acceptance_criteria:
        - criterion: "No legacy JSON IPC modules remain in default build"
          verification: "CI guardrails + build succeed without legacy symbols"
      test_requirements:
        - test_id: CI-LEGACY-IPC-001
          description: "Build fails if legacy IPC symbols remain"
          verification_command: "ci/legacy_ipc_guard.sh"

    - ticket_id: TCK-00282
      title: "CI guardrails: forbid legacy IPC reintroduction"
      group_id: GRP-010
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0008
      depends_on:
        - TCK-00281
      files_to_modify:
        - path: "scripts/ci/legacy_ipc_guard.sh"
          changes: |
            Add guard that fails on ipc_server, apm2_core::ipc, daemon.socket keys.
        - path: ".github/workflows/*"
          changes: "Wire guard into CI pipeline."
      files_to_create:
        - path: "scripts/ci/legacy_ipc_guard.sh"
          purpose: "Fail build on legacy IPC symbols/paths/config keys"
      implementation_steps:
        - step: 1
          action: "Implement guard script"
          details: "rg checks for legacy IPC symbols and legacy config keys."
        - step: 2
          action: "Wire guard into CI"
          details: "Fail builds that reintroduce legacy IPC."
      acceptance_criteria:
        - criterion: "CI fails on legacy IPC reintroduction"
          verification: "Guard script fails on forbidden symbols"
      test_requirements:
        - test_id: CI-LEGACY-IPC-002
          description: "Guard runs in CI"
          verification_command: "scripts/ci/legacy_ipc_guard.sh"

    - ticket_id: TCK-00283
      title: "ADV-012 legacy IPC bypass test"
      group_id: GRP-010
      phase: PHASE-1
      requirement_ids:
        - REQ-DCP-0001
        - REQ-DCP-0008
      depends_on:
        - TCK-00279
        - TCK-00281
      files_to_modify:
        - path: "crates/apm2-daemon/tests/adv_012_legacy_ipc.rs"
          changes: "Add ADV-012 adversarial test."
      files_to_create:
        - path: "crates/apm2-daemon/tests/adv_012_legacy_ipc.rs"
          purpose: "Legacy JSON IPC bypass + downgrade attempt"
      implementation_steps:
        - step: 1
          action: "Add ADV-012 test harness"
          details: "Probe legacy socket and send JSON frames to ProtocolServer sockets."
        - step: 2
          action: "Record evidence"
          details: "Emit evidence artifacts per PRD-0010 evidence standards."
      acceptance_criteria:
        - criterion: "Legacy socket path absent/refuses connection"
          verification: "ADV-012 fails to connect to legacy socket"
        - criterion: "ProtocolServer rejects JSON frames before handlers"
          verification: "ADV-012 fails downgrade attempts"
      test_requirements:
        - test_id: ADV-012
          description: "Legacy JSON IPC bypass + downgrade attempt"
          verification_command: "cargo test -p apm2-daemon adv_012_legacy_ipc"

    - ticket_id: TCK-00284
      title: "xtask bypass closure for external projections"
      group_id: GRP-010
      phase: PHASE-1
      requirement_ids:
        - REQ-0014
      depends_on: []
      files_to_modify:
        - path: "xtask/src/tasks/review.rs"
          changes: "Remove or hard-fail direct GitHub status writes."
        - path: "xtask/src/tasks/aat.rs"
          changes: "Remove or hard-fail direct GitHub status writes."
      files_to_create: []
      implementation_steps:
        - step: 1
          action: "Disable direct status writes"
          details: "Replace gh api status calls with hard-fail or daemon-mediated path."
        - step: 2
          action: "Add guardrails"
          details: "Ensure xtask cannot write external projections."
      acceptance_criteria:
        - criterion: "No direct external status writes from xtask"
          verification: "Code inspection + CI guard confirms removal"
        - criterion: "Authority-affecting xtask ops fail-closed"
          verification: "Attempted status write errors explicitly"
      test_requirements:
        - test_id: UT-XTASK-014
          description: "xtask external write paths removed"
          verification_command: "cargo test -p xtask"
