rfc_risks_and_open_questions:
  schema_version: "2026-01-30"
  template_version: "2026-01-23"

  # CRITICAL: This is v0 (Discovery) phase.
  # Open questions and "Known Unknowns" are documented here for investigation
  # during EXPLORE phase (v0 -> v2 transition).

  risks:
    - id: RISK-RFC-0017-001
      name: "Migration surface larger than expected"
      category: ADOPTION
      description: |
        xtask deprecation assumes limited direct usage. If migration surface is
        larger (undocumented xtask behaviors, external scripts depending on xtask),
        removal may cause unexpected breakage.
      likelihood: MEDIUM
      impact: HIGH
      mitigation:
        - "Telemetry gate: removal blocked until <5% direct xtask usage"
        - "Extended deprecation period if telemetry shows high usage"
        - "Deprecation warnings with migration guidance"
      owner: "Implementation team"
      status: OPEN

    - id: RISK-RFC-0017-002
      name: "Container UID remapping breaks peer credential validation"
      category: SECURITY
      description: |
        SO_PEERCRED returns container-namespace UID which may not match host UID
        when user namespaces remap. Could allow authentication bypass.
      likelihood: MEDIUM
      impact: HIGH
      mitigation:
        - "Require --userns=host for container deployments"
        - "Document container deployment constraints"
        - "Test peer credential validation in common runtimes"
      owner: "Security review"
      status: OPEN

    - id: RISK-RFC-0017-003
      name: "Daemon becomes single point of failure"
      category: RELIABILITY
      description: |
        With all work orchestration flowing through daemon, daemon unavailability
        blocks all agent operations.
      likelihood: LOW
      impact: HIGH
      mitigation:
        - "Daemon crash recovery within 5s (REQ-0013)"
        - "Session recovery via LEASE_REVOKED signals (OQ-011 decision)"
        - "Hybrid persistence: state file + ledger (TCK-00266)"
        - "Adversarial test coverage: ADV-010 (EVID-0018)"
        - "Future: explore daemon clustering"
      owner: "SRE/Platform team"
      status: MITIGATED

    - id: RISK-RFC-0017-004
      name: "Tool mediation latency impacts productivity"
      category: PERFORMANCE
      description: |
        Adding mediation layer for every tool call introduces latency.
        If overhead exceeds target (<5ms p50), developer productivity suffers.
      likelihood: LOW
      impact: MEDIUM
      mitigation:
        - "Benchmark targets in success metrics"
        - "Optimize hot path: capability check caching"
        - "Async event emission where possible"
      owner: "Performance team"
      status: OPEN

    - id: RISK-RFC-0017-005
      name: "RFC-0015 breaking changes invalidate design"
      category: DEPENDENCY
      description: |
        RFC depends on RFC-0015 concepts (PolicyResolvedForChangeSet, GateLeaseIssued).
        Breaking changes in RFC-0015 could require significant rework.
      likelihood: LOW
      impact: HIGH
      mitigation:
        - "Version pin in metadata: RFC-0015 v4.1+"
        - "Breaking change policy: coordinated update required"
        - "Integration tests verify RFC-0015 contract compatibility"
      owner: "Architecture team"
      status: OPEN

  open_questions:
    # Known Unknowns requiring codebase investigation in EXPLORE phase

    # =========================================================================
    # OQ-001: RESOLVED by RFC Council review 2026-01-30
    # See: evidence/rfc/RFC-0017/reviews/rfc_review_20260130T120000.yaml
    # =========================================================================
    - id: OQ-001
      question: "What existing Unix socket infrastructure exists in apm2-daemon?"
      context: |
        Design decision DD-001 proposes Unix socket IPC. Need to understand if
        there's existing socket handling code to extend or if building from scratch.
      status: RESOLVED
      resolution: |
        RFC Council exploration (2026-01-30) found TWO existing IPC stacks:

        **Stack 1: JSON IPC (apm2_core::ipc)**
        - crates/apm2-core/src/ipc/mod.rs (525 lines)
        - crates/apm2-daemon/src/ipc_server.rs (167 lines)
        - JSON encoding, 4-byte BE length framing
        - NO handshake, NO peer creds
        - ACTIVE: routes process management, credentials, episode CRUD

        **Stack 2: Protobuf Runtime Protocol (apm2_daemon::protocol)**
        - crates/apm2-daemon/src/protocol/ (7 files, ~3000 lines)
        - proto/apm2d_runtime_v1.proto (249 lines)
        - Binary protobuf, Hello/HelloAck handshake, version negotiation
        - NO peer creds (must be added)
        - NOT INTEGRATED: tested but not in main dispatcher

        CRITICAL: Must choose ONE stack for Phase 1 control plane (DD-008).

    # =========================================================================
    # OQ-001a: RESOLVED - Protocol Decision (2026-01-30)
    # =========================================================================
    - id: OQ-001a
      question: "Which IPC protocol stack becomes the Phase 1 control plane?"
      context: |
        Sprint-fatal decision point. Introducing a 3rd protocol is a COUSIN_VIOLATION.
        Must adopt either JSON IPC or Protobuf Runtime Protocol.
      status: RESOLVED
      resolved_date: "2026-01-30"
      resolved_by: "Human (operator)"
      council_finding: FND-RFC-0017-001
      decision_ref: "02_design_decisions.yaml#DD-008"
      evidence_ref: "evidence/rfc/RFC-0017/reviews/rfc_review_20260130T120000.yaml"
      resolution: |
        DECISION: OPTION A - Adopt Protobuf Runtime Protocol

        The Protobuf Runtime Protocol (crates/apm2-daemon/src/protocol/) becomes
        the control-plane IPC for PRD-0010 Phase 1. This leverages existing:
        - Handshake with version negotiation (CTR-PROTO-001)
        - Bounded reads with DoS protection (CTR-1603)
        - Canonical encoding for signing (AD-DAEMON-003)
        - Golden test vectors (AD-VERIFY-001)

        Implementation adds:
        - SO_PEERCRED authentication to ProtocolServer::accept()
        - Control-plane messages to apm2d_runtime_v1.proto
        - Thin JSON-to-protobuf CLI adapter for backward compatibility

        JSON IPC (apm2_core::ipc) remains for legacy CLI during migration.

    # =========================================================================
    # OQ-002: RESOLVED by RFC Council EXPLORE phase 2026-01-30
    # =========================================================================
    - id: OQ-002
      question: "How does daemon currently interact with governance components?"
      context: |
        Design decision DD-002 proposes daemon calls HOLON-KERNEL-GOVERNANCE.
        Need to understand current governance integration patterns.
      status: RESOLVED
      resolved_date: "2026-01-30"
      resolved_by: "RFC Council EXPLORE phase"
      resolution: |
        CURRENT STATE: The daemon does NOT currently interact with governance components.

        GOVERNANCE INFRASTRUCTURE EXISTS in apm2-core but is NOT integrated into daemon:

        1. **PolicyEngine** (apm2-core/src/policy/engine.rs):
           - Coarse-grained policy evaluation engine
           - Evaluates tool requests against policy rules
           - Default-deny security model
           - Status: DEFINED and TESTABLE but NOT WIRED into daemon

        2. **PolicyResolvedForChangeSet** (apm2-core/src/fac/policy_resolution.rs):
           - FAC anchor event for locking policy decisions
           - Binds risk_tier and determinism_class metadata
           - Intended as governance resolution interface
           - Status: DEFINED but daemon has no code path to call it

        3. **PolicyIntegratedValidator** (apm2-daemon/src/episode/capability.rs:1160-1330):
           - Fine-grained capability validation layer
           - Planned to integrate PolicyEngine but marked with TODO comments
           - Status: STUB implementation, integration DEFERRED to future tickets

        MISSING INTERACTIONS:
        - Daemon has no "query governance holon" operation
        - Daemon has no policy resolution call path
        - Daemon has no way to mint capability manifests based on resolved policies
        - Current handlers (handlers.rs) only manage process lifecycle, no governance calls

        DD-002 HYPOTHESIS VALIDATION:
        The RFC design decision DD-002 proposes "daemon calls HOLON-KERNEL-GOVERNANCE
        for policy resolution." However, codebase shows:
        - HOLON-KERNEL-GOVERNANCE holon is NOT defined/referenced anywhere in codebase
        - PolicyEngine exists but is NOT called from daemon
        - Daemon episode capability code has TODO for policy integration

        IMPLEMENTATION PATH FOR PHASE 1:
        1. Define HOLON-KERNEL-GOVERNANCE interface (or clarify if it's PolicyEngine)
        2. Add policy resolution call path to daemon IPC handlers
        3. Implement capability manifest minting based on PolicyResolvedForChangeSet
        4. Wire PolicyEngine evaluation into EpisodeRuntime
        5. Add governance error handling to IPC protocol
      evidence:
        - file: crates/apm2-core/src/policy/engine.rs
          description: "PolicyEngine exists for tool request evaluation"
        - file: crates/apm2-core/src/fac/policy_resolution.rs
          description: "PolicyResolvedForChangeSet FAC anchor event"
        - file: crates/apm2-daemon/src/episode/capability.rs
          lines: "1160-1330"
          description: "PolicyIntegratedValidator with TODO for PolicyEngine integration"
        - file: crates/apm2-daemon/src/handlers.rs
          description: "No governance queries in current handlers"

    # =========================================================================
    # OQ-003: RESOLVED by RFC Council EXPLORE phase 2026-01-30
    # =========================================================================
    - id: OQ-003
      question: "What existing capability/permission structures exist?"
      context: |
        Design decision DD-003 proposes capability manifest structure.
        Need to understand existing permission models to avoid cousin abstractions.
      status: RESOLVED
      resolved_date: "2026-01-30"
      resolved_by: "RFC Council EXPLORE phase"
      resolution: |
        COMPREHENSIVE EXISTING CAPABILITY STRUCTURES FOUND:

        1. **CONTEXT-LEVEL FILE ACCESS (ContextPack)**
           Path: crates/apm2-core/src/context/manifest.rs (1887 lines)
           - AccessLevel enum: Read | ReadWithZoom (fine-grained)
           - ManifestEntry: path + content_hash + stable_id + access_level
           - ContextPackManifest: indexed collection (O(1) lookup via HashMap)
           - Security: Path normalization, hash verification (constant-time), TOCTOU prevention
           - Resource limits: MAX_ENTRIES=10,000, MAX_PATH_LENGTH=4,096

        2. **LEASE-BACKED CAPABILITIES (Delegation Model)**
           Path: crates/apm2-core/src/lease/capability.rs (4977 lines)
           - Capability: capability_id, namespace, holder_actor_id, grantor_actor_id, state
           - CapabilityState: Granted | Delegated | Revoked | Expired
           - CapabilityProof: Cryptographic proof with delegation chain
           - CapabilityRegistry: Map-based with namespace and holder indices
           - Semantics: capability_id == lease_id (per RFC-0014 DD-0009)

        3. **DAEMON-SIDE TOOL CAPABILITY MANIFESTS**
           Path: crates/apm2-daemon/src/episode/capability.rs
           - Tool classes: Read, Write, Execute, Network, Git, Inference, Artifact
           - CapabilityScope: root_paths, allowed_patterns, size_limits, network_policy
           - Clock abstraction for deterministic expiration checking
           - Broker mediation pattern (tool requests validated before execution)

        4. **BINARY CAPABILITY ENUMERATION (CAC v1)**
           Path: crates/apm2-core/src/cac/manifest.rs (1300+ lines)
           - CapabilityManifest: schema_version, binary_hash, commands, capabilities
           - Capability: id, description, verification_method, selftest_id
           - VerificationMethod: Selftest | StaticAnalysis | Declared
           - Binary hash binding prevents replay (DD-0006)

        5. **CAPABILITY SCOPE (Fine-grained restrictions)**
           Path: crates/apm2-daemon/src/episode/scope.rs
           - CapabilityScope: root_paths, allowed_patterns, size_limits, network_policy
           - Binds tool-class capabilities to specific file system boundaries
           - Used by tool broker to validate request paths before execution

        EXTENSION POINTS FOR RFC-0017:
        - **ContextPackManifest**: Extend ManifestEntry for tool_allowlist and write_allowlist
        - **Capability Delegation**: Leverage CapabilityProof for runtime permission grants
        - **Tool Broker Mediation**: Current pattern validates tool_id; extend for paths
        - **Policy Resolution**: PolicyResolvedForChangeSet already captures risk_tier

        ANTI-COUSIN ANALYSIS COMPLETE: No new capability structures needed. Extend existing.
      evidence:
        - file: crates/apm2-core/src/context/manifest.rs
          lines: "1-1887"
          description: "ContextPackManifest with AccessLevel and OCAP allowlist"
        - file: crates/apm2-core/src/lease/capability.rs
          lines: "1-4977"
          description: "Lease-backed capabilities with delegation chain"
        - file: crates/apm2-daemon/src/episode/capability.rs
          description: "CapabilityManifest with ToolClass enumeration"
        - file: crates/apm2-daemon/src/episode/scope.rs
          description: "CapabilityScope with root_paths and allowed_patterns"
        - file: crates/apm2-core/src/cac/manifest.rs
          description: "CAC v1 CapabilityManifest with binary hash binding"

    # =========================================================================
    # OQ-004: RESOLVED by RFC Council EXPLORE phase 2026-01-30
    # =========================================================================
    - id: OQ-004
      question: "How does current tool execution work in apm2?"
      context: |
        Design decision DD-004 proposes tool broker pattern.
        Need to understand existing tool execution to design mediation layer.
      status: RESOLVED
      resolved_date: "2026-01-30"
      resolved_by: "RFC Council EXPLORE phase"
      resolution: |
        CURRENT TOOL EXECUTION ARCHITECTURE (5-layer model):

        **LAYER 1 - PROTOCOL & VALIDATION (apm2-core/src/tool/)**
        - Tool requests use protobuf messages (ToolRequest) with session_token
        - Eight tool types: FileRead, FileWrite, FileEdit, ShellExec, GitOp,
          Inference, ArtifactPublish, ArtifactFetch
        - Comprehensive validation layer enforces size limits, path constraints
        - Default-deny security model

        **LAYER 2 - ADAPTER PATTERN (apm2-core/src/adapter/)**
        Two execution paths implemented:
        A) Black-box adapter: Observes side effects and infers tool requests
        B) Claude Code instrumented adapter: Native hooks (PreToolUse/PostToolUse)
           with HookResponse for mediation/blocking

        **LAYER 3 - TOOL HANDLERS (apm2-core/src/tool/)**
        - ShellTool (shell.rs): Subprocess with timeout, workspace-root sandboxing
        - FilesystemTool (fs.rs): Path traversal protection, canonical path verification
        - InferenceTool (inference.rs): Provider abstraction, token budget tracking

        **LAYER 4 - SESSION FIREWALL (apm2-daemon/src/session/consume.rs)**
        - CONSUME mode validates FileRead against ContextPackManifest allowlist
        - Default-deny: reads outside allowlist trigger CONTEXT_MISS termination
        - validate_tool_request function (lines 412-442) enforces firewall

        **LAYER 5 - DAEMON MEDIATION (apm2-daemon/src/protocol/)**
        - Protocol messages: ToolRequest, ToolDecision (Allow/Deny/DedupeHit), ToolResult
        - CTR-PROTO-004 defines tool mediation contract
        - Daemon routes to policy engine for decision

        CREDENTIAL HANDLING:
        - Session tokens used for authentication (not direct credential access)
        - ALLOWED_TOOL_NAMES allowlist (adapter/claude_code.rs:85-106) enforces default-deny
        - PreToolUse hook provides mediation point for policy enforcement

        DD-004 HYPOTHESIS VALIDATION:
        The proposed Tool Broker Mediation Pattern aligns with existing architecture:
        - PreToolUse hook = mediation point
        - HookResponse = allow/block decision
        - Session tokens = capability binding
        Extension needed: credentials held daemon-side, exposed via broker only
      evidence:
        - file: crates/apm2-core/src/tool/mod.rs
          description: "Tool protocol module with default-deny security"
        - file: crates/apm2-core/src/tool/validation.rs
          description: "Comprehensive validation before policy engine"
        - file: crates/apm2-core/src/adapter/claude_code.rs
          lines: "85-106, 423-433"
          description: "ALLOWED_TOOL_NAMES and HookResponse mediation"
        - file: crates/apm2-daemon/src/session/consume.rs
          lines: "412-442"
          description: "validate_tool_request with context firewall"
        - file: crates/apm2-daemon/src/protocol/messages.rs
          description: "ToolRequest/ToolDecision/ToolResult protocol messages"

    # =========================================================================
    # OQ-005: RESOLVED by RFC Council EXPLORE phase 2026-01-30
    # =========================================================================
    - id: OQ-005
      question: "Does daemon have persistent state for session tracking?"
      context: |
        Design decision DD-005 proposes session recovery from persistent state.
        Need to understand if daemon has durable state or if it's stateless.
      status: RESOLVED
      resolved_date: "2026-01-30"
      resolved_by: "RFC Council EXPLORE phase"
      resolution: |
        DAEMON SESSION PERSISTENCE MODEL: LEDGER-DRIVEN

        The daemon HAS persistent state for session tracking, but it is
        LEDGER-DRIVEN rather than in-memory:

        1. **LEDGER IS THE TRUTH SOURCE**
           Path: crates/apm2-core/src/ledger/storage.rs
           - SQLite-backed append-only event ledger
           - WAL mode enables concurrent reads during writes
           - All session lifecycle events persisted as EventRecords

        2. **SESSION STATE RECONSTRUCTION**
           Path: crates/apm2-core/src/session/recovery.rs
           - replay_session_state() reconstructs state from ledger
           - find_last_session_cursor() identifies best resume point
           - SessionRecoveryState captures: started_at, last_seq_id, progress_count

        3. **CRASH RECOVERY MECHANISM**
           Path: crates/apm2-core/src/session/state.rs (lines 59-129)
           - SessionState includes resume_cursor (u64) tracking ledger position
           - Sessions can resume from exact position, not from scratch
           - restart_attempt counter enforces monotonicity (prevents replay)

        4. **IN-MEMORY DAEMON STATE**
           Path: crates/apm2-daemon/src/state.rs
           - DaemonStateHandle: Arc<RwLock<DaemonState>> (in-memory only)
           - Holds supervisor and active process runners
           - NOT persisted - reconstructed from ledger on startup

        5. **RESTART BEHAVIOR (CURRENT)**
           - Daemon crash loses all in-memory runner state
           - Ledger survives (SQLite is durable)
           - On restart: daemon CAN query ledger for active sessions
           - Recovery infrastructure exists but LEASE_REVOKED signaling not implemented

        DD-005 HYPOTHESIS VALIDATION:
        The design is GROUNDED IN EVIDENCE. Infrastructure exists:
        - Ledger provides session event storage
        - Recovery functions exist (replay_session_state, find_last_session_cursor)
        - restart_coordinator integrates with restart decisions
        - SessionReducer supports restart via monotonicity enforcement

        IMPLEMENTATION GAP FOR PHASE 1:
        - Daemon must query ledger for active sessions on startup
        - Daemon must emit LEASE_REVOKED signals within 5s timeout
        - Protocol support for LEASE_REVOKED in control-plane IPC needed
      evidence:
        - file: crates/apm2-core/src/ledger/storage.rs
          description: "SQLite-backed ledger with WAL mode"
        - file: crates/apm2-core/src/session/recovery.rs
          lines: "1-55, 212-251"
          description: "Session recovery via ledger replay"
        - file: crates/apm2-core/src/session/state.rs
          lines: "59-129"
          description: "SessionState with resume_cursor"
        - file: crates/apm2-core/src/session/restart_coordinator.rs
          lines: "200-241, 331-357"
          description: "RestartCoordinator with quarantine integration"
        - file: crates/apm2-daemon/src/state.rs
          description: "In-memory DaemonStateHandle (ephemeral)"

    # =========================================================================
    # OQ-006: RESOLVED by RFC Council EXPLORE phase 2026-01-30
    # =========================================================================
    - id: OQ-006
      question: "What signing infrastructure exists in apm2-core?"
      context: |
        Design decision DD-006 proposes Ed25519 signing with domain separation.
        Need to understand existing signing capabilities.
      status: RESOLVED
      resolved_date: "2026-01-30"
      resolved_by: "RFC Council EXPLORE phase"
      resolution: |
        COMPREHENSIVE SIGNING INFRASTRUCTURE EXISTS:

        **CRYPTOGRAPHIC FOUNDATIONS**
        Path: crates/apm2-core/src/crypto/
        - Ed25519 signing (sign.rs): ed25519_dalek, 32-byte keys, 64-byte signatures
        - Blake3 hashing (hash.rs): Event hash-chain linking, GENESIS_PREV_HASH
        - HMAC-SHA256 (webhook/signature.rs): GitHub webhook validation

        **KEY MANAGEMENT**
        Path: crates/apm2-core/src/crypto/keys.rs (636 lines)
        - KeyManager with file-based (0600 permissions) and in-memory storage
        - Actor ID validation (injection protection)
        - Key rotation support with version tracking

        **TRUST HIERARCHY**
        Path: crates/apm2-core/src/crypto/hsm.rs
        - T1 (Validator): HSM abstraction with SoftwareHsmProvider fallback
        - T2 (Holon): KeyManager for holon-level keys
        - T3 (Session): Ephemeral session keys (infrastructure ready)

        **EVENT CANONICALIZATION**
        Path: crates/apm2-core/src/events/canonical.rs (424 lines)
        - Canonicalize trait for deterministic serialization before signing
        - Sorts repeated fields lexicographically
        - Supports: WorkOpened, WorkCompleted, EvidencePublished, GateReceiptGenerated

        **PRODUCTION-READY FEATURES**
        - OS keychain integration (apm2-daemon/src/evidence/keychain.rs)
        - Constant-time comparison for webhook signatures
        - Zeroizing containers for sensitive key material
        - ReceiptSigner (apm2-daemon/src/evidence/signer.rs) for tool receipts

        DD-006 HYPOTHESIS VALIDATION:
        Ed25519 signing with domain separation is ACHIEVABLE with existing infrastructure.
        The canonicalization layer already exists; extend to new event types.

        GAPS/LIMITATIONS:
        1. HSM integration is abstraction-only (SoftwareHsmProvider not production)
        2. Kernel event signature field not yet added to KernelEvent protobuf
        3. Key rotation policy enforcement not coded (90-day schedule mentioned)
        4. Ledger event signing integration incomplete at consensus layer
      evidence:
        - file: crates/apm2-core/src/crypto/sign.rs
          lines: "1-283"
          description: "Ed25519 Signer with generate, sign, verify"
        - file: crates/apm2-core/src/crypto/keys.rs
          lines: "1-636"
          description: "KeyManager with secure file storage"
        - file: crates/apm2-core/src/crypto/hash.rs
          description: "Blake3 hash-chain for event linking"
        - file: crates/apm2-core/src/events/canonical.rs
          lines: "1-424"
          description: "Canonicalize trait for deterministic serialization"
        - file: crates/apm2-daemon/src/evidence/signer.rs
          lines: "1-539"
          description: "ReceiptSigner for tool receipts"
        - file: crates/apm2-daemon/src/evidence/keychain.rs
          lines: "1-1082"
          description: "OS keychain integration with key manifest"

    # =========================================================================
    # OQ-007: RESOLVED by RFC Council EXPLORE phase 2026-01-30
    # =========================================================================
    - id: OQ-007
      question: "What xtask commands exist and what are their daemon CLI equivalents?"
      context: |
        Design decision DD-007 proposes xtask deprecation.
        Need complete inventory of xtask commands for migration planning.
      status: RESOLVED
      resolved_date: "2026-01-30"
      resolved_by: "RFC Council EXPLORE phase"
      resolution: |
        XTASK COMMAND INVENTORY (15 commands in xtask/src/main.rs):

        **Category 1: DAEMON-MEDIATED (In Scope for RFC-0017)**
        These 4 commands will migrate to daemon IPC:
        - work claim → apm2 work claim --role=<ROLE> [NOT YET IMPLEMENTED]
        - work start → apm2 episode spawn --work-id=<ID> --role=<ROLE> [NOT YET IMPLEMENTED]
        - fac ingest → apm2 fac ingest --work-id=<ID> [NOT YET IMPLEMENTED]
        - work status → apm2 work status --work-id=<ID> [NOT YET IMPLEMENTED]

        **Category 2: SCM/GITHUB WORKFLOW TOOLS (Out of Scope)**
        These 8 commands are GitHub/SCM automation, NOT daemon operations:
        - start-ticket: Creates worktree and branch (SCM-specific)
        - commit: Git commit with pre-checks (development tool)
        - push: Push branch and create PR (GitHub-specific)
        - check: Monitor PR status (GitHub-specific)
        - finish: Post-merge cleanup (SCM workflow)
        - review security/quality/uat: AI review invocation (GitHub PR integration)
        - aat: Agent Acceptance Testing (GitHub-specific)

        **Category 3: DEVELOPMENT TOOLS (Out of Scope)**
        These 3 commands are developer infrastructure:
        - lint: Check for anti-patterns (code quality)
        - capabilities: Generate capability manifest (introspection)
        - selftest: Run CAC capability selftests (verification)

        DD-007 DEPRECATION STRATEGY CLARIFICATION:
        The three-phase deprecation (warnings → --allow-deprecated → removal)
        applies to Category 1 commands ONLY. Category 2/3 commands:
        - May remain in xtask OR migrate to separate development tool suite
        - Are NOT daemon operations and do NOT require daemon IPC
        - Deprecation applies only to work orchestration commands

        MIGRATION PATH:
        - Phase 4 (CLI Migration): Implement apm2 work/episode commands
        - Phase 5 (xtask Deprecation): Add warnings, require flag, remove crate
        - Category 2/3 disposition: Decide separately (keep xtask or new tool)
      xtask_commands:
        daemon_operations:
          - name: "work claim"
            cli_equivalent: "apm2 work claim --role=<ROLE>"
            status: "NOT_YET_IMPLEMENTED"
          - name: "work start"
            cli_equivalent: "apm2 episode spawn --work-id=<ID> --role=<ROLE>"
            status: "NOT_YET_IMPLEMENTED"
          - name: "fac ingest"
            cli_equivalent: "apm2 fac ingest --work-id=<ID>"
            status: "NOT_YET_IMPLEMENTED"
          - name: "work status"
            cli_equivalent: "apm2 work status --work-id=<ID>"
            status: "NOT_YET_IMPLEMENTED"
        github_workflow_tools:
          - "start-ticket"
          - "commit"
          - "push"
          - "check"
          - "finish"
          - "review security"
          - "review quality"
          - "review uat"
          - "aat"
        development_tools:
          - "lint"
          - "capabilities"
          - "selftest"
      evidence:
        - file: xtask/src/main.rs
          lines: "14-38, 67-192"
          description: "Complete xtask command inventory"
        - file: crates/apm2-cli/src/main.rs
          lines: "40-217"
          description: "Current apm2 CLI command structure"
        - file: documents/rfcs/RFC-0017/04_contracts_and_versioning.yaml
          lines: "317-326"
          description: "RFC-0017 migration path specification"

    # =========================================================================
    # OQ-008: DEFERRED - Multi-tenant workstation scenarios
    # Formalized during FINALIZE phase (v2 -> v4) 2026-01-30
    # =========================================================================
    - id: OQ-008
      question: "How should daemon handle multi-tenant workstation scenarios?"
      context: |
        From PRD-0010 Q-0001. Phase 1 targets single daemon per workstation.
        For shared environments, additional isolation may be needed.
      status: DEFERRED
      deferred_date: "2026-01-30"
      deferred_by: "RFC Council FINALIZE phase"
      deferral_rationale: |
        Phase 1 scope constraint: Single-user workstation is the target deployment
        model. Multi-tenant scenarios (shared dev servers, CI runners) require
        additional isolation mechanisms (per-user sockets, work_id sharding) that
        would add complexity without addressing core daemon-as-control-plane goals.

        Deferral is appropriate because:
        1. Single-user model covers primary use case (developer workstation)
        2. Multi-tenant adds authentication complexity (which user owns which work?)
        3. Phase 2 can address multi-tenant after Phase 1 validates core architecture
      future_rfc_ref: "RFC-TBD-MULTI-TENANT"
      phase_target: "Phase 2"

    # =========================================================================
    # OQ-009: DEFERRED - Windows compatibility
    # Formalized during FINALIZE phase (v2 -> v4) 2026-01-30
    # =========================================================================
    - id: OQ-009
      question: "What is the compatibility story for Windows?"
      context: |
        From PRD-0010 Q-0002. SO_PEERCRED requires Unix domain sockets.
        Windows named pipes have different authentication mechanisms.
      status: DEFERRED
      deferred_date: "2026-01-30"
      deferred_by: "RFC Council FINALIZE phase"
      deferral_rationale: |
        Phase 1 scope constraint: Unix-first design. Windows support is explicitly
        OUT OF SCOPE for Phase 1 because:

        1. SO_PEERCRED (Unix domain socket peer credentials) has no Windows equivalent
        2. Windows named pipes use different security model (security descriptors)
        3. Alternative approaches (JWT over localhost HTTP) add complexity
        4. Primary user base (APM2 developers) use Unix-like systems

        Non-goal documentation: This should be listed as explicit non-goal in
        any scope documentation. Windows users should use WSL2 for Phase 1.
      future_rfc_ref: "RFC-TBD-WINDOWS-SUPPORT"
      phase_target: "Phase 2"
      non_goal_for_phase_1: true

    # =========================================================================
    # OQ-010: RESOLVED - SSH credential mediation
    # Formalized during FINALIZE phase (v2 -> v4) 2026-01-30
    # =========================================================================
    - id: OQ-010
      question: "How does tool broker mediate SSH operations without exposing keys?"
      context: |
        From PRD-0010 Q-0004. Git operations may require SSH authentication.
        Broker must mediate without exposing SSH private keys to session.
      status: RESOLVED
      resolved_date: "2026-01-30"
      resolved_by: "RFC Council FINALIZE phase"
      resolution: |
        Daemon runs SSH agent or git credential helper internally. Session requests
        git operations via tool broker; broker uses internal agent/helper to execute
        authenticated operations. SSH_AUTH_SOCK is NOT exposed to session process.

        Implementation approach:
        1. Daemon starts internal ssh-agent subprocess (or uses system agent)
        2. Daemon holds SSH_AUTH_SOCK reference in credential broker
        3. GitOp tool requests go through broker
        4. Broker executes git commands with SSH_AUTH_SOCK set in subprocess env
        5. Session process has NO access to SSH_AUTH_SOCK or private keys

        This is analogous to credential broker pattern in DD-004: broker holds
        credentials, mediates operations, returns results without credential exposure.
      evidence:
        - pattern: "DD-004 Tool Broker Mediation Pattern"
          description: "Session requests tool calls; broker mediates"
        - pattern: "TB-003 Credential Isolation Boundary"
          description: "Credentials held by daemon only"

    # =========================================================================
    # OQ-011: BLOCKING - Session Registry Persistence (Added 2026-01-30)
    # This is a BLOCKING implementation requirement for REQ-0013.
    # =========================================================================
    - id: OQ-011
      question: "What is the concrete persistence mechanism for crash recovery?"
      context: |
        PRD-0010 REQ-0013 requires "daemon restart MUST NOT orphan running episodes"
        with LEASE_REVOKED signals within 5s. RFC-0017 DD-005 identifies ledger-driven
        recovery but OQ-005 notes "LEASE_REVOKED signaling not implemented."

        Two persistence models are referenced in documentation:
        1. Ledger replay (apm2-core/src/session/recovery.rs)
        2. State file (ecosystem.example.toml state_file config)

        Without explicit decision, crash recovery becomes vague Phase-N promise.
      status: REQUIRES_IMPLEMENTATION
      blocking: true
      blocks_requirement: REQ-0013
      resolution: |
        DECISION: Hybrid persistence model for Phase 1.

        1. **Session Registry State File** (primary crash recovery source):
           - Path: Configured via `state_file` in ecosystem.toml
           - Format: JSON with atomic write (write-to-temp + rename)
           - Contents: Map of session_id -> {pid, work_id, lease_id, spawn_time}
           - Write trigger: Synchronous on session create/destroy
           - Read trigger: Daemon startup

        2. **Ledger** (authoritative record, consistency check):
           - EpisodeSpawned/SessionTerminated events provide audit trail
           - On recovery: state file is truth for "what to kill"
           - Ledger is truth for "what happened" (post-hoc reconciliation)

        3. **LEASE_REVOKED Protocol Message**:
           - Add to apm2d_runtime_v1.proto
           - Daemon sends to each session on restart
           - Session client handler: graceful shutdown (cleanup + exit 0)
           - Timeout: 5s for signal delivery, then SIGKILL

        4. **Race Condition Handling**:
           - Crash during spawn: PID in state file but no EpisodeSpawned in ledger
             → Kill PID, emit SessionTerminated with rationale=SPAWN_INTERRUPTED
           - Crash during destroy: EpisodeSpawned in ledger but PID gone
             → Emit SessionTerminated with rationale=DAEMON_RESTART (no-op kill)

        Implementation ticket: TCK-00266
      evidence:
        - file: ecosystem.example.toml
          line: 8
          description: "state_file config option exists but not wired"
        - file: crates/apm2-core/src/session/recovery.rs
          description: "Ledger replay infrastructure exists"
        - file: proto/apm2d_runtime_v1.proto
          description: "LEASE_REVOKED message to be added"

  discovery_goals:
    summary: |
      v0 -> v2 (EXPLORE) phase COMPLETE. All open questions have been grounded
      in codebase evidence by RFC Council exploration on 2026-01-30.

    status: COMPLETE
    completed_date: "2026-01-30"

    priority_order:
      - OQ-001  # IPC infrastructure - RESOLVED (2 stacks found, protobuf chosen)
      - OQ-004  # Tool execution - RESOLVED (5-layer architecture mapped)
      - OQ-003  # Capability structures - RESOLVED (5 structures found, no cousins needed)
      - OQ-006  # Signing - RESOLVED (comprehensive Ed25519 infrastructure exists)
      - OQ-005  # Session persistence - RESOLVED (ledger-driven model confirmed)
      - OQ-002  # Governance integration - RESOLVED (PolicyEngine exists, not wired)
      - OQ-007  # xtask inventory - RESOLVED (15 commands, 4 in scope for deprecation)

    success_criteria:
      - "All REQUIRES_EXPLORATION questions resolved with codebase evidence" # ACHIEVED
      - "Design decisions updated with file paths and code references" # ACHIEVED
      - "Anti-cousin analysis complete for capability/permission structures" # ACHIEVED
      - "v2 version ready for FINALIZE phase" # ACHIEVED

    exploration_summary: |
      KEY FINDINGS FROM v0->v2 EXPLORATION:

      1. **Protocol Decision (OQ-001/OQ-001a)**: Protobuf Runtime Protocol adopted.
         Two existing stacks found; protobuf chosen for handshake, canonical encoding.

      2. **Capability Structures (OQ-003)**: 5 existing structures found - NO NEW
         ABSTRACTIONS NEEDED. Extend ContextPackManifest and CapabilityScope.

      3. **Tool Execution (OQ-004)**: 5-layer architecture already implements
         mediation pattern via PreToolUse hooks. Extend for credential brokering.

      4. **Session Persistence (OQ-005)**: Ledger-driven model confirmed. Recovery
         infrastructure exists; LEASE_REVOKED signaling is implementation gap.

      5. **Signing Infrastructure (OQ-006)**: Comprehensive Ed25519 + canonicalization
         exists. Extend to new kernel events for domain-separated signing.

      6. **Governance Integration (OQ-002)**: PolicyEngine exists but NOT wired.
         Implementation must add daemon->governance call path.

      7. **xtask Deprecation (OQ-007)**: Only 4 of 15 commands in scope. GitHub/SCM
         workflow tools are out of scope for daemon control plane.
