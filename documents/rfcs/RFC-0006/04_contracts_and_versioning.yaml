rfc_contracts_and_versioning:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"

  contracts:
    - id: CONTRACT-006-001
      name: "cargo xtask lint command contract"
      description: |
        New command for automated anti-pattern detection in the codebase.
      interface:
        command: "cargo xtask lint"
        output_format: "Warnings for detected anti-patterns"
        exit_codes:
          0: "No anti-patterns detected"
          0: "Anti-patterns detected (warnings only, does not fail)"
        patterns_checked:
          - pattern: "std::env::temp_dir"
            message: "Use tempfile::NamedTempFile instead of std::env::temp_dir"
            rationale: "Predictable paths, no cleanup, world-readable"
          - pattern: "shell interpolation with markdown"
            message: "Write prompts to temp file and redirect input"
            rationale: "Shell escaping breaks with special characters"
      backward_compatible: true
      notes: "New command; no existing behavior changed"

    - id: CONTRACT-006-002
      name: "Enhanced cargo xtask commit clippy contract"
      description: |
        Extended clippy lints in pre-commit checks.
      interface:
        additional_lints:
          - lint: "clippy::doc_markdown"
            level: "deny"
            rationale: "Catches missing backticks in docs"
          - lint: "clippy::match_same_arms"
            level: "deny"
            rationale: "Catches redundant match arms"
          - lint: "clippy::missing_const_for_fn"
            level: "warn"
            rationale: "Suggests const functions"
        tip_displayed: "Tip: Use `..` to ignore unmatched struct fields in patterns"
      backward_compatible: true
      notes: "Stricter lints may fail previously-passing code"

    - id: CONTRACT-006-003
      name: "cargo xtask check remediation output contract"
      description: |
        Failure-type-specific remediation commands in check output.
      interface:
        remediation_commands:
          Clippy: "cargo clippy --fix --allow-dirty"
          Fmt: "cargo fmt"
          Test: "cargo test --workspace"
          SecurityReview: "cargo xtask push --force-review"
          QualityReview: "cargo xtask push --force-review"
          SemverCheck: "cargo semver-checks"
      backward_compatible: true
      notes: "Additional output; existing behavior unchanged"

    - id: CONTRACT-006-004
      name: "cargo xtask review quality Gemini contract"
      description: |
        Code quality review uses Gemini CLI instead of Codex.
      interface:
        command: "cargo xtask review quality <PR_URL>"
        invocation_pattern: |
          1. Write CODE_QUALITY_PROMPT.md content to NamedTempFile
          2. Execute: script -qec "gemini --yolo < '{temp_path}'" /dev/null
          3. Parse output and post review comment
        ai_tool: "gemini"
        previous_ai_tool: "codex"
      backward_compatible: true
      notes: |
        External behavior unchanged (review comment posted). Internal
        implementation switches from Codex to Gemini CLI.

    - id: CONTRACT-006-005
      name: "Documentation contracts"
      description: |
        Documentation additions required by this RFC.
      documents:
        - path: "documents/skills/rust-textbook/26_apm2_safe_patterns_and_anti_patterns.md"
          additions:
            - section: "Anti-Patterns (Lessons Learned)"
              content: "ANTI-1 through ANTI-3 patterns"
            - pattern: "INV-2615"
              content: "Counters and Attempts Are Monotonic (APPLY: INV-2502)"
        - path: "documents/reviews/SECURITY_REVIEW_PROMPT.md"
          additions:
            - section: "Historical Issue Patterns (Check First)"
              content: "State machine, temp file, shell, struct patterns"
      backward_compatible: true
      notes: "Additions to existing documentation"

    - id: CONTRACT-006-006
      name: "Reviewer agent health monitoring contract"
      description: |
        The check command monitors AI reviewer agent health and auto-remediates
        unhealthy agents.
      interface:
        state_file: "~/.apm2/reviewer_state.json"
        state_file_creation: |
          Create parent directory (~/.apm2) with 0700 permissions if it doesn't exist.
          State file is written atomically (write to .tmp, then rename).
        state_schema: |
          {
            "reviewers": {
              "<review_type>": {
                "pid": <number>,
                "started_at": "<ISO8601>",
                "log_file": "<absolute_path>",
                "pr_url": "<github_pr_url>",
                "head_sha": "<commit_sha>"
              }
            }
          }
        health_indicators:
          - name: "process_alive"
            description: "Whether the PID exists in process table"
            detection: |
              Unix: kill(pid, 0) == 0 (signal 0 just checks existence)
              Cross-platform fallback: std::fs::metadata("/proc/<pid>").is_ok()
          - name: "last_activity"
            description: "Timestamp of last output (any activity)"
            detection: |
              stat(log_file).mtime - file modification time
              This is reliable because any Gemini output updates the log file.
        health_status:
          HEALTHY: "PID alive AND log_file mtime < 300s ago"
          STALE: "PID alive AND log_file mtime >= 300s ago"
          DEAD: "PID not alive (regardless of log_file mtime)"
          NOT_STARTED: "No entry in state file for this review type"
        output_format: |
          Fixed-width columns for alignment (shown with | as visual separator):
          - Label column: 10 chars, left-aligned ("Security:" or "Quality: ")
          - PID column: "PID " + 6 digits right-aligned (padded with spaces)
          - Activity column: "Last activity: " + 5 chars right-aligned + " ago"
          - Status column: "Status: " + status enum name

          Example output:
          ```
          Reviewer Agents:
          ----------------
            Security: PID  12345 | Last activity:   30s ago | Status: HEALTHY
            Quality:  PID  12346 | Last activity:   90s ago | Status: STALE [!]
          ```

          Format string (Rust):
          println!("  {:<9} PID {:>6} | Last activity: {:>5} ago | Status: {}{}",
                   format!("{}:", name), pid, elapsed_str, status,
                   if status == "STALE" || status == "DEAD" { " [!]" } else { "" });

          When no reviewers are active:
          ```
          Reviewer Agents:
          ----------------
            No active reviewers
          ```
        auto_remediation:
          trigger: "Status is STALE or DEAD"
          actions:
            - step: 1
              action: "Send SIGTERM to process"
              code: "nix::sys::signal::kill(Pid::from_raw(pid), Signal::SIGTERM)"
            - step: 2
              action: "Wait up to 5 seconds for graceful exit"
              code: "Poll for process exit with 100ms intervals"
            - step: 3
              action: "Send SIGKILL if still alive after 5s"
              code: "nix::sys::signal::kill(Pid::from_raw(pid), Signal::SIGKILL)"
            - step: 4
              action: "Remove entry from state file atomically"
              code: "Write to temp file, then rename"
            - step: 5
              action: "Re-trigger review with same PR URL and HEAD SHA"
              code: "Call trigger_ai_review() with saved parameters"
            - step: 6
              action: "Update state file with new reviewer entry"
          output: |
            [!] Quality reviewer stale (90s since last activity)
                Auto-remediating: killing PID 12346 and restarting review...
                Restarted quality review (new PID: 12400)
        error_handling:
          state_file_missing: "Treat as no active reviewers; allow fresh reviews"
          state_file_corrupt: "Log warning, delete corrupt file, allow fresh reviews"
          kill_fails: "Log warning (process may have exited), continue with cleanup"
          restart_fails: "Log error with details; suggest manual: cargo xtask push --force-review"
        log_file_lifecycle:
          creation: "Created via tempfile::Builder when spawning review"
          during_review: "Kept alive via std::mem::forget() to prevent premature deletion"
          on_remediation: "Deleted after killing process, before restarting"
          on_success: |
            When the AI reviewer completes successfully (posts comment, updates status),
            the reviewer is expected to exit. The next `cargo xtask check` will detect
            the DEAD status, remove the entry from state file, and delete the log file.
            This is the normal cleanup path.
          on_new_review: |
            When `cargo xtask push` starts a new review of the same type, it will:
            1. Check if an existing reviewer of that type is running
            2. If running, log a warning but proceed (old entry will be overwritten)
            3. Create new state entry (overwrites old)
            The old log file will be orphaned but is in temp directory and will be
            cleaned up by OS. To prevent orphans, push could kill old reviewer first.
      backward_compatible: true
      notes: |
        New functionality added to check command. Existing check behavior
        unchanged; reviewer health is additional output section.
        Requires nix crate for signal handling (must be added to xtask/Cargo.toml).

  versioning:
    strategy: "No version bump required"
    rationale: |
      These are enhancements and improvements to internal developer tooling.
      The xtask commands are internal tools, not public APIs. Changes are
      additive and backward compatible:
      - New lint command (additive)
      - Enhanced clippy lints (may catch more issues)
      - Better check output (informational improvement)
      - Gemini for code quality (implementation change, same external behavior)
      - Documentation additions (additive)
      - Reviewer health monitoring (additive, with auto-remediation)
