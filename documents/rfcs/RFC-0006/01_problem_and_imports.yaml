rfc_problem_and_imports:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"

  problem_statement:
    summary: "9 issues discovered during PR #58 and #59 merging require systematic remediation"
    context: |
      During the implementation and review of PR #58 (crash detection and restart logic)
      and PR #59, multiple categories of issues were discovered that slowed down the
      dev loop and required multiple review iterations. These issues fall into three
      categories:

      Category A - Tool Reliability Issues:
      - A1: Gemini CLI headless mode fails (shell tools filtered in headless mode)
      - A2: Shell escaping breaks with markdown (complex prompts as CLI args)
      - A3: Insecure temp file creation (predictable names, world-readable)

      Category B - State Machine Bugs (Found by Security Review):
      - B1: Session ID collision on restart (reducer rejected terminal restarts)
      - B2: Missing state tracking fields (resume_cursor, restart_attempt missing)
      - B3: Monotonicity violation (no restart_attempt enforcement)

      Category C - Compile/Lint Errors:
      - C1: Pattern match errors (new struct fields not matched)
      - C2: Clippy doc-markdown warnings (missing backticks in docs)
      - C3: Match arms identical bodies (redundant arms not combined)

      Root causes include: missing anti-pattern documentation, insufficient local
      checks, no historical knowledge capture, and inconsistent AI reviewer tooling.

    observed_symptoms:
      - category: "Tool Reliability"
        issue_ids: ["A1", "A2", "A3"]
        description: |
          AI tool invocation patterns were unreliable due to shell escaping issues
          and insecure temp file handling. Gemini CLI in headless mode filtered out
          shell tools, causing reviews to fail silently.
        impact: "Review cycles failed or produced incomplete results"

      - category: "State Machine Bugs"
        issue_ids: ["B1", "B2", "B3"]
        description: |
          Restart logic implementation had subtle bugs that security review caught.
          The reducer rejected restarts of terminal sessions, state tracking fields
          were missing, and monotonicity of restart_attempt was not enforced.
        impact: "Multiple review iterations required to fix state machine issues"

      - category: "Compile/Lint Errors"
        issue_ids: ["C1", "C2", "C3"]
        description: |
          New struct fields weren't matched in all pattern matches, causing compile
          errors. Clippy warnings for doc-markdown (missing backticks) and redundant
          match arms required additional fix commits.
        impact: "CI failures caught issues that could have been caught locally"

    goals:
      - "Document learned anti-patterns in coding guidelines"
      - "Enhance pre-commit checks with explicit clippy lints"
      - "Add historical issue patterns to security review prompt"
      - "Add test coverage for restart monotonicity and AI tool invocation"
      - "Improve check workflow with specific remediation guidance"
      - "Add automated anti-pattern detection (lint command)"
      - "Switch code quality reviewer from Codex to Gemini CLI"
      - "Add reviewer agent health monitoring to check command"

    non_goals:
      - "Redesign the xtask command architecture"
      - "Change the security review workflow fundamentally"
      - "Add new AI reviewer integrations beyond Gemini"

  implementation_note: |
    All improvements are additive enhancements to existing xtask tooling and
    documentation. No breaking changes to existing workflows. The switch to
    Gemini CLI for code quality review unifies AI reviewer tooling (Gemini
    for both security and code quality reviews).

  technical_context:
    temp_file_security:
      description: |
        Secure temporary file creation requires using the tempfile crate's
        NamedTempFile which creates files with 0600 permissions in a secure
        temporary directory.
      anti_pattern: |
        std::env::temp_dir().join("predictable_name.txt")
        // World-readable, predictable path, not cleaned up on panic
      safe_pattern: |
        let temp = NamedTempFile::new()?;
        temp.write_all(content)?;
        // Auto-cleaned up, 0600 permissions, unpredictable path

    shell_escaping:
      description: |
        Complex prompts containing markdown should not be passed as CLI
        arguments. Instead, write to a temp file and redirect input.
      anti_pattern: |
        Command::new("gemini").args(["--prompt", &markdown_content])
        // Breaks with special characters, quotes, backticks
      safe_pattern: |
        let temp = NamedTempFile::new()?;
        temp.write_all(prompt.as_bytes())?;
        Command::new("sh").args(["-c", &format!(
            "script -qec \"gemini --yolo < '{}'\" /dev/null",
            temp.path().display()
        )])

    restart_monotonicity:
      description: |
        The restart_attempt counter must be strictly monotonic to prevent
        replay attacks and ensure consistent state machine behavior.
      invariant: "new_restart_attempt > old_restart_attempt || old is terminal"

    reviewer_agent_health:
      description: |
        AI reviewer agents (Gemini processes) can become stale or crash during
        long reviews. The check command needs to monitor agent health to detect
        and auto-remediate unhealthy agents.
      health_indicators:
        - field: "process_alive"
          description: "Whether the PID of the spawned Gemini process is alive"
          detection: "Check if PID exists via kill(pid, 0) or /proc/<pid>"
        - field: "last_activity_timestamp"
          description: "Timestamp of the last activity from the agent"
          detection: |
            Use log file modification time (mtime) as the primary activity indicator.
            This is reliable because:
            - Gemini writes to stdout/stderr which is captured in the log
            - Any tool execution produces output that updates mtime
            - No need to parse Gemini's output format (which may change)
            Fallback: If mtime unchanged for >300s but process is alive, treat as stale.
      stale_threshold: "300 seconds (5 minutes) since last activity (log file mtime)"
      state_storage: |
        Store reviewer state in a JSON file (~/.apm2/reviewer_state.json).
        Use atomic writes (write to temp file, then rename) to prevent corruption.
        Schema:
        {
          "reviewers": {
            "security": {
              "pid": 12345,
              "started_at": "2026-01-25T01:30:00Z",
              "log_file": "/tmp/apm2_review_security_abc123.log",
              "pr_url": "https://github.com/owner/repo/pull/123",
              "head_sha": "abc123def456"
            },
            "quality": {
              "pid": 12346,
              "started_at": "2026-01-25T01:30:00Z",
              "log_file": "/tmp/apm2_review_quality_def456.log",
              "pr_url": "https://github.com/owner/repo/pull/123",
              "head_sha": "abc123def456"
            }
          }
        }
      log_capture: |
        Capture Gemini output using script's built-in logging feature.
        Two invocation patterns are used:

        1. Without log capture (discard typescript):
           script -qec "gemini --yolo < '{prompt_path}'" /dev/null
           Used by: review.rs run_ai_review() for synchronous reviews

        2. With log capture (for health monitoring):
           script -q "{log_path}" -c "gemini --yolo < '{prompt_path}'"
           Used by: push.rs trigger_ai_reviews() for background reviews

        The -q flag suppresses start/done messages.
        The -e flag returns the exit code of the child process.
        The -c flag specifies the command to run.
        The log file's mtime updates whenever new output is written.
      auto_remediation: |
        When an agent is unhealthy (process dead or last_activity > 300s ago):
        1. Send SIGTERM to process, wait 5s, then SIGKILL if still alive
        2. Remove entry from state file (using atomic write)
        3. Re-trigger review with same PR URL and HEAD SHA
        4. Log remediation action: "[!] Quality reviewer stale (90s), restarting..."
        5. Update state file with new reviewer entry

  imports:
    prd_requirements: []
    # NOTE: This is a maintenance RFC for dev loop improvements.
    # Requirements are defined inline below as RFC-local requirements.

  rfc_local_requirements:
    rationale: |
      These requirements address issues discovered during PR #58 and #59 merging.
      They focus on improving the dev loop through better documentation, enhanced
      local checks, additional test coverage, and unified AI reviewer tooling.

    requirements:
      - id: MAINT-006
        type: ENHANCEMENT
        title: "Document learned anti-patterns in coding guidelines"
        statement: |
          The coding guidelines MUST include a section on learned anti-patterns
          covering: shell argument escaping for complex strings, predictable temp
          file names, and incomplete struct field updates.
        acceptance_criteria:
          - "Anti-patterns section exists in SAFE_RUST_PATTERNS.md with 3 documented patterns"
          - "SAFE-16 pattern exists for restart monotonicity"
          - "Referenced from main coding SKILL.md"
        verification:
          command: "grep 'Anti-Patterns' documents/skills/coding/references/SAFE_RUST_PATTERNS.md"
          pass_condition: "Anti-patterns section found with documented patterns"

      - id: MAINT-007
        type: ENHANCEMENT
        title: "Enhanced clippy lints in pre-commit checks"
        statement: |
          The `cargo xtask commit` command MUST run enhanced clippy lints including
          doc_markdown, match_same_arms, and missing_const_for_fn.
        acceptance_criteria:
          - "Pre-commit catches doc-markdown warnings"
          - "Pre-commit catches match-same-arms warnings"
          - "Tip displayed about using .. in match patterns"
        verification:
          command: "cargo xtask commit 'test'"
          pass_condition: "Enhanced clippy lints are applied"

      - id: MAINT-008
        type: ENHANCEMENT
        title: "Historical issue patterns in security review prompt"
        statement: |
          The security review prompt MUST include a section on historical issue
          patterns to check first, derived from actual findings in prior PRs.
        acceptance_criteria:
          - "Prompt includes historical patterns section"
          - "Patterns cover state machine, temp files, shell, struct fields"
        verification:
          command: "grep 'Historical Issue Patterns' documents/reviews/SECURITY_REVIEW_PROMPT.md"
          pass_condition: "Historical patterns section found"

      - id: MAINT-009
        type: RELIABILITY
        title: "Test coverage for restart monotonicity"
        statement: |
          The session reducer MUST have explicit boundary tests for restart_attempt
          monotonicity including edge cases for 0->0, 0->1, 5->5, 5->6, MAX->any.
        acceptance_criteria:
          - "test_restart_monotonicity_boundary_cases test exists and passes"
          - "test_restart_preserves_terminal_state_data test exists and passes"
        verification:
          command: "cargo test -p apm2-core test_restart_monotonicity"
          pass_condition: "All restart monotonicity tests pass"

      - id: MAINT-010
        type: RELIABILITY
        title: "Test coverage for AI tool invocation patterns"
        statement: |
          The xtask push and review commands MUST have tests for temp file security
          properties (0600 permissions) and script command format validity.
        acceptance_criteria:
          - "test_temp_file_security test exists and passes"
          - "test_script_command_format test exists and passes"
        verification:
          command: "cargo test -p xtask test_temp_file"
          pass_condition: "All temp file and script command tests pass"

      - id: MAINT-011
        type: ENHANCEMENT
        title: "Specific remediation guidance in check workflow"
        statement: |
          The `cargo xtask check` command MUST display failure-type-specific
          remediation commands (e.g., cargo fmt, cargo clippy --fix).
        acceptance_criteria:
          - "Clippy failures show: cargo clippy --fix --allow-dirty"
          - "Fmt failures show: cargo fmt"
          - "Test failures show: cargo test --workspace"
        verification:
          command: "cargo xtask check"
          pass_condition: "Specific fix commands shown for each failure type"

      - id: MAINT-012
        type: ENHANCEMENT
        title: "Automated anti-pattern detection (lint command)"
        statement: |
          A new `cargo xtask lint` command MUST check for anti-patterns including
          direct std::env::temp_dir usage and shell interpolation patterns.
        acceptance_criteria:
          - "cargo xtask lint catches temp file anti-patterns"
          - "cargo xtask lint catches shell interpolation anti-patterns"
          - "Warnings (not errors) issued for anti-patterns"
        verification:
          command: "cargo xtask lint"
          pass_condition: "Anti-pattern detection runs without errors"

      - id: MAINT-013
        type: ENHANCEMENT
        title: "Switch code quality reviewer to Gemini CLI"
        statement: |
          The code quality review MUST use Gemini CLI instead of Codex, using the
          same secure temp file + script pattern as security review.
        acceptance_criteria:
          - "cargo xtask review quality uses Gemini CLI"
          - "cargo xtask push triggers Gemini for code quality review"
          - "Code quality review posts comment and updates status"
        verification:
          command: "cargo xtask review quality <PR_URL>"
          pass_condition: "Gemini CLI invoked without errors"

      - id: MAINT-014
        type: RELIABILITY
        title: "Reviewer agent health monitoring in check command"
        statement: |
          The `cargo xtask check` command MUST monitor and report the health of
          AI reviewer agents. For each active reviewer, it MUST report:
          1. Whether the process PID is alive (status)
          2. The timestamp of last activity (based on log file mtime)
          When an agent is unhealthy (dead process or last activity >300s ago),
          the check command MUST auto-remediate by killing the stale process
          and re-triggering the review.
        acceptance_criteria:
          - "Check displays reviewer PID alive/dead status for each review type"
          - "Check displays last activity timestamp for each active reviewer"
          - "Unhealthy reviewers (>300s stale) are automatically killed and restarted"
          - "Reviewer state persisted in ~/.apm2/reviewer_state.json"
          - "Gemini output redirected to log file for activity tracking (mtime)"
        verification:
          command: "cargo xtask check"
          pass_condition: |
            Output includes reviewer health section showing:
            - Security: PID <pid> | Last activity: <elapsed> ago | Status: HEALTHY/STALE/DEAD
            - Quality:  PID <pid> | Last activity: <elapsed> ago | Status: HEALTHY/STALE/DEAD
            Auto-remediation occurs when status is STALE or DEAD

      - id: MAINT-015
        type: SECURITY
        title: "Shell command construction MUST use safe quoting utilities"
        statement: |
          All shell command construction in xtask MUST use safe quoting utilities
          to prevent shell injection vulnerabilities from paths containing special
          characters (spaces, quotes, backticks, etc.).
        acceptance_criteria:
          - "quote_path() utility exists for safe path quoting"
          - "build_script_command() helper exists for PTY-wrapped commands"
          - "No raw format!() shell string construction in xtask"
          - "All shell paths use quote_path() or equivalent"
        verification:
          command: "grep -r 'format!' xtask/src | grep -v quote_path"
          pass_condition: "No unquoted path interpolation in shell commands"

      - id: MAINT-016
        type: ENHANCEMENT
        title: "Reviewer spawn logic MUST be centralized"
        statement: |
          All reviewer spawning logic (temp file creation, prompt interpolation,
          script command construction, state persistence) MUST be centralized
          in a single ReviewerSpawner component to eliminate code duplication.
        acceptance_criteria:
          - "ReviewerSpawner struct exists with spawn() method"
          - "push.rs, check.rs, review.rs all use ReviewerSpawner"
          - "No duplicate spawn logic exists across modules"
        verification:
          command: "cargo xtask lint --check-duplication"
          pass_condition: "No duplicated spawn code patterns found"

      - id: MAINT-017
        type: ENHANCEMENT
        title: "Process checks SHOULD be cross-platform"
        statement: |
          Process checking (PID alive, cmdline inspection) SHOULD use
          cross-platform APIs instead of Linux-specific /proc filesystem
          to enable macOS compatibility.
        acceptance_criteria:
          - "No direct /proc filesystem access"
          - "sysinfo crate used for process introspection"
          - "Code compiles for macOS target"
        verification:
          command: "cargo build --target x86_64-apple-darwin"
          pass_condition: "Compiles successfully or documents exception"

      - id: MAINT-018
        type: SECURITY
        title: "Temp files MUST be tracked for reliable cleanup"
        statement: |
          Temporary files created during reviewer execution MUST be tracked
          in the reviewer state file for reliable cleanup. Manual rm -f in
          shell commands MUST NOT be used for temp file cleanup.
        acceptance_criteria:
          - "Temp files tracked in reviewer_state.json"
          - "No rm -f in shell command construction"
          - "Orphaned temp files cleaned up by check command"
        verification:
          command: "grep -r 'rm -f' xtask/src"
          pass_condition: "No rm -f in shell commands"

      - id: MAINT-019
        type: ENHANCEMENT
        title: "Documentation examples MUST pass lint checks"
        statement: |
          Code examples in documentation (especially SAFE_RUST_PATTERNS.md)
          MUST pass the same anti-pattern lint checks as production code
          to prevent documentation from teaching bad patterns.
        acceptance_criteria:
          - "cargo xtask lint --include-docs scans markdown code blocks"
          - "Detects unquoted shell paths in examples"
          - "Warning displayed during commit if doc examples violate patterns"
        verification:
          command: "cargo xtask lint --include-docs"
          pass_condition: "No anti-pattern warnings in documentation"

      # Phase 5: AAT Completion and Check Watch Fix
      - id: AAT-001
        type: ENHANCEMENT
        title: "AAT MUST support configurable AI tool backend"
        statement: |
          The AAT command MUST support configuring the AI tool backend via
          environment variable (AAT_AI_TOOL) with CLI flag override (--ai-tool).
          Supported values: gemini, claude-code. Default: gemini.
        acceptance_criteria:
          - "AAT_AI_TOOL environment variable selects backend"
          - "Supported values: gemini, claude-code"
          - "--ai-tool CLI flag overrides environment variable"
          - "Default is gemini when neither set"
        verification:
          command: "AAT_AI_TOOL=claude-code cargo xtask aat --dry-run <URL>"
          pass_condition: "Uses claude-code backend"

      - id: AAT-002
        type: ENHANCEMENT
        title: "Hypothesis generation MUST use AI tool"
        statement: |
          The AAT hypothesis generation MUST invoke the configured AI tool
          with PR description and diff to generate testable hypotheses.
          The stub implementation MUST be replaced with real AI invocation.
        acceptance_criteria:
          - "AI tool invoked for hypothesis generation"
          - "PR description and diff passed to AI"
          - "At least 3 hypotheses generated"
          - "At least 1 hypothesis tests error handling"
        verification:
          command: "cargo xtask aat <PR_URL> --dry-run"
          pass_condition: "AI-generated hypotheses in output"

      - id: AAT-003
        type: ENHANCEMENT
        title: "Hypotheses MUST be executed and verified"
        statement: |
          Each generated hypothesis MUST be executed by running its
          verification_method command. The stdout, stderr, exit code,
          and executed_at timestamp MUST be captured and stored.
        acceptance_criteria:
          - "Verification commands are executed"
          - "stdout and stderr captured"
          - "exit_code captured"
          - "executed_at set AFTER command execution"
          - "Result marked PASSED/FAILED based on exit code"
        verification:
          command: "cargo xtask aat <PR_URL>"
          pass_condition: "Hypotheses show execution results with stdout/stderr"

      - id: AAT-004
        type: ENHANCEMENT
        title: "AAT MUST test input variations to detect invariance"
        statement: |
          For each CLI command in hypotheses, AAT MUST generate at least 3
          input variations, execute each, and detect invariance (identical
          output for different inputs) as an anti-gaming violation.
        acceptance_criteria:
          - "At least 3 input variations per CLI command"
          - "Each variation executed with output captured"
          - "Invariance detected when all outputs identical"
          - "Invariance flagged as anti-gaming violation"
        verification:
          command: "cargo xtask aat <PR_URL>"
          pass_condition: "Input variations tested and invariance checked"

      - id: AAT-005
        type: BUG_FIX
        title: "Anti-gaming MUST detect ISO timestamps"
        statement: |
          The anti-gaming analysis MUST detect hardcoded ISO 8601 timestamps
          (e.g., 2026-01-25T10:00:00Z) in PR diffs as potential gaming.
        acceptance_criteria:
          - "TIMESTAMP_REGEX matches ISO 8601 format"
          - "HardcodedTimestamp violation variant exists"
          - "Timestamps in added lines detected"
          - "Tests for timestamp detection pass"
        verification:
          command: "cargo test -p xtask test_timestamp"
          pass_condition: "Timestamp detection tests pass"

      - id: AAT-006
        type: ENHANCEMENT
        title: "Evidence script MUST be validated; PR format MUST be verified"
        statement: |
          AAT MUST validate that evidence scripts exist and are executable,
          Usage sections contain code blocks, and Expected Outcomes follow
          When/Then format. Actionable errors MUST be returned for failures.
        acceptance_criteria:
          - "Evidence script path validated for existence"
          - "Evidence script validated for executable permission"
          - "Usage section requires at least 1 code block"
          - "Expected outcomes require BOTH When AND Then keywords"
          - "Actionable error messages for each failure"
        verification:
          command: "cargo xtask aat <PR_URL> --dry-run"
          pass_condition: "Validation errors shown with fix suggestions"

      - id: CHECK-001
        type: BUG_FIX
        title: "Watch mode MUST exit on terminal states with 180s timeout"
        statement: |
          The check --watch command MUST exit immediately on terminal states
          (Closed, CI Failure, Changes Requested) with exit code 1, and MUST
          timeout after 180 seconds with exit code 2 and remediation suggestion.
        acceptance_criteria:
          - "Exits on PrState::Closed with exit code 1"
          - "Exits on CiStatus::Failure with exit code 1"
          - "Exits on ReviewStatus::ChangesRequested with exit code 1"
          - "Exits after 180s timeout with exit code 2"
          - "Timeout message suggests manually restarting slow checks"
          - "Clear message printed for each exit condition"
        verification:
          command: "cargo xtask check --watch"
          pass_condition: "Exits on terminal states instead of hanging"
