rfc_ticket_decomposition:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"

  decomposition_strategy: |
    Phased implementation with dependency ordering:
    - Phase 0: Documentation (parallel, no dependencies)
    - Phase 1: Local checks (parallel, no dependencies)
    - Phase 2: Test coverage (parallel, no dependencies)
    - Phase 3: Workflow improvements (dependencies on earlier phases)

  phases:
    - phase: 0
      name: "Documentation & Guidelines"
      description: "Capture learned anti-patterns and historical issue patterns"
      tickets:
        - ticket_id: "TCK-00059"
          title: "Add Learned Anti-Patterns to Coding Guidelines"
          requirements:
            - "MAINT-006"
          dependencies: []
          scope_summary: |
            Update coding guidelines with anti-patterns discovered during PR #58 and #59:

            Files to modify:
            - documents/skills/rust-textbook/26_apm2_safe_patterns_and_anti_patterns.md
            - documents/skills/coding/SKILL.md (add reference to anti-patterns section)

            Add "Anti-Patterns (Lessons Learned)" section:
            - ANTI-1: Shell argument escaping for complex strings
              Problem: Passing markdown/complex prompts as CLI arguments
              Solution: Write to temp file and redirect input
            - ANTI-2: Predictable temp file names
              Problem: std::env::temp_dir().join("fixed_name.txt")
              Solution: Use tempfile::NamedTempFile
            - ANTI-3: Incomplete struct field updates
              Problem: Adding struct fields without updating all pattern matches
              Solution: Use .. to ignore unmatched fields, run cargo check

            Add INV-2615: Counters and Attempts Are Monotonic
            - Invariant: new_restart_attempt > old_restart_attempt (unless terminal)
            - Implementation: Check in reducer before state transition

            Acceptance Criteria:
            - Anti-patterns section exists with 3 documented patterns
            - INV-2615 exists for restart monotonicity (APPLY: INV-2502)
            - Referenced from main SKILL.md

        - ticket_id: "TCK-00060"
          title: "Add Historical Issue Patterns to Security Review Prompt"
          requirements:
            - "MAINT-008"
          dependencies: []
          scope_summary: |
            Update security review prompt with historical issue patterns:

            Files to modify:
            - documents/reviews/SECURITY_REVIEW_PROMPT.md

            Add "Historical Issue Patterns (Check First)" section:
            1. State machine restart logic patterns
               - Verify restart_attempt monotonicity
               - Check terminal state transitions
               - Validate session ID handling on restart
            2. Temp file handling patterns
               - Check for std::env::temp_dir usage
               - Verify 0600 permissions
               - Check cleanup on error paths
            3. Shell/process spawning patterns
               - Check for shell interpolation with user data
               - Verify argument escaping for multi-word strings
               - Check for script command usage for PTY
            4. Struct field addition patterns
               - Verify all pattern matches updated
               - Check for missing fields in constructors
               - Verify serialization/deserialization coverage

            Acceptance Criteria:
            - Prompt includes historical patterns section
            - Patterns derived from actual findings in PR #58 and #59

    - phase: 1
      name: "Enhanced Local Checks"
      description: "Improve pre-commit checks and add automated pattern validation"
      tickets:
        - ticket_id: "TCK-00061"
          title: "Enhance Pre-Commit Clippy Lints"
          requirements:
            - "MAINT-007"
          dependencies: []
          scope_summary: |
            Enhance clippy lints in the commit command:

            Files to modify:
            - xtask/src/tasks/commit.rs

            Changes:
            1. Add explicit clippy lints to the clippy invocation:
               - -D clippy::doc_markdown (catch missing backticks)
               - -D clippy::match_same_arms (catch redundant arms)
               - -W clippy::missing_const_for_fn (suggest const)

            2. Add tip about `..` in match patterns:
               Display: "Tip: Use `..` to ignore unmatched struct fields in patterns"

            Acceptance Criteria:
            - Pre-commit catches doc-markdown warnings
            - Pre-commit catches match-same-arms warnings
            - Tip displayed during clippy check

        - ticket_id: "TCK-00062"
          title: "Add Automated Pattern Validation"
          requirements:
            - "MAINT-012"
          dependencies: []
          scope_summary: |
            Create new cargo xtask lint command for anti-pattern detection:

            Files to create:
            - xtask/src/tasks/lint.rs (new)

            Files to modify:
            - xtask/src/tasks/mod.rs (add lint module)
            - xtask/src/main.rs (add lint subcommand)

            Implementation:
            1. Create LintArgs struct with optional --fix flag
            2. Implement anti-pattern checks:
               - Check for direct std::env::temp_dir usage
                 Pattern: r"std::env::temp_dir\(\)"
                 Warning: "Use tempfile::NamedTempFile instead"
               - Check for shell interpolation patterns
                 Pattern: r"Command::new.*args.*\{.*\}" with markdown content
                 Warning: "Write prompts to temp file and redirect input"
            3. Report warnings (not errors) for anti-patterns
            4. Return success even with warnings

            Acceptance Criteria:
            - cargo xtask lint catches temp file anti-patterns
            - cargo xtask lint catches shell interpolation anti-patterns
            - Warnings issued but command succeeds

    - phase: 2
      name: "Test Coverage"
      description: "Add boundary tests for restart logic and AI tool invocation"
      tickets:
        - ticket_id: "TCK-00063"
          title: "Add Restart Monotonicity Boundary Tests"
          requirements:
            - "MAINT-009"
          dependencies: []
          scope_summary: |
            Add boundary tests for restart_attempt monotonicity:

            Files to modify:
            - crates/apm2-core/src/session/reducer.rs (add tests)

            Test cases:
            1. test_restart_monotonicity_boundary_cases
               - restart_attempt 0 -> 0: MUST FAIL
               - restart_attempt 0 -> 1: MUST succeed
               - restart_attempt 5 -> 5: MUST FAIL
               - restart_attempt 5 -> 6: MUST succeed
               - restart_attempt u32::MAX -> any: MUST FAIL (overflow)

            2. test_restart_preserves_terminal_state_data
               - Verify last_restart_attempt preserved in terminal states
               - Verify resume_cursor preserved in terminal states
               - Verify error context preserved in Crashed state

            Acceptance Criteria:
            - cargo test test_restart_monotonicity_boundary_cases passes
            - cargo test test_restart_preserves_terminal_state_data passes

        - ticket_id: "TCK-00064"
          title: "Add AI Tool Invocation Tests"
          requirements:
            - "MAINT-010"
          dependencies: []
          scope_summary: |
            Add tests for AI tool invocation patterns:

            Files to modify:
            - xtask/src/tasks/push.rs (add tests)
            - xtask/src/tasks/review.rs (add tests)

            Test cases:
            1. test_temp_file_security
               - Create NamedTempFile and verify permissions are 0600
               - Verify file path is unpredictable (not in fixed location)
               - Verify file is cleaned up after drop

            2. test_script_command_format
               - Verify script command format is valid
               - Verify input redirection syntax
               - Verify PTY allocation via script

            Acceptance Criteria:
            - cargo test -p xtask test_temp_file_security passes
            - cargo test -p xtask test_script_command_format passes

    - phase: 3
      name: "Workflow Improvements"
      description: "Improve error messages and switch to Gemini for code quality"
      tickets:
        - ticket_id: "TCK-00065"
          title: "Improve Check Workflow Error Messages"
          requirements:
            - "MAINT-011"
          dependencies:
            - "TCK-00061"
          scope_summary: |
            Add failure-type-specific remediation commands:

            Files to modify:
            - xtask/src/tasks/check.rs

            Add remediation mapping:
            - Clippy failure: "Run: cargo clippy --fix --allow-dirty"
            - Fmt failure: "Run: cargo fmt"
            - Test failure: "Run: cargo test --workspace"
            - SecurityReview failure: "Run: cargo xtask push --force-review"
            - QualityReview failure: "Run: cargo xtask push --force-review"
            - SemverCheck failure: "Run: cargo semver-checks"

            Display format:
            ```
            [X] Clippy checks failed
                Fix: cargo clippy --fix --allow-dirty
            ```

            Acceptance Criteria:
            - cargo xtask check shows specific fix commands for each failure type

        - ticket_id: "TCK-00066"
          title: "Switch Code Quality Reviewer to Gemini CLI"
          requirements:
            - "MAINT-013"
          dependencies:
            - "TCK-00064"
          scope_summary: |
            Replace Codex with Gemini CLI for code quality review:

            Files to modify:
            - xtask/src/tasks/push.rs
            - xtask/src/tasks/review.rs

            Changes:
            1. Update ReviewType::Quality.ai_tool() to return "gemini" (line 64 in review.rs, in the ai_tool() method)
            2. Replace Codex invocation with Gemini CLI pattern:

            Current (review.rs lines 304-331, in the ReviewType::Quality match arm):
            ```rust
            ReviewType::Quality => {
                // Codex uses the 'review' subcommand to review changes against base branch.
                // The review subcommand runs non-interactively by default.
                let result = std::process::Command::new("codex")
                    .args(["review", "--base", "main"])
                    .status();
                // ... error handling ...
            }
            ```

            After (same pattern as security review, lines 261-282):
            ```rust
            let result = NamedTempFile::new().and_then(|mut temp_file| {
                temp_file.write_all(prompt.as_bytes())?;
                let prompt_path = temp_file.path().display().to_string();
                let shell_cmd =
                    format!("script -qec \"gemini --yolo < '{prompt_path}'\" /dev/null");
                std::process::Command::new("sh")
                    .args(["-c", &shell_cmd])
                    .status()
            });
            ```

            3. Ensure CODE_QUALITY_PROMPT.md exists at documents/reviews/CODE_QUALITY_PROMPT.md
               (referenced by review.rs line 55; create if missing with code quality review criteria)
            4. Update doc comment on ReviewType::Quality (line 26-27) to say:
               "Code quality review using Gemini and `CODE_QUALITY_PROMPT.md`"
               (was: "Code quality review using Codex and `CODE_QUALITY_PROMPT.md`")
            5. Update push.rs trigger_ai_reviews() (lines 345-357) to use Gemini pattern for quality:
               - Replace codex check with gemini check (both already use gemini_available)
               - Use same temp file + script pattern as security review

            Acceptance Criteria:
            - cargo xtask review quality <PR_URL> uses Gemini CLI
            - cargo xtask push triggers Gemini for code quality review
            - Code quality review posts comment and updates status

        - ticket_id: "TCK-00067"
          title: "Add Reviewer Agent Health Monitoring"
          requirements:
            - "MAINT-014"
          dependencies:
            - "TCK-00066"
          scope_summary: |
            Add health monitoring for AI reviewer agents to the check command:

            Files to create:
            - xtask/src/reviewer_state.rs (new module for state management)

            Files to modify:
            - xtask/src/tasks/check.rs (add health monitoring display and auto-remediation)
            - xtask/src/tasks/push.rs (write state on spawn, redirect output to log)
            - xtask/src/tasks/review.rs (write state on spawn, redirect output to log)
            - xtask/src/main.rs (add reviewer_state module)

            Dependencies to add (xtask/Cargo.toml):
            - chrono = { workspace = true } (already present)
            - nix = { workspace = true } (must add - for kill syscall; available in workspace)
            - directories = { workspace = true } (must add - for home_dir; available in workspace as "directories")

            Implementation:

            1. Create reviewer_state.rs module with types:
               ```rust
               use chrono::{DateTime, Utc};
               use serde::{Deserialize, Serialize};
               use std::collections::HashMap;
               use std::path::PathBuf;

               #[derive(Debug, Clone, Serialize, Deserialize)]
               pub struct ReviewerEntry {
                   pub pid: u32,
                   pub started_at: DateTime<Utc>,
                   pub log_file: PathBuf,
                   pub pr_url: String,
                   pub head_sha: String,
               }

               #[derive(Debug, Clone, Copy, PartialEq, Eq)]
               pub enum HealthStatus {
                   Healthy,
                   Stale,
                   Dead,
               }

               #[derive(Debug, Default, Serialize, Deserialize)]
               pub struct ReviewerStateFile {
                   pub reviewers: HashMap<String, ReviewerEntry>,
               }
               ```

            2. Implement state file operations:
               ```rust
               impl ReviewerStateFile {
                   pub fn path() -> PathBuf {
                       directories::BaseDirs::new()
                           .expect("home dir")
                           .home_dir()
                           .join(".apm2")
                           .join("reviewer_state.json")
                   }

                   pub fn load() -> Result<Self> {
                       let path = Self::path();
                       if !path.exists() {
                           return Ok(Self::default());
                       }
                       let content = std::fs::read_to_string(&path)?;
                       Ok(serde_json::from_str(&content)?)
                   }

                   pub fn save(&self) -> Result<()> {
                       let path = Self::path();
                       // Ensure parent directory exists with 0700 permissions
                       if let Some(parent) = path.parent() {
                           std::fs::create_dir_all(parent)?;
                           #[cfg(unix)]
                           {
                               use std::os::unix::fs::PermissionsExt;
                               std::fs::set_permissions(parent,
                                   std::fs::Permissions::from_mode(0o700))?;
                           }
                       }
                       // Atomic write: temp file -> rename
                       let temp_path = path.with_extension("tmp");
                       std::fs::write(&temp_path, serde_json::to_string_pretty(self)?)?;
                       std::fs::rename(&temp_path, &path)?;
                       Ok(())
                   }
               }
               ```

            3. Implement health checking:
               ```rust
               impl ReviewerEntry {
                   pub fn check_health(&self) -> HealthStatus {
                       // Check if process is alive
                       #[cfg(unix)]
                       {
                           use nix::sys::signal::{kill, Signal};
                           use nix::unistd::Pid;
                           let alive = kill(Pid::from_raw(self.pid as i32), None).is_ok();
                           if !alive {
                               return HealthStatus::Dead;
                           }
                       }

                       // Check log file mtime for last activity
                       if let Ok(metadata) = std::fs::metadata(&self.log_file) {
                           if let Ok(mtime) = metadata.modified() {
                               let elapsed = mtime.elapsed().unwrap_or_default();
                               if elapsed.as_secs() >= 60 {
                                   return HealthStatus::Stale;
                               }
                           }
                       }
                       HealthStatus::Healthy
                   }
               }
               ```

            4. Update review spawn (push.rs, review.rs) to:
               a. Create NamedTempFile for log capture (keep reference to prevent deletion)
               b. Use script command with log capture:
                  ```rust
                  let log_file = tempfile::Builder::new()
                      .prefix("apm2_review_security_")
                      .suffix(".log")
                      .tempfile()?;
                  let log_path = log_file.path().to_owned();

                  let child = Command::new("script")
                      .args(["-q", &log_path.display().to_string(), "-c",
                             &format!("gemini --yolo < '{}'", prompt_path.display())])
                      .spawn()?;

                  // Record in state file
                  let mut state = ReviewerStateFile::load()?;
                  state.reviewers.insert("security".to_string(), ReviewerEntry {
                      pid: child.id(),
                      started_at: Utc::now(),
                      log_file: log_path,
                      pr_url: pr_url.to_string(),
                      head_sha: head_sha.to_string(),
                  });
                  state.save()?;

                  // Keep log_file handle to prevent cleanup until process exits
                  std::mem::forget(log_file);
                  ```

            5. Update check command (check.rs) to:
               a. Load ReviewerStateFile
               b. Display health status for each reviewer
               c. Trigger auto-remediation for STALE or DEAD reviewers

               Auto-remediation flow:
               ```rust
               /// Remediate a stale or dead reviewer by killing and restarting.
               ///
               /// The PR URL and HEAD SHA are read from the ReviewerEntry in the state file,
               /// which were saved when the reviewer was originally spawned. This allows
               /// restarting the same review without needing to query GitHub again.
               fn remediate_reviewer(
                   sh: &Shell,
                   name: &str,
                   entry: &ReviewerEntry,
                   state: &mut ReviewerStateFile,
               ) -> Result<()> {
                   let elapsed_secs = entry.log_file
                       .metadata().ok()
                       .and_then(|m| m.modified().ok())
                       .and_then(|t| t.elapsed().ok())
                       .map_or(0, |d| d.as_secs());

                   println!("[!] {} reviewer stale ({}s since last activity)",
                            name, elapsed_secs);
                   println!("    Auto-remediating: killing PID {} and restarting review...",
                            entry.pid);

                   // Kill process (SIGTERM, then SIGKILL after 5s)
                   #[cfg(unix)]
                   {
                       use nix::sys::signal::{kill, Signal};
                       use nix::unistd::Pid;
                       let pid = Pid::from_raw(entry.pid as i32);
                       let _ = kill(pid, Signal::SIGTERM);

                       // Poll for exit with 100ms intervals, up to 5s
                       for _ in 0..50 {
                           std::thread::sleep(Duration::from_millis(100));
                           if kill(pid, None).is_err() {
                               break; // Process exited
                           }
                       }

                       // Force kill if still alive
                       let _ = kill(pid, Signal::SIGKILL);
                   }

                   // Clean up old log file
                   let _ = std::fs::remove_file(&entry.log_file);

                   // Remove old entry from state file before restarting
                   state.reviewers.remove(name);
                   state.save()?;

                   // Re-trigger review using saved PR URL and HEAD SHA from state file
                   // This calls the same spawn_review() function used by push.rs
                   let new_pid = spawn_review(
                       sh,
                       &entry.pr_url,
                       &entry.head_sha,
                       name,  // "security" or "quality"
                   )?;

                   println!("    Restarted {} review (new PID: {})", name, new_pid);

                   Ok(())
               }
               ```

            6. Handle edge cases:
               - State file missing: treat as no active reviewers
               - State file corrupt (invalid JSON): log warning, delete, start fresh
               - PID reuse: check if /proc/<pid>/cmdline contains "gemini" or "script"
               - Multiple check commands: use file locking (flock) during remediation
               - Log file deleted: treat as stale (cannot verify activity)
               - Both reviewers stale simultaneously: remediate sequentially (security first, then quality)
                 to avoid overwhelming system resources; log each remediation separately
               - Log file cleanup on success: when review completes successfully (AI posts comment
                 and updates status), delete log file in finish/cleanup code; on remediation,
                 delete old log file before restarting

            Acceptance Criteria:
            - check command displays reviewer health section
            - Health shows PID, last activity timestamp, status for each reviewer
            - Stale reviewers (>300s) are automatically killed and restarted
            - Remediation logged to user
            - State persisted in ~/.apm2/reviewer_state.json
            - Atomic state file writes prevent corruption
            - Graceful handling of missing/corrupt state files

  dependency_graph: |
    Phase 0 (Documentation) - No dependencies:
    ┌─────────────┐  ┌─────────────┐
    │  TCK-00059  │  │  TCK-00060  │
    │ anti-       │  │ historical  │
    │ patterns    │  │ patterns    │
    └─────────────┘  └─────────────┘

    Phase 1 (Local Checks) - No dependencies:
    ┌─────────────┐  ┌─────────────┐
    │  TCK-00061  │  │  TCK-00062  │
    │ clippy      │  │ xtask lint  │
    │ lints       │  │ command     │
    └──────┬──────┘  └──────┬──────┘
           │                │
           │ depends on     │ depends on (for TCK-00072)
           ▼                │
    Phase 3:                │
    ┌─────────────┐         │
    │  TCK-00065  │         │
    │ check       │         │
    │ remediation │         │
    └─────────────┘         │
                            │
    Phase 2 (Test Coverage) - No dependencies:
    ┌─────────────┐  ┌─────────────┐
    │  TCK-00063  │  │  TCK-00064  │
    │ restart     │  │ AI tool     │
    │ monotonicity│  │ invocation  │
    └─────────────┘  └──────┬──────┘
                            │
                            │ depends on
                            ▼
                     ┌─────────────┐
                     │  TCK-00066  │
                     │ Gemini      │
                     │ switch      │
                     └──────┬──────┘
                            │
                            │ depends on
                            ▼
                     ┌─────────────┐
                     │  TCK-00067  │
                     │ reviewer    │
                     │ health      │
                     └─────────────┘

    Phase 4 (Follow-Up Improvements):
    ┌─────────────┐         ┌─────────────┐
    │  TCK-00068  │─────────│  TCK-00069  │
    │ shell       │ dep on  │ refactor    │───────┐
    │ safety      │         │ spawn       │       │
    └─────────────┘         └─────────────┘       │
                                                  │
    TCK-00067 ────────────> ┌─────────────┐       │
    (reviewer   dep on      │  TCK-00070  │       │
     health)                │ cross-      │       │
                            │ platform    │       │
                            └─────────────┘       │
                                                  │
    TCK-00067 ─────────────────────────────┐      │
    (reviewer               dep on         │      │
     health)                               v      v
                            ┌─────────────────────┐
                            │      TCK-00071      │
                            │    temp file        │
                            │    lifecycle        │
                            └─────────────────────┘

    TCK-00062 ────────────> ┌─────────────┐
    (lint cmd)    dep on    │  TCK-00072  │
                            │ doc example │
                            │ lint        │
                            └─────────────┘

    Phase 5 (AAT Completion and Check Watch Fix):
    ┌─────────────┐
    │  TCK-00073  │─────────┐
    │ AI tool     │         │
    │ config      │         │
    └─────────────┘         │
                            │ depends on
                            ▼
                     ┌─────────────┐
                     │  TCK-00074  │─────────┐
                     │ hypothesis  │         │
                     │ generation  │         │
                     └─────────────┘         │
                                             │ depends on
                                             ▼
                                      ┌─────────────┐
                                      │  TCK-00075  │─────────┐
                                      │ hypothesis  │         │
                                      │ execution   │         │
                                      └─────────────┘         │
                                                              │ depends on
                                                              ▼
                                                       ┌─────────────┐
                                                       │  TCK-00076  │
                                                       │ input       │
                                                       │ variation   │
                                                       └─────────────┘

    Standalone (no dependencies):
    ┌─────────────┐  ┌─────────────┐  ┌─────────────┐
    │  TCK-00077  │  │  TCK-00078  │  │  TCK-00079  │
    │ timestamp   │  │ validation  │  │ check watch │
    │ detection   │  │             │  │ fix         │
    └─────────────┘  └─────────────┘  └─────────────┘

    - phase: 4
      name: "Follow-Up Improvements"
      description: "Address issues discovered during Phase 0-3 implementation"
      tickets:
        - ticket_id: "TCK-00068"
          title: "Add Shell Command Safety Utility"
          requirements:
            - "MAINT-015"
          dependencies: []
          scope_summary: |
            Create shell escaping utilities to prevent shell injection vulnerabilities:

            Files to create:
            - xtask/src/shell_escape.rs

            Files to modify:
            - xtask/src/main.rs (add module)
            - xtask/src/tasks/push.rs (use quote_path)
            - xtask/src/tasks/review.rs (use quote_path)
            - xtask/src/tasks/check.rs (use quote_path)
            - xtask/Cargo.toml (add shell-escape dependency)

            Implementation:
            1. Implement quote_path() function that safely quotes paths for shell
            2. Implement build_script_command() helper for PTY-wrapped commands
            3. Update all shell command construction to use these utilities
            4. Add unit tests for edge cases (spaces, quotes, backticks, newlines)

            Acceptance Criteria:
            - No raw format!() shell string construction in xtask
            - All shell paths use quote_path() or equivalent
            - Tests cover all shell metacharacters

        - ticket_id: "TCK-00069"
          title: "Refactor Reviewer Spawn Logic into Shared Module"
          requirements:
            - "MAINT-016"
          dependencies:
            - "TCK-00068"
          scope_summary: |
            Consolidate duplicated reviewer spawn logic into ReviewerSpawner:

            Files to modify:
            - xtask/src/reviewer_state.rs (add ReviewerSpawner)
            - xtask/src/tasks/push.rs (use ReviewerSpawner)
            - xtask/src/tasks/review.rs (use ReviewerSpawner)
            - xtask/src/tasks/check.rs (use ReviewerSpawner)

            Implementation:
            1. Create ReviewerSpawner struct with spawn() method
            2. Consolidate: temp file creation, prompt interpolation, script command, state persistence
            3. Update all callers to use ReviewerSpawner::spawn()
            4. Remove duplicate implementations

            Acceptance Criteria:
            - Spawn logic exists in exactly one place
            - No duplicate temp file, script command, or state write logic

        - ticket_id: "TCK-00070"
          title: "Add Cross-Platform Process Checks"
          requirements:
            - "MAINT-017"
          dependencies:
            - "TCK-00067"
          scope_summary: |
            Replace Linux-only /proc usage with cross-platform sysinfo crate:

            Files to modify:
            - Cargo.toml (workspace sysinfo dependency)
            - xtask/Cargo.toml (sysinfo dependency)
            - xtask/src/reviewer_state.rs (is_our_process with sysinfo)

            Implementation:
            1. Add sysinfo crate to dependencies
            2. Replace /proc/{pid}/cmdline parsing with sysinfo::System::process()
            3. Add #[cfg(target_os)] guards for platform-specific code
            4. Document platform requirements

            Acceptance Criteria:
            - No direct /proc filesystem access
            - Code compiles for macOS target

        - ticket_id: "TCK-00071"
          title: "Improve Temp File Lifecycle Management"
          requirements:
            - "MAINT-018"
          dependencies:
            - "TCK-00067"
            - "TCK-00069"
          scope_summary: |
            Track temp files in state for reliable cleanup:

            Files to modify:
            - xtask/src/reviewer_state.rs (ManagedTempFile, temp_files field)
            - xtask/src/tasks/push.rs (register temp files)
            - xtask/src/tasks/review.rs (register temp files)
            - xtask/src/tasks/check.rs (orphan cleanup)

            Implementation:
            1. Create ManagedTempFile wrapper that tracks files in state
            2. Register temp files in reviewer_state.json
            3. Add cleanup sweep for orphaned temp files (>1 hour old)
            4. Remove all rm -f from shell command strings

            Acceptance Criteria:
            - No rm -f in shell command construction
            - Temp files tracked in state and cleaned up reliably

        - ticket_id: "TCK-00072"
          title: "Add Documentation Example Linting"
          requirements:
            - "MAINT-019"
          dependencies:
            - "TCK-00062"
          scope_summary: |
            Extend cargo xtask lint to check markdown code blocks:

            Files to modify:
            - xtask/Cargo.toml (add pulldown-cmark dependency)
            - xtask/src/tasks/lint.rs (add markdown scanning)
            - xtask/src/tasks/commit.rs (call lint with --include-docs)

            Implementation:
            1. Add markdown parsing with pulldown-cmark
            2. Extract Rust code blocks from *.md files
            3. Apply anti-pattern checks to documentation examples
            4. Add --include-docs flag to lint command
            5. Display warning during commit if doc examples violate patterns

            Acceptance Criteria:
            - cargo xtask lint --include-docs scans markdown code blocks
            - Detects unquoted shell paths in documentation examples
            - Warning displayed during commit

    - phase: 5
      name: "AAT Completion and Check Watch Fix"
      description: "Complete AAT implementation and fix check --watch terminal state handling"
      tickets:
        - ticket_id: "TCK-00073"
          title: "Add Configurable AI Tool Backend for AAT"
          requirements:
            - "AAT-001"
          dependencies: []
          scope_summary: |
            Add AAT_AI_TOOL environment variable (default: gemini):

            Files to create:
            - xtask/src/aat/tool_config.rs

            Files to modify:
            - xtask/src/aat/mod.rs (add module)
            - xtask/src/main.rs (add CLI arg)

            Implementation:
            1. Create AatToolConfig struct with from_env() method
            2. Support values: gemini, claude-code
            3. Add --ai-tool CLI flag override
            4. Default to gemini when no env var or flag set

            Acceptance Criteria:
            - AatToolConfig struct exists
            - Environment variable support works
            - CLI flag override works

        - ticket_id: "TCK-00074"
          title: "Implement AI-Powered Hypothesis Generation"
          requirements:
            - "AAT-002"
          dependencies:
            - "TCK-00073"
          scope_summary: |
            Replace stub generate_hypotheses() in aat.rs:207-251:

            Existing files to verify/update:
            - documents/reviews/AAT_HYPOTHESIS_PROMPT.md (already exists)

            Files to modify:
            - xtask/src/tasks/aat.rs (replace stub)

            Implementation:
            1. Create prompt template for hypothesis generation
            2. Invoke configured AI tool with PR description + diff
            3. Parse AI response into Vec<Hypothesis>
            4. Ensure at least 3 hypotheses with at least 1 error handling case

            Acceptance Criteria:
            - AI tool invoked for hypothesis generation
            - Response parsed into hypotheses
            - Validation of hypothesis count and error handling coverage

        - ticket_id: "TCK-00075"
          title: "Implement Hypothesis Execution Engine"
          requirements:
            - "AAT-003"
          dependencies:
            - "TCK-00074"
          scope_summary: |
            Create hypothesis execution engine:

            Files to create:
            - xtask/src/aat/executor.rs

            Files to modify:
            - xtask/src/aat/mod.rs (add executor module export)
            - xtask/src/tasks/aat.rs (integrate executor into run())

            Implementation:
            1. Create execute_hypothesis() function
            2. Run verification commands in shell
            3. Capture stdout, stderr, exit code
            4. Set executed_at timestamp AFTER execution
            5. Compare actual outcome to prediction
            6. Mark result as PASSED/FAILED

            Acceptance Criteria:
            - Hypotheses are actually executed
            - Output captured correctly
            - Timestamps set after execution

        - ticket_id: "TCK-00076"
          title: "Add Input Variation Testing"
          requirements:
            - "AAT-004"
          dependencies:
            - "TCK-00075"
          scope_summary: |
            Add input variation testing for anti-gaming:

            Files to create:
            - xtask/src/aat/variation.rs

            Files to modify:
            - xtask/src/aat/mod.rs (add variation module export)
            - xtask/src/aat/evidence.rs (populate InputVariation)
            - xtask/src/tasks/aat.rs (integrate variation testing)

            Implementation:
            1. For each CLI command, generate at least 3 input variations
            2. Execute each variation and capture output
            3. Detect invariance (identical output for different inputs)
            4. Populate InputVariation struct with real data
            5. Flag invariance as anti-gaming violation

            Acceptance Criteria:
            - Input variations generated and executed
            - Invariance detected and flagged

        - ticket_id: "TCK-00077"
          title: "Complete Anti-Gaming Pattern Detection"
          requirements:
            - "AAT-005"
          dependencies: []
          scope_summary: |
            Add ISO timestamp detection to anti-gaming:

            Files to modify:
            - xtask/src/aat/anti_gaming.rs (add regex + detection)
            - xtask/src/aat/types.rs (add violation variant)

            Implementation:
            1. Add TIMESTAMP_REGEX for ISO 8601 format detection
            2. Add AntiGamingViolation::HardcodedTimestamp variant
            3. Detect patterns like 2026-01-25T10:00:00Z in diff
            4. Add tests for timestamp detection

            Acceptance Criteria:
            - ISO timestamps detected in diffs
            - Tests pass

        - ticket_id: "TCK-00078"
          title: "Add Evidence Script and PR Format Validation"
          requirements:
            - "AAT-006"
          dependencies: []
          scope_summary: |
            Add validation for evidence scripts and PR format:

            Files to modify:
            - xtask/src/aat/parser.rs (add validation)
            - xtask/src/tasks/aat.rs (integrate validation)

            Implementation:
            1. Validate evidence script path exists and is executable
            2. Validate Usage section contains at least 1 code block
            3. Validate Expected Outcomes contain BOTH When AND Then keywords
            4. Return actionable errors for each validation failure

            Acceptance Criteria:
            - Evidence script validated
            - PR format validated (When/Then requirement enforced)
            - Actionable error messages

        - ticket_id: "TCK-00079"
          title: "Fix check --watch Terminal State Handling"
          requirements:
            - "CHECK-001"
          dependencies: []
          scope_summary: |
            Fix check --watch indefinite hang on terminal states:

            Files to modify:
            - xtask/src/tasks/check.rs (fix exit conditions, add timeout)

            Implementation:
            1. Add exit on PrState::Closed (exit code 1)
            2. Add exit on CiStatus::Failure (exit code 1)
            3. Add exit on ReviewStatus::ChangesRequested (exit code 1)
            4. Add 180s default timeout (non-configurable)
            5. On timeout: exit code 2, suggest "manually restart slow checks"
            6. Print clear message indicating why watch exited

            Acceptance Criteria:
            - Exits on all terminal states
            - 180s timeout with exit code 2
            - Clear exit messages

  impact_summary:
    - ticket: "TCK-00059"
      issues_prevented: ["A1", "A2", "A3", "B1", "B2", "B3"]
      impact: "Knowledge capture prevents recurrence"

    - ticket: "TCK-00060"
      issues_prevented: ["B1", "B2", "B3"]
      impact: "Faster security review (known patterns)"

    - ticket: "TCK-00061"
      issues_prevented: ["C1", "C2", "C3"]
      impact: "Catches lint issues locally"

    - ticket: "TCK-00062"
      issues_prevented: ["A2", "A3"]
      impact: "Automated anti-pattern detection"

    - ticket: "TCK-00063"
      issues_prevented: ["B3"]
      impact: "Prevents regression of monotonicity"

    - ticket: "TCK-00064"
      issues_prevented: ["A1", "A2", "A3"]
      impact: "Prevents regression of temp file issues"

    - ticket: "TCK-00065"
      issues_prevented: ["All"]
      impact: "Faster fix iteration"

    - ticket: "TCK-00066"
      issues_prevented: []
      impact: "Unified AI reviewer (Gemini for both)"

    - ticket: "TCK-00067"
      issues_prevented: ["A1"]
      impact: "Automatic detection and recovery from stale/crashed reviewers"

    - ticket: "TCK-00068"
      issues_prevented: ["A2"]
      impact: "Eliminates shell injection vulnerabilities from unquoted paths"

    - ticket: "TCK-00069"
      issues_prevented: ["A2", "A3"]
      impact: "Reduces code duplication and inconsistent security patterns"

    - ticket: "TCK-00070"
      issues_prevented: []
      impact: "Enables macOS development and reduces platform-specific bugs"

    - ticket: "TCK-00071"
      issues_prevented: ["A3"]
      impact: "Prevents temp file leaks and ensures reliable cleanup"

    - ticket: "TCK-00072"
      issues_prevented: ["A2", "A3"]
      impact: "Ensures documentation examples teach correct patterns"

    - ticket: "TCK-00073"
      issues_prevented: []
      impact: "Enables configurable AI backend for AAT flexibility"

    - ticket: "TCK-00074"
      issues_prevented: []
      impact: "AI-powered hypothesis generation replaces stub implementation"

    - ticket: "TCK-00075"
      issues_prevented: []
      impact: "Real hypothesis execution with captured output"

    - ticket: "TCK-00076"
      issues_prevented: []
      impact: "Input variation testing detects invariance anti-gaming"

    - ticket: "TCK-00077"
      issues_prevented: []
      impact: "Detects hardcoded timestamps in PRs"

    - ticket: "TCK-00078"
      issues_prevented: []
      impact: "Validates PR format and evidence scripts"

    - ticket: "TCK-00079"
      issues_prevented: []
      impact: "Fixes indefinite hang on terminal states in watch mode"

  expected_outcomes:
    - "80% fewer review iterations on state machine changes"
    - "Zero recurrence of temp file/shell escaping issues"
    - "Pre-commit catches 95% of lint issues before push"
    - "Unified AI reviewer simplifies tooling"
    - "Stale reviewers auto-remediated within 60s of detection"
    - "Zero shell injection vulnerabilities from path handling"
    - "Single source of truth for reviewer spawn logic"
    - "Cross-platform compatibility for macOS development"
    - "Reliable temp file cleanup with no orphaned files"
    - "Documentation examples validated against same lint rules as code"
    - "AAT hypothesis generation uses real AI instead of stub"
    - "AAT hypotheses are actually executed with captured output"
    - "Input variation testing detects gaming attempts"
    - "Hardcoded timestamps detected in PR diffs"
    - "PR format and evidence scripts validated before AAT runs"
    - "check --watch exits on terminal states instead of hanging indefinitely"
    - "180s timeout prevents watch mode from running forever"
