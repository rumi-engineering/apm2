rfc_design_decisions:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"

  decisions:
    - id: DD-006-001
      title: "Document Anti-Patterns in rust-textbook Chapter 26"
      statement: |
        Add a new "Anti-Patterns (Lessons Learned)" section to
        documents/skills/rust-textbook/26_apm2_safe_patterns_and_anti_patterns.md
        documenting shell escaping, temp file, and struct field update anti-patterns.
      context: |
        Issues discovered during PR #58 and #59 merging repeatedly appeared because
        there was no documented knowledge of these anti-patterns. Capturing them
        in coding guidelines prevents recurrence.
      alternatives:
        - id: ALT-0001
          name: "Add to main SKILL.md"
          pros:
            - "Single file to reference"
          cons:
            - "SKILL.md is already comprehensive"
            - "Anti-patterns deserve dedicated treatment"
          security_tradeoffs: []
          operability_tradeoffs: []
        - id: ALT-0002
          name: "Create separate ANTI_PATTERNS.md"
          pros:
            - "Dedicated file for anti-patterns"
          cons:
            - "Yet another file to maintain"
            - "Anti-patterns are the inverse of safe patterns"
          security_tradeoffs: []
          operability_tradeoffs: []
        - id: ALT-0003
          name: "Add section to rust-textbook Chapter 26 (chosen)"
          pros:
            - "Natural home next to safe patterns"
            - "Developers see both patterns and anti-patterns together"
            - "Single reference file for coding patterns"
          cons:
            - "File grows larger"
          security_tradeoffs: []
          operability_tradeoffs: []
      chosen_rationale: |
        rust-textbook Chapter 26 is the natural home for APM2-specific safe patterns
        and anti-patterns. Developers consulting safe patterns should also see what
        to avoid, in the same canonical reference.
      impacted_requirement_ids:
        - MAINT-006
      evidence_ids:
        - EVID-6001

    - id: DD-006-002
      title: "Add Historical Patterns to Security Review Prompt"
      statement: |
        Add a "Historical Issue Patterns (Check First)" section to the security
        review prompt listing patterns that have caused issues in past PRs.
      context: |
        Security review found multiple state machine bugs in PR #58. Having a
        checklist of known issue patterns helps reviewers catch similar issues
        faster and more reliably.
      alternatives:
        - id: ALT-0001
          name: "Keep prompt generic"
          pros:
            - "Simpler prompt"
          cons:
            - "Misses opportunity for institutional knowledge"
            - "Same issues may recur"
          security_tradeoffs:
            - "May miss known issue patterns"
          operability_tradeoffs: []
        - id: ALT-0002
          name: "Add historical patterns section (chosen)"
          pros:
            - "Captures institutional knowledge"
            - "Faster review (known patterns checked first)"
            - "Prevents recurrence of known issues"
          cons:
            - "Prompt grows over time"
            - "Patterns need maintenance"
          security_tradeoffs:
            - "Better coverage of known vulnerabilities"
          operability_tradeoffs: []
      chosen_rationale: |
        Historical patterns capture institutional knowledge that makes reviews
        more effective. The patterns are derived from actual issues found in PRs,
        so they represent real-world attack surfaces.
      impacted_requirement_ids:
        - MAINT-008
      evidence_ids:
        - EVID-6002

    - id: DD-006-003
      title: "Enhanced Clippy Lints for Pre-Commit"
      statement: |
        Add explicit clippy lints to pre-commit: doc_markdown (D), match_same_arms (D),
        and missing_const_for_fn (W). Display tip about using .. in match patterns.
      context: |
        PR #58 and #59 had clippy warnings that required additional fix commits.
        These could have been caught locally with stricter lints.
      alternatives:
        - id: ALT-0001
          name: "Keep current clippy defaults"
          pros:
            - "Faster local checks"
          cons:
            - "Issues caught later in CI"
            - "More fix commits needed"
          security_tradeoffs: []
          operability_tradeoffs: []
        - id: ALT-0002
          name: "Add enhanced lints (chosen)"
          pros:
            - "Catches issues locally before push"
            - "Reduces CI failures"
            - "Better code quality"
          cons:
            - "Slightly slower pre-commit"
          security_tradeoffs: []
          operability_tradeoffs:
            - "Pre-commit catches more issues"
      chosen_rationale: |
        The specific lints chosen address issues that caused CI failures in
        PR #58 and #59. Catching them locally is faster than waiting for CI.
      impacted_requirement_ids:
        - MAINT-007
      evidence_ids:
        - EVID-6003

    - id: DD-006-004
      title: "Create cargo xtask lint Command"
      statement: |
        Create a new `cargo xtask lint` command that checks for anti-patterns
        including direct temp_dir usage and shell interpolation patterns.
      context: |
        Some anti-patterns cannot be caught by clippy but can be detected with
        grep-based pattern matching. A dedicated lint command provides automated
        anti-pattern detection.
      alternatives:
        - id: ALT-0001
          name: "Rely on code review only"
          pros:
            - "No new tooling"
          cons:
            - "Human reviewers may miss patterns"
            - "Inconsistent detection"
          security_tradeoffs:
            - "Security anti-patterns may be missed"
          operability_tradeoffs: []
        - id: ALT-0002
          name: "Add custom clippy lints"
          pros:
            - "Integrated with existing tooling"
          cons:
            - "Complex to implement"
            - "Requires dylint or custom compiler plugin"
          security_tradeoffs: []
          operability_tradeoffs: []
        - id: ALT-0003
          name: "Create xtask lint command (chosen)"
          pros:
            - "Simple grep-based implementation"
            - "Easy to add new patterns"
            - "Runs as part of dev workflow"
          cons:
            - "Not as precise as compiler-based lint"
            - "May have false positives"
          security_tradeoffs: []
          operability_tradeoffs: []
      chosen_rationale: |
        A grep-based lint command is simple to implement and maintain. It can
        catch common anti-patterns without the complexity of custom compiler
        plugins. Warnings (not errors) allow developers to evaluate context.
      impacted_requirement_ids:
        - MAINT-012
      evidence_ids:
        - EVID-6004

    - id: DD-006-005
      title: "Switch Code Quality Reviewer to Gemini CLI"
      statement: |
        Replace Codex invocation for code quality review with Gemini CLI using
        the same temp file + script pattern as security review.
      context: |
        Codex CLI has been problematic (see RFC-0005 TCK-00057). Using Gemini
        CLI for both security and code quality reviews unifies tooling and
        leverages the proven temp file + script invocation pattern.
      alternatives:
        - id: ALT-0001
          name: "Fix Codex CLI invocation again"
          pros:
            - "Minimal change"
          cons:
            - "Codex CLI has been unreliable"
            - "Different tool than security review"
          security_tradeoffs: []
          operability_tradeoffs:
            - "Two different AI tools to maintain"
        - id: ALT-0002
          name: "Switch to Gemini CLI (chosen)"
          pros:
            - "Unified AI reviewer tooling"
            - "Proven invocation pattern from security review"
            - "Same temp file security model"
          cons:
            - "Migration effort"
            - "Different model characteristics"
          security_tradeoffs:
            - "Secure temp file pattern already proven"
          operability_tradeoffs:
            - "Single AI tool to maintain"
      chosen_rationale: |
        Using Gemini CLI for both security and code quality reviews simplifies
        tooling and applies the secure temp file + script pattern consistently.
        The pattern is already proven in security review implementation.
      impacted_requirement_ids:
        - MAINT-013
      evidence_ids:
        - EVID-6005

    - id: DD-006-006
      title: "Specific Remediation Commands in Check Output"
      statement: |
        Add failure-type-specific remediation commands to cargo xtask check output
        (e.g., cargo fmt for format failures, cargo clippy --fix for lint failures).
      context: |
        When cargo xtask check reports failures, developers need to know how to
        fix them. Currently they must remember or look up the fix commands.
      alternatives:
        - id: ALT-0001
          name: "Keep current generic output"
          pros:
            - "Simpler implementation"
          cons:
            - "Developers must remember fix commands"
            - "Slower iteration"
          security_tradeoffs: []
          operability_tradeoffs: []
        - id: ALT-0002
          name: "Add specific remediation commands (chosen)"
          pros:
            - "Faster fix iteration"
            - "Self-documenting workflow"
            - "Reduces cognitive load"
          cons:
            - "Slightly more verbose output"
          security_tradeoffs: []
          operability_tradeoffs:
            - "Better developer experience"
      chosen_rationale: |
        Specific remediation commands reduce cognitive load and iteration time.
        Developers can copy-paste the fix command directly from the output.
      impacted_requirement_ids:
        - MAINT-011
      evidence_ids:
        - EVID-6006

    - id: DD-006-007
      title: "Reviewer Agent Health Monitoring with Auto-Remediation"
      statement: |
        Add health monitoring to the check command that tracks AI reviewer agent
        process status and last activity timestamp (via log file mtime). Automatically
        remediate unhealthy agents by killing stale processes and restarting reviews.
      context: |
        AI reviewer agents can become stale or crash during long reviews.
        Without health monitoring, developers must manually detect and recover
        from these failures. The check command is the natural place to surface
        this information since it already shows review status.
      alternatives:
        - id: ALT-0001
          name: "Manual monitoring only"
          pros:
            - "Simpler implementation"
            - "No state file needed"
          cons:
            - "Developers must manually check process status"
            - "Stale reviews may go unnoticed"
            - "Manual kill and restart is tedious"
          security_tradeoffs: []
          operability_tradeoffs:
            - "Poor developer experience"
        - id: ALT-0002
          name: "Monitor and suggest remediation"
          pros:
            - "Shows health status"
            - "Suggests fix commands"
          cons:
            - "Still requires manual action"
            - "Adds friction to workflow"
          security_tradeoffs: []
          operability_tradeoffs: []
        - id: ALT-0003
          name: "Monitor with auto-remediation (chosen)"
          pros:
            - "Fully automatic recovery"
            - "Minimal developer intervention"
            - "Consistent review completion"
          cons:
            - "More complex implementation"
            - "State file management required"
          security_tradeoffs: []
          operability_tradeoffs:
            - "Self-healing workflow"
      chosen_rationale: |
        Auto-remediation provides the best developer experience. When an agent
        is stale (>300s since last activity as measured by log file mtime),
        automatically killing and restarting is faster than prompting the user
        to do it manually. The user is informed of the remediation action for
        transparency.
      impacted_requirement_ids:
        - MAINT-014
      evidence_ids:
        - EVID-6007

    - id: DD-006-008
      title: "Log File Modification Time for Activity Detection"
      statement: |
        Detect last activity timestamp by monitoring log file modification time (mtime)
        rather than parsing log content or implementing a wrapper script.
      context: |
        Gemini CLI output format may vary between versions and is not a stable API.
        We need a reliable way to detect when the agent last executed any action
        to determine staleness. Options include log parsing, wrapper scripts, or
        file modification tracking.
      alternatives:
        - id: ALT-0001
          name: "Wrapper script intercept"
          pros:
            - "Precise tool call detection"
          cons:
            - "Complex to implement correctly"
            - "Adds indirection layer"
            - "May interfere with PTY handling"
          security_tradeoffs: []
          operability_tradeoffs: []
        - id: ALT-0002
          name: "Parse Gemini output log for patterns"
          pros:
            - "Can detect specific tool types"
          cons:
            - "Gemini output format is not a stable API"
            - "Pattern matching may break with Gemini CLI updates"
            - "False negatives if format changes"
          security_tradeoffs: []
          operability_tradeoffs: []
        - id: ALT-0003
          name: "Log file modification time (mtime) (chosen)"
          pros:
            - "Simple and reliable implementation"
            - "Independent of Gemini output format"
            - "Any output (tool calls, thinking, errors) updates mtime"
            - "Single stat() syscall to check"
          cons:
            - "Cannot distinguish between different types of activity"
            - "Brief inactivity may trigger false staleness if agent is thinking"
          security_tradeoffs: []
          operability_tradeoffs:
            - "Simple to maintain and debug"
      chosen_rationale: |
        Log file mtime is the most reliable and maintainable approach. When Gemini
        executes tools, produces output, or encounters errors, the log file is
        updated. This approach:
        1. Does not depend on parsing unstable Gemini output format
        2. Works with any Gemini CLI version
        3. Requires only a single stat() syscall (low overhead)
        4. Naturally captures all forms of activity (not just tool calls)

        The 60-second threshold accommodates brief thinking pauses while catching
        truly stale agents. If needed, the threshold can be tuned based on experience.
      impacted_requirement_ids:
        - MAINT-014
      evidence_ids:
        - EVID-6007
