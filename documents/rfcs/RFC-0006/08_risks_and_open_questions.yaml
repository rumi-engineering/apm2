rfc_risks_and_open_questions:
  schema_version: "2026-01-25"
  template_version: "2026-01-25"

  risks:
    - id: RISK-006-001
      description: "Gemini CLI availability and stability"
      likelihood: MEDIUM
      impact: MEDIUM
      mitigation: |
        Gemini CLI is already used for security review, so availability is proven.
        If Gemini CLI becomes unavailable, can fall back to manual review process.
        Error handling detects when Gemini CLI is not installed.

    - id: RISK-006-002
      description: "Enhanced clippy lints cause false positives"
      likelihood: LOW
      impact: LOW
      mitigation: |
        The specific lints chosen (doc_markdown, match_same_arms) have low
        false positive rates. The --skip-checks flag provides escape hatch.
        Lints are standard clippy lints, not custom rules.

    - id: RISK-006-003
      description: "Anti-pattern detection has false positives"
      likelihood: MEDIUM
      impact: LOW
      mitigation: |
        The lint command issues warnings, not errors. Developers can evaluate
        context and ignore false positives. Patterns are conservative to
        minimize false positives.

    - id: RISK-006-004
      description: "Documentation drift from implementation"
      likelihood: MEDIUM
      impact: MEDIUM
      mitigation: |
        Anti-patterns documented are derived from actual issues. If implementation
        changes, documentation should be updated. Consider adding lint checks
        that verify documented patterns match implementation.

    - id: RISK-006-005
      description: "Test coverage gaps in restart monotonicity"
      likelihood: LOW
      impact: HIGH
      mitigation: |
        Boundary tests cover all critical edge cases including u32::MAX overflow.
        Property-based testing could be added later for more comprehensive
        coverage. Manual review verifies implementation matches tests.

    - id: RISK-006-006
      description: "Temp file security on shared systems"
      likelihood: LOW
      impact: MEDIUM
        mitigation: |
          tempfile crate creates files with 0600 permissions in secure temp
          directory. On shared systems, ensure TMPDIR is user-private. Document
        security assumptions in documents/skills/rust-textbook/26_apm2_safe_patterns_and_anti_patterns.md.

    - id: RISK-006-007
      description: "Log file mtime may not accurately reflect agent activity"
      likelihood: LOW
      impact: LOW
      mitigation: |
        Using log file mtime (modification time) instead of parsing output avoids
        dependency on Gemini's output format. The mtime approach is:
        - Format-independent: works regardless of Gemini CLI version
        - Reliable: any output (including errors) updates mtime
        - Simple: single stat() syscall with no parsing
        If mtime proves unreliable on some filesystems (e.g., network mounts),
        can fall back to process alive check with longer threshold (120s).

    - id: RISK-006-008
      description: "Auto-remediation may kill legitimate slow reviews"
      likelihood: LOW
      impact: MEDIUM
      mitigation: |
        The 60-second threshold is conservative for normal tool usage. Long-running
        tools like compilation may exceed this. Consider tracking "tool in progress"
        state separately from "idle". Auto-remediation logs action so user can
        manually restart if needed.

    - id: RISK-006-009
      description: "State file corruption or race conditions"
      likelihood: LOW
      impact: LOW
      mitigation: |
        Use atomic file writes (write to temp file, then rename). State file is
        JSON for easy debugging. Specific mitigations:
        - Corruption: If JSON parse fails, log warning, delete file, start fresh
        - Race condition (multiple check commands): Use flock(LOCK_EX) during
          remediation to serialize access. Health checks are read-only (no lock).
        - PID reuse: Verify /proc/<pid>/cmdline contains "gemini" or "script"
          before considering process alive. This prevents killing unrelated
          processes if the PID was reused after the reviewer exited.
        - Stale entries: If process is dead, remove entry during next check.

    - id: RISK-006-010
      description: "NamedTempFile cleanup deletes log before process finishes"
      likelihood: MEDIUM
      impact: MEDIUM
      mitigation: |
        The log file created for Gemini output must persist until the review
        completes. Two approaches:
        1. Use std::mem::forget(log_file) to prevent automatic cleanup, then
           manually delete in finish/cleanup code
        2. Use tempfile::Builder::new().keep(true) to create a persistent file,
           manually track and delete later
        The chosen approach (mem::forget) is simpler but requires careful cleanup
        in the remediation code and when reviews complete normally. Document this
        pattern in the anti-patterns section as a known footgun.

  open_questions:
    - id: OQ-006-001
      question: "Should xtask lint be part of pre-commit?"
      status: DEFERRED
      notes: |
        Currently lint is a separate command. Could be integrated into commit
        command as additional check. Start with separate command, integrate
        later if developers find it useful.

    - id: OQ-006-002
      question: "Should we version anti-patterns documentation?"
      status: RESOLVED
      resolution: |
        Anti-patterns are documented with context about when they were discovered
        (PR #58, #59). This provides historical context without complex versioning.
        New anti-patterns can be added with similar attribution.

    - id: OQ-006-003
      question: "How to handle Gemini CLI rate limits?"
      status: DEFERRED
      notes: |
        Security review already uses Gemini CLI, so rate limits are understood.
        If rate limits become an issue, implement retry with exponential backoff.
        Consider caching review results per commit SHA.

    - id: OQ-006-004
      question: "Should restart monotonicity be a compile-time check?"
      status: RESOLVED
      resolution: |
        Rust's type system cannot enforce monotonicity at compile time without
        dependent types. Runtime checks in the reducer with comprehensive tests
        provide sufficient safety. The reducer is the single enforcement point.

    - id: OQ-006-005
      question: "What happens if tempfile creation fails?"
      status: RESOLVED
      resolution: |
        NamedTempFile::new() returns Result, so failures are propagated up.
        Error message will indicate temp file creation failed. User can check
        disk space and TMPDIR permissions.

    - id: OQ-006-006
      question: "How to track agent activity accurately across PTY?"
      status: RESOLVED
      resolution: |
        Use log file modification time (mtime) as the activity indicator. When
        Gemini produces any output (tool calls, thinking, errors), the log file's
        mtime is updated. This approach:
        - Avoids parsing Gemini's output format (which may change between versions)
        - Works reliably across all PTY configurations
        - Requires only a single stat() syscall (efficient)
        - Naturally captures all forms of activity, not just tool calls

    - id: OQ-006-007
      question: "What if the user has multiple PRs being reviewed?"
      status: RESOLVED
      resolution: |
        The state file tracks ONE reviewer per type (security, quality) at a time.
        When a new review is started, it replaces any previous reviewer of that type.
        This is intentional: the typical workflow is one PR at a time, and starting
        a new review implicitly abandons the old one. If needed in the future, the
        state schema can be extended to track by (review_type, pr_url) key pairs.

  decisions_needed:
    - id: DN-006-001
      question: "Should lint command check for missing tests?"
      options:
        - "Check for missing tests"
        - "Focus on anti-patterns only (chosen)"
      chosen: "Focus on anti-patterns only"
      rationale: |
        Test coverage is checked by other tools (cargo test, tarpaulin).
        The lint command should focus on anti-patterns that other tools miss.
        Keep the command focused and fast.

    - id: DN-006-002
      question: "What verbosity level for check remediation?"
      options:
        - "Always show remediation"
        - "Show remediation only on failure (chosen)"
        - "Require --verbose flag"
      chosen: "Show remediation only on failure"
      rationale: |
        Remediation commands are most useful when there's a failure to fix.
        Showing them always adds noise. Showing only on failure keeps output
        clean while being helpful when needed.

    - id: DN-006-003
      question: "Should Gemini quality review use same model as security?"
      options:
        - "Same model for both (chosen)"
        - "Different models for different review types"
      chosen: "Same model for both"
      rationale: |
        Using the same model simplifies configuration and ensures consistent
        behavior. Different review types are distinguished by prompt, not model.
        If different characteristics are needed later, can parameterize model.

    - id: DN-006-004
      question: "What stale threshold for reviewer health?"
      options:
        - "60 seconds"
        - "120 seconds"
        - "300 seconds (chosen)"
      chosen: "300 seconds"
      rationale: |
        300 seconds (5 minutes) balances responsiveness with tolerance for slow AI
        operations. AI tool startup, large PR analysis, and complex reasoning can
        take several minutes. 60s may be too aggressive and cause false positives.
        300s provides reasonable tolerance while still detecting truly stale reviewers.
        The constant STALE_THRESHOLD_SECS can be tuned based on experience.

    - id: DN-006-005
      question: "Auto-remediate or prompt user?"
      options:
        - "Prompt user with suggested action"
        - "Auto-remediate (chosen)"
      chosen: "Auto-remediate"
      rationale: |
        User requested auto-remediation for minimal friction. When a reviewer is
        stale, automatically killing and restarting is faster than prompting.
        User is informed of remediation action for transparency. If auto-remediation
        proves problematic, can add --no-auto-remediate flag later.
