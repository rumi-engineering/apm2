rfc_test_and_evidence:
  schema_version: "2026-01-24"
  template_version: "2026-01-24"

  test_strategy:
    approach: |
      Unit tests for parsing logic with deterministic inputs/outputs.
      Integration tests use mock data where possible. Manual verification
      as final confirmation with documented pass criteria.

    unit_tests:
      - id: UT-001
        description: "Test CI status JSON parsing with various inputs"
        file: "xtask/src/tasks/check.rs"
        test_function: "test_parse_ci_status_json"
        deterministic: true
        test_cases:
          - name: "success_case"
            input: '[{"name":"CI","state":"COMPLETED","conclusion":"SUCCESS"}]'
            expected: "CiStatus::Success"
          - name: "failure_case"
            input: '[{"name":"CI","state":"COMPLETED","conclusion":"FAILURE"}]'
            expected: "CiStatus::Failure"
          - name: "pending_case"
            input: '[{"name":"CI","state":"PENDING","conclusion":null}]'
            expected: "CiStatus::Pending"
          - name: "mixed_pending_success"
            input: '[{"name":"A","state":"COMPLETED","conclusion":"SUCCESS"},{"name":"B","state":"PENDING","conclusion":null}]'
            expected: "CiStatus::Pending"
          - name: "mixed_failure_pending"
            input: '[{"name":"A","state":"COMPLETED","conclusion":"FAILURE"},{"name":"B","state":"PENDING","conclusion":null}]'
            expected: "CiStatus::Failure"
          - name: "empty_array"
            input: '[]'
            expected: "CiStatus::Pending"
          - name: "missing_conclusion_completed"
            input: '[{"name":"CI","state":"COMPLETED"}]'
            expected: "CiStatus::Success"
            rationale: |
              When state=COMPLETED but conclusion is absent, we default to Success.
              This is a fail-open approach: we assume GitHub would not mark a check
              as COMPLETED without a conclusion unless it succeeded. If this assumption
              is wrong, CI will catch it. This is safer than blocking on data issues.
          - name: "malformed_json"
            input: 'not valid json'
            expected: "CiStatus::Pending"
            rationale: |
              Malformed JSON (gh CLI errors, network issues) defaults to Pending.
              This triggers the "wait for CI" path rather than falsely claiming
              success or failure. The user sees "[..] CI checks running" and can
              investigate manually. Exit code is 1 (not 2) because we successfully
              ran but couldn't determine status.
        pass_criteria: |
          All test cases produce expected CiStatus values.
          Run: cargo test -p xtask test_parse_ci_status

      - id: UT-002
        description: "Test status creation argument construction"
        file: "xtask/src/tasks/push.rs"
        test_function: "test_status_creation"
        deterministic: true
        test_cases:
          - name: "multi_word_description"
            input_description: "Waiting for security review"
            expected: "Single argument: description=Waiting for security review"
          - name: "special_characters"
            input_description: "Review pending (see PR #123)"
            expected: "Properly escaped: description=Review pending (see PR #123)"
        pass_criteria: |
          Arguments are correctly constructed without splitting.
          Run: cargo test -p xtask test_status_creation

      - id: UT-003
        description: "Test pre-commit check logic"
        file: "xtask/src/tasks/commit.rs"
        test_function: "test_precommit_checks"
        deterministic: true
        test_cases:
          - name: "all_pass"
            mock_fmt: "exit 0"
            mock_clippy: "exit 0"
            expected: "Ok(())"
          - name: "fmt_fails"
            mock_fmt: "exit 1"
            mock_clippy: "exit 0"
            expected: "Err with fmt failure message"
          - name: "skip_checks_flag"
            skip_checks: true
            expected: "Ok(()) without running checks"
        pass_criteria: |
          Check logic correctly handles tool success/failure.
          Run: cargo test -p xtask test_precommit_checks

    integration_tests:
      - id: IT-001
        description: "End-to-end CI status detection"
        deterministic: true
        setup: |
          1. Create test fixture with mock gh CLI response
          2. Set GH_MOCK_RESPONSE env var to CI failure JSON
        execution: "cargo xtask check (with mocked gh)"
        validation:
          output_contains: "[X] CI checks failed"
          exit_code: 1
        pass_criteria: |
          When gh pr checks returns failure JSON, xtask check reports failure
          and exits with non-zero code.

      - id: IT-002
        description: "Status creation verification"
        deterministic: false  # Requires GitHub API
        setup: |
          1. Create test branch with commit
          2. Push branch to remote
        execution: |
          cargo xtask push
          gh api /repos/{owner}/{repo}/commits/{sha}/statuses
        validation:
          statuses_exist:
            - "ai-review/security"
            - "ai-review/code-quality"
        pass_criteria: |
          After push, GitHub API shows both status checks exist.
          This is verified by querying the statuses endpoint.

    # Manual verification supplements automated tests. Each MV has
    # deterministic pass/fail criteria that can be evaluated objectively.
    manual_verification:
      - id: MV-001
        description: "Verify xtask check detects CI failure"
        prerequisites:
          - "Ticket branch with open PR"
          - "At least one CI check has failed"
        steps:
          - "Run: cargo xtask check"
          - "Capture output and exit code"
        pass_criteria:
          output_must_contain: "[X] CI checks failed"
          exit_code_must_be: "non-zero (1)"
        fail_criteria:
          - "Output shows '[..] CI checks running'"
          - "Exit code is 0"

      - id: MV-002
        description: "Verify xtask push creates statuses"
        prerequisites:
          - "Ticket branch with commits"
          - "gh CLI authenticated"
        steps:
          - "Run: cargo xtask push"
          - "Run: gh api /repos/{owner}/{repo}/commits/$(git rev-parse HEAD)/statuses | jq '.[].context'"
        pass_criteria:
          output_must_include:
            - '"ai-review/security"'
            - '"ai-review/code-quality"'
        fail_criteria:
          - "Either status is missing from API response"

      - id: MV-003
        description: "Verify xtask review quality runs Codex"
        prerequisites:
          - "codex CLI installed and available"
          - "Valid PR URL"
        steps:
          - "Run: cargo xtask review quality <PR_URL>"
          - "Capture output"
        pass_criteria:
          output_must_not_contain: "unexpected argument"
          output_must_contain: "review"
        fail_criteria:
          - "Output contains 'unexpected argument --approval-mode'"

  evidence_requirements:
    - id: EVID-5001
      description: "CI failure detection works correctly"
      artifact_type: "test_output"
      verification:
        automated: "cargo test -p xtask test_parse_ci_status passes"
        manual: "MV-001 passes with documented output"
      location: "evidence/RFC-0005/EVID-5001_ci_detection.log"

    - id: EVID-5002
      description: "Status creation works correctly"
      artifact_type: "api_response"
      verification:
        automated: "cargo test -p xtask test_status_creation passes"
        manual: "MV-002 passes with API response showing statuses"
      location: "evidence/RFC-0005/EVID-5002_status_creation.json"

    - id: EVID-5003
      description: "Codex invocation works correctly"
      artifact_type: "command_output"
      verification:
        manual: "MV-003 passes without argument errors"
      location: "evidence/RFC-0005/EVID-5003_codex_invocation.log"

    - id: EVID-5004
      description: "Pre-commit checks work correctly"
      artifact_type: "test_output"
      verification:
        automated: "cargo test -p xtask test_precommit_checks passes"
      location: "evidence/RFC-0005/EVID-5004_precommit_checks.log"
