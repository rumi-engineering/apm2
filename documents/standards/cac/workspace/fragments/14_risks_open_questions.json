{
  "risks_and_open_questions": {
    "open_questions": [
      {
        "id": "CAC-OQ-0001",
        "question": "Exact canonicalization spec: strict RFC 8785 JCS vs a stricter CAC profile; how to publish, pin, and version test vectors and canonicalizer IDs?"
      },
      {
        "id": "CAC-OQ-0002",
        "question": "Stable ID namespace governance: who can mint namespaces, and how are collisions prevented across org/projects?"
      },
      {
        "id": "CAC-OQ-0003",
        "question": "Do we need typed kernel events (ControlArtifactEvent) in the MVP, or is EvidencePublished metadata sufficient?"
      },
      {
        "id": "CAC-OQ-0004",
        "question": "How to represent large binary artifacts within CAC-JSON (likely via CAS refs only) and enforce policies consistently?"
      },
      {
        "id": "CAC-OQ-0005",
        "question": "Should defect records be first-class kernel events or remain evidence artifacts referenced by events?"
      },
      {
        "id": "CAC-OQ-0006",
        "question": "TargetProfile schema: what is the minimal stage taxonomy (plan/implement/review/ops) and which policies must be mandatory vs optional?"
      },
      {
        "id": "CAC-OQ-0007",
        "question": "Compaction policy: when does patch depth require snapshotting, and how are ChangeSet summaries preserved across compaction?"
      }
    ],
    "risks": [
      {
        "id": "CAC-RISK-0001",
        "impact": "Breaks CAS dedupe, provenance, and stable-ID pinning.",
        "mitigations": [
          "Golden test vectors committed and run in CI.",
          "Versioned canonicalizer; include canonicalizer_version in receipts.",
          "Cross-language compatibility tests if multiple implementations exist."
        ],
        "name": "Canonicalizer divergence causes hash drift"
      },
      {
        "id": "CAC-RISK-0002",
        "impact": "Machines may fail admission frequently during early adoption.",
        "mitigations": [
          "Bootstrap with small schema set and evolve intentionally.",
          "Provide machine-generated patch tooling that auto-validates before submission.",
          "Use staged rollout: warn -> soft fail -> hard fail."
        ],
        "name": "Schema strictness slows iteration"
      },
      {
        "id": "CAC-RISK-0003",
        "impact": "External agent tooling stops working or requires urgent changes.",
        "mitigations": [
          "Version target profiles and pin in packs.",
          "Conformance tests run in AAT; failures become defects.",
          "Maintain fallback exports for critical vendors."
        ],
        "name": "Target delivery churn breaks export pipeline"
      },
      {
        "id": "CAC-RISK-0004",
        "impact": "Tasks fail because packs are incomplete; could be perceived as regressions.",
        "mitigations": [
          "Treat failures as compiler defects and fix packs quickly.",
          "Allow limited, explicitly budgeted escape hatches early, with strong defect emission.",
          "Prioritize pack completeness for the most common workflows."
        ],
        "name": "Consumption hermeticity causes early friction"
      },
      {
        "id": "CAC-RISK-0005",
        "impact": "Stable-ID resolution and fetch becomes slow at scale.",
        "mitigations": [
          "Maintain a cached projection store (rebuildable).",
          "Shard by namespace/kind; keep hot indexes in memory.",
          "Include compaction checkpoints."
        ],
        "name": "Indexing DCP from ledger becomes performance bottleneck"
      },
      {
        "id": "CAC-RISK-0006",
        "impact": "Patch history grows unbounded; review and replay become slow or error-prone.",
        "mitigations": [
          "Define compaction thresholds (depth/time/size) per artifact kind.",
          "Require ChangeSet summaries to accompany compaction snapshots.",
          "Maintain provenance links from snapshots back to patch chains."
        ],
        "name": "Patch soup without compaction"
      },
      {
        "id": "CAC-RISK-0007",
        "impact": "TargetProfile budgets or rendering policies are miscalibrated, causing frequent failures for weaker models.",
        "mitigations": [
          "Default to conservative budgets; adjust via measured RunReceipt data.",
          "Maintain per-model profiles and gate by capability manifest.",
          "Automate profile tuning based on sufficiency metrics."
        ],
        "name": "Target profile miscalibration"
      }
    ]
  }
}
