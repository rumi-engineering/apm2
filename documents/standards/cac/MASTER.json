{
  "classification": {
    "default_data_classification": "INTERNAL",
    "notes": [
      "Normative control artifacts can affect safety and correctness; treat as high-impact.",
      "All artifacts require provenance and admission gating."
    ],
    "security_critical": true
  },
  "doc": {
    "audience": [
      "kernel",
      "compiler",
      "policy",
      "tooling",
      "agent-runtime",
      "security"
    ],
    "created_at": "2026-01-26",
    "id": "APM2-PRD-CAC-0001",
    "last_updated_at": "2026-01-26",
    "owners": [
      {
        "holon_id": "HOLON-KERNEL-GOVERNANCE",
        "role": "schema+policy authority"
      },
      {
        "holon_id": "HOLON-CONTEXT-COMPILER",
        "role": "context compilation + export"
      },
      {
        "holon_id": "HOLON-AAT",
        "role": "acceptance testing + receipts"
      }
    ],
    "priority": "P0",
    "scope_tags": [
      "context-as-code",
      "canonical-json",
      "patch-first",
      "dcp",
      "vendor-abi",
      "messaging-native"
    ],
    "status": "draft",
    "title": "Context-as-Code (CAC) v1: Canonical Context Pipeline for the APM2 Holonic Kernel"
  },
  "schema": "apm2.prd.cac.v1",
  "schema_version": "1.0.0",
  "summary": {
    "context": [
      "APM2 already has a signed, hash-chained ledger and a content-addressed store (CAS).",
      "Today, the system still relies on implicit or prose-driven contracts (README/Markdown/scripts) and unverified assumptions about CLI functionality.",
      "This creates unplanned context discovery, brittle agent behavior, and a slow innermost loop (code+review)."
    ],
    "one_line": "Make context the authoritative program: a content-addressed context graph compiled through target profiles into deterministic packs and delivery payloads, with full provenance recorded as kernel messages.",
    "thesis": {
      "implications": [
        "If context is complete and correct, code can be generated deterministically (or within controlled nondeterminism).",
        "Therefore, the highest-leverage engineering work is to make context machine-native, canonical, and enforceable.",
        "All boundary crossings (agent\u2194kernel, kernel\u2194runtime targets) must be mediated by schemas and evidence.",
        "Model capability is treated as a compile-time TargetProfile contract, not a runtime assumption."
      ],
      "statement": "In an agent-native factory, code is a compiled artifact; context is the source program."
    }
  },
  "problem": {
    "observed_failure_modes": [
      {
        "id": "CAC-FM-0001",
        "impact": [
          "agents mis-plan",
          "reviewers miss implicit assumptions",
          "system behavior diverges from declared behavior"
        ],
        "mechanism": "Normative requirements appear in Markdown/scripts without schema validation or canonicalization.",
        "name": "Contract drift encoded in prose"
      },
      {
        "id": "CAC-FM-0002",
        "impact": [
          "agents freeze mid-flight",
          "manual debugging",
          "slow iteration",
          "loss of trust in automation"
        ],
        "mechanism": "CLI claims features via docs or flags but behavior is untested or partial.",
        "name": "Capability ambiguity in the CLI"
      },
      {
        "id": "CAC-FM-0003",
        "impact": [
          "non-determinism",
          "leaky policies",
          "hidden dependencies",
          "repeat incidents"
        ],
        "mechanism": "Consumption holons perform discretionary reads/browsing because required context was not compiled into a pack.",
        "name": "Unplanned tool calls during consumption"
      },
      {
        "id": "CAC-FM-0004",
        "impact": [
          "irreproducible outputs",
          "cannot audit",
          "cannot improve pack compiler"
        ],
        "mechanism": "Context production uses tools without explicit leases/budgets and without publishing evidence snapshots.",
        "name": "Non-replayable research behavior"
      },
      {
        "id": "CAC-FM-0005",
        "impact": [
          "drift",
          "unclear provenance",
          "unsafe edits to generated artifacts"
        ],
        "mechanism": "External systems require Markdown + directory layouts; without a compiler, teams treat these outputs as source of truth.",
        "name": "Vendor ABI requirements dominate internal design"
      }
    ],
    "primary_bottleneck": {
      "definition": "The cycle time and defect rate of the tight loop: change intent \u2192 code generation \u2192 review \u2192 merge \u2192 verification.",
      "name": "Innermost loop throughput",
      "why_context_blocks_it": [
        "Agents spend time searching or asking for context that should have been pre-packaged.",
        "Reviewers catch important bugs, but root cause is often missing or inconsistent context rather than coding mistakes.",
        "CLI/xtask mismatch causes brittle workflows and manual intervention."
      ]
    },
    "root_causes": [
      "No normative representation for context (schema-validated, canonical, versioned).",
      "No patch-first authoring pipeline with replay protection and evidence receipts.",
      "No stable-ID deterministic read plane for consumption holons.",
      "No capability truthing/selftest receipts gating agent plans.",
      "No principled compiler boundary between internal context IR and vendor-required ABIs."
    ],
    "statement": "The system lacks a single, canonical, machine-validated source of truth for the context that governs planning, execution, review, and operation. This forces discretionary context discovery, increases drift, and blocks safe cutover to the APM2 CLI as the holonic control surface."
  },
  "engineering_goals": [
    {
      "id": "CAC-G-0001",
      "name": "Canonical context substrate (CAC-JSON)",
      "success_criteria": [
        "All normative control artifacts are stored as CAC-JSON and canonicalized to stable bytes prior to admission.",
        "Artifacts validate against versioned schemas with fail-closed behavior (unknown fields rejected).",
        "Artifacts are addressable by stable IDs and immutable content hashes (CAS)."
      ]
    },
    {
      "id": "CAC-G-0002",
      "name": "Patch-first machine authoring",
      "success_criteria": [
        "Machines produce patch streams (JSON Patch / Merge Patch) rather than whole-document rewrites.",
        "Admission enforces replay protection via expected base hash.",
        "Every accepted patch produces an admission receipt (evidence) and emits ledger provenance."
      ]
    },
    {
      "id": "CAC-G-0003",
      "name": "Hermetic consumption with deterministic reads",
      "success_criteria": [
        "Consumption holons can complete tasks using only preauthorized stable-ID fetches plus actuation tools.",
        "Discretionary context discovery during consumption is denied and/or defect-emitting by policy.",
        "ContextPack manifests include transitive dependency closure (deep pinning).",
        "Run receipts capture context_pack_miss and context_pack_sufficiency; misses gate consumption unless explicitly escalated."
      ]
    },
    {
      "id": "CAC-G-0004",
      "name": "Bounded context production with replayable evidence",
      "success_criteria": [
        "Production holons operate under explicit leases/budgets and publish replayable evidence (snapshots, extraction logs, diffs).",
        "Tool calls are classified as planned/unplanned and feed defect signals into pack compiler improvement.",
        "Admissions include a ChangeSet report to summarize semantic deltas and enable compaction."
      ]
    },
    {
      "id": "CAC-G-0005",
      "name": "Target interoperability without drift",
      "success_criteria": [
        "Target profiles define rendering, retrieval, and delivery constraints independent of model intelligence.",
        "Target payloads (vendor layouts, model IRs) are compiled deterministically from CAC sources and never treated as normative.",
        "Export manifests provide provenance and are verified by conformance tests."
      ]
    },
    {
      "id": "CAC-G-0006",
      "name": "Messaging-native control plane compatibility",
      "success_criteria": [
        "CAC actions (admission, compilation, export, selftest) are reflected in kernel messages (ledger events) with hash references.",
        "Holons can negotiate capabilities and retrieve required context via stable IDs referenced in messages."
      ]
    },
    {
      "id": "CAC-G-0007",
      "name": "Measurable throughput and quality gains",
      "success_criteria": [
        "Unplanned tool calls in consumption mode trend toward zero.",
        "PR cycle time and defect recurrence improve after adoption.",
        "AAT receipts gate critical operations with high pass rates."
      ]
    },
    {
      "id": "CAC-G-0008",
      "name": "Typed quantities and context budgets",
      "success_criteria": [
        "Budgets, timeouts, costs, and probabilities are expressed as typed quantities with explicit units.",
        "ContextPack compilation and validation reject packs exceeding token/artifact/byte budgets."
      ]
    },
    {
      "id": "CAC-G-0009",
      "name": "Canonicalizer governance",
      "success_criteria": [
        "Canonicalizer id/version are recorded in envelopes and receipts for all normative artifacts.",
        "Canonicalization test vectors are governed artifacts pinned in the bootstrap bundle."
      ]
    }
  ],
  "non_goals": [
    {
      "id": "CAC-NG-0001",
      "statement": "Humans authoring normative context artifacts."
    },
    {
      "id": "CAC-NG-0002",
      "statement": "Using token-optimized formats (e.g., TOON) as normative storage."
    },
    {
      "id": "CAC-NG-0003",
      "statement": "Replacing all existing kernel Protobuf schemas in this phase."
    },
    {
      "id": "CAC-NG-0004",
      "statement": "Building a universal cross-vendor standard; we compile to target profiles and delivery payloads instead."
    }
  ],
  "principles": [
    {
      "corollaries": [
        "A missing context input is a compiler failure, not an execution-time discovery obligation.",
        "Optimizing the innermost loop is primarily optimizing context completeness and correctness."
      ],
      "id": "CAC-P-PRIN-0001",
      "name": "Context is the program",
      "statement": "Normative context artifacts are the source program; code and other outputs are compiled artifacts."
    },
    {
      "id": "CAC-P-PRIN-0002",
      "name": "Machine-native, canonical, validated",
      "statement": "Every normative artifact is machine-readable, schema-validated, and canonicalized to stable bytes before it can influence behavior."
    },
    {
      "id": "CAC-P-PRIN-0003",
      "name": "Patch-first authoring",
      "statement": "Machines author changes as small, typed, replay-protected patches; whole-document rewrites are an anti-pattern."
    },
    {
      "id": "CAC-P-PRIN-0004",
      "name": "Hermetic consumption, bounded production",
      "statement": "ZTI applies to context consumption: no discretionary context discovery; production may use tools under explicit leases/budgets with replayable evidence."
    },
    {
      "id": "CAC-P-PRIN-0005",
      "name": "Evidence is mandatory",
      "statement": "Every admission, compilation, export, and gate decision produces evidence stored in CAS and referenced by signed ledger events."
    },
    {
      "corollaries": [
        "No direct edits to generated ABI trees in mainline.",
        "Delivery conformance is tested and versioned via target profiles."
      ],
      "id": "CAC-P-PRIN-0006",
      "name": "Target profiles are the ABI contract",
      "statement": "Rendering, retrieval, and delivery are governed by target profiles; vendor or model-specific payloads are deterministic projections, never normative sources."
    },
    {
      "id": "CAC-P-PRIN-0007",
      "name": "Fail-closed, least privilege, algorithm agility",
      "statement": "Parsing, validation, and policy checks fail closed; privileges are explicit; cryptography and serialization choices remain agile under an adversarial threat model."
    },
    {
      "id": "CAC-P-PRIN-0008",
      "name": "Message-level provenance and replay",
      "statement": "All state transitions are represented as signed kernel messages referencing immutable hashes; projections are derived, reconstructable, and auditable."
    },
    {
      "corollaries": [
        "All transitive dependencies are resolved and pinned before consumption.",
        "ContextPack manifests are closure views over the context graph."
      ],
      "id": "CAC-P-PRIN-0009",
      "name": "Context graph closure",
      "statement": "Dependencies are explicit and closed; hermetic consumption operates on deep-pinned graph closures, not open-ended discovery."
    },
    {
      "id": "CAC-P-PRIN-0010",
      "name": "Typed, bounded quantities",
      "statement": "Budgets, timeouts, costs, and probabilities use typed quantities with explicit units and enforced bounds to ensure deterministic cross-language behavior."
    }
  ],
  "system_model": {
    "core_components": [
      {
        "existing_primitives_in_apm2": [
          "Signed, hash-chained KernelEvent ledger entries (apm2.kernel.v1.KernelEvent).",
          "Tool protocol messages (apm2.tool.v1.ToolRequest/ToolResponse).",
          "Evidence CAS (BLAKE3 hashes) and EvidencePublished events."
        ],
        "id": "COMP-KERNEL",
        "name": "Holonic Kernel",
        "responsibilities": [
          "Enforce policy, budgets, and leases.",
          "Persist signed events in an append-only ledger.",
          "Mediate tool execution (default-deny) and record tool events.",
          "Publish evidence artifacts to CAS and emit evidence events."
        ]
      },
      {
        "hash_algorithm": "BLAKE3-256 (as implemented in APM2 evidence module)",
        "id": "COMP-CAS",
        "name": "Content-Addressed Store (CAS)",
        "responsibilities": [
          "Store immutable blobs addressed by cryptographic content hashes.",
          "Verify integrity on store and retrieve."
        ]
      },
      {
        "id": "COMP-LEDGER",
        "name": "Ledger",
        "responsibilities": [
          "Append-only, hash-chained log of signed kernel events.",
          "Source of truth for all state transitions and provenance."
        ]
      },
      {
        "id": "COMP-DCP",
        "name": "Deterministic Content Plane (DCP)",
        "note": "DCP is implemented as an index/projection over immutable artifacts and ledger events; not an independent mutable source of truth.",
        "responsibilities": [
          "Provide stable-ID addressing for normative artifacts.",
          "Enable deterministic, preauthorized reads by stable ID in consumption mode.",
          "Track dependency edges between artifacts and expose graph closure for pack compilation."
        ]
      },
      {
        "id": "COMP-CAC-REGISTRY",
        "name": "CAC Artifact & Schema Registry",
        "responsibilities": [
          "Define artifact kinds and schema IDs.",
          "Validate and canonicalize artifacts for admission.",
          "Ship and verify a bootstrap schema bundle pinned by hash; enforce immutability of bootstrap stable IDs.",
          "Manage schema evolution rules and compatibility."
        ]
      },
      {
        "id": "COMP-COMPILER",
        "name": "Context Compiler",
        "responsibilities": [
          "Compile ContextPacks for consumption holons.",
          "Compile foreign ABI exports (vendor layouts) from internal IR.",
          "Emit provenance receipts and evidence."
        ]
      }
    ],
    "end_to_end_flow": {
      "key_invariants": [
        "Bootstrap schema bundle is verified at startup and immutable via the standard patch pipeline.",
        "No normative artifact influences execution without schema validation and canonicalization.",
        "No consumption holon uses open-ended discovery for context; misses are treated as pack compiler failures and fail the run by default.",
        "Target profiles define rendering, retrieval, and delivery constraints for compilation and execution.",
        "Every step is evidence-backed and message-represented in the signed ledger."
      ],
      "narrative": [
        "Machine authors propose changes as PatchRecords with ChangeSet reports.",
        "Kernel validates patch + schema, applies it with replay protection, canonicalizes the resulting artifact, stores it in CAS, and updates DCP index via ledger events.",
        "Context compiler builds ContextPacks using target profiles and deep-pins the transitive dependency closure, emitting receipts to CAS and ledger.",
        "Consumption holons execute tasks using only ContextPacks and stable-ID fetches; pack misses emit defects and fail runs unless explicitly escalated, feeding back into pack compiler and schema evolution."
      ]
    },
    "entities": [
      {
        "definition": "A normative CAC-JSON document that influences holonic behavior (policies, packs, skills, capabilities, contracts).",
        "id": "ENT-ARTIFACT",
        "identity": [
          "stable_id",
          "content_hash",
          "schema_ref"
        ],
        "name": "ControlArtifact"
      },
      {
        "definition": "A versioned schema (JSON Schema) used to validate a ControlArtifact kind.",
        "id": "ENT-SCHEMA",
        "name": "SchemaDefinition"
      },
      {
        "definition": "A single machine-authored patch operation (JSON Patch or Merge Patch) with replay protection and provenance, typically transported as JSONL.",
        "id": "ENT-PATCH",
        "name": "PatchRecord"
      },
      {
        "definition": "A bounded set of stable-ID addressed artifacts required for a consumption holon to execute a task without discretionary discovery.",
        "id": "ENT-PACK",
        "name": "ContextPack"
      },
      {
        "definition": "A machine-readable declaration of what the runtime/CLI actually supports, used for capability negotiation and gating.",
        "id": "ENT-CAP",
        "name": "CapabilityManifest"
      },
      {
        "definition": "A machine-readable profile describing how to compile internal artifacts into a vendor-required ABI (filesystem layout + Markdown templates), plus conformance tests.",
        "id": "ENT-VENDOR",
        "name": "VendorProfile"
      },
      {
        "definition": "A machine-readable target profile defining context budgets, rendering policy, retrieval policy, and delivery constraints independent of model intelligence.",
        "id": "ENT-TARGET",
        "name": "TargetProfile"
      },
      {
        "definition": "A structured evidence record proving an action occurred and met its contract (admission receipt, pack compilation receipt, export receipt, AAT/selftest receipt).",
        "id": "ENT-RECEIPT",
        "name": "Receipt"
      },
      {
        "definition": "A standardized semantic delta report describing patch effects, compatibility notes, and affected packs.",
        "id": "ENT-CHANGESET",
        "name": "ChangeSetReport"
      },
      {
        "definition": "A run receipt capturing context pack sufficiency, misses, and budget usage for a consumption execution.",
        "id": "ENT-RUN-RECEIPT",
        "name": "RunReceipt"
      },
      {
        "definition": "Canonicalization test vectors pinned as governed artifacts for cross-runtime determinism.",
        "id": "ENT-CANON-VECTORS",
        "name": "CanonicalizerVectors"
      }
    ],
    "modes": [
      {
        "id": "MODE-PRODUCE",
        "name": "Context Production Mode",
        "tooling_policy": "Tools allowed under explicit lease/budget; all outputs must emit evidence and be replayable to the maximum extent possible."
      },
      {
        "id": "MODE-CONSUME",
        "name": "Context Consumption Mode",
        "tooling_policy": "No discretionary context discovery; only deterministic, preauthorized stable-ID fetches plus narrowly scoped actuation tools."
      }
    ]
  },
  "format_policy": {
    "artifact_hashing_policy": {
      "algorithm": "BLAKE3-256",
      "hash_id_format": "b3-256:<hex>",
      "note": "Align with existing APM2 Evidence/CAS hashing to keep the stack coherent."
    },
    "typed_quantities": {
      "note": "All budgets, timeouts, costs, and probabilities must use typed quantities with explicit units to avoid ad hoc string formats.",
      "schema_ref": "cac.common.v1#/$defs/quantity",
      "unit_rules": [
        "Units must be explicit (e.g., ms, bytes, tokens, count, percent, usd).",
        "Values are integers; scaling is expressed via the scale field.",
        "Probabilities are represented as scaled integers (e.g., percent or ppm)."
      ]
    },
    "canonicalizer_metadata": {
      "required_fields": [
        "canonicalizer_id",
        "canonicalizer_version",
        "vectors_ref"
      ],
      "rule": "Every normative artifact envelope and receipt must record the canonicalizer id/version and reference the governed test-vector artifact."
    },
    "derived_formats": [
      {
        "id": "FMT-TOON",
        "name": "TOON",
        "policy": "Derived-only; never normative",
        "required_invariants": [
          "Must be derivable deterministically from canonical IR.",
          "Must have a defined reverse mapping back to canonical IR OR be explicitly declared one-way."
        ],
        "role": "Optional derived prompt-pack encoding for LLM consumption",
        "selection_heuristics": [
          "Prefer TOON for large, repetitive tabular arrays or repeated keys where token savings are material.",
          "Prefer compact JSON for deep, irregular, or highly nested structures."
        ]
      },
      {
        "id": "FMT-MARKDOWN",
        "name": "Markdown (Vendor ABI)",
        "notes": [
          "Generated Markdown should embed provenance metadata in frontmatter where the vendor allows.",
          "Direct edits to generated trees are rejected by CI unless routed through an import pipeline."
        ],
        "policy": "Derived-only; never normative",
        "role": "Vendor-required human-readable interface"
      }
    ],
    "normative_formats": [
      {
        "canonicalization": {
          "id": "CANON-JCS",
          "name": "JSON Canonicalization Scheme (JCS-like)",
          "note": "Adopt RFC 8785 JCS where feasible; if deviating, publish explicit test vectors as governed artifacts and treat the canonicalizer as a versioned component.",
          "requirements": [
            "Deterministic object member ordering.",
            "Deterministic number rendering (for allowed integers: minimal decimal form).",
            "Deterministic string escaping.",
            "No insignificant whitespace (canonical bytes)."
          ]
        },
        "constraints": {
          "arrays": {
            "max_length": 100000
          },
          "duplicate_keys": "FORBIDDEN",
          "encoding": "UTF-8",
          "json_standard": "RFC 8259-compatible",
          "max_depth": 128,
          "numbers": {
            "notes": [
              "Avoid float parsing ambiguity across implementations.",
              "If non-integer values are required, represent them as strings with an explicit unit/type."
            ],
            "policy": "integers_only",
            "range": "signed_64_bit"
          },
          "objects": {
            "max_members": 100000,
            "member_name_constraints": {
              "notes": [
                "Keep member names stable and tool-friendly; avoid whitespace."
              ],
              "pattern": "^[A-Za-z0-9_./:-]{1,256}$"
            }
          },
          "strings": {
            "max_bytes": 1048576,
            "normalization": "NFC recommended"
          }
        },
        "id": "FMT-CAC-JSON",
        "name": "CAC-JSON",
        "role": "Sole normative representation for control artifacts"
      },
      {
        "constraints": {
          "encoding": "UTF-8",
          "max_line_bytes": 10485760,
          "newline_rule": "Each record terminates with \\n; no embedded newlines unless escaped within JSON strings.",
          "record_rule": "Each line is a complete JSON value."
        },
        "id": "FMT-JSONL",
        "name": "JSON Lines (JSONL)",
        "role": "Append-only record streams (patch streams, receipts, defect streams)"
      }
    ],
    "patch_authoring_policy": {
      "allowed_patch_kinds": [
        "json_patch_rfc6902",
        "json_merge_patch_rfc7396"
      ],
      "default_patch_kind": "json_patch_rfc6902",
      "replay_protection": {
        "mechanism": "PatchRecord must include expected_base_hash; admission rejects mismatches.",
        "required": true
      },
      "whole_document_rewrite_policy": {
        "allowed": "discouraged",
        "reason": "Large rewrites increase review cost and reduce cache/utilization benefits.",
        "rule": "If a patch replaces >X% of nodes, system emits a warning or requires explicit justification code."
      }
    }
  },
  "artifact_kinds": {
    "kinds": [
      {
        "consume_allowed": true,
        "kind_id": "schema.definition",
        "normative": true,
        "purpose": "Defines schemas used to validate other artifacts.",
        "schema_id": "cac.schema_definition.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "policy.profile",
        "normative": true,
        "purpose": "Defines policy rules for tools, reads, budgets, and consumption hermeticity.",
        "schema_id": "cac.policy_profile.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "budget.profile",
        "normative": true,
        "purpose": "Defines budgets/limits used in leases and tool calls.",
        "schema_id": "cac.budget_profile.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "holon.contract",
        "normative": true,
        "purpose": "Defines holon roles, modes, inputs/outputs, and allowed operations.",
        "schema_id": "cac.holon_contract.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "skill.spec",
        "normative": true,
        "purpose": "Defines agent skill/instruction bundles as machine-native context.",
        "schema_id": "cac.skill_spec.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "target.profile",
        "normative": true,
        "purpose": "Defines rendering, retrieval, and delivery constraints independent of model intelligence; drives compilation.",
        "schema_id": "cac.target_profile.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "canonicalizer.vectors",
        "normative": true,
        "purpose": "Governed canonicalization test vectors pinned in the bootstrap trust root.",
        "schema_id": "cac.canonicalizer_vectors.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "vendor.profile",
        "normative": false,
        "purpose": "Derived vendor delivery profile compiled from TargetProfile (compatibility surface, not normative).",
        "schema_id": "cac.vendor_profile.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "capabilities.manifest",
        "normative": true,
        "purpose": "Declares what the CLI/kernel actually supports (truth surface for agents).",
        "schema_id": "cac.capabilities_manifest.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "context_pack.spec",
        "normative": true,
        "purpose": "Defines which stable IDs constitute a ContextPack and the pack's consumption contract.",
        "schema_id": "cac.context_pack_spec.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "context_pack.manifest",
        "normative": false,
        "purpose": "Compiled output listing resolved stable IDs, hashes, and derived pack artifacts.",
        "schema_id": "cac.context_pack_manifest.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "export.manifest",
        "normative": false,
        "purpose": "Derived output describing a vendor export tree and its provenance.",
        "schema_id": "cac.export_manifest.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "changeset.report",
        "normative": false,
        "purpose": "Standardized semantic delta report for patch admissions and compaction.",
        "schema_id": "cac.changeset_report.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "receipt.admission",
        "normative": false,
        "purpose": "Evidence receipt proving an artifact was admitted (validated, canonicalized, stored, indexed).",
        "schema_id": "cac.admission_receipt.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "receipt.aat",
        "normative": false,
        "purpose": "Evidence receipt proving acceptance/selftests passed with bounded resources.",
        "schema_id": "cac.aat_receipt.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "receipt.run",
        "normative": false,
        "purpose": "Evidence receipt for consumption runs (pack sufficiency, misses, and budget usage).",
        "schema_id": "cac.run_receipt.v1"
      },
      {
        "consume_allowed": true,
        "kind_id": "defect.record",
        "normative": false,
        "purpose": "Evidence-backed defect records feeding improvement loops.",
        "schema_id": "cac.defect_record.v1"
      }
    ],
    "notes": [
      "Normative=true kinds must be CAC-JSON, schema-validated, canonicalized, stored in CAS, and indexed in DCP before use.",
      "Derived kinds may be stored in CAS and referenced in ledger but are not authoritative sources."
    ],
    "registry_version": "1.0.0"
  },
  "schema_registry": {
    "compatibility_policy": {
      "default": "strict",
      "rules": [
        {
          "id": "SC-COMP-0001",
          "statement": "Normative artifacts must set unevaluatedProperties=false (or equivalent) to reject unknown fields."
        },
        {
          "id": "SC-COMP-0002",
          "statement": "Additive changes are allowed within a schema major version only if consumers ignore them by explicit rule; default is reject."
        },
        {
          "id": "SC-COMP-0003",
          "statement": "Deprecations must be explicit: schemas may mark fields deprecated but must continue to validate until major bump."
        }
      ]
    },
    "design": {
      "schema_id_rules": [
        "Schema IDs are stable and versioned (e.g., cac.context_pack_spec.v1).",
        "Breaking changes require new major schema ID version (v2)."
      ],
      "schema_store": "Schemas are CAC-JSON artifacts stored in CAS and referenced by stable ID + hash.",
      "validation_engine_requirements": [
        "Support JSON Schema draft 2020-12 (minimum).",
        "Fail closed on unknown keywords (unless explicitly allowed by validator profile).",
        "Enforce size/depth/resource limits during validation to prevent DoS."
      ]
    },
    "schema_discovery": {
      "bootstrap": "Kernel/CLI ships with a minimal bootstrap schema bundle pinned by hash in the binary (schema_definition + PatchRecord + AdmissionReceipt + shared refs + canonicalizer vectors). This Phase-0 trust root is immutable via the standard patch pipeline.",
      "immutability_policy": "Admission rejects patches or artifacts that attempt to modify or shadow bootstrap stable IDs.",
      "upgrade_path": "Bootstrap changes occur only via a new binary release (or a separately authorized bootstrap-upgrade flow), never via PatchRecord admission.",
      "mechanism": "Schema refs are stable IDs resolvable in DCP; schemas are themselves control artifacts."
    }
  },
  "pipeline": {
    "closed_loop": {
      "default_rule": "Treat unplanned reads/tool calls in consumption mode as compiler defects, not execution necessities.",
      "feedback_targets": [
        "ContextPack compiler rules",
        "Schema evolution (tighten or expand)",
        "Capability manifest updates",
        "Target profile updates",
        "ChangeSet compaction rules"
      ],
      "signals": [
        "PolicyViolation events",
        "BudgetExceeded events",
        "Unplanned tool call attempts in consumption mode",
        "Selftest/AAT failures",
        "Export conformance failures"
      ]
    },
    "overview": "A closed-loop, message-native context pipeline: machines propose patches with semantic deltas; kernel admits canonical artifacts; compiler builds deep-pinned packs and target-specific payloads; consumption is hermetic and budgeted; misses create defects; improvements feed back into pack compilation and target profiles.",
    "stages": [
      {
        "default_tool_budget": {
          "notes": [
            "Patch authoring may run in production mode and use tools under lease/budget."
          ],
          "tool_calls": "bounded"
        },
        "inputs": [
          "work_id",
          "target_artifact_ref (stable_id + expected_base_hash)",
          "schema_ref",
          "budget/lease refs"
        ],
        "invariants": [
          "PatchRecord must include expected_base_hash for replay protection.",
          "PatchRecord must declare patch_kind and be schema-valid itself.",
          "If patch touches security-critical artifacts, it must include a justification_code and can trigger adjudication."
        ],
        "mode": "PRODUCE",
        "name": "Patch Authoring",
        "outputs": [
          "PatchRecord (JSONL record)",
          "ChangeSetReport (semantic delta summary)",
          "optional supporting evidence (CAS refs)"
        ],
        "stage_id": "CAC-STAGE-01"
      },
      {
        "inputs": [
          "PatchRecord",
          "schema_ref",
          "policy_profile_ref",
          "artifact_kind rules"
        ],
        "invariants": [
          "Fail-closed on schema mismatch, unknown fields, forbidden constructs, size/depth limits.",
          "Reject patch if expected_base_hash does not match current artifact hash.",
          "Policy profile may deny patching certain paths/fields without adjudication.",
          "Admission requires a ChangeSetReport for patch streams."
        ],
        "kernel_messages": [
          {
            "event": "PolicyViolation",
            "event_family": "PolicyEvent",
            "when": "on denial due to policy"
          }
        ],
        "mode": "KERNEL",
        "name": "Admission Gate: Validate",
        "outputs": [
          "ValidationReport (machine-readable)",
          "admit/deny decision"
        ],
        "stage_id": "CAC-STAGE-02"
      },
      {
        "inputs": [
          "validated PatchRecord",
          "base artifact (canonical)",
          "canonicalizer id/version"
        ],
        "invariants": [
          "Canonicalization is deterministic and idempotent.",
          "New artifact must validate against target schema after patching and canonicalization.",
          "AdmissionReceipt references: patch record hash, base hash, new hash, schema hash, canonicalizer id/version."
        ],
        "kernel_messages": [
          {
            "event": "EvidencePublished",
            "event_family": "EvidenceEvent",
            "when": "on publishing AdmissionReceipt and/or admitted artifact"
          }
        ],
        "mode": "KERNEL",
        "name": "Admission Gate: Apply Patch + Canonicalize",
        "outputs": [
          "new canonical artifact bytes",
          "content_hash",
          "AdmissionReceipt"
        ],
        "stage_id": "CAC-STAGE-03"
      },
      {
        "dcp_indexing_strategy": {
          "fallback": "Explicit DCP mapping events (future extension)",
          "preferred": "Projection over ledger EvidencePublished metadata"
        },
        "inputs": [
          "canonical artifact bytes",
          "artifact metadata (stable_id, schema_id, kind)"
        ],
        "invariants": [
          "CAS blobs are immutable and verified by hash.",
          "DCP is derived: stable_id -> content_hash mapping is reconstructable from ledger events.",
          "No artifact becomes visible to consumption mode until its stable_id resolves to a pinned content_hash.",
          "Dependency edges are recorded for graph closure queries."
        ],
        "mode": "KERNEL",
        "name": "Publish to CAS + Update DCP",
        "outputs": [
          "CAS blob",
          "DCP index update",
          "ledger provenance events"
        ],
        "stage_id": "CAC-STAGE-04"
      },
      {
        "inputs": [
          "ContextPackSpec (stable_id)",
          "resolved stable_ids",
          "lease/budget refs",
          "TargetProfile (stable_id)"
        ],
        "invariants": [
          "Compilation is deterministic given resolved inputs and target profile.",
          "Manifest lists every stable_id with pinned content_hash; no floating refs.",
          "Transitive dependency closure is resolved and pinned (deep pinning).",
          "Context budgets (tokens, artifacts, bytes) are enforced during compilation.",
          "Compiler must emit evidence snapshots for any tool-derived sources."
        ],
        "kernel_messages": [
          {
            "event": "EvidencePublished",
            "event_family": "EvidenceEvent",
            "when": "on publishing pack manifest and receipts"
          }
        ],
        "mode": "PRODUCE",
        "name": "Compile ContextPacks",
        "outputs": [
          "ContextPackManifest",
          "Derived PromptPack artifacts (TOON or compact JSON)",
          "PackCompilationReceipt"
        ],
        "stage_id": "CAC-STAGE-05"
      },
      {
        "inputs": [
          "TargetProfile (stable_id)",
          "SkillSpec and other inputs (stable_ids)",
          "export target (workspace dir)"
        ],
        "invariants": [
          "Rendering is deterministic and constrained by the target profile.",
          "Export is deterministic from inputs; output tree is byte-identical for identical inputs.",
          "Generated files embed provenance (stable_ids, hashes) where possible (e.g., YAML frontmatter).",
          "Conformance tests are required and their results are published as evidence."
        ],
        "kernel_messages": [
          {
            "event": "EvidencePublished",
            "event_family": "EvidenceEvent",
            "when": "on publishing export manifest/receipt"
          },
          {
            "event": "GateReceiptGenerated",
            "event_family": "GateReceiptGenerated",
            "when": "optional gating of export"
          }
        ],
        "mode": "PRODUCE",
        "name": "Target Delivery Rendering",
        "outputs": [
          "delivery payloads (vendor layouts, model IRs)",
          "ExportManifest",
          "ExportReceipt",
          "conformance test report"
        ],
        "stage_id": "CAC-STAGE-06"
      },
      {
        "inputs": [
          "built apm2 binary",
          "capabilities manifest schema",
          "selftest suite"
        ],
        "invariants": [
          "CapabilityManifest is generated from the binary (not handwritten).",
          "Selftests are hermetic and bounded (time/tool/token budgets).",
          "AATReceipt is required for critical cutovers and for agent planning gates."
        ],
        "mode": "PRODUCE",
        "name": "Capability Truthing + Selftest (AAT)",
        "outputs": [
          "CapabilityManifest",
          "AATReceipt",
          "GateReceipt (optional)"
        ],
        "stage_id": "CAC-STAGE-07"
      },
      {
        "defect_generation": [
          {
            "default_remediation": [
              "update ContextPackSpec",
              "update pack compiler rules",
              "add stable-ID mapping"
            ],
            "defect_class": "UNPLANNED_CONTEXT_READ",
            "trigger": "attempted tool call or read not in pack allowlist"
          }
        ],
        "inputs": [
          "work_id",
          "ContextPackManifest",
          "CapabilityManifest",
          "policy profile"
        ],
        "invariants": [
          "All context reads must be stable-ID fetches from DCP via deterministic tools.",
          "Discretionary discovery attempts are denied or defect-emitting.",
          "Any required extra context is classified as a pack compiler failure defect.",
          "context_pack_miss emits a defect and fails the run unless explicitly in escalation-allowed mode."
        ],
        "mode": "CONSUME",
        "name": "Consume (Execution/Review/Ops)",
        "outputs": [
          "work outputs (code, reviews, ops actions)",
          "RunReceipt (context_pack_miss + sufficiency)",
          "evidence artifacts",
          "ledger events"
        ],
        "stage_id": "CAC-STAGE-08"
      }
    ]
  },
  "messaging_integration": {
    "capability_negotiation": {
      "mechanism": [
        "Agent/holon obtains CapabilityManifest (stable_id) and verifies AATReceipt pinned hash.",
        "Agent gates plan generation on declared capabilities and versions; if missing, it files a defect instead of probing."
      ],
      "required_fields_in_manifest": [
        "apm2_version",
        "command_inventory",
        "schemas_supported",
        "tool_protocol_version",
        "selftest_receipt_ref",
        "target_profiles_supported"
      ]
    },
    "current_messaging_assets": {
      "cas_hash": {
        "algorithm": "BLAKE3-256",
        "proto_representation": "bytes (32 bytes)"
      },
      "kernel_events_proto": {
        "file": "proto/kernel_events.proto",
        "notable_constraints": [
          "Signed events over canonical bytes; maps forbidden; repeated fields must be sorted before signing."
        ],
        "package": "apm2.kernel.v1",
        "relevant_event_families": [
          "EvidenceEvent (EvidencePublished, GateReceiptGenerated)",
          "PolicyEvent (PolicyLoaded, PolicyViolation, BudgetExceeded)",
          "ToolEvent (ToolRequested, ToolDecided, ToolExecuted)",
          "WorkEvent, SessionEvent, LeaseEvent, AdjudicationEvent"
        ]
      },
      "tool_protocol_proto": {
        "existing_tools": [
          "FileRead, FileWrite, FileEdit",
          "ShellExec",
          "GitOperation",
          "InferenceCall",
          "ArtifactPublish"
        ],
        "file": "proto/tool_protocol.proto",
        "gap": "No tool exists to fetch CAS/DCP artifacts by stable ID (required for hermetic consumption).",
        "package": "apm2.tool.v1"
      }
    },
    "mapping_strategy_v1": {
      "evidence_categories": [
        "CONTROL_ARTIFACT",
        "SCHEMA_DEFINITION",
        "CONTEXT_PACK",
        "PROMPT_PACK",
        "TARGET_PROFILE",
        "VENDOR_EXPORT",
        "CAPABILITY_MANIFEST",
        "AAT_RECEIPT",
        "ADMISSION_RECEIPT",
        "CHANGESET_REPORT",
        "RUN_RECEIPT",
        "CANONICALIZER_VECTORS"
      ],
      "metadata_encoding": {
        "format": "key=value strings (aligns with EvidencePublished.metadata)",
        "rules": [
          "Keys must be ASCII lowercase with underscores (e.g., dcp_id=...).",
          "Values must be URL-escaped if they contain spaces or '='."
        ]
      },
      "principle": "Use existing kernel event families (EvidencePublished + metadata) as the initial control-plane signal carrier; avoid proto changes for MVP unless necessary.",
      "required_evidence_metadata_keys": [
        "dcp_id",
        "artifact_kind",
        "schema_id",
        "schema_hash",
        "canonicalization",
        "canonicalizer_id",
        "canonicalizer_version",
        "target_profile_id"
      ]
    },
    "optional_kernel_schema_extensions": [
      {
        "benefit": "Typed fields instead of metadata strings; easier querying and policy enforcement.",
        "id": "CAC-MSG-OPT-0001",
        "proposal": "Add ControlArtifactEvent family to apm2.kernel.v1.KernelEvent payload.",
        "risk": "Proto evolution coordination; requires updating reducers and clients.",
        "status": "optional_post_mvp"
      }
    ],
    "required_protocol_extensions": [
      {
        "id": "CAC-MSG-REQ-0001",
        "priority": "P0",
        "proposal": {
          "purpose": "Deterministic retrieval of context artifacts by stable ID or content hash.",
          "request_fields": [
            {
              "name": "stable_id",
              "required": false,
              "type": "string"
            },
            {
              "name": "content_hash",
              "required": false,
              "type": "bytes"
            },
            {
              "name": "expected_hash",
              "required": false,
              "type": "bytes"
            },
            {
              "name": "max_bytes",
              "required": true,
              "type": "uint64"
            },
            {
              "name": "format",
              "notes": [
                "raw_bytes",
                "utf8_text",
                "json_canonical"
              ],
              "required": true,
              "type": "string"
            }
          ],
          "response_contract": [
            "Returns result_hash and/or inline_result per ToolSuccess.",
            "Policy enforces: only stable-ID allowlisted reads in consumption mode.",
            "If expected_hash provided and mismatch occurs, return ToolError and emit PolicyViolation/Defect."
          ],
          "tool_name": "ArtifactFetch"
        },
        "target": "apm2.tool.v1.ToolRequest"
      },
      {
        "id": "CAC-MSG-REQ-0002",
        "priority": "P1",
        "proposal": {
          "purpose": "Resolve a stable_id to a pinned content hash and schema ref without fetching full content.",
          "request_fields": [
            {
              "name": "stable_id",
              "required": true,
              "type": "string"
            }
          ],
          "response_contract": [
            "Returns resolved_hash + schema_id + schema_hash as a small inline JSON payload.",
            "Consumption-mode reads are still enforced; resolve itself is deterministic."
          ],
          "tool_name": "DcpResolve"
        },
        "target": "apm2.tool.v1.ToolRequest"
      }
    ]
  },
  "security": {
    "controls": [
      {
        "details": "Restrict CAC-JSON to integer-only numbers within 64-bit range; enforce max depth and size.",
        "id": "SEC-CTRL-0001",
        "name": "Canonical JSON profile (no floats, bounded depth)",
        "type": "preventative"
      },
      {
        "details": "Canonicalizer is a versioned component; include golden vectors and cross-platform tests; canonical bytes used for hashing.",
        "id": "SEC-CTRL-0002",
        "name": "Deterministic canonicalizer with test vectors",
        "type": "preventative"
      },
      {
        "details": "Canonicalizer id/version and test-vector reference are recorded in envelopes/receipts; vectors are governed artifacts pinned in the bootstrap bundle.",
        "id": "SEC-CTRL-0009",
        "name": "Canonicalizer governance metadata",
        "type": "preventative"
      },
      {
        "details": "Validator profile rejects unknown fields; schemas use unevaluatedProperties=false.",
        "id": "SEC-CTRL-0003",
        "name": "Schema strictness (unknown field rejection)",
        "type": "preventative"
      },
      {
        "details": "Ledger events are signed and hash-chained; artifacts are content-addressed and integrity-verified.",
        "id": "SEC-CTRL-0004",
        "name": "Signed ledger + CAS hashes",
        "type": "detective+preventative"
      },
      {
        "details": "Consumption holons run with restricted filesystem and network; only deterministic ArtifactFetch permitted for context.",
        "id": "SEC-CTRL-0005",
        "name": "Hermetic runtime sandboxing",
        "type": "preventative"
      },
      {
        "details": "Generated Markdown includes provenance frontmatter; export manifest records hashes; conformance tests gate use.",
        "id": "SEC-CTRL-0006",
        "name": "Provenance embedding in vendor exports",
        "type": "detective"
      },
      {
        "details": "Hard bounds: max bytes, max depth, max array length, max schema complexity.",
        "id": "SEC-CTRL-0007",
        "name": "DoS limits in parsers and validators",
        "type": "preventative"
      },
      {
        "details": "Bootstrap schema bundle is embedded and pinned by hash; admission rejects modifications or shadowing; validator refuses to operate if bootstrap verification fails.",
        "id": "SEC-CTRL-0008",
        "name": "Bootstrap trust root immutability",
        "type": "preventative"
      }
    ],
    "cryptography_plan": {
      "current": {
        "artifact_hashing": "BLAKE3-256",
        "ledger_signatures": "Ed25519 (per kernel_events.proto comment)"
      },
      "future": {
        "note": "This PRD requires agility and versioning; it does not mandate immediate PQ deployment.",
        "pq_readiness": [
          "Introduce algorithm agility fields in receipts/manifests (signature_algorithm_id).",
          "Support hybrid signatures for critical artifacts/events when PQ algorithms are adopted."
        ]
      }
    },
    "security_properties": [
      {
        "id": "SEC-PROP-0001",
        "name": "Fail-closed admission",
        "statement": "Artifacts cannot enter DCP or influence execution unless validated and canonicalized."
      },
      {
        "id": "SEC-PROP-0002",
        "name": "Replay protection",
        "statement": "All patch admissions require expected_base_hash matching current state."
      },
      {
        "id": "SEC-PROP-0003",
        "name": "Least privilege consumption",
        "statement": "Consumption holons have deterministic reads only; no open-ended browsing."
      },
      {
        "id": "SEC-PROP-0004",
        "name": "End-to-end provenance",
        "statement": "All state transitions are recorded as signed events referencing immutable hashes."
      },
      {
        "id": "SEC-PROP-0005",
        "name": "Algorithm agility",
        "statement": "Cryptographic mechanisms and canonicalization engines are versioned and upgradable without breaking auditability."
      }
    ],
    "threat_model": {
      "assets_to_protect": [
        "Integrity of control artifacts (policies, packs, capabilities).",
        "Integrity of ledger event chain and signatures.",
        "Confidentiality of sensitive context and secrets.",
        "Availability of admission/validation pipeline (DoS resistance)."
      ],
      "assumption": "Adversary includes state actors with advanced capabilities, including discovery and exploitation of novel zero-days and future quantum threats.",
      "attack_surfaces": [
        "Parser and canonicalizer bugs (ambiguity, crashes, differential parsing).",
        "Schema bypass via unknown fields or permissive validators.",
        "Replay attacks against patch admission or work transitions.",
        "Supply-chain injection via vendor ABI outputs or imports.",
        "Privilege escalation through tool calls and filesystem reads.",
        "Resource exhaustion via deeply nested JSON, huge arrays, or pathological schemas."
      ]
    }
  },
  "implementation": {
    "components": [
      {
        "component_id": "CAC-CANON",
        "interfaces": [
          "canonicalize(bytes)->canonical_bytes",
          "hash(canonical_bytes)->b3-256"
        ],
        "name": "CAC Canonicalizer",
        "responsibilities": [
          "Parse CAC-JSON without floats and with strict limits.",
          "Emit canonical bytes deterministically.",
          "Expose test-vector based verification."
        ],
        "type": "rust_library"
      },
      {
        "component_id": "CAC-VALID",
        "name": "CAC Validator",
        "responsibilities": [
          "Validate artifacts against JSON Schemas (draft 2020-12 minimum).",
          "Enforce validator profile: unknown fields rejected, size/depth bounds.",
          "Validate PatchRecord streams.",
          "Enforce typed-quantity constraints and ContextPack budget ceilings."
        ],
        "type": "rust_library"
      },
      {
        "component_id": "CAC-BOOTSTRAP",
        "name": "Bootstrap Schema Bundle",
        "responsibilities": [
          "Embed a minimal schema bundle pinned by hash in the apm2 binary (Phase-0 trust root).",
          "Expose a read-only bootstrap manifest to the validator and admission pipeline.",
          "Reject any patch or artifact that attempts to modify or shadow bootstrap stable IDs."
        ],
        "type": "binary_embedded_data"
      },
      {
        "component_id": "CAC-PATCH",
        "name": "Patch Engine",
        "responsibilities": [
          "Apply JSON Patch / Merge Patch to canonical JSON trees.",
          "Enforce replay protection via expected_base_hash.",
          "Emit ChangeSetReport (semantic delta) for review and compaction."
        ],
        "type": "rust_library"
      },
      {
        "component_id": "CAC-DCP",
        "name": "DCP Index / Resolver",
        "responsibilities": [
          "Resolve stable_id -> pinned content_hash + schema refs.",
          "Provide deterministic reads for consumption mode via ArtifactFetch.",
          "Reconstruct index from ledger events.",
          "Provide dependency graph closure for pack compilation."
        ],
        "type": "projection_service_or_library"
      },
      {
        "commands": [
          "apm2 cac lint",
          "apm2 cac fmt",
          "apm2 cac apply-patch",
          "apm2 pack compile",
          "apm2 export --profile <target>",
          "apm2 capabilities --json",
          "apm2 selftest"
        ],
        "component_id": "CAC-CLI",
        "name": "APM2 CLI CAC Commands",
        "note": "These commands must have machine-readable contracts and be listed in capabilities manifest.",
        "type": "cli_surface"
      },
      {
        "component_id": "CAC-COMPILER",
        "name": "Context Compiler",
        "responsibilities": [
          "Compile ContextPackSpec into ContextPackManifest + derived artifacts.",
          "Deep-pin transitive dependencies to produce self-contained packs.",
          "Compile target payloads per TargetProfile (vendor layouts, model IRs).",
          "Emit receipts and evidence."
        ],
        "type": "service_or_library"
      },
      {
        "component_id": "CAC-AAT",
        "name": "Selftest/AAT Harness",
        "responsibilities": [
          "Run hermetic acceptance tests for CLI contracts, tool protocol, and export determinism.",
          "Emit structured AATReceipt stored in CAS and referenced in ledger."
        ],
        "type": "test_harness"
      }
    ],
    "mvp_scope": {
      "explicit_exclusions": [
        "Two-way import of vendor Markdown into CAC (optional future).",
        "Full defect triage UI; defects can be emitted as structured records/events."
      ],
      "goal": "A working end-to-end CAC pipeline integrated with the existing APM2 ledger/CAS/tool protocol, sufficient to gate the innermost loop and enable safe CLI cutover.",
      "must_ship": [
        "CAC-JSON canonicalizer + validator (strict).",
        "Schema registry bootstrap bundle pinned in the binary, immutable via patch admission, plus resolution via DCP.",
        "Patch admission pipeline (apply-patch) with replay protection and admission receipts.",
        "DCP stable-ID resolution index (projection).",
        "ArtifactFetch tool protocol extension (or equivalent deterministic read surface).",
        "ContextPack spec + compiler producing deep-pinned manifests and derived pack artifacts.",
        "TargetProfile schema + compiler integration (rendering, retrieval, budgets).",
        "CapabilityManifest generator + selftest receipt pipeline (AAT).",
        "Target delivery pipeline (at least one profile: Claude Code skills) with export manifest + conformance tests.",
        "ChangeSetReport emission for patch admissions.",
        "RunReceipt emission for consumption runs (pack sufficiency + misses)."
      ]
    },
    "phases": [
      {
        "deliverables": [
          "Bootstrap schema bundle embedded in apm2 binary with pinned hashes.",
          "Bootstrap manifest and immutability rules (no PatchRecord updates; no shadowing).",
          "Validator/admission pipeline uses bootstrap bundle before DCP availability."
        ],
        "exit_criteria": [
          "Bootstrap hashes verified at startup.",
          "Admission rejects patches targeting bootstrap stable IDs.",
          "PatchRecord and AdmissionReceipt validation succeeds using only bootstrap schemas."
        ],
        "name": "Bootstrap Trust Root",
        "phase_id": "CAC-IMP-00"
      },
      {
        "deliverables": [
          "CAC-JSON profile + canonicalizer (with vectors)",
          "Schema bootstrap registry + validator",
          "PatchRecord schema + JSONL tooling",
          "Typed quantity standard in common schema"
        ],
        "exit_criteria": [
          "Canonicalization idempotence tests pass",
          "Schema validation is fail-closed",
          "Patch replay protection enforced"
        ],
        "name": "Foundations",
        "phase_id": "CAC-IMP-01"
      },
      {
        "deliverables": [
          "apm2 cac apply-patch end-to-end: validate -> apply -> canonicalize -> store -> evidence -> ledger",
          "AdmissionReceipt schema and emission",
          "DCP resolver MVP",
          "ChangeSetReport emission and storage"
        ],
        "exit_criteria": [
          "Artifacts become resolvable by stable ID with pinned hash",
          "EvidencePublished events emitted with required metadata"
        ],
        "name": "Admission + Provenance",
        "phase_id": "CAC-IMP-02"
      },
      {
        "deliverables": [
          "Tool protocol extension: ArtifactFetch (and optional DcpResolve)",
          "Policy rules to enforce consumption hermeticity",
          "RunReceipt emission with context_pack_miss + sufficiency"
        ],
        "exit_criteria": [
          "Consumption holon can fetch required context only by stable ID",
          "Unauthorized reads are denied and defect-emitting"
        ],
        "name": "Deterministic Fetch Surface",
        "phase_id": "CAC-IMP-03"
      },
      {
        "deliverables": [
          "ContextPackSpec schema",
          "pack compile producing manifests + derived prompt packs",
          "PackCompilationReceipt emission",
          "TargetProfile integration + deep-pinning closure"
        ],
        "exit_criteria": [
          "Consumption tasks run without discretionary context discovery",
          "Pack outputs are deterministic and provenanced",
          "Packs are self-contained under transitive closure"
        ],
        "name": "ContextPack Compiler",
        "phase_id": "CAC-IMP-04"
      },
      {
        "deliverables": [
          "TargetProfile schema + claude_code/v1 target profile",
          "apm2 export produces delivery payloads + ExportManifest + conformance tests",
          "apm2 capabilities --json + apm2 selftest + AATReceipt gating"
        ],
        "exit_criteria": [
          "Target delivery is deterministic and CI-enforced",
          "Capabilities manifest matches reality (selftested)"
        ],
        "name": "Target Delivery + Capabilities Truthing",
        "phase_id": "CAC-IMP-05"
      }
    ]
  },
  "testing_and_rollout": {
    "aat_strategy": {
      "principle": "Small, hermetic, sub-minute AATs gate the innermost loop; larger E2E tests run nightly.",
      "receipt_policy": {
        "gating": [
          "Cutover to CLI requires recent passing AATReceipt pinned by hash.",
          "Agent planning gates require verifying receipt hash in CapabilityManifest."
        ],
        "receipt_kind": "receipt.aat",
        "receipt_storage": "CAS + EvidencePublished event",
        "required": true
      },
      "required_aat_suites": [
        {
          "max_duration_ms": 60000,
          "purpose": "Validate bootstrap trust root, CAC admission pipeline, canonicalization metadata, schema validation, and replay protection.",
          "suite_id": "AAT-CAC-CORE"
        },
        {
          "max_duration_ms": 60000,
          "purpose": "Validate ArtifactFetch/DcpResolve determinism and consumption-mode enforcement.",
          "suite_id": "AAT-CAC-FETCH"
        },
        {
          "max_duration_ms": 60000,
          "purpose": "Validate target delivery determinism and conformance.",
          "suite_id": "AAT-CAC-EXPORT"
        },
        {
          "max_duration_ms": 60000,
          "purpose": "Truth capabilities manifest against actual CLI behavior.",
          "suite_id": "AAT-CAC-CAP"
        }
      ]
    },
    "acceptance_tests": [
      {
        "asserts": [
          "canonicalize(canonical_bytes) == canonical_bytes",
          "hash stability across platforms and runs"
        ],
        "id": "CAC-AT-0001",
        "name": "Canonicalization idempotence"
      },
      {
        "asserts": [
          "Unknown fields are rejected",
          "Artifacts exceeding size/depth limits are rejected"
        ],
        "id": "CAC-AT-0002",
        "name": "Schema strictness"
      },
      {
        "asserts": [
          "Patch with wrong expected_base_hash is rejected",
          "Accepted patch emits AdmissionReceipt referencing base + new hashes"
        ],
        "id": "CAC-AT-0003",
        "name": "Patch replay protection"
      },
      {
        "asserts": [
          "stable_id resolves to pinned hash deterministically from ledger projection",
          "Resolution can be reconstructed from ledger events"
        ],
        "id": "CAC-AT-0004",
        "name": "DCP resolution determinism"
      },
      {
        "asserts": [
          "Consumption holon cannot fetch artifacts not listed in ContextPack manifest allowlist",
          "Attempted discretionary read emits PolicyViolation and DefectRecord"
        ],
        "id": "CAC-AT-0005",
        "name": "Hermetic consumption enforcement"
      },
      {
        "asserts": [
          "Exports from identical inputs produce byte-identical trees",
          "ExportManifest hashes match",
          "Conformance test report passes"
        ],
        "id": "CAC-AT-0006",
        "name": "Vendor export determinism"
      },
      {
        "asserts": [
          "CapabilityManifest validates against schema",
          "Declared commands are invocable and produce declared outputs"
        ],
        "id": "CAC-AT-0007",
        "name": "Capabilities truthing"
      },
      {
        "asserts": [
          "Bootstrap manifest hashes match the compiled bundle",
          "Patch targeting a bootstrap stable ID is rejected",
          "Validator operates using only the bootstrap schema set"
        ],
        "id": "CAC-AT-0008",
        "name": "Bootstrap trust root"
      },
      {
        "asserts": [
          "TargetProfile budgets are enforced during pack compilation",
          "Rendering policy is honored for derived payloads"
        ],
        "id": "CAC-AT-0009",
        "name": "Target profile enforcement"
      },
      {
        "asserts": [
          "Transitive dependencies are included in ContextPack manifests",
          "Consumption does not require additional discretionary reads"
        ],
        "id": "CAC-AT-0010",
        "name": "Deep pinning closure"
      },
      {
        "asserts": [
          "context_pack_miss triggers DefectRecord and run failure by default",
          "RunReceipt records sufficiency and budget deltas"
        ],
        "id": "CAC-AT-0011",
        "name": "Run receipt gating"
      },
      {
        "asserts": [
          "Typed quantities reject unknown units",
          "Scaled integer quantities round-trip deterministically"
        ],
        "id": "CAC-AT-0012",
        "name": "Typed quantity validation"
      }
    ],
    "metrics": {
      "lagging": [
        {
          "definition": "Median time from work opened to work completed + merged.",
          "id": "CAC-M-LAG-0001",
          "name": "PR cycle time",
          "target": "improve after CAC adoption"
        },
        {
          "definition": "Repeat incidence of UNPLANNED_CONTEXT_READ defects on similar work types.",
          "id": "CAC-M-LAG-0002",
          "name": "Defect recurrence rate (missing-context class)",
          "target": "decrease month-over-month"
        }
      ],
      "leading": [
        {
          "definition": "Count of denied or defect-emitting context reads per work item.",
          "id": "CAC-M-LEAD-0001",
          "name": "Unplanned context reads in consumption mode",
          "target": "monotonic decrease toward zero"
        },
        {
          "definition": "Fraction of work items completed without unplanned reads.",
          "id": "CAC-M-LEAD-0002",
          "name": "ContextPack completeness rate",
          "target": "increase toward 99%+"
        },
        {
          "definition": "Rate of context_pack_miss entries per run receipt.",
          "id": "CAC-M-LEAD-0004",
          "name": "ContextPack miss rate",
          "target": "decrease toward zero"
        },
        {
          "definition": "Fraction of runs where context_pack_sufficiency=true.",
          "id": "CAC-M-LEAD-0005",
          "name": "ContextPack sufficiency rate",
          "target": "increase toward 99%+"
        },
        {
          "definition": "Schema/canonicalization/replay/policy rejection counts.",
          "id": "CAC-M-LEAD-0003",
          "name": "Admission rejection rate by category",
          "target": "high early, then stabilizes as authoring improves"
        }
      ]
    },
    "rollout_plan": {
      "phases": [
        {
          "ci_behavior": "warnings only",
          "duration_days": 7,
          "name": "Warn-only linting + bootstrap schemas",
          "phase_id": "CAC-R-01"
        },
        {
          "ci_behavior": "fail on admission violations for new artifacts",
          "duration_days": 14,
          "name": "Admission pipeline enabled + receipts",
          "phase_id": "CAC-R-02"
        },
        {
          "ci_behavior": "fail on discretionary reads; file defects automatically",
          "duration_days": 14,
          "name": "Hermetic consumption + run receipt gating",
          "phase_id": "CAC-R-03"
        },
        {
          "ci_behavior": "fail on export drift; require passing AATReceipt for cutover",
          "duration_days": 14,
          "name": "Target delivery + capabilities gating for CLI cutover",
          "phase_id": "CAC-R-04"
        }
      ],
      "principle": "Start with capability truthing + deterministic fetch; then shift workflows to CAC packs; keep fallbacks until confidence is high."
    }
  },
  "risks_and_open_questions": {
    "open_questions": [
      {
        "id": "CAC-OQ-0001",
        "question": "Exact canonicalization spec: strict RFC 8785 JCS vs a stricter CAC profile; how to publish, pin, and version test vectors and canonicalizer IDs?"
      },
      {
        "id": "CAC-OQ-0002",
        "question": "Stable ID namespace governance: who can mint namespaces, and how are collisions prevented across org/projects?"
      },
      {
        "id": "CAC-OQ-0003",
        "question": "Do we need typed kernel events (ControlArtifactEvent) in the MVP, or is EvidencePublished metadata sufficient?"
      },
      {
        "id": "CAC-OQ-0004",
        "question": "How to represent large binary artifacts within CAC-JSON (likely via CAS refs only) and enforce policies consistently?"
      },
      {
        "id": "CAC-OQ-0005",
        "question": "Should defect records be first-class kernel events or remain evidence artifacts referenced by events?"
      },
      {
        "id": "CAC-OQ-0006",
        "question": "TargetProfile schema: what is the minimal stage taxonomy (plan/implement/review/ops) and which policies must be mandatory vs optional?"
      },
      {
        "id": "CAC-OQ-0007",
        "question": "Compaction policy: when does patch depth require snapshotting, and how are ChangeSet summaries preserved across compaction?"
      }
    ],
    "risks": [
      {
        "id": "CAC-RISK-0001",
        "impact": "Breaks CAS dedupe, provenance, and stable-ID pinning.",
        "mitigations": [
          "Golden test vectors committed and run in CI.",
          "Versioned canonicalizer; include canonicalizer_version in receipts.",
          "Cross-language compatibility tests if multiple implementations exist."
        ],
        "name": "Canonicalizer divergence causes hash drift"
      },
      {
        "id": "CAC-RISK-0002",
        "impact": "Machines may fail admission frequently during early adoption.",
        "mitigations": [
          "Bootstrap with small schema set and evolve intentionally.",
          "Provide machine-generated patch tooling that auto-validates before submission.",
          "Use staged rollout: warn -> soft fail -> hard fail."
        ],
        "name": "Schema strictness slows iteration"
      },
      {
        "id": "CAC-RISK-0003",
        "impact": "External agent tooling stops working or requires urgent changes.",
        "mitigations": [
          "Version target profiles and pin in packs.",
          "Conformance tests run in AAT; failures become defects.",
          "Maintain fallback exports for critical vendors."
        ],
        "name": "Target delivery churn breaks export pipeline"
      },
      {
        "id": "CAC-RISK-0004",
        "impact": "Tasks fail because packs are incomplete; could be perceived as regressions.",
        "mitigations": [
          "Treat failures as compiler defects and fix packs quickly.",
          "Allow limited, explicitly budgeted escape hatches early, with strong defect emission.",
          "Prioritize pack completeness for the most common workflows."
        ],
        "name": "Consumption hermeticity causes early friction"
      },
      {
        "id": "CAC-RISK-0005",
        "impact": "Stable-ID resolution and fetch becomes slow at scale.",
        "mitigations": [
          "Maintain a cached projection store (rebuildable).",
          "Shard by namespace/kind; keep hot indexes in memory.",
          "Include compaction checkpoints."
        ],
        "name": "Indexing DCP from ledger becomes performance bottleneck"
      },
      {
        "id": "CAC-RISK-0006",
        "impact": "Patch history grows unbounded; review and replay become slow or error-prone.",
        "mitigations": [
          "Define compaction thresholds (depth/time/size) per artifact kind.",
          "Require ChangeSet summaries to accompany compaction snapshots.",
          "Maintain provenance links from snapshots back to patch chains."
        ],
        "name": "Patch soup without compaction"
      },
      {
        "id": "CAC-RISK-0007",
        "impact": "TargetProfile budgets or rendering policies are miscalibrated, causing frequent failures for weaker models.",
        "mitigations": [
          "Default to conservative budgets; adjust via measured RunReceipt data.",
          "Maintain per-model profiles and gate by capability manifest.",
          "Automate profile tuning based on sufficiency metrics."
        ],
        "name": "Target profile miscalibration"
      }
    ]
  },
  "definition_of_done": {
    "mvp_definition": [
      "CAC-JSON canonicalizer + schema validator are integrated into the APM2 CLI/kernel toolchain and are used for all normative control artifacts.",
      "Bootstrap schema bundle is embedded and hash-pinned in the apm2 binary; bootstrap stable IDs are immutable via PatchRecord admission.",
      "Canonicalizer id/version and test-vector reference are recorded in envelopes/receipts for all normative artifacts.",
      "Machines can submit PatchRecords; kernel admits updated artifacts with replay protection and emits AdmissionReceipts to CAS + ledger provenance.",
      "Admissions include ChangeSetReport summaries that support review and compaction.",
      "DCP stable-ID resolution exists and is reconstructable from ledger; consumption holons can fetch required context via deterministic tools (ArtifactFetch).",
      "TargetProfile schema defines budgets and rendering policies; compiler produces deep-pinned ContextPack manifests with transitive closure.",
      "Consumption holons emit RunReceipts with context_pack_miss and sufficiency; misses fail runs by default unless explicitly escalated.",
      "CapabilityManifest is generated from the apm2 binary and verified by selftests; AATReceipt gates cutover and agent planning.",
      "At least one target delivery profile (claude_code/v1) exists with deterministic export and conformance tests; export is provenanced and CI-enforced as derived output.",
      "Defect records are emitted for unplanned consumption reads/tool calls and feed back into pack compiler improvements."
    ],
    "post_mvp_extensions": [
      "Optional typed kernel event families for control artifacts and DCP mappings.",
      "Two-way import from vendor ABIs into CAC (airlock) if needed.",
      "Richer semantic diff tooling for patch review at scale.",
      "Hybrid/PQ signature support for critical receipts/events."
    ]
  },
  "references": [
    {
      "id": "REF-JSON",
      "title": "The JavaScript Object Notation (JSON) Data Interchange Format (RFC 8259)",
      "url": "https://www.rfc-editor.org/rfc/rfc8259"
    },
    {
      "id": "REF-JCS",
      "title": "JSON Canonicalization Scheme (RFC 8785)",
      "url": "https://www.rfc-editor.org/rfc/rfc8785"
    },
    {
      "id": "REF-JSONPATCH",
      "title": "JSON Patch (RFC 6902)",
      "url": "https://www.rfc-editor.org/rfc/rfc6902"
    },
    {
      "id": "REF-JSONMERGE",
      "title": "JSON Merge Patch (RFC 7396)",
      "url": "https://www.rfc-editor.org/rfc/rfc7396"
    },
    {
      "id": "REF-JSONSCHEMA",
      "title": "JSON Schema (2020-12)",
      "url": "https://json-schema.org/draft/2020-12/json-schema-core.html"
    },
    {
      "id": "REF-APM2-KERNEL",
      "title": "APM2 Kernel Event Schema (repo)",
      "url": "file:proto/kernel_events.proto"
    },
    {
      "id": "REF-APM2-TOOL",
      "title": "APM2 Tool Protocol Schema (repo)",
      "url": "file:proto/tool_protocol.proto"
    }
  ],
  "design_selection": {
    "future_upgrade_path": [
      "Introduce typed ControlArtifactEvent when queryability and policy enforcement demand it.",
      "Generate typed events from existing EvidencePublished metadata to preserve continuity.",
      "Optionally move schema definitions to proto once the artifact set stabilizes."
    ],
    "id": "CAC-DESIGN-MASTER",
    "inputs_considered": [
      "CAC-DESIGN-A",
      "CAC-DESIGN-B",
      "CAC-DESIGN-C"
    ],
    "nonnegotiables": [
      "ArtifactFetch (or equivalent) deterministic stable-ID fetch surface is P0.",
      "Fail-closed validation and canonicalization prior to admission is P0.",
      "Consumption hermeticity and defect emission for unplanned reads is P0."
    ],
    "schema": "apm2.design.merge_rationale.v1",
    "schema_version": "1.0.0",
    "selected": {
      "deferred": [
        "CAC-DESIGN-B"
      ],
      "primary": [
        "CAC-DESIGN-A",
        "CAC-DESIGN-C"
      ]
    },
    "title": "Selected Design: JSON-First CAC with Ledger-Native DCP Projection and Deterministic Fetch",
    "why_this_combination": [
      "MVP must ship quickly and integrate with existing APM2 evidence/ledger patterns.",
      "Ledger-native projections preserve auditability and prevent split-brain sources of truth.",
      "Typed proto events are valuable but introduce coordination and migration costs; defer until CAC artifacts and workflows stabilize."
    ]
  },
  "parallel_designs": [
    {
      "id": "CAC-DESIGN-A",
      "path": "parallel/option_A.json"
    },
    {
      "id": "CAC-DESIGN-B",
      "path": "parallel/option_B.json"
    },
    {
      "id": "CAC-DESIGN-C",
      "path": "parallel/option_C.json"
    }
  ]
}
