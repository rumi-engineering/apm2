{
    "kind": "instruction.spec",
    "schema": "cac.instruction_spec.v1",
    "schema_version": "1.0.0",
    "meta": {
        "classification": "INTERNAL",
        "created_at": "2026-02-20T06:00:00Z",
        "dependencies": [
            "dcp://apm2.local/instructions/alien_engineering_protocol/master@v1"
        ],
        "labels": [
            "alien-coding",
            "agent-orchestrators",
            "rust",
            "state-machines",
            "verification-first",
            "derived-state-discipline",
            "v2"
        ],
        "provenance": {
            "actor_id": "HOLON-INSTR-EMITTER",
            "work_id": "alien_coding_orchestrators_master_v2"
        },
        "stable_id": "dcp://apm2.local/instructions/alien_coding_orchestrators/master@v2"
    },
    "payload": {
        "i": "Alien Coding (Orchestrators) v2: implement agent orchestrators as deterministic, replayable Rust state machines with explicit identity, explicit evidence, explicit effects, and a strict derived-state discipline that makes divergence structurally hard.",
        "t": {
            "sys": "APM2",
            "repo": "{repo_root}",
            "language": "Rust (edition 2024)",
            "platform": "Ubuntu 24.04 only",
            "users": "agents and internal operators",
            "deployment_model": "rolling updates + rollback; architectural cleanliness is rewarded",
            "scope": [
                "crates/apm2-core",
                "crates/apm2-daemon",
                "crates/apm2-holon",
                "crates/apm2-cli (orchestrator-like loops)"
            ],
            "anchor_patterns_in_repo": [
                "Reducer determinism + checkpoint replay equivalence: crates/apm2-core/src/reducer/*",
                "Explicit state machine with invariants: crates/apm2-daemon/src/episode/state.rs",
                "Gate orchestrator with resource bounds + injected clock + explicit statuses: crates/apm2-daemon/src/gate/orchestrator.rs",
                "Event-sourced orchestration state: crates/apm2-holon/src/orchestration/state.rs"
            ]
        },
        "north_star_properties": {
            "deterministic_under_replay": {
                "definition": "Given the same ordered input sequence, the transition core yields byte-identical state and effect list.",
                "mechanics": [
                    "Treat time, randomness, external observations, and I/O outcomes as explicit Inputs.",
                    "Treat ordering as explicit (ledger cursor, sequence numbers, HLC)."
                ],
                "machine_check": "Property test: replay from genesis equals replay from checkpoint; repeated replay yields identical final state."
            },
            "single_source_of_truth": {
                "definition": "Each fact has one canonical owner; other consumers hold references or derive views.",
                "mechanics": [
                    "Canonical owners are: ledger events, CAS artifacts, signed config, and stable IDs minted by authority.",
                    "Orchestrator State stores references (ids, digests, cursors), plus the minimal sufficient statistic required for future decisions."
                ],
                "machine_check": "Tests reconstruct State from canonical inputs; derived views recompute from State with no external reads."
            },
            "closed_by_default_progression": {
                "definition": "Progression requires explicit evidence; ambiguity selects a safe terminal outcome that preserves auditability.",
                "mechanics": [
                    "Model terminal outcomes as explicit absorbing states.",
                    "Bind authority actions to receipts/signatures/digests; store those bindings."
                ],
                "machine_check": "Invariant tests: terminal states absorb; missing evidence yields terminal-deny/quarantine outcomes."
            },
            "idempotent_authority": {
                "definition": "Repeating the same logical trigger yields the same durable result, not duplicated spawns/leases/receipts.",
                "mechanics": [
                    "Compute idempotency keys from stable input digests (work_id + changeset_digest + gate_type + revision).",
                    "Store bounded idempotency memory in State or in an authority-backed store."
                ],
                "machine_check": "Tests feed duplicated Inputs; effects stay stable; at-most-once issuance is preserved."
            },
            "bounded_resources": {
                "definition": "State growth and work per input are explicitly bounded.",
                "mechanics": [
                    "Bound maps/sets/strings by constants.",
                    "Select bounded behavior: reject, evict, degrade, checkpoint, compact."
                ],
                "machine_check": "Tests push inputs to bounds; State remains within limits; behavior remains deterministic."
            }
        },
        "orchestrator_information_flow": {
            "shape": "Inputs -> normalize -> step(State, Input, Snapshot) -> (NextState, Effects) -> drive(Effects) -> Observations -> Inputs",
            "contract": {
                "step": [
                    "Deterministic function producing NextState + Effects as data.",
                    "Only branches on explicit State/Input/Decision enums.",
                    "Uses ContextSnapshot values passed in (time, budgets, liveness, environment readings)."
                ],
                "drive": [
                    "Executes Effects (I/O, process ops, ledger writes, CAS writes).",
                    "Converts outcomes into Observations, then Inputs.",
                    "Records durable evidence for every authority-relevant effect."
                ]
            }
        },
        "ledger_projection_grounding": {
            "thesis": "The step function is a fold over the append-only ledger. State is the projection that fold produces. Effects are primarily acts of evidence creation — their operational consequence (API call, process spawn, lease issuance) is the side effect, not the substance.",
            "event_first_design": {
                "instruction": "Before designing State or the Input enum, design the ledger event vocabulary. Ask: if this machine ran to completion, what named events would appear in the ledger, and what would each contain? The events define the information domain; State is only what you must carry between events to fold the next one correctly.",
                "test": "Can you reconstruct the full machine history from ledger events alone, with no in-memory state? If not, a ledger event is missing."
            },
            "step_is_the_reducer": {
                "instruction": "The step function IS the reduce/fold. Input enum variants correspond to ledger event types (observed by the driver) plus driver-boundary observations (time readings, process signals, API outcomes). Determinism is not a testing nicety — it is the requirement that derives from the ledger being ground truth: if step is non-deterministic, the machine's projection diverges across restarts.",
                "state_field_test": "For every State field ask: 'Do I need this to correctly fold the next event?' If the answer is no, it is a cache and belongs in a witnessed cache or derived view, not in canonical State."
            },
            "closure_properties": {
                "instruction": "The step function must satisfy the three properties of the Cl_P closure operator. These are the algebraic requirements that make the ledger the single source of truth — not guidelines.",
                "extensive": {
                    "definition": "Missing evidence yields fail/pending/quarantine, never a spurious pass.",
                    "machine_check": "Invariant test: step called with an Input carrying no evidence for a required gate must produce a non-Pass terminal or a waiting state. A Completed/Pass state with empty evidence refs is a defect."
                },
                "monotone": {
                    "definition": "Additional evidence can only advance state, never retract it. A passing gate cannot be un-passed by a subsequent event.",
                    "machine_check": "Property test: fold(A) then fold(A ++ B) — final state from A+B is at least as advanced as from A alone."
                },
                "idempotent": {
                    "definition": "Same event sequence, same output. This is why replay-from-genesis equals replay-from-checkpoint, and why replaying a deduplicated event stream is safe.",
                    "machine_check": "Already covered in verification_suite.property_tests. Extend with: fold(dedupe(events ++ events)) == fold(events)."
                }
            },
            "effects_as_evidence_creation": {
                "instruction": "For every Effect, identify its primary evidence artifact first: what named ledger event or CAS digest does it produce? The API call or process op is the mechanism; the ledger/CAS write is the substance. This ordering is what makes replay safe.",
                "sequencing_rule": "Emit the evidence-anchoring ledger event BEFORE the irreversible operational effect (already stated in effect_emission.ordering). The reason: on restart, the driver checks the ledger first and skips re-execution if the result event already exists.",
                "canonical_pattern_external_write": {
                    "description": "Idempotent write to a 3rd-party authority (GitHub PR creation, issue comment, external API mutation).",
                    "steps": [
                        "1. Step emits Effect::RecordIntent { idempotency_key, action_id, action } — driver writes intent event to ledger.",
                        "2. Step emits Effect::CallExternalApi { action_id, params } — driver checks ledger for an existing result event for action_id FIRST; if found, synthesizes the Input from the ledger record and skips the call.",
                        "3. Call returns; driver converts outcome to Input::ApiResult { action_id, outcome }.",
                        "4. Step processes ApiResult, emits Effect::RecordOutcome { action_id, outcome } — driver writes result event to ledger.",
                        "5. On any subsequent replay: step 2 finds the result event; no call is made; Input::ApiResult is synthesized from the ledger record."
                    ],
                    "anti_pattern": "Executing the external call as a bare driver side-effect without a prior intent event. A crash between the call and the result record leaves the system unable to determine whether the call succeeded. The next restart re-executes, producing a duplicate action."
                }
            }
        },
        "cursor_and_activation": {
            "goal": "Give every machine an explicit, durable position in the event stream so that cross-machine coordination is exactly-once by construction, not by memory.",
            "ledger_cursor_in_state": {
                "instruction": "Include a ledger cursor field in State representing the position up to which the machine has durably processed events. Justification as sufficient statistic: it is the minimal information needed to resume folding from the correct position after a crash.",
                "invariant": "Events before the cursor are provably already processed — not because the machine remembers processing them, but because the cursor is structurally past them. No in-memory seen-set can provide this guarantee across restarts."
            },
            "cursor_advancement_ordering": {
                "instruction": "Advance the cursor only AFTER the result effects that justify the advancement have been durably written to the ledger. If you advance the cursor in State before your result events are flushed, a crash between those two operations produces a checkpoint that claims progress the ledger does not contain.",
                "ordering": [
                    "1. Read events from ledger starting at state.ledger_cursor.",
                    "2. Feed each event into step as an Input variant; collect (NextState, Effects).",
                    "3. Execute Effects: write result events to ledger (durable).",
                    "4. Only then checkpoint NextState (which contains the advanced cursor).",
                    "5. On crash-restart: load checkpoint, read ledger from checkpoint.cursor — events before cursor are skipped structurally."
                ]
            },
            "at_most_once_activation": {
                "instruction": "When a machine activates in response to a cross-machine ledger event (e.g., session_terminated triggering gate orchestration), the activation itself must be a ledger event whose idempotency key is derived from the triggering event's stable position or id. The driver checks the ledger for an existing activation record before processing — no in-memory lock required as the primary guarantee.",
                "pattern": [
                    "Triggering event arrives at cursor position P.",
                    "Driver checks ledger: does an activation record exist for trigger_event_id=P?",
                    "If yes: advance cursor past P, no further action (already processed).",
                    "If no: emit Effect::RecordActivation { trigger_event_id: P, action_id } to ledger, then proceed with activation effects.",
                    "Crash at any point: restart reads the ledger, finds (or doesn't find) the activation record, and branches correctly."
                ],
                "benefit": "Double-activation becomes structurally impossible without relying on in-memory deduplication state that does not survive crashes."
            }
        },
        "derived_state_discipline": {
            "core_axiom": "State is a sufficient statistic for future decisions under the modeled Inputs; every other datum is a derived view or an external observation.",
            "fact_ownership_map": {
                "instruction": "For every value used by the orchestrator, name its owner explicitly: ledger event, CAS artifact, config field, minted id, or a State field justified as a sufficient statistic.",
                "owner_catalog": {
                    "ledger": [
                        "Authoritative lifecycle transitions",
                        "Receipts and verdicts (signed)",
                        "Work/session/episode identifiers and relationships"
                    ],
                    "cas": [
                        "Large payloads, prompts, evidence bundles, manifests",
                        "Content-addressed documents referenced by digest"
                    ],
                    "config": [
                        "Timeouts, limits, policy profiles, role specs"
                    ],
                    "state": [
                        "Cursor into event stream / processing position",
                        "Outstanding obligations (pending leases, pending episodes, pending receipts)",
                        "Idempotency memory and bounded dedupe windows",
                        "Controller memory (backoff state, escalation level) as sufficient statistic"
                    ]
                },
                "output": "A code-level comment block near the State definition listing each State field and its justification as a sufficient statistic."
            },
            "derived_views": {
                "instruction": "Expose derived information through pure view functions computed from canonical State (and optional stable config), returning purpose-specific view structs.",
                "pattern": {
                    "name": "Projection -> View -> Decision",
                    "definition": [
                        "Projection: durable State folded from Inputs/events.",
                        "View: ephemeral struct computed from State to simplify decisions.",
                        "Decision: typed enum expressing branching outcomes in a compact vocabulary."
                    ],
                    "benefit": "Derived values become impossible to desynchronize because a single function defines their computation.",
                    "implementation": [
                        "Implement `impl State { fn view(&self, cfg: &Config) -> View }`.",
                        "Keep View small and purpose-specific; create multiple Views for different decisions when useful."
                    ]
                }
            },
            "reference_over_copy": {
                "instruction": "Represent canonical artifacts by stable references (ids, digests, cursors) and derive expanded content on demand in the driver boundary.",
                "examples": [
                    "Store `changeset_digest` and a `cas_ref` to the changeset bundle; driver loads bundle by digest when executing an effect.",
                    "Store `receipt_id` and verifying key reference; driver fetches and verifies receipt to produce an Input."
                ]
            },
            "witnessed_caches": {
                "instruction": "When performance benefits from materializing derived values, store a cache paired with a witness that makes validity decidable.",
                "witness_forms": [
                    "source_digest (hash of canonical inputs used for derivation)",
                    "epoch / version counter that increments on any relevant State change",
                    "cursor_range (ledger position interval covered by the cache)"
                ],
                "pattern": {
                    "name": "CacheWithWitness",
                    "rust": "/// Cache with an explicit validity witness.\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n#[serde(deny_unknown_fields)]\npub struct CacheWithWitness<T> {\n    pub witness: [u8; 32],\n    pub value: T,\n}\n\nimpl<T> CacheWithWitness<T> {\n    pub fn is_valid_for(&self, witness: [u8; 32]) -> bool {\n        self.witness == witness\n    }\n}\n"
                }
            },
            "local_state_budget": {
                "instruction": "Use local variables inside a function as ephemeral computations; use State only for sufficient statistics required across calls/restarts.",
                "decision_test": [
                    "If the value is recomputable from (State, Input, Config), keep it derived.",
                    "If the value must survive restarts or deduplicate authority actions, keep it in State with a justification comment."
                ]
            }
        },
        "transition_core": {
            "goal": "Make the core logic mechanically checkable: total transitions, explicit branching vocabulary, explicit effects.",
            "types": {
                "State": [
                    "Enum or struct with explicit variants/fields reflecting real phases.",
                    "Serde tags and deny-unknown-fields when persisted.",
                    "Explicit discriminants for persisted enums when overlapping versions are expected during rolling updates."
                ],
                "Input": [
                    "Every external observation represented as an enum variant.",
                    "Includes Tick/Time inputs as explicit data.",
                    "Includes driver outcomes (spawn ok/fail, receipt verified/invalid, pid exited, liveness report)."
                ],
                "Effect": [
                    "Every authority action as explicit data.",
                    "Includes intent, idempotency key, and evidence binding fields.",
                    "Driver produces Observations that become Inputs."
                ],
                "Decision": [
                    "Small enums used as guard outcomes (e.g., Progression::Allow/Block/Quarantine, SpawnPlan::Spawn/Resume/Skip).",
                    "Decision enums replace boolean branching vocabulary."
                ]
            },
            "branching_form": {
                "instruction": "Centralize branching in exhaustive matches on (State, Input) and (Decision, State).",
                "guard_style": [
                    "Compute Decision via pure functions returning enums.",
                    "Use match guards for numeric thresholds when the threshold is explicit and tested."
                ],
                "benefit": "Branch coverage becomes enumeratable; missing cases become compile-visible."
            },
            "effect_emission": {
                "instruction": "Emit Effects as a list returned from step; treat the list as an ordered script that the driver interprets.",
                "ordering": [
                    "Place evidence-anchoring effects before irreversible effects (e.g., emit policy-resolution event before issuing a lease).",
                    "Place dedupe/idempotency marking effects in the same step that decides issuance."
                ],
                "idempotency_shape": [
                    "Effect includes `idempotency_key` and `logical_action_id`.",
                    "State stores the action id in a bounded structure."
                ]
            },
            "template": {
                "rust": "/// Deterministic transition core.\npub fn step(\n    state: State,\n    input: Input,\n    snapshot: Snapshot,\n    cfg: &Config,\n) -> Result<(State, Vec<Effect>), Error> {\n    use State::*;\n    use Input::*;\n\n    match (state, input) {\n        (Idle { .. }, Start { work_id, changeset_digest }) => {\n            let action_id = ActionId::from_parts(&work_id, &changeset_digest);\n            let effects = vec![\n                Effect::EmitEvent(Event::OrchestrationStarted { work_id, changeset_digest }),\n                Effect::IssueLease { action_id },\n            ];\n            Ok((Leasing { action_id }, effects))\n        }\n\n        (Leasing { action_id }, LeaseIssued { lease_id }) => {\n            let effects = vec![Effect::SpawnEpisode { action_id, lease_id: lease_id.clone() }];\n            Ok((Running { action_id, lease_id, controller: Controller::new() }, effects))\n        }\n\n        (Running { action_id, lease_id, controller }, Tick { elapsed_ms }) => {\n            let (controller2, plan) = controller.plan(elapsed_ms, cfg);\n            match plan {\n                NudgePlan::None => Ok((Running { action_id, lease_id, controller: controller2 }, vec![])),\n                NudgePlan::Nudge { message_ref } => {\n                    let effects = vec![Effect::SendNudge { action_id, lease_id: lease_id.clone(), message_ref }];\n                    Ok((Running { action_id, lease_id, controller: controller2 }, effects))\n                }\n                NudgePlan::Escalate { reason } => {\n                    let effects = vec![Effect::EmitEvent(Event::Escalated { action_id, reason })];\n                    Ok((Quarantined { action_id, lease_id, reason }, effects))\n                }\n            }\n        }\n\n        (Running { action_id, lease_id, .. }, ReceiptVerified { receipt_id, passed }) => {\n            let effects = vec![Effect::EmitEvent(Event::Completed { action_id, receipt_id: receipt_id.clone(), passed })];\n            Ok((Completed { action_id, lease_id, receipt_id, passed }, effects))\n        }\n\n        (terminal @ (Completed { .. } | Quarantined { .. }), _) => Ok((terminal, vec![])),\n    }\n}\n"
            }
        },
        "driver_shell": {
            "goal": "Convert effects into reality while preserving determinism through explicit Inputs and durable evidence.",
            "effect_execution": {
                "instruction": "Implement a driver loop that executes Effects and immediately records an Observation as an Input for the next step.",
                "primitives": [
                    "CAS writes yield a digest; store digest in emitted event and in State references.",
                    "Ledger writes yield an event id / cursor; feed it back as Input.",
                    "Process operations yield a ProcessBinding; feed it back as Input."
                ]
            },
            "context_snapshot": {
                "instruction": "Provide the transition core with a Snapshot object holding bounded, validated observations. Snapshot is a trust boundary: the step function branches on its values without further validation, so the driver owns all validation.",
                "snapshot_fields": [
                    "monotonic_elapsed_ms",
                    "budget_remaining",
                    "liveness_report_summary",
                    "authoritative_head_sha / changeset_digest",
                    "active_leases set for dedupe (bounded view)"
                ],
                "trust_boundary": {
                    "property": "The step function fully trusts every Snapshot field. An elapsed time that goes backwards, a budget that exceeds its initial value, or an active_leases set with unbounded entries will cause step to produce wrong state — which gets checkpointed and replayed indefinitely.",
                    "validation_rule": "All Snapshot fields must be validated and clamped at the driver boundary before step is called. Validation failures must not be silently truncated and passed to step.",
                    "on_invalid_snapshot": "Emit Input::SnapshotRejected { field, reason } rather than passing a corrupted Snapshot to step. The machine handles this as a structured event (typically: pause, emit escalation ledger event, await corrected observation). Rejection becomes observable in the ledger, not a silent divergence."
                }
            }
        },
        "universal_addressing": {
            "goal": "Bind ephemeral handles to stable identities so that authority targets remain unambiguous across time and restarts.",
            "address_types": {
                "instruction": "Define newtypes/enums for stable addressing and store them in State, Events, and Effects.",
                "recommended": [
                    "WorkId, SessionId, EpisodeId, LeaseId (typed newtypes)",
                    "ActorId / RoleId (typed newtypes)",
                    "Digest32 (CAS hash wrapper)"
                ]
            },
            "process_binding": {
                "instruction": "Represent process identity as a binding between a stable address and a measured handle.",
                "fields": [
                    "pid",
                    "proc_start_time (or equivalent kernel identity witness)",
                    "lease_id or session_id (stable authority binding)",
                    "spawn_nonce (deterministic nonce derived from action id + attempt number)",
                    "cgroup_path or sandbox capsule id (when available)"
                ],
                "benefit": "PID reuse becomes mechanically distinguishable; process control operations target a specific binding."
            },
            "addressing_rule": {
                "instruction": "Carry the stable address through every layer: event -> state -> effect -> driver call -> observation -> input.",
                "result": "Logs, receipts, and evidence become joinable by stable keys without inference."
            }
        },
        "nudging_and_control": {
            "goal": "Model nudges/restarts/escalations as an explicit controller state machine with saturation and memory.",
            "controller_state": {
                "instruction": "Store controller memory in State as a sufficient statistic (attempt count, last action time, backoff stage, escalation stage).",
                "fields": [
                    "attempt: u32",
                    "last_progress_at_ms: u64",
                    "last_nudge_at_ms: Option<u64>",
                    "backoff: BackoffStage",
                    "escalation: EscalationStage"
                ]
            },
            "signals": {
                "instruction": "Compute progress signals as derived views from canonical evidence.",
                "examples": [
                    "receipt count delta",
                    "ledger cursor advanced for this action id",
                    "heartbeat freshness bucket",
                    "budget burn rate bucket"
                ]
            },
            "plans": {
                "instruction": "Emit a typed plan (None / Nudge / Restart / Escalate) as a Decision enum, then translate it into Effects.",
                "deterministic_jitter": "When jitter helps stability, derive it from a stable seed (hash(action_id || attempt)) so replay stays deterministic."
            }
        },
        "persistence_and_schema": {
            "goal": "Make persisted state/events resilient under rolling updates and mechanically verifiable.",
            "serde_profile": [
                "serde tags for enums (`#[serde(tag = \"state\")]` or explicit field tags).",
                "deny unknown fields for persisted structs/enums.",
                "bounded string lengths validated at boundaries."
            ],
            "evolution": {
                "instruction": "When versions overlap in production, keep discriminants/tags stable; introduce new variants/fields with explicit defaults and bounded validation.",
                "artifact_binding": [
                    "Store digests for CAS artifacts in events/state.",
                    "Store verifying key references and signature verification results as Inputs."
                ]
            }
        },
        "verification_suite": {
            "goal": "Ship executable proofs: invariants, replay determinism, idempotency, and bound behavior.",
            "invariants_as_tests": [
                "Terminal absorption: terminal states yield empty effects for all inputs.",
                "Monotonicity: elapsed/budget counters progress monotonically within modeled semantics.",
                "At-most-once issuance: repeating Start/Trigger inputs yields stable authority outputs.",
                "Evidence binding: every Completed state has a receipt id and verified flag in its causal history."
            ],
            "property_tests": {
                "instruction": "Generate event/input sequences and assert determinism and invariants.",
                "minimum": [
                    "Replay equivalence: fold(inputs) equals fold(inputs) repeated.",
                    "Checkpoint equivalence: fold(genesis) equals fold(prefix)+fold(suffix) with checkpoint."
                ]
            },
            "transition_enumeration": {
                "instruction": "Enumerate (State variant × Input variant) combinations for small machines and assert each pair produces a defined Outcome.",
                "result": "Branch coverage becomes mechanical; missing cases surface early."
            },
            "golden_vectors": {
                "instruction": "Keep golden vectors for serialization and signatures on authority-relevant artifacts.",
                "targets": [
                    "receipts",
                    "leases",
                    "context packs / manifests"
                ]
            }
        },
        "refactor_moves_for_existing_orchestrators": {
            "goal": "Turn a loop with scattered branching into a state machine with explicit effects while preserving behavior.",
            "moves": [
                "Name the phases currently implicit in control flow; encode them as a State enum with explicit data fields.",
                "Name the external triggers and observations; encode them as an Input enum.",
                "Name the authority actions; encode them as an Effect enum with idempotency keys and evidence binding fields.",
                "Lift branching vocabulary into Decision enums and pure guard functions.",
                "Wrap existing side-effecting code as driver handlers for Effects; convert outcomes into Inputs.",
                "Add invariant tests first for current behavior; then strengthen invariants that delete bug classes (determinism, idempotency, boundedness)."
            ]
        },
        "review_lenses": {
            "lens_1_state_is_sufficient_statistic": [
                "Each State field has a justification as sufficient statistic.",
                "Derived information is provided via view functions.",
                "Artifacts appear as references (ids/digests/cursors) rather than expanded copies."
            ],
            "lens_2_determinism_and_replay": [
                "Transition core accepts time and observations as Inputs/Snapshot fields.",
                "Effect list ordering is stable and intentional.",
                "Tests cover replay equivalence."
            ],
            "lens_3_identity_and_evidence": [
                "Stable addresses flow end-to-end.",
                "Ephemeral handles appear only within bindings that include identity witnesses.",
                "Every authority outcome has a durable receipt/event trail."
            ],
            "lens_4_bounds_and_containment": [
                "All collections have explicit limits and defined behavior at the limit.",
                "String sizes and external payload sizes are bounded and validated."
            ]
        }
    }
}