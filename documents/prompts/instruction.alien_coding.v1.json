{
    "kind": "instruction.spec",
    "schema": "cac.instruction_spec.v1",
    "schema_version": "1.0.0",
    "meta": {
        "classification": "INTERNAL",
        "created_at": "2026-02-20T06:00:00Z",
        "dependencies": [
            "dcp://apm2.local/instructions/alien_engineering_protocol/master@v1"
        ],
        "labels": [
            "alien-coding",
            "agent-orchestrators",
            "rust",
            "state-machines",
            "verification-first",
            "derived-state-discipline",
            "v2"
        ],
        "provenance": {
            "actor_id": "HOLON-INSTR-EMITTER",
            "work_id": "alien_coding_orchestrators_master_v2"
        },
        "stable_id": "dcp://apm2.local/instructions/alien_coding_orchestrators/master@v2"
    },
    "payload": {
        "i": "Alien Coding (Orchestrators) v2: implement agent orchestrators as deterministic, replayable Rust state machines with explicit identity, explicit evidence, explicit effects, and a strict derived-state discipline that makes divergence structurally hard.",
        "t": {
            "sys": "APM2",
            "repo": "{repo_root}",
            "language": "Rust (edition 2024)",
            "platform": "Ubuntu 24.04 only",
            "users": "agents and internal operators",
            "deployment_model": "rolling updates + rollback; architectural cleanliness is rewarded",
            "scope": [
                "crates/apm2-core",
                "crates/apm2-daemon",
                "crates/apm2-holon",
                "crates/apm2-cli (orchestrator-like loops)"
            ],
            "anchor_patterns_in_repo": [
                "Reducer determinism + checkpoint replay equivalence: crates/apm2-core/src/reducer/*",
                "Explicit state machine with invariants: crates/apm2-daemon/src/episode/state.rs",
                "Gate orchestrator with resource bounds + injected clock + explicit statuses: crates/apm2-daemon/src/gate/orchestrator.rs",
                "Event-sourced orchestration state: crates/apm2-holon/src/orchestration/state.rs"
            ]
        },
        "north_star_properties": {
            "deterministic_under_replay": {
                "definition": "Given the same ordered input sequence, the transition core yields byte-identical state and effect list.",
                "mechanics": [
                    "Treat time, randomness, external observations, and I/O outcomes as explicit Inputs.",
                    "Treat ordering as explicit (ledger cursor, sequence numbers, HLC)."
                ],
                "machine_check": "Property test: replay from genesis equals replay from checkpoint; repeated replay yields identical final state."
            },
            "single_source_of_truth": {
                "definition": "Each fact has one canonical owner; other consumers hold references or derive views.",
                "mechanics": [
                    "Canonical owners are: ledger events, CAS artifacts, signed config, and stable IDs minted by authority.",
                    "Orchestrator State stores references (ids, digests, cursors), plus the minimal sufficient statistic required for future decisions."
                ],
                "machine_check": "Tests reconstruct State from canonical inputs; derived views recompute from State with no external reads."
            },
            "closed_by_default_progression": {
                "definition": "Progression requires explicit evidence; ambiguity selects a safe terminal outcome that preserves auditability.",
                "mechanics": [
                    "Model terminal outcomes as explicit absorbing states.",
                    "Bind authority actions to receipts/signatures/digests; store those bindings."
                ],
                "machine_check": "Invariant tests: terminal states absorb; missing evidence yields terminal-deny/quarantine outcomes."
            },
            "idempotent_authority": {
                "definition": "Repeating the same logical trigger yields the same durable result, not duplicated spawns/leases/receipts.",
                "mechanics": [
                    "Compute idempotency keys from stable input digests (work_id + changeset_digest + gate_type + revision).",
                    "Store bounded idempotency memory in State or in an authority-backed store."
                ],
                "machine_check": "Tests feed duplicated Inputs; effects stay stable; at-most-once issuance is preserved."
            },
            "bounded_resources": {
                "definition": "State growth and work per input are explicitly bounded.",
                "mechanics": [
                    "Bound maps/sets/strings by constants.",
                    "Select bounded behavior: reject, evict, degrade, checkpoint, compact."
                ],
                "machine_check": "Tests push inputs to bounds; State remains within limits; behavior remains deterministic."
            },
            "illegal_states_unrepresentable": {
                "definition": "Core domain logic is written against precise domain types; illegal states are structurally unrepresentable in State/Input/Effect and in any View used for decisions.",
                "mechanics": [
                    "Prefer strengthening argument types over weakening return types (Option/Result) when the failure mode is an invariant that can be proven once upstream.",
                    "Parse/normalize untrusted data at the driver boundary into domain types with fallible constructors (TryFrom/FromStr/serde try_from). The step function trusts parsed types and does not re-validate.",
                    "Prefer enums/newtypes over bool flags and sentinel values; store proofs/evidence references (receipt ids, digests, cursors), not 'validated' booleans.",
                    "Avoid denormalized duplicates; keep a single canonical owner and derive views from it."
                ],
                "machine_check": "Greppable rules: no `unreachable!(\"already checked\")`/`expect(\"should never happen\")` in the transition core; tests exist for every domain-type constructor with invalid cases; step/state structs avoid raw String/bool/Vec for invariant-bearing fields."
            }
        },
        "orchestrator_information_flow": {
            "shape": "Inputs -> normalize -> step(State, Input, Snapshot) -> (NextState, Effects) -> drive(Effects) -> Observations -> Inputs",
            "contract": {
                "step": [
                    "Deterministic function producing NextState + Effects as data.",
                    "Only branches on explicit State/Input/Decision enums.",
                    "Uses ContextSnapshot values passed in (time, budgets, liveness, environment readings)."
                ],
                "drive": [
                    "Executes Effects (I/O, process ops, ledger writes, CAS writes).",
                    "Converts outcomes into Observations, then Inputs.",
                    "Records durable evidence for every authority-relevant effect."
                ]
            }
        },
        "ledger_projection_grounding": {
            "thesis": "The step function is a fold over the append-only ledger. State is the projection that fold produces. Effects are primarily acts of evidence creation — their operational consequence (API call, process spawn, lease issuance) is the side effect, not the substance.",
            "event_first_design": {
                "instruction": "Before designing State or the Input enum, design the ledger event vocabulary. Ask: if this machine ran to completion, what named events would appear in the ledger, and what would each contain? The events define the information domain; State is only what you must carry between events to fold the next one correctly.",
                "test": "Can you reconstruct the full machine history from ledger events alone, with no in-memory state? If not, a ledger event is missing."
            },
            "step_is_the_reducer": {
                "instruction": "The step function IS the reduce/fold. Input enum variants correspond to ledger event types (observed by the driver) plus driver-boundary observations (time readings, process signals, API outcomes). Determinism is not a testing nicety — it is the requirement that derives from the ledger being ground truth: if step is non-deterministic, the machine's projection diverges across restarts.",
                "state_field_test": "For every State field ask: 'Do I need this to correctly fold the next event?' If the answer is no, it is a cache and belongs in a witnessed cache or derived view, not in canonical State."
            },
            "closure_properties": {
                "instruction": "The step function must satisfy the three properties of the Cl_P closure operator. These are the algebraic requirements that make the ledger the single source of truth — not guidelines.",
                "extensive": {
                    "definition": "Missing evidence yields fail/pending/quarantine, never a spurious pass.",
                    "machine_check": "Invariant test: step called with an Input carrying no evidence for a required gate must produce a non-Pass terminal or a waiting state. A Completed/Pass state with empty evidence refs is a defect."
                },
                "monotone": {
                    "definition": "Additional evidence can only advance state, never retract it. A passing gate cannot be un-passed by a subsequent event.",
                    "machine_check": "Property test: fold(A) then fold(A ++ B) — final state from A+B is at least as advanced as from A alone."
                },
                "idempotent": {
                    "definition": "Same event sequence, same output. This is why replay-from-genesis equals replay-from-checkpoint, and why replaying a deduplicated event stream is safe.",
                    "machine_check": "Already covered in verification_suite.property_tests. Extend with: fold(dedupe(events ++ events)) == fold(events)."
                }
            },
            "effects_as_evidence_creation": {
                "instruction": "For every Effect, identify its primary evidence artifact first: what named ledger event or CAS digest does it produce? The API call or process op is the mechanism; the ledger/CAS write is the substance. This ordering is what makes replay safe.",
                "sequencing_rule": "Emit the evidence-anchoring ledger event BEFORE the irreversible operational effect (already stated in effect_emission.ordering). The reason: on restart, the driver checks the ledger first and skips re-execution if the result event already exists.",
                "canonical_pattern_external_write": {
                    "description": "Idempotent write to a 3rd-party authority (GitHub PR creation, issue comment, external API mutation).",
                    "steps": [
                        "1. Step emits Effect::RecordIntent { idempotency_key, action_id, action } — driver writes intent event to ledger.",
                        "2. Step emits Effect::CallExternalApi { action_id, params } — driver checks ledger for an existing result event for action_id FIRST; if found, synthesizes the Input from the ledger record and skips the call.",
                        "3. Call returns; driver converts outcome to Input::ApiResult { action_id, outcome }.",
                        "4. Step processes ApiResult, emits Effect::RecordOutcome { action_id, outcome } — driver writes result event to ledger.",
                        "5. On any subsequent replay: step 2 finds the result event; no call is made; Input::ApiResult is synthesized from the ledger record."
                    ],
                    "anti_pattern": "Executing the external call as a bare driver side-effect without a prior intent event. A crash between the call and the result record leaves the system unable to determine whether the call succeeded. The next restart re-executes, producing a duplicate action."
                }
            }
        },
        "cursor_and_activation": {
            "goal": "Give every machine an explicit, durable position in the event stream so that cross-machine coordination is exactly-once by construction, not by memory.",
            "ledger_cursor_in_state": {
                "instruction": "Include a ledger cursor field in State representing the position up to which the machine has durably processed events. Justification as sufficient statistic: it is the minimal information needed to resume folding from the correct position after a crash.",
                "invariant": "Events before the cursor are provably already processed — not because the machine remembers processing them, but because the cursor is structurally past them. No in-memory seen-set can provide this guarantee across restarts."
            },
            "cursor_advancement_ordering": {
                "instruction": "Advance the cursor only AFTER the result effects that justify the advancement have been durably written to the ledger. If you advance the cursor in State before your result events are flushed, a crash between those two operations produces a checkpoint that claims progress the ledger does not contain.",
                "ordering": [
                    "1. Read events from ledger starting at state.ledger_cursor.",
                    "2. Feed each event into step as an Input variant; collect (NextState, Effects).",
                    "3. Execute Effects: write result events to ledger (durable).",
                    "4. Only then checkpoint NextState (which contains the advanced cursor).",
                    "5. On crash-restart: load checkpoint, read ledger from checkpoint.cursor — events before cursor are skipped structurally."
                ]
            },
            "at_most_once_activation": {
                "instruction": "When a machine activates in response to a cross-machine ledger event (e.g., session_terminated triggering gate orchestration), the activation itself must be a ledger event whose idempotency key is derived from the triggering event's stable position or id. The driver checks the ledger for an existing activation record before processing — no in-memory lock required as the primary guarantee.",
                "pattern": [
                    "Triggering event arrives at cursor position P.",
                    "Driver checks ledger: does an activation record exist for trigger_event_id=P?",
                    "If yes: advance cursor past P, no further action (already processed).",
                    "If no: emit Effect::RecordActivation { trigger_event_id: P, action_id } to ledger, then proceed with activation effects.",
                    "Crash at any point: restart reads the ledger, finds (or doesn't find) the activation record, and branches correctly."
                ],
                "benefit": "Double-activation becomes structurally impossible without relying on in-memory deduplication state that does not survive crashes."
            }
        },
        "derived_state_discipline": {
            "core_axiom": "State is a sufficient statistic for future decisions under the modeled Inputs; every other datum is a derived view or an external observation.",
            "fact_ownership_map": {
                "instruction": "For every value used by the orchestrator, name its owner explicitly: ledger event, CAS artifact, config field, minted id, or a State field justified as a sufficient statistic.",
                "owner_catalog": {
                    "ledger": [
                        "Authoritative lifecycle transitions",
                        "Receipts and verdicts (signed)",
                        "Work/session/episode identifiers and relationships"
                    ],
                    "cas": [
                        "Large payloads, prompts, evidence bundles, manifests",
                        "Content-addressed documents referenced by digest"
                    ],
                    "config": [
                        "Timeouts, limits, policy profiles, role specs"
                    ],
                    "state": [
                        "Cursor into event stream / processing position",
                        "Outstanding obligations (pending leases, pending episodes, pending receipts)",
                        "Idempotency memory and bounded dedupe windows",
                        "Controller memory (backoff state, escalation level) as sufficient statistic"
                    ]
                },
                "output": "A code-level comment block near the State definition listing each State field and its justification as a sufficient statistic."
            },
            "derived_views": {
                "instruction": "Expose derived information through pure view functions computed from canonical State (and optional stable config), returning purpose-specific view structs.",
                "pattern": {
                    "name": "Projection -> View -> Decision",
                    "definition": [
                        "Projection: durable State folded from Inputs/events.",
                        "View: ephemeral struct computed from State to simplify decisions.",
                        "Decision: typed enum expressing branching outcomes in a compact vocabulary."
                    ],
                    "benefit": "Derived values become impossible to desynchronize because a single function defines their computation.",
                    "implementation": [
                        "Implement `impl State { fn view(&self, cfg: &Config) -> View }`.",
                        "Keep View small and purpose-specific; create multiple Views for different decisions when useful."
                    ]
                }
            },
            "reference_over_copy": {
                "instruction": "Represent canonical artifacts by stable references (ids, digests, cursors) and derive expanded content on demand in the driver boundary.",
                "examples": [
                    "Store `changeset_digest` and a `cas_ref` to the changeset bundle; driver loads bundle by digest when executing an effect.",
                    "Store `receipt_id` and verifying key reference; driver fetches and verifies receipt to produce an Input."
                ]
            },
            "witnessed_caches": {
                "instruction": "When performance benefits from materializing derived values, store a cache paired with a witness that makes validity decidable.",
                "witness_forms": [
                    "source_digest (hash of canonical inputs used for derivation)",
                    "epoch / version counter that increments on any relevant State change",
                    "cursor_range (ledger position interval covered by the cache)"
                ],
                "pattern": {
                    "name": "CacheWithWitness",
                    "rust": "/// Cache with an explicit validity witness.\n#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]\n#[serde(deny_unknown_fields)]\npub struct CacheWithWitness<T> {\n    pub witness: [u8; 32],\n    pub value: T,\n}\n\nimpl<T> CacheWithWitness<T> {\n    pub fn is_valid_for(&self, witness: [u8; 32]) -> bool {\n        self.witness == witness\n    }\n}\n"
                }
            },
            "local_state_budget": {
                "instruction": "Use local variables inside a function as ephemeral computations; use State only for sufficient statistics required across calls/restarts.",
                "decision_test": [
                    "If the value is recomputable from (State, Input, Config), keep it derived.",
                    "If the value must survive restarts or deduplicate authority actions, keep it in State with a justification comment."
                ]
            }
        },
        "parse_dont_validate": {
            "goal": "Eliminate shotgun validation in the transition core by parsing/normalizing untrusted data into precise domain types at the boundary. Make illegal states unrepresentable where practical; otherwise, encapsulate them behind smart constructors and keep the proof object, not a boolean.",
            "core_thesis": "A parser consumes less-structured input and produces more-structured output. Prefer `parse/try_from/from_str` that returns a domain type over `validate/verify/is_valid` that returns bool/() and discards the proof. The step function should only accept the parsed domain types it needs; parsing failures become explicit Inputs and ledger-visible outcomes.",
            "raw_vs_parsed_split": {
                "instruction": "Maintain an explicit split between Raw (untrusted) data and Parsed (trusted-for-core) data. Raw exists only at the driver boundary; Parsed is what appears in Input/Snapshot/State/EvidenceRefs.",
                "pattern": [
                    "Driver receives RawObservation (strings, bytes, json values, exit codes, timestamps, API payloads).",
                    "Driver parses RawObservation into ParsedInput / ParsedSnapshot fields using fallible constructors.",
                    "On parse failure: emit an explicit Input::ParseRejected / Input::SnapshotRejected carrying structured error evidence; do NOT pass partially-validated primitives into `step`."
                ]
            },
            "invariants": {
                "invariant_1_only_parsed_enters_step": {
                    "definition": "`step(State, Input, Snapshot)` may branch only on values whose invariants are already proven. If `step` needs an invariant, the invariant must be encoded in the type of the value.",
                    "mechanics": [
                        "Use newtypes/enums/NonZero*/NonEmpty*/arrays/bounded wrappers to represent invariants.",
                        "Keep newtype fields private; expose only fallible constructors (`TryFrom`, `FromStr`, `parse`, `new`).",
                        "If an invariant cannot be fully encoded, encapsulate the value and provide safe accessors so illegal states cannot leak."
                    ],
                    "machine_check": "Code review + tests: transition core contains no ad-hoc parsing of strings/bytes/json; no `panic!/unreachable!/expect(\"already checked\")` paths relying on earlier validation; constructors have negative tests for invalid inputs."
                },
                "invariant_2_no_boolean_flags": {
                    "definition": "No boolean flags in canonical State/Input/Evidence. Booleans discard semantics and make illegal combinations representable.",
                    "mechanics": [
                        "Replace `bool` with small enums: `GateVerdict::{Pass, Fail}`, `LightBulbState::{On, Off}`, `Liveness::{Alive, Dead, Unknown}`.",
                        "Convert to/from external API booleans at the driver boundary via `From`/`Into`."
                    ],
                    "machine_check": "Greppable rule for orchestrator core: `bool` is not used in State/Input/Evidence structs/enums except in leaf driver bindings that immediately convert into a semantic enum."
                },
                "invariant_3_no_sentinel_values": {
                    "definition": "Sentinel values (-1, empty string, 0 meaning 'invalid', magic prefixes) are forbidden as domain encodings. Use Option/enums/newtypes instead.",
                    "mechanics": [
                        "Use `Option<T>` for absence, and enums for multi-way state.",
                        "Use NonZero types (`NonZeroU64`, etc.) when 0 is illegal.",
                        "Use `Bounded*` and `NonEmpty*` wrappers when emptiness/size is semantically constrained."
                    ],
                    "machine_check": "Tests: domain constructors reject sentinel encodings; serialization golden vectors prove illegal encodings cannot be produced."
                },
                "invariant_4_avoid_shotgun_parsing": {
                    "definition": "No 'shotgun parsing': do not mix parsing/validation checks throughout processing logic. Fully parse the representation you need before acting on it.",
                    "mechanics": [
                        "Parsing in multiple passes is allowed, but the first side-effectful Effect must only occur after the required invariants are proven for that branch.",
                        "Parsing/validation failures must be ledger-visible (event or Input variant), not silent truncation."
                    ],
                    "machine_check": "Property test: for randomly generated RawObservations, driver either (a) produces ParsedInput and `step` never panics, or (b) produces ParseRejected input that drives a safe terminal/waiting outcome."
                },
                "invariant_5_validation_functions_must_return_proof": {
                    "definition": "Pure 'validator' functions that return `bool` or `Result<(), E>` are forbidden when their sole job is to establish an invariant. They throw away the proof and invite refactor bugs.",
                    "mechanics": [
                        "Replace `fn verify(x: &T) -> bool` with `fn parse(x: RawT) -> Result<ParsedT, ParseError>`.",
                        "If a third-party API forces a weak type (e.g., `bool` or `String`), convert at the boundary and keep the strong type internally."
                    ],
                    "machine_check": "Greppable rule: orchestrator core should not define `is_valid*`, `validate*`, `verify*` functions unless they return a parsed/proof type."
                }
            },
            "anti_patterns": [
                "Storing `String` IDs/digests and re-validating prefixes/lengths at each use-site.",
                "Accepting `serde_json::Value` or untyped maps in the transition core and `unwrap()`-ing fields later.",
                "Using `unreachable!(\"already checked\")` as a substitute for a NonEmpty/NonZero type.",
                "Representing multi-way states as several booleans (e.g., `running && !completed && !failed`).",
                "Parsing external API payloads inside `step` (breaks determinism and makes core partial)."
            ],
            "counterexample": {
                "name": "Shotgun parsing + boolean flags (do not do this)",
                "rust": "/// Anti-pattern: raw primitives in State/Input + ad-hoc validation inside `step`.\n#[derive(Debug, Clone)]\npub struct Snapshot {\n    pub monotonic_elapsed_ms: u64,        // claimed monotonic; not enforced by type\n    pub active_leases: Vec<String>,       // unbounded + untyped\n}\n\n#[derive(Debug, Clone)]\npub enum Input {\n    Tick { elapsed_ms: u64 },\n    ApiResult { action_id: String, ok: bool, receipt_json: String },\n}\n\n#[derive(Debug, Clone)]\npub struct State {\n    pub action_id: String,\n    pub passed: bool,\n    pub receipt_json: Option<String>,\n}\n\npub fn step(mut state: State, input: Input, snap: Snapshot) -> (State, Vec<()>) {\n    // Shotgun validation scattered throughout the transition core.\n    if snap.monotonic_elapsed_ms == 0 {\n        // \"should never happen\" — but nothing prevents it.\n    }\n\n    match input {\n        Input::ApiResult { action_id, ok, receipt_json } => {\n            // Core panics on bad data instead of rejecting at the boundary.\n            if !action_id.starts_with(\"act_\") {\n                panic!(\"invalid action id\");\n            }\n\n            // \"ok\" has unclear semantics; receipt_json is unparsed.\n            if ok && receipt_json.contains(\"\\\"sig\\\"\") {\n                state.passed = true;\n                state.receipt_json = Some(receipt_json);\n            }\n        }\n        _ => {}\n    }\n\n    (state, vec![])\n}\n"
            },
            "examples": {
                "simple": {
                    "name": "Strengthen parameters with a domain type (NonZero) instead of weakening return types",
                    "rust": "use std::num::NonZeroU64;\n\n/// Domain type: a lease TTL that is guaranteed non-zero.\n#[derive(Debug, Clone, Copy, PartialEq, Eq)]\npub struct LeaseTtlMs(NonZeroU64);\n\n#[derive(Debug, thiserror::Error)]\npub enum LeaseTtlParseError {\n    #[error(\"ttl must be non-zero\")]\n    Zero,\n}\n\nimpl LeaseTtlMs {\n    pub fn parse(raw_ms: u64) -> Result<Self, LeaseTtlParseError> {\n        let nz = NonZeroU64::new(raw_ms).ok_or(LeaseTtlParseError::Zero)?;\n        Ok(Self(nz))\n    }\n\n    pub fn get(self) -> u64 {\n        self.0.get()\n    }\n}\n\n/// Transition core now cannot be called with an illegal ttl.\nfn issue_lease(ttl: LeaseTtlMs) {\n    // no validation needed here\n    let _ttl_ms = ttl.get();\n}\n"
                },
                "medium": {
                    "name": "Parse config/observations into NonEmpty/Bounded types at the driver boundary",
                    "rust": "use std::path::PathBuf;\n\n#[derive(Debug, Clone)]\npub struct NonEmptyVec<T>(T, Vec<T>);\n\n#[derive(Debug, thiserror::Error)]\n#[error(\"must be non-empty\")]\npub struct Empty;\n\nimpl<T> TryFrom<Vec<T>> for NonEmptyVec<T> {\n    type Error = Empty;\n\n    fn try_from(mut v: Vec<T>) -> Result<Self, Self::Error> {\n        if v.is_empty() {\n            return Err(Empty);\n        }\n        let first = v.remove(0);\n        Ok(NonEmptyVec(first, v))\n    }\n}\n\nimpl<T> NonEmptyVec<T> {\n    pub fn first(&self) -> &T {\n        &self.0\n    }\n\n    pub fn iter(&self) -> impl Iterator<Item = &T> {\n        std::iter::once(&self.0).chain(self.1.iter())\n    }\n}\n\n/// Snapshot passed into `step` uses the stronger type.\n#[derive(Debug, Clone)]\npub struct Snapshot {\n    pub cfg_dirs: NonEmptyVec<PathBuf>,\n}\n\n/// Driver boundary: parse once.\nfn read_cfg_dirs() -> Result<NonEmptyVec<PathBuf>, Box<dyn std::error::Error>> {\n    let raw = std::env::var(\"CONFIG_DIRS\")?;\n    let v = raw.split(',').map(PathBuf::from).collect::<Vec<_>>();\n    Ok(NonEmptyVec::try_from(v)?)\n}\n\nfn core_logic(snap: &Snapshot) {\n    // No redundant match on Option; the type proves non-empty.\n    let cache_dir: &PathBuf = snap.cfg_dirs.first();\n    let _ = cache_dir;\n}\n"
                },
                "advanced": {
                    "name": "Typestate to encode effect ordering for external authority writes (intent -> call -> outcome)",
                    "rust": "use std::marker::PhantomData;\n\n#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\npub struct ActionId([u8; 16]);\n\n#[derive(Debug, Clone)]\npub enum Effect {\n    RecordIntent { action_id: ActionId },\n    CallExternal { action_id: ActionId },\n    RecordOutcome { action_id: ActionId },\n}\n\npub enum UnrecordedIntent {}\npub enum IntentRecorded {}\npub enum Called {}\n\n/// A typed 'plan' that makes illegal effect orderings unrepresentable.\n#[derive(Debug, Clone, Copy)]\npub struct ExternalWrite<S> {\n    action_id: ActionId,\n    _s: PhantomData<S>,\n}\n\nimpl ExternalWrite<UnrecordedIntent> {\n    pub fn new(action_id: ActionId) -> Self {\n        Self { action_id, _s: PhantomData }\n    }\n\n    pub fn record_intent(self) -> (ExternalWrite<IntentRecorded>, Effect) {\n        (\n            ExternalWrite { action_id: self.action_id, _s: PhantomData },\n            Effect::RecordIntent { action_id: self.action_id },\n        )\n    }\n}\n\nimpl ExternalWrite<IntentRecorded> {\n    pub fn call(self) -> (ExternalWrite<Called>, Effect) {\n        (\n            ExternalWrite { action_id: self.action_id, _s: PhantomData },\n            Effect::CallExternal { action_id: self.action_id },\n        )\n    }\n}\n\nimpl ExternalWrite<Called> {\n    pub fn record_outcome(self) -> Effect {\n        Effect::RecordOutcome { action_id: self.action_id }\n    }\n}\n\nfn build_effects(action_id: ActionId) -> Vec<Effect> {\n    let (w1, e1) = ExternalWrite::<UnrecordedIntent>::new(action_id).record_intent();\n    let (w2, e2) = w1.call();\n    let e3 = w2.record_outcome();\n    vec![e1, e2, e3]\n}\n"
                }
            }
        },
        "transition_core": {
            "goal": "Make the core logic mechanically checkable: total transitions, explicit branching vocabulary, explicit effects.",
            "types": {
                "State": [
                    "Enum or struct with explicit variants/fields reflecting real phases.",
                    "Serde tags and deny-unknown-fields when persisted.",
                    "Explicit discriminants for persisted enums when overlapping versions are expected during rolling updates.",
                    "Avoid primitive obsession: no raw String/bool/sentinel encodings for domain meaning. Use domain newtypes/enums/bounded/non-empty wrappers so illegal states are unrepresentable."
                ],
                "Input": [
                    "Every external observation represented as an enum variant.",
                    "Includes Tick/Time inputs as explicit data.",
                    "Includes driver outcomes (spawn ok/fail, receipt verified/invalid, pid exited, liveness report).",
                    "Input variants carry parsed/proven domain values; the driver owns parsing/validation of raw observations (strings/bytes/json)."
                ],
                "Effect": [
                    "Every authority action as explicit data.",
                    "Includes intent, idempotency key, and evidence binding fields.",
                    "Driver produces Observations that become Inputs.",
                    "Effect payloads use stable, parsed domain references (ids/digests/cursors), not unvalidated strings; convert to external API weak types only at the driver boundary."
                ],
                "Decision": [
                    "Small enums used as guard outcomes (e.g., Progression::Allow/Block/Quarantine, SpawnPlan::Spawn/Resume/Skip).",
                    "Decision enums replace boolean branching vocabulary."
                ]
            },
            "branching_form": {
                "instruction": "Centralize branching in exhaustive matches on (State, Input) and (Decision, State).",
                "guard_style": [
                    "Compute Decision via pure functions returning enums.",
                    "Use match guards for numeric thresholds when the threshold is explicit and tested."
                ],
                "benefit": "Branch coverage becomes enumeratable; missing cases become compile-visible."
            },
            "effect_emission": {
                "instruction": "Emit Effects as a list returned from step; treat the list as an ordered script that the driver interprets.",
                "ordering": [
                    "Place evidence-anchoring effects before irreversible effects (e.g., emit policy-resolution event before issuing a lease).",
                    "Place dedupe/idempotency marking effects in the same step that decides issuance."
                ],
                "idempotency_shape": [
                    "Effect includes `idempotency_key` and `logical_action_id`.",
                    "State stores the action id in a bounded structure."
                ]
            },
            "template": {
                "rust": "/// Deterministic transition core.\npub fn step(\n    state: State,\n    input: Input,\n    snapshot: Snapshot,\n    cfg: &Config,\n) -> Result<(State, Vec<Effect>), Error> {\n    use State::*;\n    use Input::*;\n\n    match (state, input) {\n        (Idle { .. }, Start { work_id, changeset_digest }) => {\n            let action_id = ActionId::from_parts(&work_id, &changeset_digest);\n            let effects = vec![\n                Effect::EmitEvent(Event::OrchestrationStarted { work_id, changeset_digest }),\n                Effect::IssueLease { action_id },\n            ];\n            Ok((Leasing { action_id }, effects))\n        }\n\n        (Leasing { action_id }, LeaseIssued { lease_id }) => {\n            let effects = vec![Effect::SpawnEpisode { action_id, lease_id: lease_id.clone() }];\n            Ok((Running { action_id, lease_id, controller: Controller::new() }, effects))\n        }\n\n        (Running { action_id, lease_id, controller }, Tick { elapsed_ms }) => {\n            let (controller2, plan) = controller.plan(elapsed_ms, cfg);\n            match plan {\n                NudgePlan::None => Ok((Running { action_id, lease_id, controller: controller2 }, vec![])),\n                NudgePlan::Nudge { message_ref } => {\n                    let effects = vec![Effect::SendNudge { action_id, lease_id: lease_id.clone(), message_ref }];\n                    Ok((Running { action_id, lease_id, controller: controller2 }, effects))\n                }\n                NudgePlan::Escalate { reason } => {\n                    let effects = vec![Effect::EmitEvent(Event::Escalated { action_id, reason })];\n                    Ok((Quarantined { action_id, lease_id, reason }, effects))\n                }\n            }\n        }\n\n        (Running { action_id, lease_id, .. }, ReceiptVerified { receipt_id, passed }) => {\n            let effects = vec![Effect::EmitEvent(Event::Completed { action_id, receipt_id: receipt_id.clone(), passed })];\n            Ok((Completed { action_id, lease_id, receipt_id, passed }, effects))\n        }\n\n        (terminal @ (Completed { .. } | Quarantined { .. }), _) => Ok((terminal, vec![])),\n    }\n}\n"
            }
        },
        "driver_shell": {
            "goal": "Convert effects into reality while preserving determinism through explicit Inputs and durable evidence.",
            "effect_execution": {
                "instruction": "Implement a driver loop that executes Effects and immediately records an Observation as an Input for the next step.",
                "primitives": [
                    "CAS writes yield a digest; store digest in emitted event and in State references.",
                    "Ledger writes yield an event id / cursor; feed it back as Input.",
                    "Process operations yield a ProcessBinding; feed it back as Input."
                ]
            },
            "context_snapshot": {
                "instruction": "Provide the transition core with a Snapshot object holding bounded, validated observations. Snapshot is a trust boundary: the step function branches on its values without further validation, so the driver owns all validation.",
                "snapshot_fields": [
                    "monotonic_elapsed_ms",
                    "budget_remaining",
                    "liveness_report_summary",
                    "authoritative_head_sha / changeset_digest",
                    "active_leases set for dedupe (bounded view)"
                ],
                "trust_boundary": {
                    "property": "The step function fully trusts every Snapshot field. An elapsed time that goes backwards, a budget that exceeds its initial value, or an active_leases set with unbounded entries will cause step to produce wrong state — which gets checkpointed and replayed indefinitely.",
                    "validation_rule": "All Snapshot fields must be validated and clamped at the driver boundary before step is called. Validation failures must not be silently truncated and passed to step.",
                    "on_invalid_snapshot": "Emit Input::SnapshotRejected { field, reason } rather than passing a corrupted Snapshot to step. The machine handles this as a structured event (typically: pause, emit escalation ledger event, await corrected observation). Rejection becomes observable in the ledger, not a silent divergence."
                },
                "type_driven_snapshot": {
                    "instruction": "Prefer Snapshot fields to be domain types (newtypes/enums/bounded collections) rather than raw primitives. If `step` must trust a Snapshot invariant, make that invariant unconstructible in the Snapshot type (or constructible only via a fallible boundary parser).",
                    "examples": [
                        "Use `MonotonicMs` newtype constructed only by a monotonic clock adapter; never pass raw `u64` elapsed times if `step` assumes monotonicity.",
                        "Use `BudgetRemaining` newtype that is clamped/validated once; `step` must not contain `if budget < 0` checks.",
                        "Use `BoundedSet<LeaseId, MAX>` (or equivalent) instead of `Vec<String>` for active lease views."
                    ],
                    "anti_pattern": "Passing `Snapshot { budget_remaining: i64, active_leases: Vec<String> }` and then sprinkling validation and parsing throughout `step`."
                }
            }
        },
        "universal_addressing": {
            "goal": "Bind ephemeral handles to stable identities so that authority targets remain unambiguous across time and restarts.",
            "address_types": {
                "instruction": "Define newtypes/enums for stable addressing and store them in State, Events, and Effects.",
                "recommended": [
                    "WorkId, SessionId, EpisodeId, LeaseId (typed newtypes)",
                    "ActorId / RoleId (typed newtypes)",
                    "Digest32 (CAS hash wrapper)"
                ]
            },
            "process_binding": {
                "instruction": "Represent process identity as a binding between a stable address and a measured handle.",
                "fields": [
                    "pid",
                    "proc_start_time (or equivalent kernel identity witness)",
                    "lease_id or session_id (stable authority binding)",
                    "spawn_nonce (deterministic nonce derived from action id + attempt number)",
                    "cgroup_path or sandbox capsule id (when available)"
                ],
                "benefit": "PID reuse becomes mechanically distinguishable; process control operations target a specific binding."
            },
            "addressing_rule": {
                "instruction": "Carry the stable address through every layer: event -> state -> effect -> driver call -> observation -> input.",
                "result": "Logs, receipts, and evidence become joinable by stable keys without inference."
            }
        },
        "nudging_and_control": {
            "goal": "Model nudges/restarts/escalations as an explicit controller state machine with saturation and memory.",
            "controller_state": {
                "instruction": "Store controller memory in State as a sufficient statistic (attempt count, last action time, backoff stage, escalation stage).",
                "fields": [
                    "attempt: u32",
                    "last_progress_at_ms: u64",
                    "last_nudge_at_ms: Option<u64>",
                    "backoff: BackoffStage",
                    "escalation: EscalationStage"
                ]
            },
            "signals": {
                "instruction": "Compute progress signals as derived views from canonical evidence.",
                "examples": [
                    "receipt count delta",
                    "ledger cursor advanced for this action id",
                    "heartbeat freshness bucket",
                    "budget burn rate bucket"
                ]
            },
            "plans": {
                "instruction": "Emit a typed plan (None / Nudge / Restart / Escalate) as a Decision enum, then translate it into Effects.",
                "deterministic_jitter": "When jitter helps stability, derive it from a stable seed (hash(action_id || attempt)) so replay stays deterministic."
            }
        },
        "persistence_and_schema": {
            "goal": "Make persisted state/events resilient under rolling updates and mechanically verifiable.",
            "serde_profile": [
                "serde tags for enums (`#[serde(tag = \"state\")]` or explicit field tags).",
                "deny unknown fields for persisted structs/enums.",
                "bounded string lengths validated at boundaries."
            ],
            "evolution": {
                "instruction": "When versions overlap in production, keep discriminants/tags stable; introduce new variants/fields with explicit defaults and bounded validation.",
                "artifact_binding": [
                    "Store digests for CAS artifacts in events/state.",
                    "Store verifying key references and signature verification results as Inputs."
                ]
            }
        },
        "verification_suite": {
            "goal": "Ship executable proofs: invariants, replay determinism, idempotency, and bound behavior.",
            "invariants_as_tests": [
                "Terminal absorption: terminal states yield empty effects for all inputs.",
                "Monotonicity: elapsed/budget counters progress monotonically within modeled semantics.",
                "At-most-once issuance: repeating Start/Trigger inputs yields stable authority outputs.",
                "Evidence binding: every Completed state has a receipt id and verified flag in its causal history."
            ],
            "property_tests": {
                "instruction": "Generate event/input sequences and assert determinism and invariants.",
                "minimum": [
                    "Replay equivalence: fold(inputs) equals fold(inputs) repeated.",
                    "Checkpoint equivalence: fold(genesis) equals fold(prefix)+fold(suffix) with checkpoint."
                ]
            },
            "transition_enumeration": {
                "instruction": "Enumerate (State variant × Input variant) combinations for small machines and assert each pair produces a defined Outcome.",
                "result": "Branch coverage becomes mechanical; missing cases surface early."
            },
            "golden_vectors": {
                "instruction": "Keep golden vectors for serialization and signatures on authority-relevant artifacts.",
                "targets": [
                    "receipts",
                    "leases",
                    "context packs / manifests"
                ]
            }
        },
        "refactor_moves_for_existing_orchestrators": {
            "goal": "Turn a loop with scattered branching into a state machine with explicit effects while preserving behavior.",
            "moves": [
                "Name the phases currently implicit in control flow; encode them as a State enum with explicit data fields.",
                "Name the external triggers and observations; encode them as an Input enum.",
                "Name the authority actions; encode them as an Effect enum with idempotency keys and evidence binding fields.",
                "Lift branching vocabulary into Decision enums and pure guard functions.",
                "Wrap existing side-effecting code as driver handlers for Effects; convert outcomes into Inputs.",
                "Add invariant tests first for current behavior; then strengthen invariants that delete bug classes (determinism, idempotency, boundedness).",
                "Replace scattered `validate/verify/is_valid` checks and boolean flags with boundary parsing into domain types (newtypes/enums/NonEmpty/Bounded). Make illegal states unrepresentable in State/Input/Effect."
            ]
        },
        "review_lenses": {
            "lens_1_state_is_sufficient_statistic": [
                "Each State field has a justification as sufficient statistic.",
                "Derived information is provided via view functions.",
                "Artifacts appear as references (ids/digests/cursors) rather than expanded copies."
            ],
            "lens_2_determinism_and_replay": [
                "Transition core accepts time and observations as Inputs/Snapshot fields.",
                "Effect list ordering is stable and intentional.",
                "Tests cover replay equivalence."
            ],
            "lens_3_identity_and_evidence": [
                "Stable addresses flow end-to-end.",
                "Ephemeral handles appear only within bindings that include identity witnesses.",
                "Every authority outcome has a durable receipt/event trail."
            ],
            "lens_4_bounds_and_containment": [
                "All collections have explicit limits and defined behavior at the limit.",
                "String sizes and external payload sizes are bounded and validated."
            ],
            "lens_5_parse_dont_validate": [
                "State/Input/Effect carry parsed domain types (NonZero/NonEmpty/Bounded/enum newtypes), not raw primitives with comments.",
                "No boolean flags or sentinel values used to encode domain meaning.",
                "Parsing/validation is isolated to the driver boundary; transition core contains no ad-hoc parsing or validation helpers that discard proofs.",
                "Parse failures become explicit Inputs/ledger events; the machine never panics on malformed observations."
            ]
        }
    }
}
