{
  "kind": "instruction.spec",
  "schema": "cac.instruction_spec.v1",
  "schema_version": "1.0.0",
  "meta": {
    "classification": "INTERNAL",
    "created_at": "2026-02-21T00:00:00Z",
    "dependencies": [
      "dcp://apm2.local/instructions/alien_engineering_protocol/master@v1"
    ],
    "labels": [
      "alien-coding",
      "agent-orchestrators",
      "rust",
      "state-machines",
      "verification-first",
      "derived-state-discipline",
      "ledger-first",
      "cas-first",
      "bft-ready",
      "controller-loop",
      "projection-cache",
      "v3"
    ],
    "provenance": {
      "actor_id": "HOLON-INSTR-EMITTER",
      "work_id": "alien_coding_orchestrators_master_v3"
    },
    "stable_id": "dcp://apm2.local/instructions/alien_coding_orchestrators/master@v3"
  },
  "payload": {
    "i": "Alien Coding (Orchestrators) v3: build orchestration as a deterministic controller over the APM2 substrate (Ledger + CAS + optional BFT finality). One canonical event log, one artifact plane, zero ad-hoc durable state.",
    "t": {
      "sys": "APM2",
      "repo": "{repo_root}",
      "language": "Rust (edition 2024)",
      "platform": "Ubuntu 24.04 only",
      "users": "agents and internal operators",
      "deployment_model": "rolling updates + rollback; architectural cleanliness is rewarded",
      "scope": [
        "crates/apm2-core",
        "crates/apm2-daemon",
        "crates/apm2-holon",
        "crates/apm2-cli (orchestrator-like loops)"
      ],
      "anchor_patterns_in_repo": [
        "Reducer determinism + checkpoint replay equivalence: crates/apm2-core/src/reducer/*",
        "Ledger as canonical substrate (seq_id, schema_digest, consensus fields): crates/apm2-core/src/ledger/*",
        "BFT-integrated ledger backend + consensus metadata persistence: crates/apm2-core/src/ledger/bft_backend.rs",
        "HotStuff BFT state machine (Chained HotStuff): crates/apm2-core/src/consensus/bft.rs",
        "CAS trait + bounded verification: crates/apm2-core/src/evidence/cas.rs",
        "Daemon durable CAS (filesystem-backed, tamper-evident): crates/apm2-daemon/src/cas/mod.rs",
        "Read-only CAS reader used by CLI workers: crates/apm2-core/src/fac/cas_reader.rs",
        "Explicit state machine with invariants: crates/apm2-daemon/src/episode/state.rs",
        "Gate orchestrator with resource bounds + injected clock + explicit statuses: crates/apm2-daemon/src/gate/orchestrator.rs",
        "Event-sourced work/lease/session reducers: crates/apm2-core/src/work/* ; crates/apm2-core/src/lease/* ; crates/apm2-core/src/session/*",
        "FAC review (legacy divergent persistence patterns to refactor away): crates/apm2-cli/src/commands/fac_review/*"
      ]
    },
    "north_star_properties": {
      "dominance_ordered_failure": {
        "definition": "Conflict resolution must strictly adhere to META-DOMINANCE: Containment/Security > Verification/Correctness > Liveness/Progress.",
        "mechanics": [
          "If a containment boundary or correctness constraint fails, the orchestrator MUST fail-closed.",
          "Liveness watchdogs or retries must never override a containment or correctness failure.",
          "Record failures as defects; do not silently mask them to maintain progress."
        ],
        "machine_check": "Tests assert that containment/correctness failures trap execution into terminal/escalated states, halting further progress."
      },
      "single_source_of_truth": {
        "definition": "Each fact has one canonical owner; all other representations are references or derived projections.",
        "mechanics": [
          "Canonical owners are: finalized ledger events (optionally BFT-finalized), CAS artifacts (by digest), signed config, and stable IDs minted by authority.",
          "Orchestrator State stores references (ids, digests, cursors), plus the minimal sufficient statistic required for future decisions.",
          "Any on-disk cache (queues, state.json, gate caches) must be rebuildable from ledger+CAS or be explicitly labeled as best-effort telemetry."
        ],
        "machine_check": "Given only the ledger + referenced CAS blobs + config, tests can reconstruct the projection/state exactly. Derived caches can be deleted without data loss."
      },
      "deterministic_under_replay": {
        "definition": "Given the same ordered input sequence, the transition core yields byte-identical state and effect list.",
        "mechanics": [
          "Treat time, randomness, external observations, and I/O outcomes as explicit Inputs (never implicit reads inside step).",
          "Treat ordering as explicit: ledger cursor (seq_id/consensus index), sequence numbers, or HLC."
        ],
        "machine_check": "Property test: replay from genesis equals replay from checkpoint; repeated replay yields identical final state."
      },
      "idempotent_authority": {
        "definition": "Repeating the same logical trigger yields the same durable result (no duplicate spawns/leases/comments/verdicts).",
        "mechanics": [
          "Compute idempotency keys from stable digests (work_id + inputs_digest + action_kind + revision).",
          "Write an intent event before irreversible actions; on retry, driver checks for existing receipt/result events."
        ],
        "machine_check": "Tests feed duplicated Inputs; effects remain stable; at-most-once issuance is preserved."
      },
      "finality_aware_authority": {
        "definition": "Irreversible side effects are gated on authoritative finality. Under BFT, do not act on tentative/forkable facts.",
        "mechanics": [
          "Separate: Intent -> Execute -> Receipt. Only treat receipts anchored in finalized ledger as authoritative.",
          "When BFT is enabled, treat consensus-committed events (QC/epoch/round) as the canonical order; avoid relying on local wall-clock ordering."
        ],
        "machine_check": "Simulation test: reorder/delay tentative inputs; orchestrator never produces conflicting irreversible effects."
      },
      "closed_by_default_progression": {
        "definition": "Progression requires explicit evidence; ambiguity selects a safe terminal outcome that preserves auditability.",
        "mechanics": [
          "Model terminal outcomes as explicit absorbing states.",
          "Bind authority actions to receipts/signatures/digests; store those bindings."
        ],
        "machine_check": "Invariant tests: terminal states absorb; missing evidence yields terminal-deny/quarantine outcomes."
      },
      "bounded_resources": {
        "definition": "State growth and work per input are explicitly bounded.",
        "mechanics": [
          "Bound maps/sets/strings by constants.",
          "Select bounded behavior: reject, evict, degrade, checkpoint, compact.",
          "Never scan unbounded directories or ledgers in the hot path; use cursors and incremental iteration."
        ],
        "machine_check": "Tests push inputs to bounds; State remains within limits; behavior remains deterministic."
      },
      "no_shadow_state": {
        "definition": "Do not create new durable state stores outside the substrate (Ledger+CAS).",
        "mechanics": [
          "If you think you need `~/.apm2/<thing>.json`, you probably need a ledger event type + reducer projection.",
          "If you think you need `~/.apm2/<thing>/cache`, it must be a witnessed cache: versioned, bounded, rebuildable from ledger+CAS, and safe to delete."
        ],
        "machine_check": "Code review: any new persistent file format requires an explicit justification for why it is not a ledger event or CAS blob."
      }
    },
    "orchestrator_information_flow": {
      "thesis": "Orchestrators are controllers that converge the world toward invariants by folding the ledger and emitting idempotent effects. They do not 'remember' progress in ad-hoc files; they re-derive it from durable evidence.",
      "planes": {
        "authority_plane": [
          "Ledger events (append-only, hash-chained; optionally BFT-finalized).",
          "Consensus metadata (epoch/round/QC) when enabled."
        ],
        "artifact_plane": [
          "CAS blobs keyed by digest (patch bundles, diffs, logs, transcripts, review artifacts).",
          "Ledger stores only digests and semantic references."
        ],
        "derived_plane": [
          "Projections (reducers) computed from ledger events.",
          "Witnessed caches (optional): accelerators that can be dropped and rebuilt."
        ]
      },
      "controller_loop": [
        "Observe: read new ledger events since cursor (and any bounded external observations as Inputs).",
        "Fold: run deterministic step/reducer to update State.",
        "Plan: compute required effects to converge toward invariants (leases, dispatch, reconciliation).",
        "Commit: scale evidence emission with action leverage (Evidence Tiering). Low-leverage actions yield Summary Receipts or Ephemeral State; high-leverage boundaries yield Merkle-linked, persistent ledger intents/receipts.",
        "Repeat: advance cursor; checkpoint projection."
      ],
      "anti_patterns": [
        "A separate 'review_state.json' (canonical) beside the ledger.",
        "Unbounded scans of filesystem directories to infer truth (should be derived/projection).",
        "Executing an irreversible action without first writing an intent event with an idempotency key."
      ]
    },
    "ledger_projection_grounding": {
      "thesis": "The step function is a fold over the (finalized) ledger. State is the projection that fold produces. Effects are primarily acts of evidence creation (ledger events + CAS blobs).",
      "event_first_design": {
        "instruction": "Before designing State or the Input enum, design the ledger event vocabulary. Ask: if this machine ran to completion, what named events would appear in the ledger, and what would each contain?",
        "test": "Can you reconstruct the full machine history from ledger events + referenced CAS blobs alone? If not, a ledger event (or CAS reference) is missing."
      },
      "finality_model": {
        "instruction": "Design event types with explicit finality semantics. Under BFT, the ledger may have tentative observations and finalized authority events.",
        "rules": [
          "Only perform irreversible external effects after recording an intent and verifying no finalized receipt already exists for the same idempotency key.",
          "If BFT is enabled, prefer acting only once the relevant intent is finalized/committed (QC present) unless the action is explicitly 'safe under forks' (pure reads, bounded observations).",
          "When finality is unavailable/unknown, fail closed for authority actions and proceed only with reversible/local effects."
        ]
      },
      "closure_operator": {
        "instruction": "The step function must satisfy closure/idempotence/monotonicity properties: fold is deterministic; folding more evidence can only advance state; folding duplicates does not change semantics.",
        "idempotent": {
          "definition": "fold(A ++ A) == fold(A).",
          "machine_check": "Property test with duplicated input sequences."
        },
        "monotone": {
          "definition": "Additional evidence can only advance state, never retract it (unless the domain explicitly models retractions as separate events).",
          "machine_check": "Property test: fold(A) then fold(A ++ B) never regresses."
        }
      },
      "effects_as_evidence_creation": {
        "instruction": "For every Effect, identify its primary evidence artifact first: what ledger event or CAS digest does it produce? The API call/process op is the mechanism; the ledger/CAS write is the substance.",
        "sequencing_rule": "Emit the evidence-anchoring intent event BEFORE the irreversible operational effect; then emit a receipt/result event AFTER.",
        "canonical_pattern_external_write": {
          "description": "Idempotent write to an external authority (GitHub comment, verdict update, PR body mutation).",
          "steps": [
            "1) Emit Event::IntentRecorded { idempotency_key, action }",
            "2) Driver checks ledger for existing Event::ReceiptRecorded with same idempotency_key; if found, synthesize Input and skip external call",
            "3) Execute external call",
            "4) Emit Event::ReceiptRecorded { idempotency_key, outcome, external_ref }",
            "5) Replay is safe: step 2 finds receipt and no duplicate call occurs"
          ],
          "anti_pattern": "Perform the external call first and only then write an outcome; crashes create ambiguity and duplicates."
        }
      }
    },
    "cursor_and_activation": {
      "goal": "Make orchestration incremental, bounded, and restart-safe by driving everything off cursors over the canonical substrate.",
      "cursor_types": [
        "Ledger seq_id cursor (single-node or local finalized).",
        "Consensus cursor (epoch, committed height, QC hash) when BFT is enabled.",
        "Derived cursor for external observations (e.g., GitHub timeline cursor) stored as ledger events."
      ],
      "activation": [
        "Activation should be triggered by 'new events since cursor' rather than ad-hoc timers.",
        "Timers exist only to schedule nudges/retries; they must not be the source of truth."
      ],
      "checkpointing": [
        "Checkpoint State periodically (bounded) to accelerate restart.",
        "Checkpoint is a cache; correctness always derives from ledger replay."
      ]
    },
    "derived_state_discipline": {
      "instruction": "Everything not in (ledger events, CAS blobs, signed config, minted IDs) is derived. Treat derived caches as disposable accelerators.",
      "rules": [
        "State fields must be sufficient statistics for folding the next event; do not store convenience copies of facts already owned by the ledger.",
        "Any filesystem representation (queues, pulse files, caches) must be: bounded, versioned, and rebuildable from ledger+CAS.",
        "If a derived cache disagrees with the projection, the projection wins; delete and rebuild the cache.",
        "Unbounded dynamic discovery of context is forbidden; orchestrators must enforce ContextPacks and strict token/tool budgets (LAW-02 & LAW-06)."
      ],
      "witnessed_cache_pattern": {
        "definition": "A cache that is safe to delete because it is fully derivable from canonical evidence; it may include additional indexing, but no new facts.",
        "required_fields": [
          "cache_version",
          "source_cursor_range",
          "bounds (max entries/bytes)",
          "integrity checks (hashes) for index files when needed"
        ]
      }
    },
    "transition_core": {
      "goal": "Pure decision logic: (State, Input, Snapshot, Config) -> (State, Effects). No I/O; no syscalls; no hidden time reads.",
      "types": {
        "State": "projection over ledger events; small and bounded; stores cursors, ids, digests, and minimal sufficient statistics",
        "Input": "ledger events plus explicit driver observations (time tick, process exit, API result, file lock probe result)",
        "Effect": "intent/receipt ledger writes, CAS writes, and operational actions (spawn/kill) that are idempotent by key"
      },
      "branching_form": "match (state, input) with exhaustive enums. No booleans-as-state; represent terminal states explicitly.",
      "effect_emission": {
        "ordering": [
          "1) Emit intent event (ledger) and/or CAS blob write (if content must exist before action)",
          "1.5) Validate stop-state (budget > 0, lease valid, no revocation signals) before irreversibility (INV-F-11 & INV-F-17)",
          "2) Perform operational effect (spawn/process/API call)",
          "3) Emit receipt/result event (ledger) binding outcome to intent idempotency_key"
        ],
        "idempotency": "Every operational effect must have an idempotency key derived from stable inputs; driver must be able to skip if receipt already exists."
      },
      "template": {
        "rust": "/// Deterministic transition core (controller/reconciler style).\npub fn step(state: State, input: Input, snap: Snapshot, cfg: &Config) -> Result<(State, Vec<Effect>), Error> {\n    use Input::*;\n    use State::*;\n\n    match (state, input) {\n        (Idle { work_id, cursor }, Input::LedgerEvent(ev)) => {\n            // Fold events first; planning happens on Tick.\n            let st = state.fold(ev, cfg)?;\n            Ok((st, vec![]))\n        }\n\n        (st, Tick { now_ms }) => {\n            // Plan is a pure function of the projection + bounded snapshot.\n            let plan = st.plan(snap, cfg, now_ms)?;\n            Ok((st, plan.effects))\n        }\n\n        // Example: external authority mutation is intent->execute->receipt.\n        (Mutating { idempotency_key, action, .. }, ExternalCallResult { idempotency_key: k, outcome }) if k == idempotency_key => {\n            let effects = vec![\n                Effect::EmitLedgerEvent(Event::ReceiptRecorded { idempotency_key, outcome }),\n            ];\n            Ok((Done { last_outcome: Some(outcome) }, effects))\n        }\n\n        // Default: ignore unknown combinations (closed world via exhaustive enums preferred).\n        (st, _) => Ok((st, vec![])),\n    }\n}"
      }
    },
    "driver_shell": {
      "goal": "The driver is the only place that touches the outside world. It executes Effects, writes ledger events, writes/reads CAS blobs, and converts outcomes into Inputs.",
      "rules": [
        "Driver must be restart-safe: on startup it replays ledger, reconstructs State, and resumes from cursor without special-case recovery logic.",
        "Driver must be idempotent by design: before executing an operational effect, check whether a receipt/result event already exists for the idempotency key.",
        "Driver must verify stop-state bounds (budget limit, revocation signals, lease freshness) before crossing outside execution boundaries.",
        "All external reads used for decisions must be captured as Inputs and (when they matter) recorded as ledger events so replay is possible."
      ],
      "interfaces": {
        "Ledger": [
          "append(event) -> seq_id / consensus index",
          "read_since(cursor, limit) -> events",
          "optional: append_via_bft(event, metadata) -> consensus index"
        ],
        "CAS": [
          "store(bytes) -> digest",
          "retrieve(digest) -> bytes (bounded + verified)",
          "never embed large blobs directly in ledger payloads"
        ]
      },
      "concurrency": [
        "Multiple drivers may run; only one should own a given (work_id, role) lease at a time.",
        "Use leases issued by authority (ledger) rather than ad-hoc PID checks as the primary concurrency guard.",
        "If local OS locks exist (FAC lane locks), treat them as derived enforcement mechanisms; canonical ownership is still ledger/lease."
      ]
    },
    "universal_addressing": {
      "instruction": "Identity must be stable across replays, restarts, and distributed replicas.",
      "rules": [
        "Use stable IDs (DCP stable_id) for instructions, prompts, work items, policies.",
        "Use digests (BLAKE3) for content-addressed artifacts; store digest references in events/state.",
        "Construct idempotency keys from stable IDs + content digests + action kind (never from wall clock)."
      ],
      "examples": [
        "review_session_id = hash(owner_repo + pr_number + head_sha + review_kind)",
        "dispatch_idempotency_key = hash(review_session_id + backend + model_id + prompt_digest)"
      ]
    },
    "nudging_and_control": {
      "goal": "Progress must be controller-driven and measurable. Liveness is a first-class signal, not inferred from PID existence.",
      "rules": [
        "All nudges/retries are planned in step() and emitted as Effects (e.g., schedule tick, re-dispatch, renew lease).",
        "Watchdogs must be progress-aware (gated on projection updates), not background threads that mask deadlocks.",
        "Prefer evidence-based liveness: leases, receipts, systemd unit states, CAS artifacts; PID checks are a last resort and must be identity-verified."
      ]
    },
    "persistence_and_schema": {
      "goal": "Persisted state/events must survive rolling updates and be mechanically verifiable.",
      "serde_profile": [
        "serde tags for enums (`#[serde(tag = \"type\")]` or explicit field tags).",
        "deny unknown fields for persisted structs/enums.",
        "bounded string lengths validated at boundaries."
      ],
      "evolution": {
        "instruction": "Keep discriminants stable; add new variants/fields with explicit defaults and bounded validation. Never silently repurpose fields.",
        "artifact_binding": [
          "Store CAS digests in events/state; verify on read.",
          "Include schema_digest in ledger events where supported (BLAKE3 of schema).",
          "Canonicalize JSON payloads (RFC 8785 / JCS) before hashing/signing when applicable."
        ]
      }
    },
    "verification_suite": {
      "goal": "Orchestrators must have a mechanical proof surface: determinism, idempotency, crash recovery, boundedness.",
      "required": [
        "Replay equivalence: fold(genesis..N) == fold(checkpoint)+fold(delta).",
        "Duplicate input idempotence: folding duplicated events does not change final semantics.",
        "Crash-point recovery: model crashes between (intent, operational effect, receipt) and assert replay-safe behavior.",
        "Fault injection: simulate I/O errors, partial writes, delayed receipts, and ensure safe convergence."
      ],
      "bft_ready_tests": [
        "Reordering/delay of tentative inputs does not cause conflicting irreversible effects.",
        "At-most-once external authority writes under duplicated/replayed intents."
      ],
      "cas_tests": [
        "Hash mismatch fails closed.",
        "Reads are bounded before allocation.",
        "Digest references in events/state are validated."
      ]
    },
    "refactor_moves_for_existing_orchestrators": {
      "top_priority": "Collapse divergent persistence systems into the substrate: ledger for events, CAS for blobs. Eliminate bespoke state files and unstructured telemetry as canonical truth.",
      "moves": [
        "FAC queue: treat on-disk directories as a projection cache; move canonical job lifecycle (claim/lease/receipt/terminal) into ledger events; keep filesystem as an accelerator during migration.",
        "FAC lane leases: bind ownership to durable lease identity and evidence (receipt/unit identity), not PID existence; PID checks must be identity-verified if used.",
        "FAC review: replace review_state.json + pulse files + NDJSON as canonical state with a ledger event vocabulary + reducer projection; store diffs/logs/findings in CAS and reference digests.",
        "Holon orchestration: avoid creating another ledger; reuse apm2-core ledger + CAS abstractions, and project holon state via reducers.",
        "Any cache (gate_cache, projection_store): enforce witnessed-cache rules (versioned, bounded, rebuildable)."
      ],
      "migration_rule": "During migration, you may keep legacy files as derived views for operator UX, but the canonical source must become ledger+CAS. Derived views must be deletable without losing truth."
    },
    "review_lenses": {
      "what_to_praise": [
        "A clear event vocabulary with stable discriminants and bounded payloads.",
        "CAS-first artifact handling (digest references everywhere).",
        "Intent->execute->receipt patterns for all irreversible operations.",
        "Incremental cursor-based loops with bounded work per tick.",
        "Deterministic step() with explicit Inputs and injected time."
      ],
      "red_flags": [
        "New canonical JSON files under ~/.apm2 not backed by ledger events.",
        "Unbounded scans of directories or ledgers inside the hot path.",
        "PID existence used as ownership without identity binding.",
        "External authority calls without a prior intent event and idempotency key.",
        "Mixing multiple sources of truth (e.g., review_state.json says Done but ledger says Pending)."
      ],
      "fac_review_specific": [
        "Pulse files should not be the canonical liveness mechanism; they may be a derived operator convenience only.",
        "Finding stores should be CAS-backed with digest references in events; do not treat local directories as truth.",
        "GitHub projection cache must be witnessed-cache compliant and rebuildable."
      ]
    }
  }
}