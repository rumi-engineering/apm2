{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-29",
    "template_version": "2026-01-29",
    "ticket": {
      "id": "TCK-00489",
      "title": "Priority-aware quarantine lifecycle with saturation-safe insertion",
      "status": "CLOSED"
    },
    "binds": {
      "prd_id": "PRD-0010",
      "rfc_id": "RFC-0028",
      "requirements": [
        {
          "requirement_id": "REQ-0004",
          "requirement_ref": "documents/rfcs/RFC-0028/requirements/REQ-0004.yaml#requirement"
        }
      ],
      "evidence_artifacts": [
        {
          "evidence_id": "EVID-0005",
          "artifact_ref": "documents/rfcs/RFC-0028/evidence_artifacts/EVID-0005.yaml#evidence_artifact"
        }
      ]
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER",
        "AGENT_REVIEWER"
      ],
      "responsibility_domains": [
        "DOMAIN_SECURITY",
        "DOMAIN_RUNTIME"
      ]
    },
    "dependencies": {
      "tickets": [
        {
          "ticket_id": "TCK-00488",
          "reason": "Authoritative witnesses provide the evidence that triggers quarantine; quarantine lifecycle must handle the resulting containment actions correctly."
        }
      ]
    },
    "scope": {
      "in_scope": [
        "Problem 1: quarantine capped at 512 entries with unconditional oldest-first eviction. Adversary can flood quarantines to evict a specific channel before TTL expires.",
        "Problem 2: when quarantine table is saturated, insertion returns false and caller logs warning but proceeds. Mandatory quarantine actions are dropped silently.",
        "Fix 1: priority-aware eviction. Active quarantines (unexpired, triggered by MAJOR+ violations) are never evicted by lower-priority entries. Only expired or lower-severity quarantines can be evicted.",
        "Fix 2: when quarantine insertion fails due to saturation AND no evictable entries exist, the request MUST be denied (fail-closed). Proceeding without quarantine when quarantine is mandatory violates containment semantics.",
        "Fix 3: per-session/per-tenant quarantine quota isolation. A single adversarial session's quarantine entries should not consume the global budget and starve other sessions."
      ],
      "out_of_scope": [
        "Boundary-flow evidence infrastructure (TCK-00488).",
        "Persistent quarantine state across daemon restarts (future)."
      ]
    },
    "plan": {
      "steps": [
        "Add severity/priority field to quarantine entries (derived from violation type: BLOCKER > MAJOR > MINOR).",
        "Implement priority-aware eviction: on overflow, evict only expired entries first, then lowest-priority entries. Never evict unexpired entries with severity >= incoming entry.",
        "Implement saturation-safe insertion: when capacity is full and no evictable entries exist, return error. Caller must deny the request.",
        "Modify boundary-flow admission caller: on quarantine insertion failure, deny request with structured defect (not warning + proceed).",
        "Add per-session quota: each session gets a bounded slice of quarantine capacity. Session-level overflow cannot impact other sessions.",
        "Add tests: (a) adversarial flood cannot evict unexpired high-severity quarantine, (b) saturation causes request denial not warning, (c) per-session quota limits isolation, (d) expired entries evicted before active entries, (e) normal-path quarantine lifecycle works with TTL expiry and clearance.",
        "Run mandatory pre-commit checks."
      ]
    },
    "definition_of_done": {
      "evidence_ids": [
        "EVID-0005"
      ],
      "criteria": [
        "Active unexpired quarantines are never evicted by lower-priority entries.",
        "Quarantine saturation causes request denial (fail-closed), not silent proceed.",
        "Per-session quota isolation prevents cross-session quarantine exhaustion.",
        "Adversarial flood test demonstrates containment preservation."
      ]
    },
    "notes": {
      "security": "This is a containment lifecycle ticket, orthogonal to PCAC. PCAC gates authority\nadmission; quarantine handles post-violation containment. Both must be correct for\nthe boundary-flow integrity contract to hold.\n\nThe key invariant: if a leakage/timing violation is detected and quarantine is the\nmandated containment action, that quarantine MUST actually happen. \"Log and proceed\"\nviolates fail-closed semantics.\n",
      "verification": "Adversarial flood test: fill quarantine to capacity with low-severity entries from\nsession A, then trigger a high-severity quarantine on session B's channel. Verify\nthat session B's quarantine succeeds (evicting a session A entry) and is not dropped.\n"
    }
  }
}
