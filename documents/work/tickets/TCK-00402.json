{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-29",
    "template_version": "2026-01-29",
    "ticket": {
      "id": "TCK-00402",
      "title": "Implement CodexCliAdapter with TI1 tool bridge protocol for blanket-preserving Codex integration",
      "status": "CLOSED"
    },
    "binds": {
      "prd_id": "PRD-0009",
      "rfc_id": "RFC-0018",
      "requirements": [
        {
          "requirement_id": "REQ-HEF-0010",
          "requirement_ref": "documents/rfcs/RFC-0018/requirements/REQ-HEF-0010.yaml#rfc_requirement"
        }
      ],
      "evidence_artifacts": [
        {
          "evidence_id": "EVID-HEF-0011",
          "artifact_ref": "documents/rfcs/RFC-0018/evidence_artifacts/EVID-HEF-0011.yaml#rfc_evidence_artifact"
        },
        {
          "evidence_id": "EVID-HEF-0012",
          "artifact_ref": "documents/rfcs/RFC-0018/evidence_artifacts/EVID-HEF-0012.yaml#rfc_evidence_artifact"
        }
      ]
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_RUNTIME",
        "DOMAIN_SECURITY"
      ]
    },
    "dependencies": {
      "tickets": [
        {
          "ticket_id": "TCK-00396",
          "reason": "HarnessHandle must have real PTY storage for send_input and terminate to work."
        },
        {
          "ticket_id": "TCK-00399",
          "reason": "AdapterRegistry must be wired into SpawnEpisode before any adapter can be used."
        },
        {
          "ticket_id": "TCK-00401",
          "reason": "ToolBroker must be initialized in production for TI1 tool requests to execute instead of failing with NotInitialized."
        }
      ]
    },
    "scope": {
      "in_scope": [
        "Add AdapterType::Codex variant to the adapter type enum.",
        "Implement CodexCliAdapter struct implementing HarnessAdapter trait.",
        "Implement TI1 ToolIntent protocol detection in the adapter's output scanner — scan for ⟦TI1 <nonce>⟧ delimiter-framed tool requests, NOT vendor-specific JSONL parsing.",
        "Inject TI1 grammar instructions into the Codex agent's system prompt at spawn time so the agent emits ⟦TI1⟧ requests instead of using native tool calls.",
        "Inject tool results back to the agent via stdin using ⟦TR1 <nonce>⟧ framing.",
        "Codex exec invocation with model parameter injection (-m gpt-5.3-codex or configurable).",
        "Map TI1 tool intent names to kernel ToolClass values using the codex-cli-v1 profile's capability_map.",
        "Register CodexCliAdapter in AdapterRegistry when codex-cli-v1 profile is selected.",
        "Handle Codex-specific environment (CODEX_HEADLESS=1, NO_COLOR=1) and permission flags."
      ],
      "out_of_scope": [
        "Parsing Codex's raw JSONL event stream — this would violate the Markov blanket by treating agent internal state as authoritative.",
        "Codex sandbox integration — tool mediation is kernel-side via TI1.",
        "Multi-turn Codex conversations — each episode is a single codex exec invocation.",
        "Refactoring ClaudeCodeAdapter to TI1 (separate ticket — the same blanket violation exists there)."
      ]
    },
    "plan": {
      "steps": [
        "Read documents/rfcs/RFC-0019/11_agent_adapter_profiles.md section 3 ('Tool bridging options') to understand the TI1 protocol wire format: ⟦TI1 <nonce>⟧ <request_id> <tool_name> <args_b64url> for requests, ⟦TR1 <nonce>⟧ <request_id> ok <cas_result_hash> for responses.",
        "Read crates/apm2-core/src/fac/agent_adapter_profile.rs ToolBridgeConfig (line ~364) — understand nonce_prefix, protocol_version, max_args_size, tool_timeout_ms.",
        "Add AdapterType::Codex to the enum in crates/apm2-daemon/src/episode/adapter.rs.",
        "Create crates/apm2-daemon/src/episode/codex_cli.rs (new file). Define CodexCliAdapter struct with fields: semaphore, tool_bridge_config, nonce (per-episode, derived from ToolBridgeConfig.nonce_prefix + episode_id).",
        "Implement a TI1 scanner module (crates/apm2-daemon/src/episode/ti1_scanner.rs or within codex_cli.rs): scan each line of PTY output for the ⟦TI1 <nonce>⟧ delimiter. Lines NOT matching the delimiter are treated as opaque agent output (logged for evidence but not interpreted). Lines matching are parsed as TI1 frames and emitted as HarnessEvent::ToolRequest.",
        "Implement TI1 response injection: when the kernel completes a tool request, format the result as ⟦TR1 <nonce>⟧ <request_id> ok <cas_hash> and write it to the agent's stdin via HarnessHandle::send_input().",
        "Generate the TI1 system prompt preamble: at spawn time, prepend instructions to the agent's prompt that explain the ⟦TI1⟧ grammar, available tool names (from capability_map), and the nonce to use. This teaches the agent to emit TI1 frames instead of native tool calls.",
        "Implement HarnessAdapter::spawn(): build the codex exec command (command='codex', args=['exec', '-m', model, prompt_with_ti1_preamble]). Enable '--dangerously-bypass-approvals-and-sandbox' only behind explicit rollout config/waiver guard (WVR-0002). Spawn via PtyRunner::spawn(). Start background TI1 scanner task.",
        "Implement send_input(): write TR1-framed tool results to stdin.",
        "Implement terminate(): send SIGTERM, wait for codex cleanup, fallback to SIGKILL.",
        "Register CodexCliAdapter in AdapterRegistry when profile matches codex-cli-v1.",
        "Add unit tests: test TI1 scanner with sample output containing both opaque agent text and ⟦TI1⟧ frames. Verify only TI1 frames are emitted as ToolRequest events. Verify opaque text is preserved for evidence.",
        "Run cargo fmt --all && cargo clippy --workspace --all-targets --all-features -- -D warnings && cargo doc --workspace --no-deps && cargo test -p apm2-daemon."
      ]
    },
    "definition_of_done": {
      "evidence_ids": [
        "EVID-HEF-0011",
        "EVID-HEF-0012"
      ],
      "criteria": [
        "AdapterType::Codex variant exists.",
        "CodexCliAdapter implements all HarnessAdapter methods (spawn, send_input, terminate).",
        "TI1 scanner detects ⟦TI1 <nonce>⟧ delimiter-framed tool requests in agent output without parsing vendor-specific JSONL.",
        "Agent output lines NOT matching TI1 delimiter are treated as opaque internal state — logged for evidence but never interpreted as tool requests (Markov blanket preserved).",
        "TR1 response framing injects tool results back via stdin.",
        "TI1 preamble is injected into agent's system prompt at spawn time.",
        "Tool intent names are mapped to kernel ToolClass via the profile's capability_map.",
        "Codex process is spawned with correct flags: -m <model>, CODEX_HEADLESS=1; bypass flag is disabled by default and enabled only when rollout waiver guard (WVR-0002) is active.",
        "Nonce is per-episode (nonce_prefix + episode_id hash) to prevent cross-episode replay.",
        "AdapterRegistry registers CodexCliAdapter when codex-cli-v1 profile is selected.",
        "terminate() guarantees process cleanup (no zombie codex processes).",
        "Unit tests cover TI1 scanning, delimiter detection, opaque line handling, and nonce validation.",
        "All CI checks pass: cargo fmt, clippy (zero warnings), doc, tests."
      ]
    },
    "notes": {
      "context": "IMPORTANT ARCHITECTURAL DECISION: This ticket uses the TI1 ToolIntent protocol (RFC-0019\nsection 11, Option C) instead of parsing Codex's raw JSONL event stream. Parsing vendor-specific\nJSONL would violate the Markov blanket by treating agent internal state as authoritative tool\nrequest signals.\n\nPer RFC-0020 section 2.2.1: \"Internal states (model reasoning, planning traces) are explicitly\nnon-authoritative unless committed into CAS and bound by receipts.\" The agent's raw JSONL output\nis internal state. Tool requests must cross the boundary through the kernel-defined TI1 grammar.\n\nThe TI1 protocol is already specified in the codebase:\n  - Wire format: ⟦TI1 <nonce>⟧ <request_id> <tool_name> <args_b64url>\n  - Response: ⟦TR1 <nonce>⟧ <request_id> ok <cas_result_hash>\n  - ToolBridgeConfig in every builtin profile (protocol_version=\"TI1\", nonce_prefix=\"codex\")\n\nThe codex-cli-v1 adapter profile (builtin_profiles.rs:315) already defines:\n  - command: codex, args: [\"exec\", \"{prompt}\"]\n  - env: CODEX_HEADLESS=1, NO_COLOR=1\n  - tool_bridge: enabled=true, protocol_version=\"TI1\", nonce_prefix=\"codex\"\n  - capability_map: read_file -> kernel.fs.read, write_file -> kernel.fs.write,\n    shell -> kernel.shell.exec, browse_web -> kernel.net.browse\n\nNOTE: The existing ClaudeCodeAdapter (claude_code.rs) also violates the blanket by parsing\nJSON/XML from Claude's raw output via ClaudeCodeParser. A separate ticket should refactor\nClaudeCodeAdapter to use TI1 as well. This ticket establishes the TI1 pattern for Codex first.\n",
      "files": "- documents/rfcs/RFC-0019/11_agent_adapter_profiles.md (TI1 protocol spec, section 3)\n- documents/rfcs/RFC-0020/HOLONIC_SUBSTRATE_INTERFACE.md (Markov blanket definition at ~line 750)\n- crates/apm2-core/src/fac/agent_adapter_profile.rs (ToolBridgeConfig at line ~364)\n- crates/apm2-core/src/fac/builtin_profiles.rs (codex_cli_profile at line 315, tool_bridge config)\n- crates/apm2-daemon/src/episode/adapter.rs (AdapterType enum at ~278, HarnessAdapter trait at ~900)\n- crates/apm2-daemon/src/episode/claude_code.rs (ClaudeCodeAdapter — reference, but uses Option B not Option C)\n- crates/apm2-daemon/src/episode/claude_parser.rs (ClaudeCodeParser — blanket-violating vendor JSON/XML parsing)\n- crates/apm2-daemon/src/episode/raw_adapter.rs (RawAdapter — generic adapter baseline)\n- crates/apm2-daemon/src/episode/registry.rs (AdapterRegistry, adapter selection by type)\n",
      "security": "- MARKOV BLANKET: The adapter MUST NOT interpret agent output as tool requests unless it matches\n  the ⟦TI1 <nonce>⟧ delimiter. All other output is opaque internal state.\n- Nonce MUST be per-episode and unpredictable (BLAKE3(nonce_prefix || episode_id || spawn_time_ns))\n  to prevent cross-episode replay or injection attacks.\n- TI1 args_b64url MUST be bounded by max_args_size from ToolBridgeConfig (default 1MB).\n  Reject frames exceeding this limit.\n- Tool results injected via TR1 MUST reference CAS hashes, not raw data, to prevent the agent\n  from receiving unbounded data via stdin.\n- ROLLOUT WAIVER WVR-0002: Codex bypass flag MAY be enabled only in daemon-mediated rollout paths\n  with TI1 + policy checks, default OFF in config, and forbidden outside waiver scope.\n- CODEX_HEADLESS=1 prevents interactive prompts that would hang the daemon.\n- Model parameter string MUST be validated against a known-good pattern (alphanumeric + dots + hyphens)\n  to prevent command injection.\n"
    }
  }
}
