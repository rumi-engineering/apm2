ticket_meta:
  schema_version: "2026-01-29"
  template_version: "2026-01-29"
  ticket:
    id: "TCK-00624"
    title: "Implement bounded failure taxonomy with machine-readable remediation for apm2 fac gates"
    status: "OPEN"
  binds:
    prd_id: "PRD-PLACEHOLDER"
    rfc_id: "RFC-0019"
    requirements: ["REQ-0035"]
    evidence_artifacts: []
  custody:
    agent_roles: ["AGENT_IMPLEMENTER"]
    responsibility_domains: ["DOMAIN_RUNTIME", "DOMAIN_CI"]
  dependencies:
    tickets:
      - ticket_id: "TCK-00621"
        reason: "Two-phase structure provides the stage field required by the failure taxonomy."

root_cause_analysis:
  summary: |
    Gates failures currently surface as heterogeneous error messages drawn from
    raw system errors, cargo output, git errors, and internal panics. No stable
    taxonomy exists, so orchestrators and agents cannot make deterministic
    branching decisions on failure type. Remediation is either absent or buried
    in log files that agents are not expected to read. The closed failure
    taxonomy and machine-readable remediation contract fix both problems.

scope:
  in_scope:
    - id: "S1_FAILURE_TYPES"
      title: "Define StructuredFailure type and the four failure codes"
      detail: |
        Define in a shared module:
          struct StructuredFailure {
            failure_code: FailureCode,   // enum
            failure_class: FailureClass, // enum: prep | authority | execution
            stage: GatesRunPhase,        // prep | execute
            root_cause: String,          // human-readable one-liner
            remediation: String,         // actionable instruction
            diagnostics: Vec<String>,    // raw internal errors (never top-level)
          }
          enum FailureCode {
            PrepNotReady,
            PrepSupplyUnavailable,
            AuthorityDenied,
            GateExecutionFailed,
          }
    - id: "S2_EMIT_ON_STDOUT"
      title: "Emit StructuredFailure as JSON on stdout for all failure paths"
      detail: |
        All four failure codes must be reachable from existing code paths.
        Wire StructuredFailure emission at:
          - ReadinessController failure → PrepNotReady
          - Closure hydration failure with no network → PrepSupplyUnavailable
          - Policy/token/admission rejection → AuthorityDenied
          - Gate process exit != 0 → GateExecutionFailed
        Emit as a JSON line on stdout (not stderr) with --json flag.
        Without --json, emit a human-friendly formatted version of the
        same structured data.
    - id: "S3_SUPPRESS_RAW_ERRORS"
      title: "Demote all raw internal errors to diagnostics[]"
      detail: |
        Audit all existing error propagation paths in fac gates. Any raw
        system error, cargo output line, or internal string error that
        currently reaches top-level stdout must be moved into diagnostics[]
        within the enclosing StructuredFailure.
    - id: "S4_REGRESSION_TESTS"
      title: "Regression tests enumerating all four failure codes"
      detail: |
        - Test: each of the four FailureCode variants is reachable and produces
          correct failure_code, failure_class, stage, root_cause, remediation.
        - Test: diagnostics[] is populated with raw errors; top-level output
          contains only structured fields.
        - Test: remediation field alone is sufficient for recovery without logs
          (assert non-empty and action-oriented for PREP_NOT_READY and
          PREP_SUPPLY_UNAVAILABLE).
    - id: "S5_SHARED_DST_MODULE_POST_PUSH_CLOSURE"
      title: "Create shared DST test module after fac push closure-complete"
      detail: |
        Shared deterministic simulated testing helpers (env mutation
        serialization + panic-safe restoration) are in-scope for this ticket
        only after closure-complete validation of `apm2 fac push` is done:
          - bounded completion (no stuck caller path),
          - local CLI dogfood pass,
          - edge-case regressions green.
        This sequencing is mandatory to avoid mixing stabilization and test
        harness refactors in one unresolved change window.
    - id: "S7_MERGE_FLOW_FANOUT_FIRST_THEN_LOCAL_RESET"
      title: "Redesign merge sequencing: fanout-first, then stash+fetch+reset-hard on local main"
      detail: |
        Current flow (incorrect):
          sync_local_main_with_origin → try_fast_forward_main (local ref update)
          → persist_signed_merge_receipt → push_local_main_to_origin
          → project_merge_to_all_sinks (GitHub API merge, idempotent at this point)

        Required flow:
          1. project_merge_to_all_sinks — call GitHub API (fanout) to merge the PR first.
          2. On first successful projection result:
             a. git stash --include-untracked on ~/Projects/apm2 (main worktree),
                covering ALL local state (tracked, untracked, staged).
             b. git fetch origin refs/heads/main.
             c. git reset --hard to the merged SHA returned by the successful
                projection (GitHub for now).
             d. Assert the working tree is completely clean (no tracked changes,
                no untracked files, no ignored artifacts that belong to the build).
          3. Persist the signed merge receipt only after the local main is confirmed
             clean and consistent with the projection result.

        The key invariant: local main must never be fast-forwarded locally before
        the projection succeeds. If the projection (GitHub API merge) fails, local
        main stays on its pre-merge state. The stash-before-reset ensures no local
        work is silently discarded without a recovery path.
    - id: "S8_MERGE_CONFLICT_TOCTOU_GUARD"
      title: "Bugfix: re-check merge conflicts after evidence gates pass to close TOCTOU window"
      detail: |
        The merge_conflict_main gate currently runs once at the start of the execute
        phase (step 3 in run_execute_phase). Evidence gates take 2-3 minutes.
        During that window, a concurrent push to main can introduce a new conflict
        on the branch under review, leaving gates recorded as PASS even though the
        branch now has a merge conflict.

        Fix: run a second merge_conflict_main check immediately after all evidence
        gates pass and before recording the overall GatesSummary as passed. If the
        second check finds a conflict, override the result to FAIL with
        failure_code = GateExecutionFailed and remediation = "dispatch implementor".
        The first check (fast-fail early) is kept for speed; the second check
        (bookend guard) closes the race window.
    - id: "S9_GATE_ORDERING_FASTEST_FIRST"
      title: "Re-order evidence gates fastest-first to minimize wasted compute on failure"
      detail: |
        Within the evidence gate pipeline, gates should be ordered by expected
        duration ascending so that the cheapest checks eliminate failing branches
        before expensive checks run. Current known ordering issue: rustfmt, clippy,
        and cargo test may not be sequenced by duration.

        Required ordering principle: a gate that is expected to complete in T seconds
        should not be scheduled after a gate expected to take 10T seconds. Apply this
        principle to the evidence gate list produced by run_evidence_gates_with_lane_context.
        Document the rationale for the chosen order in a code comment so future gate
        additions can be slotted correctly.
    - id: "S6_DISPATCH_IMPLEMENTOR_ON_GATE_FAILURE"
      title: "Bugfix: recommended action on evidence gate failure must be dispatch-implementor"
      detail: |
        When an evidence gate fails (e.g. rustfmt check, clippy, cargo test),
        the remediation field emitted by StructuredFailure — and any
        human-readable output — must recommend "dispatch implementor" as the
        next action. Recommending "request-reviews" on a gate failure is
        incorrect: review cannot proceed until the gate passes, so dispatching
        the implementor to fix the underlying issue is the only valid path.
        Apply consistently across all GateExecutionFailed remediation strings.
  out_of_scope:
    - "Adding new top-level failure codes beyond the four defined."
    - "JSONL full event schema (TCK-00625 owns the broader stdout contract)."
    - "Failure taxonomy for commands other than the gates phase of apm2 fac push."

plan:
  steps:
    - id: "STEP_01"
      title: "Define StructuredFailure, FailureCode, FailureClass types"
      detail: |
        In fac_review/ or a shared fac_error module. Derive Serialize for
        JSON emission. Implement Display for human-friendly format.
    - id: "STEP_02"
      title: "Wire StructuredFailure into all failure paths"
      detail: |
        Replace ad-hoc error strings in gates entry point with StructuredFailure
        construction. Capture raw errors in diagnostics[]. Emit on stdout.
    - id: "STEP_03"
      title: "Audit and demote raw error propagation"
      detail: |
        Search all error! / eprintln! / return Err(...) paths in the gates
        pipeline. Move raw content into diagnostics[]. Verify no raw errors
        reach top-level stdout.
    - id: "STEP_04"
      title: "Add regression tests and workspace validation"
      detail: |
        cargo fmt --all && cargo clippy --workspace --all-targets --all-features -- -D warnings
        cargo doc --workspace --no-deps && cargo test --workspace

definition_of_done:
  evidence_ids:
    - "EXEC-TCK00624-FAILURE-TAXONOMY"
    - "EXEC-TCK00624-ALL-FOUR-CODES"
    - "EXEC-TCK00624-WORKSPACE-VALIDATION"
  criteria:
    - "StructuredFailure type is defined with all required fields."
    - "All four FailureCode values are reachable from gates execution paths."
    - "Every failure emits failure_code, failure_class, stage, root_cause, and remediation."
    - "No raw system errors appear at the top level of stdout output."
    - "remediation field for PREP_NOT_READY and PREP_SUPPLY_UNAVAILABLE is actionable without log access."
    - "Regression tests enumerate all four codes and verify output shape."
    - "Workspace validation completes successfully."

notes:
  context: |
    This ticket defines the shared StructuredFailure type that all other
    gates tickets reference. TCK-00622 uses PREP_SUPPLY_UNAVAILABLE;
    TCK-00620 uses PREP_NOT_READY; TCK-00623 uses AUTHORITY_DENIED for
    closure signature rejection. The taxonomy is explicitly closed: no
    new top-level codes may be added without a new requirement.
  security: "fail-closed; raw errors are demoted to diagnostics, never top-level"
