{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-29",
    "template_version": "2026-01-29",
    "ticket": {
      "id": "TCK-00661",
      "title": "FAC worker: Progress-aware systemd watchdog (restart on deadlock/hang without breaking long jobs)",
      "status": "OPEN"
    },
    "binds": {
      "prd_id": "PRD-0001",
      "rfc_id": "RFC-0019",
      "requirements": [
        "REQ-0020"
      ],
      "evidence_artifacts": []
    },
    "custody": {
      "agent_roles": [
        "Implementer",
        "Reviewer"
      ],
      "responsibility_domains": [
        "fac/worker",
        "fac/services"
      ]
    },
    "dependencies": {
      "tickets": [
        "TCK-00600",
        "TCK-00660"
      ]
    }
  },
  "context": {
    "observed_symptoms": [
      "Worker queue activation is now event-driven, but watchdog liveness remains decoupled from execution progress.",
      "Workers can remain \"alive\" under systemd while making no queue/repair progress (deadlock/hang).",
      "Queue stalls can persist because watchdog pings continue even when the main loop is wedged."
    ],
    "code_evidence": [
      "Worker spawns a dedicated watchdog thread that pings independently of main loop progress:\n  crates/apm2-cli/src/commands/fac_worker.rs:1385-1422\n",
      "WatchdogTicker itself only enforces periodicity; it has no notion of work progress:\n  crates/apm2-core/src/fac/sd_notify.rs:309-377\n"
    ]
  },
  "problem_statement": "The current watchdog design can mask deadlocks and indefinite hangs: the background thread will\ncontinue pinging as long as the process is alive, even if the main loop cannot wake/process queue\nwork or runtime repair signals. This is a liveness failure. Watchdog pings must be contingent on\nforward progress from the main execution path.\n",
  "root_cause_analysis": {
    "primary_cause": "Watchdog pinging is decoupled from the worker's \"progress\". There is no shared progress signal\nbetween the main loop and the watchdog thread.\n"
  },
  "proposed_change": {
    "intent": "Make the watchdog \"progress-aware\":\n  - Main loop updates a shared progress timestamp/counter on every meaningful forward step.\n  - Watchdog thread pings only if progress is recent enough.\n  - Long-running operations must periodically bump progress (without requiring completion).\n"
  },
  "invariants": [
    {
      "id": "INV-WD-001",
      "statement": "If the worker main loop makes no progress for > watchdog_staleness_threshold, the watchdog thread MUST stop pinging and systemd MUST restart the worker."
    },
    {
      "id": "INV-WD-002",
      "statement": "Legitimate long jobs MUST be able to keep the watchdog alive via periodic progress bumps (without requiring job completion)."
    }
  ],
  "scope": {
    "in_scope": [
      {
        "id": "S1",
        "description": "Introduce a progress signal shared between threads:\n  - AtomicU64 last_progress_epoch_ms (or monotonic Instant encoded as ms since start)\n  - touch_progress(reason) helper updates the atomic and (optionally) a lightweight counter\n"
      },
      {
        "id": "S2",
        "description": "Change watchdog thread behavior:\n  - Before ping_if_due(), check whether (now - last_progress) <= threshold\n  - Threshold should be derived from WATCHDOG_USEC (e.g., 0.75 * WatchdogSec) with a hard\n    minimum/maximum clamp.\n  - If progress is stale, log once and stop pinging (allow systemd to restart).\n"
      },
      {
        "id": "S3",
        "description": "Ensure progress bumps occur during long-running operations:\n  - Warm phases already accept a heartbeat_fn; extend to call touch_progress inside that fn.\n  - For blocking waits (e.g., waiting on systemd-run --wait), replace single blocking wait\n    with a poll loop (try_wait + sleep) that bumps progress periodically.\n  - For gate execution steps that can block, add periodic bumps (where feasible) or wrap in\n    a thread that signals progress.\n"
      },
      {
        "id": "S4",
        "description": "Add tests:\n  - Unit: watchdog thread suppresses ping when progress stale (inject a fake clock/atomic).\n  - Regression: simulate a stuck main thread by not updating progress; verify watchdog loop would stop pinging.\n  - Integration (best-effort): ensure progress is bumped during warm execution loop (via injected hook).\n"
      }
    ],
    "out_of_scope": [
      "Implementing a full watchdog that also checks external resource health (disk, network, etc.)."
    ]
  },
  "plan": {
    "steps": [
      {
        "id": "P1",
        "description": "Add progress atomic + touch_progress helper; wire into main loop at scan/claim/commit boundaries."
      },
      {
        "id": "P2",
        "description": "Update watchdog thread to gate pings on progress freshness."
      },
      {
        "id": "P3",
        "description": "Replace blocking waits with progress-bumping loops where needed."
      },
      {
        "id": "P4",
        "description": "Add tests (dependency injection for time/progress) and verify no regressions."
      }
    ]
  },
  "definition_of_done": {
    "criteria": [
      "A wedged worker (no progress updates) will stop pinging watchdog and be restarted by systemd.",
      "Legitimate long-running operations continue to bump progress and do not cause spurious restarts.",
      "Progress bumps are visible in worker heartbeat (optional counter increment) to aid diagnosis."
    ],
    "evidence_ids": [
      "EVID-TCK-00661-01 (unit): watchdog gating on progress freshness",
      "EVID-TCK-00661-02 (integration): long operation bumps progress periodically"
    ]
  },
  "notes": {
    "risk": [
      "If progress bumps are missed in a legit long path, systemd may restart mid-job. Mitigate by ensuring all long waits are wrapped."
    ],
    "compatibility": "In non-systemd environments, watchdog ticker is disabled; this change should be a no-op.\n"
  },
  "fac_security_contract": {
    "source": "documents/work/tickets/FAC_SECURITY_MODEL_INVARIANTS_V1.yaml",
    "profile": "FAC-RFC0032-BASELINE",
    "required_invariants": [
      "INV-FAC-TRUTH-001",
      "INV-FAC-WORK-BIND-001",
      "INV-FAC-CLAIM-BIND-001",
      "INV-FAC-ACTOR-BIND-001",
      "INV-FAC-IDEMP-001",
      "INV-FAC-EVID-001"
    ],
    "enforcement_requirements": [
      "Any new requirement, code path, or test added under this ticket must map to one or more required_invariants.",
      "Any invariant relaxation requires explicit amendment in this ticket and the shared security model document.",
      "Reviewer denial is expected for invariant-unmapped behavior changes."
    ]
  }
}
