{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-29",
    "template_version": "2026-01-29",
    "ticket": {
      "id": "TCK-00609",
      "title": "Close the doctor command gap: every recommended action must carry an executable command",
      "status": "MERGED"
    },
    "binds": {
      "prd_id": "PRD-PLACEHOLDER",
      "rfc_id": "RFC-0019",
      "requirements": [],
      "evidence_artifacts": []
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_RUNTIME"
      ]
    },
    "dependencies": {
      "tickets": [
        {
          "ticket_id": "TCK-00605",
          "reason": "TCK-00605 introduced build_recommended_action, the doctor --wait-for-recommended-action poll loop, and auto-merge via maybe_auto_merge_if_ready()."
        },
        {
          "ticket_id": "TCK-00607",
          "reason": "TCK-00607 S4 auto-nudge changes the review completion flow that feeds into doctor verdicts."
        }
      ]
    },
    "root_cause_analysis": {
      "summary": "`build_recommended_action()` in\n`crates/apm2-cli/src/commands/fac_review/mod.rs:2334-2442` is the\nbrain of the orchestrator control loop. The orchestrator-monitor\nagent polls doctor, reads `recommended_action`, and reacts. Every\norchestrator decision routes through this single function.\n\nThe function emits 6 actions. Two have executable commands; four do\nnot. The two WITH commands (`fix`, `restart_reviews`) work flawlessly\nin the field — the orchestrator runs the command and polls again. The\nfour WITHOUT commands (`dispatch_implementor`, `merge`, `escalate`,\n`wait`) are exactly where every field failure occurred, because the\norchestrator LLM must improvise what to do next.\n\nCurrent action cascade:\n\n    1. integrity/corruption  → \"fix\"                 command: ✓\n    2. merge_ready           → \"merge\"               command: ✗\n    3. merge conflicts       → \"escalate\"            command: ✗\n    4. deny/blocker/major    → \"dispatch_implementor\" command: ✗\n    5. no agents + pending   → \"restart_reviews\"     command: ✓\n    6. budget exhausted      → \"escalate\"            command: ✗\n    7. default               → \"wait\"                command: ✗\n\nFive defects compound this structural gap:\n\nDEFECT 1: dispatch_implementor fires before all verdicts are in\n\nThe check at lines 2379-2393 fires when ANY dimension has\ndeny/blocker/major, without verifying that ALL dimensions have\nnon-pending formal_verdicts:\n\n    let requires_implementor_remediation = input.findings_summary.iter().any(|entry| {\n        entry.formal_verdict.eq_ignore_ascii_case(\"deny\")\n            || entry.counts.blocker > 0\n            || entry.counts.major > 0\n    });\n    if requires_implementor_remediation { ... }\n\nThe has_pending_verdict check exists at line 2396-2399 but is only\nused in the restart_reviews branch. The dispatch_implementor branch\nnever consults it. Impact: orchestrator dispatches implementors with\npartial findings, then dispatches again when the second dimension\ncompletes. Double dispatch, wasted resources, possible conflicts.\n\nDEFECT 2: dispatch_implementor has command: None\n\nThe orchestrator-monitor skill devotes an entire 8-step node\n(FIX_AGENT_PROMPT_CONTRACT) to constructing the implementor\ndispatch. It must assemble: ticket ID, PR number, branch, HEAD SHA,\nworktree path, findings list, and the implementor skill reference.\nAll of this information is already available inside\nbuild_recommended_action() (via DoctorActionInputs and the\nDoctorPrSummary being constructed). But command is None, so the\nLLM must re-derive it from raw JSON fields.\n\nCompare with restart_reviews (lines 2405-2421) which constructs a\ncomplete command including --force and --refresh-identity flags\nbased on terminal_reason analysis. The dispatch_implementor branch\nshould follow the same pattern.\n\nDEFECT 3: merge action is unreachable in practice\n\nAuto-merge fires synchronously inside `finalize_projected_verdict()`\nat lifecycle.rs:2128 via `maybe_auto_merge_if_ready()`. This runs\nin the reviewer agent's process during `verdict set`. By the time\nthe orchestrator polls doctor:\n\n  - If auto-merge succeeded: lifecycle_state=merged. But\n    build_recommended_action() never checks lifecycle state for\n    merged — it has no branch for \"this PR is already done.\" The\n    function either returns \"merge\" (if merge_ready is still true\n    from stale verdict/gate data) or falls through to \"wait.\"\n    Neither is correct. The orchestrator needs \"done.\"\n\n  - If auto-merge failed: lifecycle has a MergeFailed event.\n    merge_ready may still be true (verdicts approve, gates pass,\n    sha fresh) because merge_ready doesn't check for MergeFailed\n    events. Doctor would emit \"merge\" — but the merge already\n    failed. The orchestrator can't do anything with this.\n\nThe field report confirms: \"the merge action never fired because\nthe PR isn't merged by the CLI.\" The orchestrator used\n--exit-on dispatch_implementor,merge but the happy path (all\napprove → auto-merge → done) never produced an exit signal.\n\nDEFECT 4: wait action has no command\n\nThe terminal fallback (line 2436-2441) returns command: None. The\norchestrator receives \"wait\" with no actionable next step. It must\nindependently decide to poll again, construct the poll command\nwith the right flags, and manage timing — all LLM reasoning that\nshould be deterministic.\n\nDEFECT 5: escalate action has no command\n\nBoth escalate paths (merge conflicts at line 2370, budget exhaustion\nat line 2427) return command: None. The orchestrator receives\n\"escalate\" but has no guidance on what escalation looks like.\n\nROOT CAUSE PATTERN\n\nDoctor was built as a diagnostic tool for humans. Its action\nvocabulary and command surface were designed for a human to read\n\"dispatch_implementor\" and know what to do. But the primary\nconsumer is now the orchestrator-monitor agent — an LLM in a\ntight poll loop making programmatic decisions. Every action\nwithout a command is a gap where the LLM must improvise, which\nis expensive, slow, and error-prone.\n\nThe two actions WITH commands (fix, restart_reviews) never appear\nin bug reports. The four WITHOUT commands are the source of every\nfield failure. The fix is to close the command gap: every action\nmust carry an executable command or sufficient structured context\nfor the orchestrator to act without re-deriving state.\n"
    }
  },
  "scope": {
    "in_scope": [
      {
        "id": "S1_GATE_DISPATCH_ON_ALL_VERDICTS",
        "title": "Gate dispatch_implementor on all expected verdicts being non-pending",
        "detail": "In `build_recommended_action()` at\n`crates/apm2-cli/src/commands/fac_review/mod.rs:2379-2393`:\n\nAdd a check that ALL expected dimensions have a non-pending\nformal_verdict before emitting dispatch_implementor. If any\ndimension is still pending, fall through to wait.\n\nCurrent logic (lines 2379-2393):\n    let requires_implementor_remediation = input.findings_summary.iter().any(|entry| {\n        entry.formal_verdict.eq_ignore_ascii_case(\"deny\")\n            || entry.counts.blocker > 0\n            || entry.counts.major > 0\n    });\n    if requires_implementor_remediation {\n        return DoctorRecommendedAction {\n            action: \"dispatch_implementor\".to_string(), ...\n        };\n    }\n\nFixed logic:\n    let all_verdicts_resolved = !input.findings_summary.iter().any(|entry| {\n        entry.formal_verdict.eq_ignore_ascii_case(\"pending\")\n    });\n    let requires_implementor_remediation = input.findings_summary.iter().any(|entry| {\n        entry.formal_verdict.eq_ignore_ascii_case(\"deny\")\n            || entry.counts.blocker > 0\n            || entry.counts.major > 0\n    });\n    if requires_implementor_remediation && all_verdicts_resolved {\n        return DoctorRecommendedAction {\n            action: \"dispatch_implementor\".to_string(), ...\n        };\n    }\n\nThe existing has_pending_verdict variable at line 2399 is scoped\ninside a later block. Either hoist it above the dispatch check or\ncompute all_verdicts_resolved independently.\n\nAcceptance:\n  - Security finishes with \"deny\", code-quality still \"pending\" →\n    doctor recommends \"wait\", NOT \"dispatch_implementor\".\n  - Both dimensions finish (security=deny, code-quality=approve) →\n    doctor recommends \"dispatch_implementor\".\n  - Both dimensions finish with deny → doctor recommends\n    \"dispatch_implementor\" with the complete findings set.\n"
      },
      {
        "id": "S2_DISPATCH_IMPLEMENTOR_COMMAND",
        "title": "Populate command and context on dispatch_implementor action",
        "detail": "In `build_recommended_action()`, the dispatch_implementor return\nat lines 2387-2392 has `command: None`.\n\nDoctor already has all the information the orchestrator needs to\nconstruct the implementor dispatch — it is available either in\nDoctorActionInputs or in the DoctorPrSummary being built by the\ncaller (run_doctor_inner). The minimal viable command is:\n\n    command: Some(format!(\n        \"apm2 fac doctor --pr {} --json\",\n        input.pr_number\n    ))\n\nThis tells the orchestrator: \"run this command to get the full\ncontext you need for the implementor handoff.\" But this is already\nwhat the orchestrator does, so it adds minimal value.\n\nThe higher-value approach: add a structured `context` field to\nDoctorRecommendedAction that carries the implementor-relevant\ndata inline. But DoctorRecommendedAction is a serialized public\nstruct — adding a field is a schema change.\n\nThe pragmatic middle ground: populate `command` with an\n`apm2 fac review findings --pr <N> --json` command (gives the\norchestrator the exact findings to include in the handoff), and\ninclude the reason field with enough structured detail for the\norchestrator to act:\n\n    command: Some(format!(\n        \"apm2 fac review findings --pr {}\",\n        input.pr_number\n    ))\n\nAdditionally, enrich the `reason` field to include the dimension\nverdicts and finding counts inline, so the orchestrator does not\nneed to cross-reference findings_summary separately. Example:\n\n    reason: \"security=deny(2B/1M) code-quality=approve(0B/0M/1m/3N); review findings require implementor remediation\"\n\nThis mirrors the field report request for \"a merged view showing\nsecurity: APPROVE (0B/0M/0m/2N) in one field.\"\n\nAcceptance:\n  - dispatch_implementor action has command != None.\n  - reason includes per-dimension verdict and finding counts.\n  - Orchestrator can construct implementor handoff from\n    recommended_action alone without parsing findings_summary.\n"
      },
      {
        "id": "S3_MERGED_AND_APPROVE_ACTIONS",
        "title": "Add 'done' action for merged PRs and 'approve' for all-verdicts-approve",
        "detail": "build_recommended_action() currently has no branch for two states\nthe orchestrator needs:\n\n(a) PR is already merged (lifecycle.state == \"merged\"):\n\n    The function never checks lifecycle state for the merged\n    terminal. When auto-merge succeeds via\n    maybe_auto_merge_if_ready() (lifecycle.rs:2006-2097), the\n    lifecycle transitions to \"merged\" — but build_recommended_action\n    falls through to \"merge\" (if merge_ready is still true) or\n    \"wait\". Neither is correct.\n\n    Add a check early in the cascade (after the integrity check,\n    before merge_ready):\n\n        if let Some(lifecycle) = input.lifecycle {\n            if lifecycle.state.eq_ignore_ascii_case(\"merged\") {\n                return DoctorRecommendedAction {\n                    action: \"done\".to_string(),\n                    reason: \"PR has been merged to main\".to_string(),\n                    priority: \"low\".to_string(),\n                    command: None,\n                };\n            }\n        }\n\n(b) All verdicts approve but merge_ready is false\n    (e.g., gates not yet cached, sha_freshness unknown):\n\n    The orchestrator's happy-path classification is READY_TO_MERGE,\n    which requires only all_verdicts_approve — NOT the full\n    merge_ready conjunction (gates_pass + sha_fresh +\n    no_merge_conflicts). When all verdicts approve, auto-merge\n    will fire (or already fired). The orchestrator just needs to\n    know \"all reviews are done and they all approve\" so it can\n    stop dispatching implementors and wait for auto-merge.\n\n    Add a check after the merge_ready check:\n\n        if input.merge_readiness.all_verdicts_approve {\n            return DoctorRecommendedAction {\n                action: \"approve\".to_string(),\n                reason: \"all review dimensions approve; awaiting auto-merge\".to_string(),\n                priority: \"low\".to_string(),\n                command: Some(format!(\n                    \"apm2 fac doctor --pr {} --json --wait-for-recommended-action\",\n                    input.pr_number\n                )),\n            };\n        }\n\nUpdate DOCTOR_WAIT_EXIT_ACTIONS to include \"done\" and \"approve\":\n\n    const DOCTOR_WAIT_EXIT_ACTIONS: [&str; 7] = [\n        \"fix\", \"escalate\", \"merge\", \"dispatch_implementor\",\n        \"restart_reviews\", \"done\", \"approve\",\n    ];\n\nUpdate DoctorExitActionArg enum to include Done and Approve\nvariants with corresponding as_str() mappings.\n\nThe action cascade becomes:\n\n    1. integrity/corruption    → \"fix\"                  command: ✓\n    2. lifecycle=merged        → \"done\"                 command: ✓ (None — terminal)\n    3. merge_ready             → \"merge\"                command: ✓ (None — terminal)\n    4. all_verdicts_approve    → \"approve\"              command: ✓\n    5. merge conflicts         → \"escalate\"             command: ✓\n    6. deny/blocker/major      → \"dispatch_implementor\" command: ✓\n       (gated on all_verdicts_resolved)\n    7. no agents + pending     → \"restart_reviews\"      command: ✓\n    8. budget exhausted        → \"escalate\"             command: ✓\n    9. default                 → \"wait\"                 command: ✓\n\nAcceptance:\n  - Merged PR returns action=\"done\".\n  - All verdicts approve (but merge_ready=false) returns\n    action=\"approve\".\n  - Orchestrator using --exit-on approve exits on happy path\n    without needing to parse merge_readiness fields.\n  - Orchestrator using --exit-on done can detect post-merge\n    state without parsing lifecycle.state.\n"
      },
      {
        "id": "S4_WAIT_AND_ESCALATE_COMMANDS",
        "title": "Populate command on wait and escalate actions",
        "detail": "Two remaining actions with command: None.\n\nWAIT (lines 2436-2441):\nChange to:\n    command: Some(format!(\n        \"apm2 fac doctor --pr {} --json --wait-for-recommended-action\",\n        input.pr_number\n    ))\n\nESCALATE — merge conflicts (lines 2370-2377):\nChange to:\n    command: Some(format!(\n        \"apm2 fac doctor --pr {} --json\",\n        input.pr_number\n    ))\n\nThe escalate command points back to doctor because escalation\nrequires human review of the full doctor output. The command\ngives the orchestrator something to report when it escalates.\n\nESCALATE — budget exhausted (lines 2427-2433):\nSame pattern:\n    command: Some(format!(\n        \"apm2 fac doctor --pr {} --json\",\n        input.pr_number\n    ))\n\nAcceptance:\n  - Every action in the cascade has command != None (or command\n    is intentionally None only for terminal actions like \"done\"\n    and \"merge\" where no further CLI action is needed).\n  - Orchestrator never receives a non-terminal action with no\n    guidance on what to do next.\n"
      },
      {
        "id": "S5_UPDATE_EXISTING_TESTS",
        "title": "Update existing tests for new action semantics",
        "detail": "1. Update dispatch_implementor tests to include both dimensions\n   with non-pending verdicts:\n   - test_build_recommended_action_dispatches_on_formal_deny_without_findings\n     (line 5803): Add code-quality with formal_verdict=\"approve\".\n   - test_build_recommended_action_dispatches_on_major_findings_without_formal_deny\n     (line 5828): Add security with formal_verdict=\"approve\".\n\n2. Update any test asserting command: None for actions that now\n   have commands (wait, escalate, dispatch_implementor).\n\n3. Update test_normalize_doctor_exit_actions_defaults_include_escalate\n   to also check for \"done\" and \"approve\" in defaults.\n\nAcceptance:\n  - All existing tests updated and passing.\n  - No test asserts command: None for actions that now have commands.\n"
      },
      {
        "id": "S6_ADD_NEW_TESTS",
        "title": "Add tests for new action behaviors",
        "detail": "New tests for verdict gating:\n1. test_build_recommended_action_waits_when_one_dimension_pending_despite_deny:\n   Security=deny+blocker, code-quality=pending → action=\"wait\"\n2. test_build_recommended_action_dispatches_when_all_dimensions_resolved:\n   Security=deny, code-quality=approve → action=\"dispatch_implementor\"\n3. test_build_recommended_action_dispatches_when_both_deny:\n   Security=deny, code-quality=deny → action=\"dispatch_implementor\"\n\nNew tests for done action:\n4. test_build_recommended_action_returns_done_for_merged_lifecycle:\n   lifecycle.state=\"merged\" → action=\"done\"\n5. test_build_recommended_action_done_takes_priority_over_merge_ready:\n   lifecycle.state=\"merged\" AND merge_ready=true → action=\"done\"\n\nNew tests for approve action:\n6. test_build_recommended_action_returns_approve_when_all_verdicts_approve_but_not_merge_ready:\n   all_verdicts_approve=true, gates_pass=false → action=\"approve\"\n7. test_build_recommended_action_merge_takes_priority_over_approve:\n   merge_ready=true → action=\"merge\" (not \"approve\")\n\nNew tests for commands:\n8. test_build_recommended_action_wait_has_command:\n   Default fallback → command contains \"--wait-for-recommended-action\"\n9. test_build_recommended_action_dispatch_implementor_has_command:\n   dispatch_implementor → command is Some\n10. test_build_recommended_action_dispatch_implementor_reason_includes_dimension_summary:\n    dispatch_implementor → reason contains per-dimension counts\n\nNew tests for exit-on:\n11. test_doctor_exit_on_accepts_done_action:\n    --exit-on done parses successfully\n12. test_doctor_exit_on_accepts_approve_action:\n    --exit-on approve parses successfully\n\nAcceptance:\n  - All 12 new tests pass.\n  - Full coverage of the new action cascade branches.\n"
      },
      {
        "id": "S7_REMOVE_DUPLICATE_TICKET_YAMLS_FROM_RFC_AMENDMENT",
        "title": "Remove duplicate ticket YAMLs from RFC-0019 amendment A1",
        "detail": "`documents/rfcs/RFC-0019/20_fac_execution_substrate_build_farm_revision.md`\ncontained a \"17. Ticket YAMLs (drop-in proposals)\" section starting at\nline 1876 with ~4135 lines of inline ticket YAML proposals (TCK-00510,\nTCK-00511, and others). These are duplicates of tickets that have since\nbeen properly created in `documents/work/tickets/`.\n\nThe section has been removed. The canonical ticket location is\n`documents/work/tickets/TCK-NNNNN.yaml` — RFC amendment files should\nreference tickets by ID, not embed full YAML copies.\n\nThis change is already applied (4135 lines deleted, 1 trailing\nnewline inserted).\n\nAcceptance:\n  - No `ticket_meta:` blocks remain in the RFC amendment file.\n  - The file ends cleanly after the \"warm and GC interfaces /\n    compute lease concept / Nix reproduction\" outline.\n"
      },
      {
        "id": "S8_HARDEN_STUCK_STALE_AGENT_DETECTION",
        "title": "Harden detection of stuck/stale agents so orchestrators don't have to",
        "detail": "The agent registry (lifecycle.rs) tracks `TrackedAgent` entries with\nstate transitions: Dispatched → Running → Completed/Crashed/Reaped.\nThe reaper (`reap_registry_stale_entries()` at lifecycle.rs:1680-1762)\nauto-reaps agents with dead PIDs or no PID after 240s. But\n`build_recommended_action()` has no awareness of agent staleness —\nit only checks `active_agents == 0` for the restart_reviews branch.\n\nThree gaps force orchestrators to manually detect and recover stuck\nagents:\n\nGAP 1: IDLE RUNNING AGENTS NOT DETECTED\n\nDoctor already collects `last_activity_seconds_ago` (age of most\nrecent event from review events log) and `elapsed_seconds` (time\nsince agent started) in DoctorAgentSnapshot, but\nbuild_recommended_action() never consults these. An agent in Running\nstate with a live PID but zero activity for 30+ minutes will produce\naction=\"wait\" indefinitely.\n\nFix: Before the terminal \"wait\" fallback, check active agents for\nstaleness. If ALL active agents have `last_activity_seconds_ago >\nAGENT_IDLE_TIMEOUT` (e.g., 300 seconds), emit action=\"restart_reviews\"\nwith reason \"all active reviewer agents are idle (no activity for\n{N}s); recommend restart\" and command pointing to\n`apm2 fac restart --pr <N> --force --refresh-identity`.\n\nThis requires adding agent snapshot data to DoctorActionInputs.\nCurrently DoctorActionInputs carries `active_agents: usize` (a\ncount). Extend it to carry a lightweight activity summary:\n\n    pub struct DoctorAgentActivitySummary {\n        pub active_agents: usize,\n        pub all_active_idle: bool,       // all active agents idle > threshold\n        pub max_idle_seconds: Option<u64>, // worst-case idle time\n    }\n\nGAP 2: DISPATCHED-NEVER-RUNNING NOT SURFACED\n\nThe reaper handles Dispatched-without-PID after 240s TTL, but doctor\nrecommends \"wait\" during that entire window. The orchestrator sees\n\"wait\" and has no way to know a dispatch may have failed.\n\nFix: If any agent is in Dispatched state with elapsed > 120s (the\nbase DISPATCH_PENDING_TTL), include a warning in the recommended\naction reason: \"reviewer dispatch pending for {N}s (may be stuck)\".\nThis doesn't change the action — the reaper will handle cleanup —\nbut gives the orchestrator visibility.\n\nGAP 3: DOCTOR --FIX SHOULD AUTO-REAP AND RESTART\n\nCurrently `derive_doctor_repair_plan()` (mod.rs:1365-1404) sets\n`reap_stale_agents = true` when it detects dead-PID agents or\ncapacity overflow. But it does NOT trigger a restart after reaping.\nThe orchestrator must poll again, see restart_reviews, and execute\nit — an extra round-trip.\n\nFix: In `run_repair_plan()`, after reaping stale agents, if verdicts\nare still pending and active_agents drops to zero, also execute a\nrestart (equivalent to `apm2 fac restart --pr <N>`). Log the\ncompound repair: \"reaped stale agents and restarted reviews.\"\n\nAcceptance:\n  - Running agent with no activity for >300s triggers\n    action=\"restart_reviews\" (not \"wait\").\n  - Dispatched agent pending for >120s includes warning text in\n    recommended_action.reason.\n  - `apm2 fac doctor --pr <N> --fix` reaps stale agents AND\n    restarts reviews in a single invocation when applicable.\n  - Orchestrator control loop no longer needs IDLE_AGENT_RECOVERY\n    step (180s timeout) — doctor handles it.\n"
      },
      {
        "id": "S9_UPDATE_ORCHESTRATOR_MONITOR_SKILL",
        "title": "Update orchestrator-monitor SKILL.md for new action vocabulary",
        "detail": "`documents/skills/orchestrator-monitor/SKILL.md` must be updated to\nreflect the changes in S1-S8. The orchestrator's control loop\nsimplifies dramatically when every action has a command.\n\nCHANGES REQUIRED:\n\n1. SIMPLIFY HEARTBEAT_LOOP CLASSIFY step (line 88-91):\n\n   The 8-state classification (MERGED, READY_TO_MERGE, PR_CONFLICTING,\n   CI_FAILED, REVIEW_FAILED, REVIEW_MISSING, WAITING_CI,\n   BLOCKED_UNKNOWN) is now largely redundant — doctor's action\n   vocabulary covers these states directly:\n     - MERGED            → doctor action \"done\"\n     - READY_TO_MERGE    → doctor action \"approve\" or \"merge\"\n     - PR_CONFLICTING    → doctor action \"escalate\" (conflicts)\n     - REVIEW_FAILED     → doctor action \"dispatch_implementor\"\n     - REVIEW_MISSING    → doctor action \"restart_reviews\"\n     - WAITING_CI        → doctor action \"wait\"\n     - BLOCKED_UNKNOWN   → doctor action \"escalate\" (budget)\n     - CI_FAILED         → doctor action \"fix\"\n\n   Update CLASSIFY to: \"Read recommended_action from doctor output.\n   The action field is the authoritative classification.\" Keep the\n   state names as documentation labels but stop requiring the\n   orchestrator to derive them from raw JSON fields.\n\n2. SIMPLIFY EXECUTE_ACTIONS node (lines 102-121):\n\n   Currently 5 sub-steps with manual logic per state. Replace with\n   a command-driven dispatch pattern:\n\n     - If action has command: execute the command.\n     - If action is terminal (done, merge): record completion, move on.\n     - If action is \"dispatch_implementor\": execute command to get\n       findings, then dispatch implementor with handoff payload.\n\n   The READY_TO_MERGE_ACTION (\"check main branch... check again\n   shortly until merged\") is replaced by polling with\n   `--exit-on done` — auto-merge handles the actual merge.\n\n3. SIMPLIFY FIX_AGENT_PROMPT_CONTRACT node (lines 165-195):\n\n   The 8-step prompt construction is now partially addressed by\n   dispatch_implementor having a command and enriched reason with\n   per-dimension verdicts. The node should focus on what the\n   orchestrator ADDS beyond what doctor provides:\n     - Ticket ID (from orchestrator context, not doctor)\n     - Worktree path (from orchestrator state)\n     - implementor skill invocation syntax\n\n   The node no longer needs to: derive findings from raw\n   findings_summary JSON, compute HEAD SHA, or determine which\n   dimensions failed — this is all in the enriched reason.\n\n4. UPDATE operational_playbook scenarios (lines 214-263):\n\n   Add new scenarios:\n     - trigger: \"Doctor reports action=done\"\n       action: \"PR is complete. Remove from active monitoring set.\"\n     - trigger: \"Doctor reports action=approve\"\n       action: \"All reviews approve. Poll with --exit-on done to\n       await auto-merge completion.\"\n     - trigger: \"Doctor reports stuck/idle agents\"\n       action: \"Follow recommended_action.command (restart with\n       --force). Do not manually inspect agent logs.\"\n\n   Update existing scenarios to reference command field:\n     - \"dispatch_implementor\" scenario: \"Execute\n       recommended_action.command to retrieve findings, then\n       construct implementor handoff.\"\n     - \"wait\" scenario: \"Execute recommended_action.command (polls\n       with --wait-for-recommended-action).\"\n\n5. REMOVE IDLE_AGENT_RECOVERY from STALL_AND_BACKPRESSURE (line 133):\n\n   The 180s idle agent timeout is now handled by doctor (S8). Remove\n   the orchestrator-side idle detection. Keep ENFORCE_BACKPRESSURE\n   but simplify: doctor's action already accounts for capacity.\n\n6. UPDATE invariants (lines 265-275):\n\n   Add: \"When doctor provides recommended_action.command, execute it\n   verbatim. Do not re-derive commands from raw JSON fields.\"\n   Add: \"Use --exit-on done to detect PR completion instead of\n   parsing lifecycle.state from doctor JSON.\"\n\n7. ADD simplified control loop pattern to notes (lines 24-29):\n\n   The ideal orchestrator loop is now:\n       for pr in scope:\n         loop:\n           result = apm2 fac doctor --pr {pr} --json \\\n               --wait-for-recommended-action \\\n               --exit-on done\n           match result.action:\n             \"done\" → break\n             \"dispatch_implementor\" → dispatch_with_handoff(result)\n             _ → execute(result.command)\n\n   Document this pattern in notes as the canonical control loop.\n\nAcceptance:\n  - SKILL.md references \"done\" and \"approve\" as valid doctor actions.\n  - FIX_AGENT_PROMPT_CONTRACT simplified to focus on orchestrator-\n    added context (ticket ID, worktree, skill invocation), not\n    re-deriving findings from raw JSON.\n  - IDLE_AGENT_RECOVERY removed or replaced with \"doctor handles\n    stuck agent detection.\"\n  - Operational playbook has scenarios for done, approve, and\n    stuck-agent recovery.\n  - The simplified control loop pattern is documented.\n"
      },
      {
        "id": "S10_UPDATE_IMPLEMENTOR_DEFAULT_SKILL",
        "title": "Update implementor-default SKILL.md for doctor integration awareness",
        "detail": "`documents/skills/implementor-default/SKILL.md` needs targeted\nupdates to align with the new doctor action vocabulary. The\nimplementor workflow itself doesn't change — implementors still\nwrite code, run gates, and push. But the context they receive from\norchestrator handoffs changes because the orchestrator now gets\nricher information from doctor.\n\nCHANGES REQUIRED:\n\n1. UPDATE FETCH_REVIEW_FINDINGS step (START node, line 82-88):\n\n   Currently says:\n       `apm2 fac review findings --pr <PR_NUMBER> --json`\n\n   This is correct and unchanged. But add a note that orchestrator\n   handoffs now include per-dimension verdict summaries from\n   doctor's enriched dispatch_implementor reason (e.g.,\n   \"security=deny(2B/1M) code-quality=approve\"). The implementor\n   should still fetch full findings via the command, but can use\n   the summary for triage priority.\n\n2. ADD awareness of doctor action gating in orientation/notes:\n\n   The implementor should know that it is only dispatched AFTER all\n   review dimensions have completed (S1 gating). This means:\n     - The findings set is COMPLETE — no more reviews are pending.\n     - The implementor should address ALL findings across ALL\n       dimensions in a single pass, not just the dimension that\n       triggered dispatch.\n     - There will be no surprise \"second dispatch\" for a later\n       dimension completing.\n\n3. UPDATE references section (lines 20-57):\n\n   Verify the RFC-0019 amendment reference at line 26 still points\n   to a valid file (it does — we cleaned up the amendment in S7\n   but didn't remove valid content). No change needed unless the\n   file path changed.\n\nAcceptance:\n  - SKILL.md notes that dispatch occurs only after all verdicts\n    are resolved.\n  - FETCH_REVIEW_FINDINGS step mentions orchestrator handoff\n    includes per-dimension summary.\n  - No broken references after S7 amendment cleanup.\n"
      }
    ],
    "out_of_scope": [
      "Adding a full `apm2 fac dispatch-implementor --pr <N>` CLI verb that autonomously launches an implementor agent. This would be the ideal long-term fix for S2, but is a large change requiring agent lifecycle management in the CLI. The pragmatic S2 fix (command + enriched reason) is sufficient to close the orchestrator improvisation gap.",
      "Adding `apm2 fac merge --pr <N>` CLI verb. Auto-merge via maybe_auto_merge_if_ready() handles the merge path; the new 'done' and 'approve' actions make the merged/approved state observable to orchestrators.",
      "Changing the --wait-for-recommended-action poll loop mechanics (the loop correctly polls until action matches exit_on; this ticket changes what actions are emitted, not how the loop works).",
      "Adding --repo filter or --exclude-examples to global doctor mode (useful but separate concern from the action cascade).",
      "Adding --active-only or --current-sha-only agent filtering (useful but orthogonal to the action command gap).",
      "Adding worktree_status.behind_main_by field (useful but orthogonal)."
    ]
  },
  "plan": {
    "steps": [
      {
        "id": "STEP_01",
        "title": "Add 'done' action for merged lifecycle state",
        "detail": "In build_recommended_action(), after the integrity check (line\n2358) and before the merge_ready check (line 2360), add:\n\n    if let Some(lifecycle) = input.lifecycle {\n        if lifecycle.state.eq_ignore_ascii_case(\"merged\") {\n            return DoctorRecommendedAction {\n                action: \"done\".to_string(),\n                reason: \"PR has been merged to main\".to_string(),\n                priority: \"low\".to_string(),\n                command: None,\n            };\n        }\n    }\n"
      },
      {
        "id": "STEP_02",
        "title": "Add 'approve' action for all-verdicts-approve",
        "detail": "After the merge_ready check (line 2368) and before the merge\nconflict check (line 2370), add:\n\n    if input.merge_readiness.all_verdicts_approve {\n        return DoctorRecommendedAction {\n            action: \"approve\".to_string(),\n            reason: \"all review dimensions approve; awaiting auto-merge\".to_string(),\n            priority: \"low\".to_string(),\n            command: Some(format!(\n                \"apm2 fac doctor --pr {} --json --wait-for-recommended-action\",\n                input.pr_number\n            )),\n        };\n    }\n"
      },
      {
        "id": "STEP_03",
        "title": "Gate dispatch_implementor on all_verdicts_resolved",
        "detail": "Before the requires_implementor_remediation check (line 2379),\ncompute:\n    let all_verdicts_resolved = !input.findings_summary.iter().any(|entry| {\n        entry.formal_verdict.eq_ignore_ascii_case(\"pending\")\n    });\n\nChange the guard from:\n    if requires_implementor_remediation {\nTo:\n    if requires_implementor_remediation && all_verdicts_resolved {\n"
      },
      {
        "id": "STEP_04",
        "title": "Populate command on dispatch_implementor",
        "detail": "Change the dispatch_implementor return to include a command:\n    command: Some(format!(\n        \"apm2 fac review findings --pr {}\",\n        input.pr_number\n    ))\n\nEnrich the reason to include per-dimension summary:\n    Build a compact summary string from input.findings_summary,\n    e.g. \"security=deny(2B/1M) code-quality=approve(0B/0M/1m/3N)\"\n    and prepend it to the existing reason/push_hint.\n"
      },
      {
        "id": "STEP_05",
        "title": "Populate command on wait and escalate actions",
        "detail": "1. Wait (line 2436): set command to\n   \"apm2 fac doctor --pr {pr} --json --wait-for-recommended-action\"\n2. Escalate — merge conflicts (line 2370): set command to\n   \"apm2 fac doctor --pr {pr} --json\"\n3. Escalate — budget exhausted (line 2427): set command to\n   \"apm2 fac doctor --pr {pr} --json\"\n"
      },
      {
        "id": "STEP_06",
        "title": "Update DOCTOR_WAIT_EXIT_ACTIONS and DoctorExitActionArg",
        "detail": "1. Add \"done\" and \"approve\" to DOCTOR_WAIT_EXIT_ACTIONS array.\n2. Add Done and Approve variants to DoctorExitActionArg enum.\n3. Add corresponding as_str() mappings.\n4. Update normalize_doctor_exit_actions if needed.\n"
      },
      {
        "id": "STEP_07",
        "title": "Update existing tests",
        "detail": "Update all tests that assert on action values or command: None\nfor actions that now have commands. Update dispatch_implementor\ntests to include both dimensions with non-pending verdicts.\n"
      },
      {
        "id": "STEP_08",
        "title": "Add new tests",
        "detail": "Add the 12 tests described in S6. Cover: verdict gating (3),\ndone action (2), approve action (2), command fields (3),\nexit-on variants (2).\n"
      },
      {
        "id": "STEP_09",
        "title": "Add agent activity summary to DoctorActionInputs",
        "detail": "1. Define DoctorAgentActivitySummary struct with:\n   active_agents, all_active_idle, max_idle_seconds.\n2. Populate from DoctorAgentSnapshot data already collected in\n   run_doctor_inner().\n3. Replace active_agents: usize in DoctorActionInputs with the\n   new summary struct.\n4. Update build_recommended_action() to use summary fields.\n"
      },
      {
        "id": "STEP_10",
        "title": "Add stuck/idle agent detection to build_recommended_action()",
        "detail": "Before the terminal \"wait\" fallback:\n1. If all_active_idle (all active agents idle > threshold),\n   return restart_reviews with --force --refresh-identity command.\n2. If any Dispatched agent > 120s, append warning to wait reason.\n\nIn run_repair_plan():\n3. After reaping stale agents, if active_agents drops to zero and\n   verdicts pending, auto-restart reviews.\n"
      },
      {
        "id": "STEP_11",
        "title": "Update orchestrator-monitor SKILL.md",
        "detail": "Apply all changes described in S9:\n1. Simplify CLASSIFY to reference doctor action vocabulary.\n2. Simplify EXECUTE_ACTIONS to command-driven dispatch.\n3. Simplify FIX_AGENT_PROMPT_CONTRACT.\n4. Update operational_playbook with done/approve/stuck scenarios.\n5. Remove IDLE_AGENT_RECOVERY.\n6. Update invariants.\n7. Add simplified control loop pattern to notes.\n"
      },
      {
        "id": "STEP_12",
        "title": "Update implementor-default SKILL.md",
        "detail": "Apply changes described in S10:\n1. Add note about per-dimension summary in orchestrator handoffs.\n2. Add awareness that dispatch is gated on all verdicts resolved.\n3. Verify references still valid after S7 amendment cleanup.\n"
      },
      {
        "id": "STEP_13",
        "title": "Verify full cascade and all changes",
        "detail": "1. cargo test -p apm2-cli — all tests pass.\n2. Verify every action in build_recommended_action() has either\n   command: Some(...) or is a terminal action (done, merge).\n3. Verify the action cascade order is:\n   fix → done → merge → approve → escalate(conflicts) →\n   dispatch_implementor → restart_reviews(idle) →\n   restart_reviews(no agents) → escalate(budget) → wait\n4. Grep-verify no remaining command: None for non-terminal actions.\n5. Verify SKILL.md files are consistent with new action vocabulary.\n6. Verify no broken references in implementor-default SKILL.md.\n"
      }
    ]
  },
  "definition_of_done": {
    "evidence_ids": [],
    "criteria": [
      "Every non-terminal recommended action has `command: Some(...)` — orchestrators never receive an actionable recommendation with no executable next step.",
      "`build_recommended_action()` returns `done` when lifecycle.state is `merged`.",
      "`build_recommended_action()` returns `approve` when all_verdicts_approve=true but merge_ready=false.",
      "`build_recommended_action()` returns `dispatch_implementor` only when ALL expected dimensions have non-pending formal_verdicts AND at least one has deny/blocker/major.",
      "dispatch_implementor reason includes per-dimension verdict and finding counts inline (e.g., 'security=deny(2B/1M) code-quality=approve').",
      "dispatch_implementor command points to `apm2 fac review findings --pr <N>` for structured findings retrieval.",
      "`--exit-on done` and `--exit-on approve` are valid DoctorExitActionArg variants.",
      "`--wait-for-recommended-action --exit-on approve` exits on the happy path (all verdicts approve) without the orchestrator needing to parse merge_readiness.",
      "`--wait-for-recommended-action --exit-on done` exits when auto-merge has completed.",
      "wait action command contains `--wait-for-recommended-action` so orchestrators have an actionable polling next step.",
      "Existing dispatch_implementor tests updated to include both dimensions and continue to pass.",
      "12 new tests cover verdict gating, done/approve actions, command fields, and exit-on parsing.",
      "Running agent idle >300s with live PID triggers action=restart_reviews (not wait).",
      "`apm2 fac doctor --pr <N> --fix` reaps stale agents AND restarts reviews in one invocation when verdicts are pending.",
      "orchestrator-monitor SKILL.md references done, approve, and stuck-agent actions; FIX_AGENT_PROMPT_CONTRACT simplified; IDLE_AGENT_RECOVERY removed.",
      "orchestrator-monitor SKILL.md documents the simplified control loop pattern (poll → match action → execute command).",
      "implementor-default SKILL.md notes dispatch is gated on all verdicts resolved and handoffs include per-dimension summaries.",
      "`cargo test -p apm2-cli` passes."
    ]
  },
  "notes": {
    "context": "ARCHITECTURAL CONTEXT\n\nThe orchestrator-monitor agent (documents/skills/orchestrator-monitor/\nSKILL.md) is a reactive controller. It polls doctor, reads\nrecommended_action, and acts. Every orchestrator decision routes\nthrough build_recommended_action() — that function IS the control\nplane.\n\nThe orchestrator classifies each PR into one of 8 states (MERGED,\nREADY_TO_MERGE, PR_CONFLICTING, CI_FAILED, REVIEW_FAILED,\nREVIEW_MISSING, WAITING_CI, BLOCKED_UNKNOWN). But doctor only emits\n6 actions. The mapping is lossy — the orchestrator LLM must\nre-derive state from raw JSON fields to fill the gap.\n\nFIELD EVIDENCE\n\nFrom multi-PR orchestration runs:\n\n1. dispatch_implementor fires when security denies but code-quality\n   is still pending. Orchestrator dispatches with partial findings.\n   Code-quality finishes → second dispatch_implementor → double\n   dispatch.\n\n2. \"merge action never fired because the PR isn't merged by the CLI.\"\n   Orchestrator used --exit-on dispatch_implementor,merge for happy\n   path detection. But auto-merge fires in the reviewer's verdict-set\n   codepath (lifecycle.rs:2128 → maybe_auto_merge_if_ready), not via\n   doctor. By the time doctor polls, either the PR is merged (but\n   doctor has no \"done\" action) or auto-merge hasn't fired yet (but\n   doctor has no \"approve\" action distinct from \"merge\"). The\n   orchestrator's happy path has no exit signal.\n\n3. All command:None actions required LLM improvisation. The\n   orchestrator-monitor skill devotes an 8-step\n   FIX_AGENT_PROMPT_CONTRACT to constructing the implementor dispatch\n   — work that exists solely because dispatch_implementor has no\n   command.\n\nTHE FIX PATTERN\n\nTwo actions WITH commands (fix, restart_reviews) never appear in bug\nreports. Four WITHOUT commands are the source of every field failure.\nClose the command gap and the orchestrator reduces to:\n\n    loop:\n      result = apm2 fac doctor --pr N --json \\\n          --wait-for-recommended-action \\\n          --exit-on done\n      if result.action == \"done\": break\n      execute(result.command)\n\nEvery action becomes either:\n- Terminal (done, merge): orchestrator observes and moves on\n- Actionable (fix, restart_reviews, dispatch_implementor, wait,\n  approve, escalate): orchestrator executes the command\n\nThe LLM reasoning is reserved for the implementor (actual code\nchanges) and the reviewer (actual code review). The orchestrator\ncontrol loop becomes deterministic.\n",
    "security": "default-deny, least privilege, fail-closed"
  }
}
