{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-27",
    "template_version": "2026-01-27",
    "ticket": {
      "id": "TCK-00146",
      "title": "Implement capability gating",
      "status": "CLOSED"
    },
    "binds": {
      "prd_id": "PRD-0007",
      "rfc_id": "RFC-0011",
      "requirements": [
        {
          "requirement_id": "CAC-REQ-0014",
          "requirement_ref": "documents/prds/PRD-0007/requirements/REQ-0014.yaml#prd_requirement"
        },
        {
          "requirement_id": "CAC-REQ-0006",
          "requirement_ref": "documents/prds/PRD-0007/requirements/REQ-0006.yaml#prd_requirement"
        }
      ],
      "evidence_artifacts": [
        "EVID-0007"
      ]
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_KERNEL",
        "DOMAIN_AGENT_RUNTIME"
      ]
    },
    "dependencies": {
      "tickets": [
        "TCK-00145"
      ]
    },
    "scope": {
      "in_scope": [
        "Implement CapabilityGate struct for receipt verification",
        "Add capability_ids allowlist to planning context",
        "Implement capability negotiation via stable IDs",
        "Enforce cutover gating based on AATReceipt",
        "Add CapabilityRequired event for planning phase",
        "Emit DefectRecord when capability unavailable",
        "Support graceful degradation for optional capabilities"
      ],
      "out_of_scope": [
        "CapabilityManifest generation (TCK-00144)",
        "Selftest execution (TCK-00145)",
        "CLI commands (TCK-00147)",
        "Dynamic capability discovery at runtime"
      ]
    },
    "plan": {
      "steps": [
        "Create crates/apm2-core/src/cac/capability_gate.rs",
        "Define CapabilityGate struct with verify_receipt() method",
        "Implement binary_hash validation against current binary",
        "Add CapabilityRequirement struct: capability_id, required (bool)",
        "Add check_capabilities(requirements, receipt) -> Result<Vec<CapabilityStatus>>",
        "Define CapabilityStatus enum: Available, Unavailable, Degraded",
        "Add CapabilityRequired event to kernel events (proto/kernel_events.proto)",
        "Implement emit_defect_record() for missing capabilities",
        "Integrate with planning phase: filter plan steps by available capabilities",
        "Add capability_ids field to EpisodeConfig for negotiation",
        "Write tests for gating enforcement scenarios"
      ]
    },
    "definition_of_done": {
      "evidence_ids": [
        "EVID-0007"
      ],
      "criteria": [
        "CapabilityGate::verify_receipt() validates AATReceipt signature",
        "Binary hash mismatch rejects stale receipts",
        "check_capabilities() returns correct status for each capability",
        "CapabilityRequired event emitted during planning phase",
        "DefectRecord emitted when required capability unavailable",
        "Planning filters steps by available capabilities",
        "All tests pass: cargo test capability_gate"
      ]
    },
    "notes": {
      "rust_textbook_refs": [
        {
          "file": ".claude/skills/rust-textbook/12_api_design_stdlib_quality.md",
          "contracts": [
            "CTR-1201: Public API Contract Explicit - gating API documents enforcement behavior",
            "CTR-1203: Visibility Enforces Invariants - CapabilityGate internal state private"
          ]
        },
        {
          "file": ".claude/skills/rust-textbook/07_errors_panics_diagnostics.md",
          "contracts": [
            "CTR-0703: Error Types Structured - CapabilityError enum for caller branching",
            "CTR-0704: must_use on Values With Correctness Obligations - gate results"
          ]
        },
        {
          "file": ".claude/skills/rust-textbook/26_apm2_safe_patterns_and_anti_patterns.md",
          "contracts": [
            "CTR-2605: State Machines Explicit Enums - CapabilityStatus enum",
            "CTR-2606: Errors Typed and Actionable - CapabilityError variants"
          ]
        }
      ],
      "codebase_context": {
        "new_files": [
          {
            "path": "crates/apm2-core/src/cac/capability_gate.rs",
            "description": "CapabilityGate struct and gating logic"
          }
        ],
        "extend_files": [
          {
            "path": "crates/apm2-core/src/cac/mod.rs",
            "description": "Export capability_gate module"
          },
          {
            "path": "proto/kernel_events.proto",
            "description": "Add CapabilityRequired event (new tag)"
          },
          {
            "path": "crates/apm2-holon/src/episode/controller.rs",
            "description": "Integrate capability check in planning phase"
          }
        ],
        "reference_files": [
          {
            "path": "crates/apm2-core/src/evidence/receipt.rs",
            "description": "GateReceipt::verify() pattern (lines 653-657)"
          },
          {
            "path": "crates/apm2-core/src/evidence/mod.rs",
            "description": "DefectRecord pattern"
          }
        ]
      },
      "security": "AATReceipt verification prevents capability spoofing (DD-0006).\nBinary hash binding ensures receipt matches current binary.\nCutover gating prevents untested capabilities from reaching production.\n",
      "architecture": "Per DD-0006: AATReceipt gates critical cutovers and agent planning.\nCapability negotiation via stable_ids field in EpisodeConfig.\nGraceful degradation for optional capabilities (Degraded status).\nDefectRecord emission creates feedback loop for capability gaps.\n"
    }
  }
}
