ticket_meta:
  schema_version: "2026-01-29"
  template_version: "2026-01-29"
  ticket:
    id: "TCK-00675"
    title: "apm2-daemon: extract freeze-aware SQLite ledger polling (legacy+canonical merge) into shared module + standardize canonical event_id padding for cursor correctness"
    status: "OPEN"
  binds:
    prd_id: "PRD-PLACEHOLDER"
    rfc_id: "RFC-0020"
    requirements: []
    evidence_artifacts: []
  custody:
    agent_roles: ["AGENT_IMPLEMENTER", "AGENT_REVIEWER"]
    responsibility_domains: ["DOMAIN_DAEMON", "DOMAIN_DATA", "DOMAIN_RUNTIME"]
  dependencies:
    tickets: []

root_cause_analysis:
  summary: |
    APM2 currently has multiple independent implementations of "tail the ledger with a durable
    cursor across two schemas":

      - Projection worker LedgerTailer (crates/apm2-daemon/src/projection/worker.rs)
        merges legacy `ledger_events` and canonical `events`, synthesizing canonical event_id as
        `canonical-{seq_id:020}` to preserve lexical ordering.

      - Gate timeout kernel SqliteTimeoutLedgerReader (crates/apm2-daemon/src/gate/timeout_kernel.rs)
        re-implements its own canonical+legacy queries (8 query functions) and also synthesizes
        `canonical-{seq_id:020}` (with SQL tie-breaker expression).

      - The general ledger reader path (crates/apm2-daemon/src/ledger.rs canonical_row_to_event)
        synthesizes `event_id` as `canonical-{seq_id}` (not zero padded), which breaks lexical
        ordering for seq_id >= 10 and can produce cursor anomalies when timestamps are equal.

    This duplication is already diverging on a load-bearing invariant: cursor ordering requires a
    total order (timestamp_ns, event_id) where event_id compares lexicographically in a way that
    matches canonical seq order. Without a single shared poller + canonical id helper, future
    orchestrators will reintroduce subtle cursor bugs (skips, duplicates, non-deterministic replay).

scope:
  in_scope:
    - id: "LED-POLL-001"
      title: "Introduce a single shared freeze-aware poller module"
      detail: |
        Create a new daemon module (location is flexible, but MUST be shared across projection and
        orchestrator-kernel consumers), e.g.:

          crates/apm2-daemon/src/ledger_poll.rs
          or crates/apm2-daemon/src/ledger/poll.rs

        The module must provide:
          - `fn canonical_event_id(seq_id: i64) -> String` that returns `canonical-{seq_id:020}`
          - `fn canonical_event_id_cmp_sql_expr() -> &'static str` or an inline helper used by
            prepared statements to compare cursor_event_id against seq_id lexicographically
            (the current SUBSTR('000...') || CAST(seq_id AS TEXT) approach).

          - A freeze-aware poll function that merges both sources:

              fn poll_events_blocking(
                conn: &rusqlite::Connection,
                event_types: &[&str],
                cursor_ts_ns: i64,
                cursor_event_id: &str,
                limit: usize,
              ) -> Result<Vec<SignedLedgerEvent>, String>

            Semantics:
              - Reads from legacy `ledger_events` if present.
              - Reads from canonical `events` if present.
              - Filters by event_types (SQL `IN (...)`), not per-type queries.
              - Applies cursor condition:
                  timestamp_ns > cursor_ts
                  OR (timestamp_ns = cursor_ts AND event_id > cursor_event_id)
                where canonical event_id is the padded synthesized form.
              - Returns events sorted by (timestamp_ns ASC, event_id ASC) and truncated to `limit`.

          - An async wrapper:
              async fn poll_events_async(...) -> Result<Vec<SignedLedgerEvent>, String>
            implemented via `tokio::task::spawn_blocking`, mirroring the pattern used in
            projection/worker.rs.

        NOTE: The shared poller should NOT interpret payloads. It returns raw `SignedLedgerEvent`
        (or `EventEnvelope`) and leaves parsing to domain-specific code.

    - id: "LED-POLL-002"
      title: "Refactor projection worker LedgerTailer and gate timeout kernel to use shared poller"
      detail: |
        Refactor:
          - crates/apm2-daemon/src/projection/worker.rs:
              LedgerTailer::{poll_events, poll_events_async} must delegate to shared poller
              and canonical_event_id helper.
              Remove duplicate canonical poll SQL.

          - crates/apm2-daemon/src/gate/timeout_kernel.rs:
              SqliteTimeoutLedgerReader::poll must delegate to shared poller with the union of
              relevant event_types:
                - gate_lease_issued
                - gate.timed_out
                - gate.receipt / GateReceipt / gate_receipt
                - gate.all_completed
              Then map returned SignedLedgerEvent -> TimeoutObservedEvent using existing parse_* helpers.
              Delete the 8 query_* functions and the manual merge/truncate code.

        The goal is extraction + reuse, not a new framework.

    - id: "LED-POLL-003"
      title: "Standardize canonical event_id padding across all canonical reads"
      detail: |
        Update crates/apm2-daemon/src/ledger.rs:
          - canonical_row_to_event() must synthesize event_id using the shared helper:
              event_id = canonical_event_id(seq_id)
            rather than `format!(\"canonical-{seq_id}\")`.

        Ensure any parsing logic that extracts seq_id from the event_id remains correct with leading zeros.

    - id: "LED-POLL-004"
      title: "Cursor correctness tests covering padding + merge ordering"
      detail: |
        Add tests (preferably near the shared poller module) that cover:
          - canonical_event_id lexical ordering:
              canonical-000...009 < canonical-000...010 < canonical-000...100
          - merged polling across legacy+canonical with same timestamp_ns:
              ensure stable order and no skips when advancing cursor by the last event.

        Additionally, add a regression test that uses canonical_row_to_event() and asserts it produces
        padded event_id, preventing future regressions.

    - id: "LED-POLL-005"
      title: "Documentation + enforcement for 'no bespoke canonical/legacy merge pollers'"
      detail: |
        Documentation:
          - Update crates/apm2-daemon/src/projection/AGENTS.md to describe the shared poller as the
            canonical implementation of freeze-aware cursor tailing.
          - Add a short module-level doc comment in the new poller module defining the cursor contract.

        Enforcement:
          - Update CODE_QUALITY_PROMPT.cac.json (or via TCK-00678) with an invariant:
              "If a PR adds SQL that unions/merges `ledger_events` and `events`, it MUST use the shared
               poller module. Hand-rolled cursor comparisons or canonical event_id synthesis is a finding."
          - Update safe patterns doc with a greppable rule:
              "Use canonical_event_id(seq_id) helper; never format canonical IDs ad-hoc."

  out_of_scope:
    - Replacing SQLite with a new store.
    - Removing the dual-ledger transitional period (legacy vs canonical).
    - Changing the ledger schema.

implementation_notes:
  critical_structural_boundaries:
    - id: "IMPL-LED-POLL-01"
      title: "spawn_blocking for rusqlite inside async"
      detail: |
        All async callers must use spawn_blocking (or an equivalent offloading mechanism) for rusqlite
        operations. The shared module should provide the async wrapper so orchestrators don't reintroduce
        runtime blocking.
    - id: "IMPL-LED-POLL-02"
      title: "Cursor total order is a system invariant"
      detail: |
        The ordering used for cursor comparison MUST remain the same everywhere:
          (timestamp_ns, event_id) with event_id lexicographically comparable.
        canonical_event_id padding is non-negotiable if event_id is used as tie-breaker.

documentation_and_enforcement:
  documentation_deliverables:
    - "New shared poller module has module docs stating cursor ordering and canonical ID rules."
    - "Projection and gate docs updated to point to the shared poller as the only allowed merge implementation."
  enforcement_deliverables:
    - "Code-quality reviewer invariant added (prompt + safe-patterns entry) banning ad-hoc canonical/legacy merge logic."

plan:
  steps:
    - "Create shared poller module with canonical_event_id helper + blocking + async poll APIs."
    - "Refactor projection LedgerTailer to call shared poller."
    - "Refactor gate timeout kernel ledger reader to call shared poller; delete bespoke query_* functions."
    - "Update ledger.rs canonical_row_to_event to use canonical_event_id helper."
    - "Add tests for canonical padding + merge ordering + ledger.rs regression."
    - "Update documentation and reviewer enforcement artifacts."

definition_of_done:
  criteria:
    - "Projection worker and gate timeout kernel no longer contain bespoke canonical+legacy merge SQL; they delegate to shared poller."
    - "ledger.rs canonical_row_to_event emits padded canonical event_id."
    - "New tests cover canonical padding ordering and merged polling cursor advancement."
    - "Docs and reviewer invariant exist to prevent future re-introduction of bespoke pollers."

risks:
  - id: "R-LED-POLL-01"
    title: "Behavioral drift in polling semantics could affect projection timing"
    mitigation: |
      Keep the refactor mechanical: preserve existing SQL predicates and ordering, but centralize them.
      Add focused tests for ordering and cursor advancement.
