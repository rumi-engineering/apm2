ticket_meta:
  schema_version: "2026-01-29"
  template_version: "2026-01-29"
  ticket:
    id: "TCK-00387"
    title: "Daemon crash recovery: wire persistent session state to lease revocation and work cleanup"
    status: "OPEN"
  binds:
    prd_id: "PRD-0009"
    rfc_id: "RFC-0018"
  custody:
    agent_roles:
      - "AGENT_IMPLEMENTER"
    responsibility_domains:
      - "DOMAIN_RUNTIME"
      - "DOMAIN_SECURITY"
  dependencies:
    tickets:
      - ticket_id: "TCK-00383"
        reason: "Ledger event emission must be wired for lease revocation events to persist."
  scope:
    in_scope:
      - "Wire `perform_crash_recovery` in main.rs to actually recover sessions from persistent state."
      - "Load persisted sessions from state file on startup."
      - "For each recovered session: emit LEASE_REVOKED event to ledger."
      - "For each recovered session with in-progress work: transition work to Aborted or re-claimable state."
      - "Clean up stale socket/PID state from previous daemon instance."
      - "Log recovery actions for operational visibility."
    out_of_scope:
      - "Session resumption (crash-only design means sessions are terminated, not resumed)."
      - "PersistentSessionRegistry implementation (already exists and tested in TCK-00266)."
      - "CrashRecoveryManager infrastructure (already exists in session module)."
  plan:
    steps:
      - "In perform_crash_recovery, load persistent sessions from DaemonStateHandle's session registry."
      - "For each persisted session, create a LEASE_REVOKED event with reason='daemon_restart'."
      - "Emit lease revocation events to the SqliteLedgerEventEmitter."
      - "For each session with active work claims, check if work state should be reset to Open (re-claimable)."
      - "Clear the persistent session registry after successful recovery."
      - "Add timeout protection (already has 5000ms timeout in main.rs)."
      - "Add integration test: persist sessions, simulate daemon restart, verify recovery emits correct events."
  definition_of_done:
    criteria:
      - "Daemon startup with stale sessions in state file emits LEASE_REVOKED events."
      - "Work items bound to stale sessions become re-claimable."
      - "Recovery completes within 5-second timeout."
      - "Recovery is idempotent (second startup with same state doesn't double-emit)."
      - "Recovery failure does not prevent daemon from starting (warn and continue)."
  notes:
    context: |
      Crash recovery at main.rs line 1013 calls `perform_crash_recovery(&state)` which
      is essentially a no-op:

        // TODO: When session persistence is implemented, this will:
        // 1. Load persistent session state from disk/database
        // 2. Populate a session registry with recovered sessions
        // 3. Call recovery_manager.recover_sessions() with the registry

      The PersistentSessionRegistry IS wired (line 734-735 of main.rs via
      `DaemonStateHandle::new_with_persistent_sessions`). The CrashRecoveryManager
      infrastructure exists in the session module. But the actual recovery logic
      that connects these components is not implemented.

      Without crash recovery, a daemon restart leaves orphaned leases and work
      items stuck in claimed/in-progress states indefinitely. The FAC resume
      command (`apm2 fac resume`) exists for manual recovery, but autonomous
      operation requires the daemon to self-heal on startup.

      AAT finding: Daemon startup logged "Crash recovery completed (no persistent
      sessions to recover) elapsed_ms=0 sessions_recovered=0" -- confirming the
      no-op behavior.
    files: |
      - crates/apm2-daemon/src/main.rs (line 1013: perform_crash_recovery, line 734: persistent sessions)
      - crates/apm2-daemon/src/session/ (CrashRecoveryManager, PersistentSessionRegistry)
      - crates/apm2-daemon/src/ledger.rs (SqliteLedgerEventEmitter for lease revocation events)
      - crates/apm2-core/src/work/state.rs (work state transitions for recovery)
    security: |
      Crash recovery must be fail-safe: if recovery fails, the daemon should still
      start and log warnings. Orphaned leases should time out via HTF time envelopes
      even without explicit revocation.
