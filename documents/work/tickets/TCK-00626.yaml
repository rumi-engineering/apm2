ticket_meta:
  schema_version: "2026-01-29"
  template_version: "2026-01-29"
  ticket:
    id: "TCK-00626"
    title: "Implement cache reuse explainability: hit/miss with first mismatch dimension"
    status: "IN_PROGRESS"
  binds:
    prd_id: "PRD-PLACEHOLDER"
    rfc_id: "RFC-0019"
    requirements: ["REQ-0037"]
    evidence_artifacts: []
  custody:
    agent_roles: ["AGENT_IMPLEMENTER"]
    responsibility_domains: ["DOMAIN_RUNTIME", "DOMAIN_CI"]
  dependencies:
    tickets:
      - ticket_id: "TCK-00623"
        reason: "closure_hash dimension requires the closure artifact to be defined."
      - ticket_id: "TCK-00625"
        reason: "cache_decision is emitted within the gate_finished event; JSONL schema must exist."

root_cause_analysis:
  summary: |
    Gate cache misses are currently silent: the gate re-runs without any
    indication of why the cache was not reused. This makes it impossible to
    distinguish an expected miss (toolchain changed) from an unexpected one
    (policy hash instability, receipt binding regression). Operators and
    orchestrators have no way to verify that cache reuse is working correctly
    on the warm path, and cannot diagnose slow repeated runs without reading
    internal cache YAML files.

scope:
  in_scope:
    - id: "S1_CACHE_DECISION_RECORD"
      title: "Define CacheDecision struct with all required fields"
      detail: |
        struct CacheDecision {
          hit: bool,
          reason_code: CacheReasonCode,   // enum (see REQ-0037 for full list)
          first_mismatch_dimension: Option<CacheReasonCode>,
          cached_sha: Option<String>,
        }
        enum CacheReasonCode: 11 variants as listed in REQ-0037
    - id: "S2_CHECK_REUSE_ATTRIBUTION"
      title: "Return CacheDecision from check_reuse() with first mismatch dimension"
      detail: |
        Refactor gate_cache.rs::check_reuse() to return CacheDecision instead
        of ReuseDecision. On miss, record first_mismatch_dimension as the first
        check that failed (policy_hash before toolchain, toolchain before
        closure_hash, etc.) using a defined check order:
          1. sha_miss / gate_miss
          2. signature_invalid
          3. receipt_binding_missing
          4. policy_drift
          5. toolchain_drift
          6. closure_drift
          7. input_drift
          8. network_policy_drift
          9. sandbox_drift
          10. ttl_expired
    - id: "S3_INLINE_IN_GATE_FINISHED"
      title: "Inline CacheDecision in gate_finished event"
      detail: |
        Populate the cache_decision field in gate_finished (from TCK-00625)
        with the CacheDecision returned by check_reuse(). The cache_decision
        event type from REQ-0036 is satisfied by this inline record.
    - id: "S4_REGRESSION_TESTS"
      title: "Regression tests for all 11 reason codes"
      detail: |
        - Test: cache hit -> reason_code=cache_hit, first_mismatch_dimension=null.
        - Test: each of the 10 miss codes -> correct reason_code and
          first_mismatch_dimension in gate_finished event.
        - Test: policy_drift miss does NOT also report toolchain_drift
          (first mismatch stops at policy_drift).
        - Test: stdout event stream alone identifies miss cause (no file reads needed).
    - id: "BF_001_DISPATCH_DIAGNOSTIC"
      title: "Auto-trigger review dispatch after push: PID liveness check + structured diagnostics"
      detail: |
        Push dispatch returns 'joined' for dead PIDs due to stale idempotency.
        Add PID liveness verification for non-terminal 'joined' results.
        Emit structured dispatch_failed JSONL events with recovery commands.
        Improve human-readable error messages with explicit recovery actions.
    - id: "BF_002_WAIT_MERGED_DETECTION"
      title: "Wait loop detects externally-merged PRs via periodic GitHub API poll"
      detail: |
        The --wait-for-recommended-action loop uses lightweight=true exclusively,
        which skips GitHub API. PRs merged externally are never detected. Fix by
        periodically using non-lightweight polls (every 5th tick) and injecting
        merged lifecycle events when GitHub API confirms merge.
  out_of_scope:
    - "Changing cache eviction or TTL policy."
    - "Adding new reason codes beyond the 11 defined (requires new requirement)."
    - "Retroactive re-attribution of existing cache entries."

plan:
  steps:
    - id: "STEP_01"
      title: "Define CacheDecision and CacheReasonCode types"
      detail: |
        In gate_cache_v3.rs. Add CacheDecision struct and CacheReasonCode
        enum with 11+1 variants. Add check_reuse_decision() wrapper and
        map_reason_to_code() helper.
    - id: "STEP_02"
      title: "Refactor check_reuse() to produce CacheDecision with first_mismatch_dimension"
      detail: |
        Implement ordered dimension checks; set first_mismatch_dimension at
        first failing check. Return CacheDecision with full attribution.
    - id: "STEP_03"
      title: "Inline CacheDecision in gate_finished event"
      detail: |
        Pass CacheDecision to the gate_finished event constructor. Wire
        through evidence pipeline via reuse_decision_with_v3_fallback return
        tuple, GateProgressEvent::Completed, and EvidenceGateResult.
    - id: "STEP_04"
      title: "Add regression tests and workspace validation"
      detail: |
        cargo fmt --all && cargo clippy --workspace --all-targets --all-features -- -D warnings
        cargo doc --workspace --no-deps && cargo test --workspace
    - id: "STEP_05"
      title: "BF-001: Push dispatch PID liveness + structured diagnostics"
      detail: |
        Verify PID liveness for 'joined' dispatch results. Emit dispatch_failed
        JSONL events on failure. Improve stderr messages with recovery commands.
    - id: "STEP_06"
      title: "BF-002: Wait loop merged state detection"
      detail: |
        Add fetch_pr_merged_at to github_reads. Inject merged lifecycle event
        in run_doctor_inner when GitHub API confirms merge. Periodically use
        non-lightweight mode in wait loop CollectSummary state.

definition_of_done:
  evidence_ids:
    - "EXEC-TCK00626-CACHE-DECISION"
    - "EXEC-TCK00626-ALL-REASON-CODES"
    - "EXEC-TCK00626-WORKSPACE-VALIDATION"
    - "EXEC-TCK00626-BF001-DISPATCH"
    - "EXEC-TCK00626-BF002-MERGED"
  criteria:
    - "CacheDecision struct with all required fields replaces ReuseDecision."
    - "check_reuse() returns first_mismatch_dimension for every miss type."
    - "gate_finished event includes cache_decision with hit, reason_code, first_mismatch_dimension."
    - "All 11 reason_code values are reachable and tested."
    - "Cache miss cause is identifiable from stdout event stream without reading gate_cache_v2 files."
    - "Regression tests cover all 11 codes and verify correct first_mismatch_dimension."
    - "Workspace validation completes successfully."
    - "Push dispatch verifies PID liveness for 'joined' results and emits structured dispatch_failed events."
    - "Wait loop periodically detects externally-merged PRs via GitHub API and exits with terminal 'done' action."

notes:
  context: |
    This ticket refactors the existing ReuseDecision type in gate_cache.rs
    into the richer CacheDecision type. The ordered dimension check logic
    already exists implicitly in check_reuse(); this ticket makes the ordering
    explicit and captures the first failing dimension. The removal of the
    allow_legacy_cache bypass (TCK-00619) simplifies the check order by
    eliminating the legacy_cache_override_unsafe path.
  security: "cache_decision exposes only non-sensitive dimension names; no key material in output"
