{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-29",
    "template_version": "2026-01-29",
    "ticket": {
      "id": "TCK-00401",
      "title": "Initialize ToolBroker with capability manifest and policy engine in production path",
      "status": "CLOSED"
    },
    "binds": {
      "prd_id": "PRD-0009",
      "rfc_id": "RFC-0018",
      "requirements": [
        {
          "requirement_id": "REQ-HEF-0010",
          "requirement_ref": "documents/rfcs/RFC-0018/requirements/REQ-HEF-0010.yaml#rfc_requirement"
        }
      ],
      "evidence_artifacts": [
        {
          "evidence_id": "EVID-HEF-0011",
          "artifact_ref": "documents/rfcs/RFC-0018/evidence_artifacts/EVID-HEF-0011.yaml#rfc_evidence_artifact"
        }
      ]
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_RUNTIME",
        "DOMAIN_SECURITY"
      ]
    },
    "dependencies": {
      "tickets": [
        {
          "ticket_id": "TCK-00383",
          "reason": "Session dispatcher must be wired with CAS/broker dependencies in production before broker initialization can be enforced end-to-end."
        },
        {
          "ticket_id": "TCK-00331",
          "reason": "RoleSpec tool allowlists are the policy source for broker allow/deny behavior."
        }
      ]
    },
    "scope": {
      "in_scope": [
        "Call ToolBroker::initialize_with_manifest() in the production path when a session is created during SpawnEpisode.",
        "Load the capability manifest from CAS and pass it to the broker's CapabilityValidator.",
        "Initialize BrokerPolicyEngine with a default policy that respects the RoleSpec tool allowlist.",
        "Wire the CredentialStore into the ToolBroker's github_store and ssh_store fields.",
        "Ensure the broker is per-session (each session gets its own initialized broker instance with scoped capabilities)."
      ],
      "out_of_scope": [
        "Custom policy engine rules beyond role-based tool allowlists.",
        "Dynamic policy hot-reloading during an episode.",
        "Full RBAC/ABAC policy language — use the existing RoleConformanceHarness for validation."
      ]
    },
    "plan": {
      "steps": [
        "Read crates/apm2-daemon/src/episode/broker.rs to understand initialize_with_manifest() (currently only called in tests). Identify what CapabilityValidator needs: the manifest bytes, session context, and optionally a risk tier.",
        "Read crates/apm2-daemon/src/state.rs lines 593-594 where the broker is created as SharedToolBroker with no initialization. Understand the current architecture: one global broker shared across all sessions.",
        "DESIGN DECISION: Change from one global broker to per-session broker instances. Each session needs its own CapabilityValidator scoped to that session's manifest. Create a BrokerFactory or SessionBrokerManager that creates initialized broker instances per SpawnEpisode.",
        "Edit state.rs: replace the single SharedToolBroker with a BrokerFactory that holds the CAS reference and default config. Each session gets its own broker via factory.create_for_session(manifest_hash, risk_tier).",
        "Implement BrokerFactory::create_for_session(): loads manifest from CAS, creates ToolBroker, calls initialize_with_manifest(), sets up policy engine from the resolved RoleSpec's tool_allowlist, wires credential stores.",
        "Edit session_dispatch.rs handle_request_tool(): instead of using the global broker, look up the per-session broker from the session registry.",
        "Wire CredentialStore into the broker: edit state.rs to pass the CredentialStore (already created at line 678) as github_store and ssh_store to the BrokerFactory. Use broker.with_github_store() and broker.with_ssh_store().",
        "Initialize BrokerPolicyEngine: create a policy that maps ToolClass -> allow/deny based on the RoleSpec's tool_allowlist. For each tool class in the allowlist, create an Allow rule. Default: Deny.",
        "Add integration test: SpawnEpisode, then RequestTool with a tool class in the manifest's allowlist — should succeed. RequestTool with a tool class NOT in the allowlist — should return PolicyDeny.",
        "Run cargo fmt --all && cargo clippy --workspace --all-targets --all-features -- -D warnings && cargo doc --workspace --no-deps && cargo test -p apm2-daemon."
      ]
    },
    "definition_of_done": {
      "evidence_ids": [
        "EVID-HEF-0011"
      ],
      "criteria": [
        "ToolBroker is initialized per-session with the session's capability manifest loaded from CAS.",
        "BrokerPolicyEngine evaluates tool requests against the RoleSpec's tool_allowlist (not default deny-all).",
        "RequestTool for an allowed tool class returns a tool result (not BrokerError::NotInitialized).",
        "RequestTool for a disallowed tool class returns PolicyDeny (not NotInitialized).",
        "CredentialStore is wired into the broker's github_store and ssh_store fields.",
        "Git tool class requests can access GitHub credentials when available.",
        "Per-session broker isolation: one session's capabilities do not leak to another session.",
        "All existing broker unit tests continue to pass.",
        "New integration test verifies the production initialization path.",
        "All CI checks pass: cargo fmt, clippy (zero warnings), doc, tests."
      ]
    },
    "notes": {
      "context": "AAT evidence (H5: FAIL) showed that every RequestTool returns \"broker not initialized: call\ninitialize() first\". Root cause analysis found TWO issues:\n\nA1: The ToolBroker's validator field is a RwLock<Option<CapabilityValidator>> initialized to\nNone in ToolBroker::new() (broker.rs:589). The initialize_with_manifest() method that sets it\nis ONLY called in #[cfg(test)] blocks, never in production code.\n\nA2: Even if A1 were fixed, the BrokerPolicyEngine is created with engine: None, which makes\nevaluate() return PolicyDecision::Deny for all requests. No production code calls set_policy()\nor with_policy().\n\nAdditionally, G1: the github_store and ssh_store fields in ToolBroker are always None in\nproduction — the CredentialStore exists (state.rs:678) but is only passed to the\nPrivilegedDispatcher for IPC credential management, not to the ToolBroker for tool-time\ncredential mediation.\n\nThe current architecture uses a SINGLE global SharedToolBroker. This is architecturally wrong\nbecause different sessions have different capability manifests. The fix requires per-session\nbroker instances, each initialized with the session's specific manifest and role-scoped policy.\n\nThe RoleConformanceHarness (role_conformance.rs:494) has enforce_tool_call() which validates\ntool calls against a RoleSpec's allowlist — this logic should be used to build the policy engine\nrules, not duplicated.\n",
      "files": "- crates/apm2-daemon/src/episode/broker.rs (ToolBroker::new at ~589, initialize_with_manifest, BrokerPolicyEngine::new, evaluate at ~293)\n- crates/apm2-daemon/src/state.rs (SharedToolBroker creation at line 593, CredentialStore at 678)\n- crates/apm2-daemon/src/protocol/session_dispatch.rs (handle_request_tool using global broker, validator check at ~1126)\n- crates/apm2-core/src/fac/role_conformance.rs (enforce_tool_call at ~494 — validates against RoleSpec allowlist)\n- crates/apm2-core/src/fac/role_spec.rs (ToolAllowlist at 336, RoleBudgets at 459)\n- crates/apm2-core/src/fac/builtin_roles.rs (7 builtin roles with tool allowlists)\n",
      "security": "- Per-session broker isolation is CRITICAL — one session must not inherit another's capabilities.\n- Capability manifest must be loaded from CAS by hash (fail-closed on missing).\n- Policy engine must default to Deny (fail-closed) — only explicitly allowed tools pass.\n- Credential mediation must validate the tool class matches (Git creds only for Git tools).\n- Broker initialization must happen atomically with session creation — no window where an\n  uninitialized broker can serve requests.\n- CredentialStore access must respect session scope — session A cannot access session B's credentials.\n"
    }
  }
}
