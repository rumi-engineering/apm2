ticket_meta:
  schema_version: '2026-01-29'
  template_version: '2026-01-29'
  ticket:
    id: 'TCK-00661'
    title: 'FAC worker: Progress-aware systemd watchdog (restart on deadlock/hang without breaking long jobs)'
    status: 'OPEN'
  binds:
    prd_id: 'PRD-0001'
    rfc_id: 'RFC-0019'
    requirements:
      - 'REQ-0020' # eventual consistency + resilience
    evidence_artifacts: []
  custody:
    agent_roles:
      - 'Implementer'
      - 'Reviewer'
    responsibility_domains:
      - 'fac/worker'
      - 'fac/services'
  dependencies:
    tickets:
      - 'TCK-00600' # worker service Type=notify + watchdog baseline
      - 'TCK-00660' # event-driven runtime activation + claimed repair coordinator baseline

context:
  observed_symptoms:
    - 'Worker queue activation is now event-driven, but watchdog liveness remains decoupled from execution progress.'
    - 'Workers can remain "alive" under systemd while making no queue/repair progress (deadlock/hang).'
    - 'Queue stalls can persist because watchdog pings continue even when the main loop is wedged.'
  code_evidence:
    - |
      Worker spawns a dedicated watchdog thread that pings independently of main loop progress:
        crates/apm2-cli/src/commands/fac_worker.rs:1385-1422
    - |
      WatchdogTicker itself only enforces periodicity; it has no notion of work progress:
        crates/apm2-core/src/fac/sd_notify.rs:309-377

problem_statement: |
  The current watchdog design can mask deadlocks and indefinite hangs: the background thread will
  continue pinging as long as the process is alive, even if the main loop cannot wake/process queue
  work or runtime repair signals. This is a liveness failure. Watchdog pings must be contingent on
  forward progress from the main execution path.

root_cause_analysis:
  primary_cause: |
    Watchdog pinging is decoupled from the worker's "progress". There is no shared progress signal
    between the main loop and the watchdog thread.

proposed_change:
  intent: |
    Make the watchdog "progress-aware":
      - Main loop updates a shared progress timestamp/counter on every meaningful forward step.
      - Watchdog thread pings only if progress is recent enough.
      - Long-running operations must periodically bump progress (without requiring completion).

invariants:
  - id: 'INV-WD-001'
    statement: 'If the worker main loop makes no progress for > watchdog_staleness_threshold, the watchdog thread MUST stop pinging and systemd MUST restart the worker.'
  - id: 'INV-WD-002'
    statement: 'Legitimate long jobs MUST be able to keep the watchdog alive via periodic progress bumps (without requiring job completion).'

scope:
  in_scope:
    - id: 'S1'
      description: |
        Introduce a progress signal shared between threads:
          - AtomicU64 last_progress_epoch_ms (or monotonic Instant encoded as ms since start)
          - touch_progress(reason) helper updates the atomic and (optionally) a lightweight counter
    - id: 'S2'
      description: |
        Change watchdog thread behavior:
          - Before ping_if_due(), check whether (now - last_progress) <= threshold
          - Threshold should be derived from WATCHDOG_USEC (e.g., 0.75 * WatchdogSec) with a hard
            minimum/maximum clamp.
          - If progress is stale, log once and stop pinging (allow systemd to restart).
    - id: 'S3'
      description: |
        Ensure progress bumps occur during long-running operations:
          - Warm phases already accept a heartbeat_fn; extend to call touch_progress inside that fn.
          - For blocking waits (e.g., waiting on systemd-run --wait), replace single blocking wait
            with a poll loop (try_wait + sleep) that bumps progress periodically.
          - For gate execution steps that can block, add periodic bumps (where feasible) or wrap in
            a thread that signals progress.
    - id: 'S4'
      description: |
        Add tests:
          - Unit: watchdog thread suppresses ping when progress stale (inject a fake clock/atomic).
          - Regression: simulate a stuck main thread by not updating progress; verify watchdog loop would stop pinging.
          - Integration (best-effort): ensure progress is bumped during warm execution loop (via injected hook).
  out_of_scope:
    - 'Implementing a full watchdog that also checks external resource health (disk, network, etc.).'

plan:
  steps:
    - id: 'P1'
      description: 'Add progress atomic + touch_progress helper; wire into main loop at scan/claim/commit boundaries.'
    - id: 'P2'
      description: 'Update watchdog thread to gate pings on progress freshness.'
    - id: 'P3'
      description: 'Replace blocking waits with progress-bumping loops where needed.'
    - id: 'P4'
      description: 'Add tests (dependency injection for time/progress) and verify no regressions.'


definition_of_done:
  criteria:
    - 'A wedged worker (no progress updates) will stop pinging watchdog and be restarted by systemd.'
    - 'Legitimate long-running operations continue to bump progress and do not cause spurious restarts.'
    - 'Progress bumps are visible in worker heartbeat (optional counter increment) to aid diagnosis.'
  evidence_ids:
    - 'EVID-TCK-00661-01 (unit): watchdog gating on progress freshness'
    - 'EVID-TCK-00661-02 (integration): long operation bumps progress periodically'

notes:
  risk:
    - 'If progress bumps are missed in a legit long path, systemd may restart mid-job. Mitigate by ensuring all long waits are wrapped.'
  compatibility: |
    In non-systemd environments, watchdog ticker is disabled; this change should be a no-op.
