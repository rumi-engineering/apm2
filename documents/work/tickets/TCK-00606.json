{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-29",
    "template_version": "2026-01-29",
    "ticket": {
      "id": "TCK-00606",
      "title": "FAC CLI JSON parity — every fac subcommand outputs JSON by default, long-running commands stream JSONL",
      "status": "MERGED"
    },
    "binds": {
      "prd_id": "PRD-PLACEHOLDER",
      "rfc_id": "RFC-0019",
      "requirements": [],
      "evidence_artifacts": []
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_CLI"
      ]
    },
    "dependencies": {
      "tickets": []
    },
    "root_cause_analysis": {
      "summary": "LLM agents interacting with the `apm2 fac` CLI uniformly assume that\nevery subcommand accepts `--json` and produces structured output. This\nis rational inference — most FAC commands already have `--json` — but\nseveral commands silently ignore the flag or don't accept it at all,\ncausing agent workflows to break or produce unparseable output.\n\nTwo distinct problems:\n\n1. MISSING --json FLAG ON SEVERAL FAC COMMANDS\n   The following FAC subcommands return `false` from\n   `subcommand_requests_machine_output()` and either lack a `--json`\n   arg entirely or silently ignore the parent `FacCommand.json`:\n\n   - `fac gates` — has no `--json` on GatesArgs; uses parent json flag\n     via `json_output` local, but is listed in the hard-coded `false`\n     arm of `subcommand_requests_machine_output()`, so the parent\n     flag doesn't propagate correctly in all call paths.\n   - `fac push` — PushArgs has no `--json` flag. Output is a mix of\n     println! and eprintln! text with no structured alternative. The\n     parent `FacCommand.json` is threaded through some paths but not\n     all, and `subcommand_requests_machine_output` returns false.\n   - `fac restart` — RestartArgs has no `--json` flag. Output is text-\n     only. Agent must parse human prose to determine restart outcome.\n   - `fac lane status` — LaneStatusArgs has no `--json` flag. Output\n     is a text table. Agent cannot programmatically read lane state.\n   - `fac lane reset` — LaneResetArgs has no `--json` flag.\n   - `fac worker` — WorkerArgs has no `--json` flag. Long-running\n     process with text-only log output.\n   - `fac pipeline` — PipelineArgs has no `--json` flag. Internal but\n     still needs structured output for orchestration.\n   - `fac review run` — ReviewRunArgs has no `--json` flag. Long-\n     running review orchestration with text-only progress output.\n   - `fac review dispatch` — ReviewDispatchArgs has no `--json` flag.\n     Returns dispatch result as text.\n   - `fac review tail` — ReviewTailArgs has no `--json` flag (already\n     NDJSON by nature, but no explicit flag).\n   - `fac pr auth-setup` / `fac pr auth-check` — no `--json` flag.\n   - `fac episode inspect` — uses parent json flag but not listed in\n     machine_output detection.\n   - `fac receipt show` — uses parent json flag but not listed.\n   - `fac context rebuild` — uses parent json flag but not listed.\n   - `fac resume` — uses parent json flag but not listed.\n\n   When an agent calls `apm2 fac push --json`, clap rejects the flag\n   because PushArgs doesn't define it. The parent FacCommand.json\n   exists but is consumed before subcommand dispatch — the agent\n   cannot know which commands accept it at the parent level vs the\n   subcommand level. This inconsistency is the hallucination vector.\n\n2. LONG-RUNNING COMMANDS OUTPUT NOTHING UNTIL COMPLETION\n   `fac gates` runs 5+ sequential gates (fmt, clippy, doc, test,\n   merge-conflicts) taking 2-10 minutes total. The text path prints\n   progress inline, but the JSON path produces a single JSON blob\n   only on completion. An agent waiting for gates gets zero signal\n   for minutes, then either a full JSON object or an error.\n\n   Same problem for `fac push` (git push + gates + PR + dispatch),\n   `fac review run` (full review orchestration), `fac worker`\n   (continuous job processing), and `fac pipeline` (background\n   evidence + review).\n\n   These commands should stream JSONL (one JSON object per line)\n   by default, with each event representing a meaningful progress\n   checkpoint. The final line is the summary/result object. This\n   gives agents real-time observability without polling.\n\nRoot causes:\n1. ORGANIC FLAG GROWTH: --json was added per-subcommand over time.\n   Commands that predated the convention or were considered \"human-\n   only\" (push, restart, lane) never got it.\n2. DUAL-LEVEL FLAG CONFUSION: FacCommand.json exists at the parent\n   level but subcommand_requests_machine_output() only checks\n   subcommand-level flags. Some commands use the parent flag, some\n   don't, some use both with `json_output || args.json`.\n3. BATCH-ONLY JSON: The existing JSON pattern assumes commands are\n   short-lived and can buffer the entire response. Long-running\n   commands were left as text-only because the pattern didn't fit.\n"
    },
    "scope": {
      "scope_clarification": "Removing non-machine-parseable output (dead text-mode branches,\nunstructured eprintln, human-readable println) is a best-effort goal\nscoped to `fac` subcommands. Follow-up tickets will address residual\ntext output paths in non-FAC areas of the codebase.\n\nS4 field clarification (implementation diverges from original spec):\n  - S4(c) lane status: the implementation uses LaneStatusV1 fields\n    { lane_id, state, job_id, pid, started_at, toolchain_fingerprint,\n    lane_profile_hash, lock_held, pid_alive } which are derived from\n    lock state + lease record + PID liveness. These fields are more\n    operationally useful than the originally specified { lane_id,\n    state, pid, lease_holder, lease_expires_at, workspace_path }.\n    The struct is defined in apm2-core and shared across CLI and\n    daemon — changing field names would break the core API.\n  - S4(d) lane reset: the implementation returns { lane_id, status,\n    files_deleted, dirs_deleted } on success and { lane_id, status,\n    reason, refused_receipts } on failure/corruption. These fields\n    are more informative than the originally specified { lane_id,\n    reset, force, cleanup_result }. The implementation captures\n    actual deletion counts and refused-delete receipts for auditing.\n",
      "in_scope": [
        {
          "id": "S1_GATES_JSON_AND_JSONL",
          "title": "`fac gates` — add --json flag to GatesArgs, stream JSONL progress by default",
          "detail": "Current state: GatesArgs has no --json flag. The parent\nFacCommand.json is threaded to run_gates() as json_output, but\nsubcommand_requests_machine_output() returns false for Gates.\nGates run 5+ sequential checks (merge_conflicts, fmt, clippy,\ndoc, test) taking 2-10 minutes. In JSON mode, nothing is emitted\nuntil all gates finish.\n\nRequired changes:\n(a) Add `#[arg(long, default_value_t = false)] pub json: bool`\n    to GatesArgs.\n(b) Update subcommand_requests_machine_output() to return\n    args.json for FacSubcommand::Gates.\n(c) Resolve the effective json flag as `json_output || args.json`\n    at the dispatch site (already the pattern for doctor, logs).\n(d) In run_gates_inner(), when JSON mode is active, emit one\n    JSONL line to stdout as each gate completes:\n    ```\n    {\"event\":\"gate_started\",\"gate\":\"fmt\",\"ts\":\"...\"}\n    {\"event\":\"gate_completed\",\"gate\":\"fmt\",\"status\":\"pass\",\"duration_secs\":3,\"ts\":\"...\"}\n    {\"event\":\"gate_started\",\"gate\":\"clippy\",\"ts\":\"...\"}\n    {\"event\":\"gate_completed\",\"gate\":\"clippy\",\"status\":\"pass\",\"duration_secs\":12,\"ts\":\"...\"}\n    ...\n    {\"event\":\"gates_summary\",\"sha\":\"abc123\",\"passed\":true,\"bounded\":true,...,\"gates\":[...]}\n    ```\n    The final line is the existing GatesSummary struct serialized\n    as compact JSON (not pretty-printed — JSONL requires one\n    object per line).\n(e) In text mode, preserve existing behavior (human table).\n(f) Error events are also JSONL:\n    `{\"event\":\"gate_error\",\"gate\":\"test\",\"error\":\"...\",\"ts\":\"...\"}`\n\nAffected files:\n- crates/apm2-cli/src/commands/fac.rs (GatesArgs, dispatch, machine_output)\n- crates/apm2-cli/src/commands/fac_review/gates.rs (run_gates, run_gates_inner)\n"
        },
        {
          "id": "S2_PUSH_JSON_AND_JSONL",
          "title": "`fac push` — add --json flag, stream JSONL for multi-stage pipeline",
          "detail": "Current state: PushArgs has no --json flag. Output is a mix of\nprintln!/eprintln! across ~1500 lines in push.rs. The push\npipeline has 4+ stages (git push, gates, PR create/update,\ndispatch) each taking significant time.\n\nRequired changes:\n(a) Add `#[arg(long, default_value_t = false)] pub json: bool`\n    to PushArgs.\n(b) Update subcommand_requests_machine_output() for Push.\n(c) When JSON mode is active, stream JSONL progress:\n    ```\n    {\"event\":\"push_started\",\"branch\":\"...\",\"remote\":\"...\",\"ts\":\"...\"}\n    {\"event\":\"git_push_completed\",\"status\":\"pass\",\"duration_secs\":2,\"ts\":\"...\"}\n    {\"event\":\"gates_started\",\"ts\":\"...\"}\n    {\"event\":\"gate_completed\",\"gate\":\"fmt\",\"status\":\"pass\",\"duration_secs\":3,\"ts\":\"...\"}\n    ... (gate events as in S1)\n    {\"event\":\"gates_completed\",\"passed\":true,\"duration_secs\":120,\"ts\":\"...\"}\n    {\"event\":\"pr_updated\",\"pr_number\":615,\"url\":\"...\",\"ts\":\"...\"}\n    {\"event\":\"dispatch_completed\",\"status\":\"pass\",\"ts\":\"...\"}\n    {\"event\":\"push_summary\",\"sha\":\"...\",\"pr_number\":615,\"passed\":true,...}\n    ```\n(d) If dispatch fails but push+gates+PR succeed, the summary\n    still reports overall success with a `dispatch_warning` field\n    (ties into TCK-00605 P1_PUSH_EXIT_CODE_SEPARATION).\n(e) In text mode, preserve existing behavior.\n\nAffected files:\n- crates/apm2-cli/src/commands/fac.rs (PushArgs, dispatch, machine_output)\n- crates/apm2-cli/src/commands/fac_review/push.rs\n"
        },
        {
          "id": "S3_RESTART_JSON",
          "title": "`fac restart` — add --json flag with structured outcome",
          "detail": "Current state: RestartArgs has no --json flag. Output is text\ndescribing which stages were restarted.\n\nRequired changes:\n(a) Add `#[arg(long, default_value_t = false)] pub json: bool`\n    to RestartArgs.\n(b) Update subcommand_requests_machine_output() for Restart.\n(c) Define RestartResponse struct:\n    { pr_number, sha, strategy, stages_restarted: [...],\n      gates_skipped: bool, dispatch_result, duration_secs }\n(d) Output as single JSON object (restart is fast enough to not\n    need JSONL streaming).\n\nAffected files:\n- crates/apm2-cli/src/commands/fac.rs (RestartArgs, dispatch, machine_output)\n- crates/apm2-cli/src/commands/fac_review/repair_cycle.rs\n"
        },
        {
          "id": "S4_LANE_JSON",
          "title": "`fac lane status` and `fac lane reset` — add --json flag",
          "detail": "Current state: LaneStatusArgs and LaneResetArgs have no --json\nflag. Lane status outputs a text table; lane reset outputs a\nconfirmation message.\n\nRequired changes:\n(a) Add `#[arg(long, default_value_t = false)] pub json: bool`\n    to both LaneStatusArgs and LaneResetArgs.\n(b) Update subcommand_requests_machine_output() for Lane.\n(c) Lane status JSON: array of lane objects with { lane_id,\n    state, pid, lease_holder, lease_expires_at, workspace_path }.\n(d) Lane reset JSON: { lane_id, reset, force, cleanup_result }.\n\nAffected files:\n- crates/apm2-cli/src/commands/fac.rs (LaneStatusArgs, LaneResetArgs, dispatch, machine_output)\n"
        },
        {
          "id": "S5_REVIEW_RUN_DISPATCH_JSON",
          "title": "`fac review run` and `fac review dispatch` — add --json flag",
          "detail": "Current state: ReviewRunArgs and ReviewDispatchArgs have no\n--json flag. `review run` is long-running (full review\norchestration). `review dispatch` is a fire-and-forget spawn.\n\nRequired changes:\n(a) Add `#[arg(long, default_value_t = false)] pub json: bool`\n    to both ReviewRunArgs and ReviewDispatchArgs.\n(b) Update subcommand_requests_machine_output() for both.\n(c) `review dispatch` JSON: single object with { pr_number,\n    review_type, dispatched_pids: [...], sha, model }.\n    Dispatch is fast — no JSONL needed.\n(d) `review run` JSON: JSONL stream — this is a long-running\n    orchestration. Events should mirror the existing NDJSON\n    telemetry stream that `review tail` reads, with a final\n    summary line.\n(e) `review tail` already outputs NDJSON. Add explicit --json\n    flag to ReviewTailArgs for consistency (noop since output\n    is already JSONL, but prevents clap rejection when agents\n    pass --json).\n\nAffected files:\n- crates/apm2-cli/src/commands/fac.rs (ReviewRunArgs, ReviewDispatchArgs, ReviewTailArgs, machine_output)\n- crates/apm2-cli/src/commands/fac_review/mod.rs (dispatch, run)\n"
        },
        {
          "id": "S6_WORKER_PIPELINE_JSONL",
          "title": "`fac worker` and `fac pipeline` — add --json flag, stream JSONL",
          "detail": "Current state: WorkerArgs and PipelineArgs have no --json flag.\nWorker is a continuous long-running process. Pipeline is an\ninternal background process.\n\nRequired changes:\n(a) Add `#[arg(long, default_value_t = false)] pub json: bool`\n    to WorkerArgs and PipelineArgs.\n(b) Update subcommand_requests_machine_output() for both.\n(c) Worker JSONL: one line per job processed:\n    { event: \"job_started\"|\"job_completed\"|\"job_failed\",\n      job_id, duration_secs, exit_code, ... }\n(d) Pipeline JSONL: stage progress events similar to push.\n\nAffected files:\n- crates/apm2-cli/src/commands/fac.rs (WorkerArgs, PipelineArgs, machine_output)\n- crates/apm2-cli/src/commands/fac_worker.rs\n"
        },
        {
          "id": "S7_PR_AUTH_JSON",
          "title": "`fac pr auth-setup` and `fac pr auth-check` — add --json flag",
          "detail": "Current state: PrArgs routes to fac_pr module. Auth-setup and\nauth-check output text instructions/status.\n\nRequired changes:\n(a) Add --json flag to auth-setup and auth-check args.\n(b) Auth-check JSON: { authenticated, login, token_expires_at,\n    permissions: { ... } }.\n(c) Auth-setup JSON: { setup_completed, steps: [...] }.\n\nAffected files:\n- crates/apm2-cli/src/commands/fac_pr/mod.rs\n- crates/apm2-cli/src/commands/fac_pr/auth_setup.rs\n- crates/apm2-cli/src/commands/fac_pr/auth_check.rs\n"
        },
        {
          "id": "S8_DECISION_MODEL_PROVENANCE",
          "title": "Review decisions and findings must include the model that produced them",
          "detail": "The review run state (ReviewRunState, ReviewStateEntry in types.rs)\nalready tracks `model_id` (e.g. \"gpt-5.3-codex\") and `backend_id`\n(e.g. \"codex\") for the reviewer that performed the work. But this\nprovenance information is absent from the artifacts that agents and\norchestrators actually read:\n\n1. DecisionEntry (decision.rs:56) — the per-dimension verdict record\n   stored locally and projected to GitHub. Has decision, reason,\n   set_by, set_at — but no model_id or backend_id. An orchestrator\n   reading `verdict show` cannot tell which model produced the verdict\n   without cross-referencing review run state files.\n\n2. DimensionDecisionView (decision.rs:131) — the view struct returned\n   by `apm2 fac review verdict show`. Has dimension, decision, reason,\n   set_by, set_at, sha — but no model_id or backend_id.\n\n3. DecisionShowReport (decision.rs:115) — the top-level verdict show\n   report. Contains dimensions array of DimensionDecisionView but no\n   model info at either level.\n\n4. StoredFinding (findings_store.rs:68) — individual review findings.\n   Has reviewer_id but no model_id or backend_id. When an orchestrator\n   reads findings, it cannot attribute them to a specific model without\n   joining on reviewer_id and reverse-mapping through state files.\n\n5. GitHub-projected decision comment — the YAML payload projected to\n   GitHub PR comments via verdict_projection.rs. Contains the\n   DecisionComment schema which lacks model provenance.\n\nRequired changes:\n(a) Add `model_id: Option<String>` and `backend_id: Option<String>`\n    to DecisionEntry. These are set when `verdict set` is called\n    (the calling reviewer knows its own model) or when the auto-verdict\n    reaper derives a verdict (it can read model_id from the\n    ReviewRunState of the reaped agent).\n(b) Add `model_id` and `backend_id` to DimensionDecisionView so\n    `verdict show --json` includes the model in its output.\n(c) Add `model_id` and `backend_id` to StoredFinding. The `finding`\n    subcommand already accepts `--reviewer-id`; add `--model-id`\n    and `--backend-id` optional args to ReviewFindingArgs. The\n    orchestrator (review run) passes these when emitting findings.\n(d) Update the GitHub decision comment projection to include model\n    provenance in the YAML payload per dimension.\n(e) Update DecisionShowReport to surface model info in the\n    dimensions array.\n(f) Use `#[serde(default, skip_serializing_if = \"Option::is_none\")]`\n    on all new fields for backwards compatibility with existing\n    stored artifacts that lack the fields.\n\nThis is a provenance bug: the system knows which model did the work\nbut strips that information from the artifacts that consumers read.\nOrchestrators need model provenance to make fallback/retry decisions\n(e.g. \"security was reviewed by gemini-3-flash, retry with codex\")\nand for audit trails.\n\nAffected files:\n- crates/apm2-cli/src/commands/fac_review/decision.rs (DecisionEntry, DimensionDecisionView, DecisionShowReport, run_verdict_set)\n- crates/apm2-cli/src/commands/fac_review/findings_store.rs (StoredFinding)\n- crates/apm2-cli/src/commands/fac_review/finding.rs (FindingSummary, append logic)\n- crates/apm2-cli/src/commands/fac_review/verdict_projection.rs (GitHub comment payload)\n- crates/apm2-cli/src/commands/fac.rs (ReviewFindingArgs — add --model-id, --backend-id)\n"
        },
        {
          "id": "S9_REMAINING_SUBCOMMANDS_MACHINE_OUTPUT_FIX",
          "title": "Fix subcommand_requests_machine_output() for all remaining commands",
          "detail": "Several commands already use the parent FacCommand.json flag via\nthe json_output local but are listed in the `false` arm of\nsubcommand_requests_machine_output(). This means the parent\nflag doesn't suppress human-formatted stderr/warning output\nin those code paths.\n\nCommands that use parent json but return false from machine_output:\n- Gates, Work, Services, Gc, RoleLaunch, Episode, Receipt,\n  Context, Resume, Lane, Push, Restart, Worker, Pipeline, Pr.\n\nAfter S1-S7 add per-subcommand --json flags, update\nsubcommand_requests_machine_output() to check the subcommand-\nlevel flag for every arm. No arm should unconditionally return\nfalse. Commands with both parent and subcommand --json flags\nresolve as `parent_json || subcommand_json`.\n\nAffected file:\n- crates/apm2-cli/src/commands/fac.rs (subcommand_requests_machine_output)\n"
        },
        {
          "id": "S10_DOCTOR_WAIT_FOR_RECOMMENDED_ACTION",
          "title": "`fac doctor --pr <N> --wait-for-recommended-action` — blocking poll loop that exits on actionable state",
          "detail": "This is the main value-add of the ticket. Orchestrators currently\npoll `apm2 fac doctor --pr <N> --json` in a tight loop, parsing\nthe output, checking recommended_action, sleeping, and repeating.\nThis is expensive (LLM reasoning per tick), unreliable (agents\nmisparse or skip polling), and wasteful (most polls return \"wait\").\n\n`--wait-for-recommended-action` moves this polling loop into\ndeterministic Rust: doctor repeatedly evaluates PR state and\nblocks until the recommended_action is something OTHER than\n\"wait\", then exits with the full doctor JSON output. The\norchestrator calls one command and gets back a ready-to-act\ndoctor snapshot.\n\nCLI interface:\n```\napm2 fac doctor --pr 615 --wait-for-recommended-action [--json]\n```\n\nPreconditions:\n(a) `--pr <N>` is REQUIRED when `--wait-for-recommended-action`\n    is set. Doctor without `--pr` returns system health, not a\n    per-PR recommended_action — there's nothing to wait for.\n    If `--pr` is missing, exit immediately with a clear error:\n    \"`--wait-for-recommended-action` requires `--pr <N>`\".\n(b) Incompatible with `--fix`: if both flags are passed, exit\n    immediately with an error. `--fix` is a one-shot repair;\n    `--wait-for-recommended-action` is a blocking observer.\n    They serve opposite purposes.\n\nBehavior:\n(c) On invocation, run `run_doctor_inner()` immediately to get\n    the current DoctorPrSummary.\n(d) Check `summary.recommended_action.action`:\n    - If NOT \"wait\" → the PR needs attention. Emit the full\n      DoctorPrSummary JSON and exit immediately.\n    - If \"wait\" → the PR is in a steady state (reviews running,\n      nothing broken). Enter the poll loop.\n(e) Poll loop:\n    - Sleep for a configurable interval (default 1 second,\n      controlled by `--poll-interval-seconds`). The 1-second\n      default is intentional: `run_doctor_inner()` reads local\n      files only (no network, no subprocess) and completes in\n      single-digit milliseconds. Polling at 1s gives sub-second\n      reaction time to state changes (reviewer crash, verdict\n      written, findings appended) with negligible CPU cost.\n    - Re-run `run_doctor_inner()` to get fresh state.\n    - Check recommended_action against the exit-on set.\n    - If action matches → emit the DoctorPrSummary JSON and exit.\n    - If \"wait\" → continue polling.\n(f) Timeout: the poll loop has a wall-clock timeout (default 60s,\n    controlled by `--wait-timeout-seconds`, hard max 180s). If\n    the timeout expires without the action leaving \"wait\",\n    doctor emits the FULL DoctorPrSummary JSON (identical to a\n    normal doctor invocation) and exits with code 0. This\n    forces the orchestrator back into its dispatch loop — it\n    must re-evaluate, handle other PRs, and re-invoke. The\n    180s hard cap prevents orchestrators from using a huge\n    timeout to avoid doing work.\n    Clap validation: `--wait-timeout-seconds` must be in [5, 180].\n    Values outside this range are rejected at parse time.\n(g) Exit-on filter (`--exit-on`): by default, ANY non-\"wait\"\n    action causes immediate exit (fix, escalate, merge,\n    dispatch_implementor, restart_reviews). The `--exit-on` flag\n    narrows this to a specific subset:\n    ```\n    apm2 fac doctor --pr 615 --wait-for-recommended-action \\\n      --exit-on fix,escalate,merge\n    ```\n    This would keep polling through `dispatch_implementor` and\n    `restart_reviews` — useful when those actions are handled by\n    separate background automation and the orchestrator only\n    wants to wake for terminal or emergency states.\n    If omitted, all non-wait actions trigger exit (default\n    behavior, backwards compatible).\n    Validation: values must be from the closed action vocabulary.\n    Unknown actions are rejected at parse time.\n(h) JSONL streaming mode: when `--json` is active alongside\n    `--wait-for-recommended-action`, emit one JSONL line per\n    poll tick. Intermediate lines are intentionally minimal —\n    just enough for liveness detection and log timestamps:\n    ```\n    {\"event\":\"doctor_poll\",\"tick\":0,\"action\":\"wait\",\"ts\":\"2026-02-14T12:00:01Z\"}\n    {\"event\":\"doctor_poll\",\"tick\":1,\"action\":\"wait\",\"ts\":\"2026-02-14T12:00:02Z\"}\n    {\"event\":\"doctor_poll\",\"tick\":2,\"action\":\"wait\",\"ts\":\"2026-02-14T12:00:03Z\"}\n    ...\n    ```\n    The intermediate `doctor_poll` lines carry only four fields:\n    event, tick, action, ts. No summary, no diagnostics.\n    This is a heartbeat, not a report.\n\n    On exit (action resolved OR timeout), the final line is a\n    `doctor_result` containing the FULL DoctorPrSummary:\n    ```\n    {\"event\":\"doctor_result\",\"tick\":14,\"action\":\"dispatch_implementor\",\"ts\":\"2026-02-14T12:00:15Z\",\"summary\":{...full DoctorPrSummary...}}\n    ```\n    On timeout, the final line is identical but action is \"wait\"\n    and the summary reflects current state — the orchestrator\n    gets a complete snapshot either way.\n\n    An orchestrator that doesn't need heartbeats can ignore all\n    lines except the last.\n(i) Signal handling (SIGINT / SIGTERM): the poll loop installs\n    a signal handler (e.g. via `ctrlc` crate or `signal_hook`).\n    On interrupt:\n    - Run one final `run_doctor_inner()` to get current state.\n    - Emit the DoctorPrSummary as the final JSONL `doctor_result`\n      line (or pretty JSON in text mode).\n    - Exit with code 0.\n    This guarantees the orchestrator always gets a usable\n    snapshot, even on Ctrl-C or process manager kill. Without\n    this, an interrupted wait produces truncated/empty output\n    and the orchestrator has no state to work with.\n(j) Exit codes:\n    - 0: recommended_action resolved to a matching exit-on\n         action, OR timeout expired, OR signal received.\n    - 1: doctor evaluation itself failed (state unreadable,\n         file corruption, etc.), OR precondition violation\n         (missing --pr, incompatible --fix).\n    The exit code does NOT distinguish between action types.\n    The action field in the JSON output is the discriminator.\n\nWhy this matters:\n- Eliminates the polling loop from the LLM orchestrator entirely.\n  The orchestrator calls `doctor --pr <N> --wait-for-recommended-action`\n  and blocks. When it returns, the action field tells the\n  orchestrator exactly what to do next.\n- Reduces orchestrator API cost by ~60x: instead of the LLM\n  being invoked every 30-60s to check status and re-reason,\n  it's invoked once when there's actually something to do.\n- Eliminates the \"orchestrator fell asleep\" failure mode: the\n  Rust poll loop is deterministic and doesn't forget to check.\n- Eliminates the \"orchestrator misinterpreted doctor output\"\n  failure mode: the action vocabulary is closed and machine-\n  readable, and the orchestrator never sees intermediate \"wait\"\n  states.\n- The 60-second default timeout (hard max 180s) is a forcing\n  function: the orchestrator MUST come back into its dispatch\n  loop regularly. Even if reviews take hours, it gets control\n  back to handle other PRs, check global state, log progress.\n  The hard cap prevents lazy orchestrators from setting a 1-hour\n  timeout and going to sleep.\n- Signal safety means the orchestrator always gets a doctor\n  snapshot on return, regardless of how the wait ended (action\n  resolved, timeout, interrupt). No code path produces empty\n  or truncated output.\n\nNew CLI args on DoctorArgs:\n- `--wait-for-recommended-action` (bool flag)\n- `--poll-interval-seconds` (u64, default 1, min 1, max 10)\n- `--wait-timeout-seconds` (u64, default 60, min 5, max 180)\n- `--exit-on` (comma-separated list of actions from the closed\n  vocabulary: fix, escalate, merge, dispatch_implementor,\n  restart_reviews; default: all non-wait actions)\n\nAffected files:\n- crates/apm2-cli/src/commands/fac.rs (DoctorArgs — new flags)\n- crates/apm2-cli/src/commands/fac_review/mod.rs (run_doctor — poll loop, JSONL streaming, signal handler)\n"
        },
        {
          "id": "S11_DEFAULT_JSON_OUTPUT",
          "title": "Make JSON the default output for all fac commands",
          "detail": "After S1-S8 ensure every fac subcommand has a --json flag and\nmachine_output detection, flip the default so agents don't need\nto remember to pass --json.\n\nApproach:\n(a) Change FacCommand.json default from \"false\" to \"true\".\n(b) Add `#[arg(long, default_value_t = false)] pub text: bool`\n    to FacCommand for human-readable opt-in.\n(c) Effective format = if text { text } else { json }.\n(d) Per-subcommand --json flags remain as aliases / overrides\n    but are effectively noops when the parent defaults to json.\n(e) JSONL-streaming commands (gates, push, review run, worker,\n    pipeline) stream compact JSONL by default. The `--text`\n    flag switches them to their existing human-formatted output.\n\nThis is the terminal state: every `apm2 fac` invocation produces\nmachine-parseable output without any flag. Agents work correctly\nout of the box. Humans pass `--text` when they want a table.\n\nAffected file:\n- crates/apm2-cli/src/commands/fac.rs (FacCommand)\n"
        },
        {
          "id": "S12_REMOVE_HUMAN_READABLE_OUTPUT",
          "title": "Remove all human-readable text output paths — JSON-only invariant",
          "detail": "End support for human-readable (text/table) output across all\nFAC commands. Every FAC command must emit JSON or JSONL to\nstdout unconditionally. There is no `--text` escape hatch.\n\nThis supersedes S11's `--text` opt-in approach. The reasoning:\nFAC commands are consumed exclusively by agents and automation.\nMaintaining dual output paths (text + JSON) doubles the testing\nsurface, introduces format-drift bugs where one path is updated\nbut not the other, and adds dead code that no consumer uses.\n\nRequired changes:\n(a) Remove the `--text` flag from FacCommand (if added by S11)\n    and all per-subcommand text-mode output branches.\n(b) Remove all `if !json_output { println!(...) }` text-mode\n    formatting paths, human tables, and human_log! invocations\n    that write to stdout.\n(c) Diagnostic/progress messages may still go to stderr (they\n    are not parsed by consumers), but stdout is reserved\n    exclusively for JSON/JSONL.\n(d) Short-lived commands emit a single pretty-printed JSON\n    object to stdout.\n(e) Long-running commands emit compact JSONL to stdout (one\n    object per line, flushed after each event).\n(f) Error responses are JSON objects on stdout with an `error`\n    field — not bare text on stderr.\n\nInvariant: `apm2 fac <any-subcommand> | jq .` must always\nsucceed (single-object commands) or `apm2 fac <any-subcommand>\n| while read line; do echo \"$line\" | jq .; done` must succeed\n(JSONL-streaming commands).\n\nAffected files:\n- crates/apm2-cli/src/commands/fac.rs (remove --text, remove text branches)\n- crates/apm2-cli/src/commands/fac_review/gates.rs (remove human table)\n- crates/apm2-cli/src/commands/fac_review/push.rs (remove text output)\n- crates/apm2-cli/src/commands/fac_review/repair_cycle.rs (remove text output)\n- crates/apm2-cli/src/commands/fac_review/mod.rs (remove text branches in doctor, wait, status, etc.)\n- All other fac_review/*.rs and fac_*.rs files with text-mode branches\n"
        },
        {
          "id": "S13_GITHUB_COMMENT_CODE_FENCE_ESCAPE",
          "title": "Fix code fence truncation in GitHub PR comment projection",
          "detail": "GitHub-projected comments (verdict decisions, CI status) use\nYAML inside a markdown fenced code block:\n\n    <!-- marker -->\n    ```yaml\n    # marker\n    {serde_yaml output}```\n\nTwo bugs cause code blocks to be truncated or sliced:\n\n1. MISSING NEWLINE BEFORE CLOSING FENCE\n   render_decision_comment_body() in both decision.rs and\n   verdict_projection.rs, and to_comment_body() in ci_status.rs,\n   produce the closing fence as `{yaml}``` ` without a guaranteed\n   newline separator. While serde_yaml::to_string() typically\n   emits a trailing `\\n`, the format string does not defensively\n   ensure one. If any edge case omits it, the closing fence is\n   not on its own line and GitHub does not close the code block.\n\n2. YAML VALUES CONTAINING TRIPLE BACKTICKS\n   Reviewer-generated text fields (reason, finding summary,\n   finding details) may contain markdown code fences (```)\n   within their values. serde_yaml serializes these as-is in\n   block or flow scalars. When embedded inside the outer\n   ```yaml fence, GitHub's markdown parser sees the inner\n   backticks as the closing fence, truncating everything after.\n   The read-side parser extract_fenced_yaml() (decision.rs:441)\n   has the same vulnerability — it searches for \"\\n```\" and\n   matches the first occurrence, which may be inside a YAML\n   value rather than the actual closing fence.\n\nRequired changes:\n(a) Fix the format string in all three render functions to\n    defensively ensure a newline before the closing fence:\n    `format!(\"<!-- {MARKER} -->\\n```yaml\\n# {MARKER}\\n{yaml}\\n```\\n\")`\n    (The extra \\n before ``` is harmless if yaml already ends\n    with \\n, producing a blank line which is valid markdown.)\n(b) Sanitize YAML string values before serialization: replace\n    any occurrence of ``` (triple backtick) within string\n    fields with a safe alternative (e.g., replace backticks\n    with Unicode fullwidth grave accent U+FF40, or HTML entity\n    &#96;&#96;&#96;) to prevent premature fence closure.\n    Alternatively, use a unique fence marker (e.g.,\n    `````yaml ... ````` with 5 backticks) that is statistically\n    unlikely to appear in reviewer text.\n(c) Harden extract_fenced_yaml() to match the closing fence\n    using the same backtick count as the opening fence, and\n    require the closing fence to be on a line by itself (no\n    leading content other than optional whitespace).\n(d) Apply the same fix to ci_status.rs::to_comment_body().\n\nAffected files:\n- crates/apm2-cli/src/commands/fac_review/decision.rs (render_decision_comment_body, extract_fenced_yaml)\n- crates/apm2-cli/src/commands/fac_review/verdict_projection.rs (render_decision_comment_body)\n- crates/apm2-cli/src/commands/fac_review/ci_status.rs (to_comment_body)\n"
        },
        {
          "id": "S14_STRUCTURED_ERROR_OUTPUT",
          "title": "All errors and warnings on stdout must be valid JSON — never break jq",
          "detail": "Several FAC commands currently emit unstructured error/warning\ntext to stdout, which corrupts the JSON stream and breaks\n`jq` parsing. This is the #1 way agents lose parseable output.\n\nCurrent violation patterns:\n\n1. UNSTRUCTURED ERROR LISTS ON STDOUT\n   decision.rs:945-947, findings.rs:438-440, and\n   verdict_projection.rs:1575-1577 print human-formatted error\n   listings to stdout via println!:\n     println!(\"  Errors:\");\n     println!(\"    - {error}\");\n   These lines land in the same stream as JSON output and\n   break any `| jq .` pipeline.\n\n2. MIXED STRUCTURED/UNSTRUCTURED IN SAME COMMAND\n   Some commands emit a JSON payload via println! for the\n   success path but fall through to eprintln!/println! for\n   error paths. An agent piping stdout to jq gets either\n   valid JSON or garbage — no reliable error contract.\n\n3. JSONL STREAM CORRUPTION\n   For JSONL-streaming commands (gates, push, worker), if an\n   error occurs mid-stream, the error must be a valid JSONL\n   line, not bare text. A bare `eprintln!(\"ERROR: ...\")` is\n   safe (stderr, not parsed), but a `println!(\"ERROR: ...\")`\n   mid-JSONL-stream produces an unparseable line.\n\nRequired changes:\n\n(a) Establish the stdout-is-JSON invariant:\n    - stdout MUST contain only valid JSON (single object) or\n      valid JSONL (one JSON object per line). No exceptions.\n    - stderr is the sink for human-readable diagnostics,\n      progress messages, and warnings. These are never parsed\n      by consumers and cannot break jq.\n\n(b) For single-object commands, errors become JSON error\n    objects on stdout:\n      {\"error\": \"<error_code>\", \"message\": \"<detail>\"}\n    This is already the pattern in gates.rs (line 106-113)\n    and lifecycle.rs (line 2907). Normalize all commands to\n    use this pattern.\n\n(c) For JSONL-streaming commands, errors become JSONL event\n    lines on stdout:\n      {\"event\": \"<command>_error\", \"error\": \"<detail>\", \"ts\": \"...\"}\n    The stream remains parseable line-by-line. The consumer\n    detects the error via the event field discriminator.\n\n(d) Audit and fix every println! call in fac_review/ that\n    emits non-JSON content. Specific known violations:\n    - decision.rs:945-947 (error list in text verdict show)\n    - findings.rs:431, 438-440 (error details in text findings)\n    - verdict_projection.rs:1575-1577 (error list in text show)\n    These are text-mode paths that S12 removes entirely.\n    After S12, these code paths no longer exist — but the\n    error information they carried must be preserved as\n    fields within the JSON response (e.g., an `errors: [...]`\n    array in the response struct).\n\n(e) Provide a shared error emission helper alongside the\n    JSONL helper in jsonl.rs:\n    - `fn emit_json_error(code: &str, message: &str)` for\n      single-object error responses.\n    - `fn emit_jsonl_error(event_prefix: &str, message: &str)`\n      for error events within a JSONL stream.\n    Both write to stdout and flush.\n\n(f) Exit codes remain meaningful:\n    - 0: command succeeded (JSON response contains result)\n    - 1: command failed (JSON response contains error)\n    The consumer reads the exit code first, then parses the\n    JSON payload. Both paths produce valid JSON.\n\nContract: for any FAC command invocation, the following must\nhold:\n  `apm2 fac <cmd> [args] 2>/dev/null | jq . >/dev/null`\nmust exit 0 (valid JSON) regardless of whether the command\nitself succeeded or failed. Failures produce JSON error\nobjects, not parse failures.\n\nAffected files:\n- crates/apm2-cli/src/commands/fac_review/jsonl.rs (error helpers)\n- crates/apm2-cli/src/commands/fac_review/decision.rs (remove println! error lists)\n- crates/apm2-cli/src/commands/fac_review/findings.rs (remove println! error lists)\n- crates/apm2-cli/src/commands/fac_review/verdict_projection.rs (remove println! error lists)\n- crates/apm2-cli/src/commands/fac_review/gates.rs (normalize error path)\n- crates/apm2-cli/src/commands/fac_review/push.rs (normalize error path)\n- crates/apm2-cli/src/commands/fac_review/repair_cycle.rs (normalize error path)\n- crates/apm2-cli/src/commands/fac_review/mod.rs (normalize error paths)\n- crates/apm2-cli/src/commands/fac_gc.rs (normalize error path)\n- crates/apm2-cli/src/commands/fac_broker.rs (normalize error path)\n"
        }
      ],
      "out_of_scope": [
        "Non-FAC commands (process management, creds, daemon). Those are a separate ticket.",
        "Changing the semantic content of any command's output — only the wire format changes.",
        "Adding new subcommands.",
        "Changing exit codes or error semantics.",
        "Modifying the NDJSON telemetry file format under ~/.apm2/ — only stdout output changes.",
        "Pretty-printing JSONL — JSONL lines are compact (one object per line); pretty JSON is only for single-object responses.",
        "Human-readable text output — S12 removes all text output paths; no --text flag will exist."
      ]
    },
    "plan": {
      "steps": [
        {
          "id": "STEP_01",
          "title": "Define JSONL event types and streaming helper",
          "detail": "Create a small helper module or function for JSONL output:\n- `fn emit_jsonl(event: &impl Serialize)` — serializes to compact\n  JSON + newline, writes to stdout, flushes.\n- Define event envelope: every JSONL line has `event` (string),\n  `ts` (ISO-8601 timestamp), plus event-specific fields.\n- Define shared event types: GateStarted, GateCompleted,\n  GateError, StageStarted, StageCompleted, for reuse across\n  gates/push/pipeline.\n- Place in a shared location accessible to fac_review submodules\n  (e.g. fac_review/jsonl.rs or a function in fac_review/types.rs).\n"
        },
        {
          "id": "STEP_02",
          "title": "Gates: add --json to GatesArgs and stream JSONL progress",
          "detail": "(a) Add json: bool to GatesArgs.\n(b) Thread the flag through run_gates() and run_gates_inner().\n(c) At each gate boundary in run_gates_inner(), emit JSONL\n    gate_started/gate_completed events.\n(d) Final line: GatesSummary serialized as compact JSONL.\n(e) Update subcommand_requests_machine_output() for Gates.\n"
        },
        {
          "id": "STEP_03",
          "title": "Push: add --json to PushArgs and stream JSONL progress",
          "detail": "(a) Add json: bool to PushArgs.\n(b) Identify the stage boundaries in push.rs (git push, gates,\n    PR update, dispatch).\n(c) Emit JSONL stage events at each boundary.\n(d) Final line: PushSummary with overall result.\n(e) Update subcommand_requests_machine_output() for Push.\n"
        },
        {
          "id": "STEP_04",
          "title": "Restart: add --json to RestartArgs",
          "detail": "(a) Add json: bool to RestartArgs.\n(b) Define RestartResponse struct.\n(c) Single JSON object output (not JSONL — restart is fast).\n(d) Update subcommand_requests_machine_output() for Restart.\n"
        },
        {
          "id": "STEP_05",
          "title": "Lane: add --json to LaneStatusArgs and LaneResetArgs",
          "detail": "(a) Add json: bool to both.\n(b) Define LaneStatusResponse (array of lane entries) and\n    LaneResetResponse.\n(c) Update subcommand_requests_machine_output() for Lane.\n"
        },
        {
          "id": "STEP_06",
          "title": "Review run/dispatch/tail: add --json flags",
          "detail": "(a) Add json: bool to ReviewRunArgs, ReviewDispatchArgs,\n    ReviewTailArgs.\n(b) Review dispatch: single JSON object response.\n(c) Review run: JSONL stream (mirrors telemetry events).\n(d) Review tail: --json is a noop (already NDJSON) but prevents\n    clap rejection.\n(e) Update subcommand_requests_machine_output() for all three.\n"
        },
        {
          "id": "STEP_07",
          "title": "Worker/pipeline: add --json flags with JSONL",
          "detail": "(a) Add json: bool to WorkerArgs and PipelineArgs.\n(b) Worker: JSONL line per job lifecycle event.\n(c) Pipeline: JSONL stage events.\n(d) Update subcommand_requests_machine_output() for both.\n"
        },
        {
          "id": "STEP_08",
          "title": "PR auth-setup/auth-check: add --json flags",
          "detail": "(a) Add json: bool to auth-setup and auth-check args.\n(b) Define response structs.\n(c) Update subcommand_requests_machine_output() for Pr.\n"
        },
        {
          "id": "STEP_09",
          "title": "Decision model provenance: add model_id/backend_id to verdicts and findings",
          "detail": "(a) Add model_id, backend_id (Option<String>) to DecisionEntry\n    and DimensionDecisionView in decision.rs.\n(b) In run_verdict_set(), propagate model_id/backend_id from the\n    calling context (ReviewRunState) into the DecisionEntry.\n(c) Add model_id, backend_id to StoredFinding in findings_store.rs.\n(d) Add --model-id and --backend-id optional args to ReviewFindingArgs\n    in fac.rs; thread through to finding append logic.\n(e) Update verdict_projection.rs to include model provenance in\n    the GitHub decision comment YAML payload.\n(f) Use #[serde(default, skip_serializing_if = \"Option::is_none\")]\n    on all new fields.\n"
        },
        {
          "id": "STEP_10",
          "title": "Doctor --wait-for-recommended-action: poll loop with JSONL heartbeats",
          "detail": "(a) Add `--wait-for-recommended-action`, `--poll-interval-seconds`\n    (default 1, clap range 1..=10), `--wait-timeout-seconds`\n    (default 60, clap range 5..=180), `--exit-on` (optional\n    comma-separated action list) to DoctorArgs in fac.rs.\n(b) Precondition validation in run_doctor():\n    - Reject if --pr is missing (\"requires --pr <N>\").\n    - Reject if --fix is also set (\"incompatible with --fix\").\n    - Parse and validate --exit-on values against closed vocab.\n(c) In run_doctor(), when wait_for_recommended_action is true:\n    - Run initial run_doctor_inner(). If action matches exit-on\n      set, emit full DoctorPrSummary and return immediately.\n    - Enter poll loop: sleep(1s), re-run run_doctor_inner(),\n      check action against exit-on set. Emit minimal JSONL\n      heartbeat per tick when json_output is true.\n    - On match OR timeout: emit final DoctorPrSummary (as JSONL\n      doctor_result with full summary, or pretty JSON) and exit.\n      Both action-resolved and timeout produce the full snapshot.\n(d) The poll loop must be a simple synchronous thread::sleep loop\n    (same pattern as run_wait_inner in the same module). No async.\n(e) JSONL heartbeat: { event: \"doctor_poll\", tick, action, ts }.\n    Minimal — just liveness + timestamp. No diagnostics, no\n    summary payload.\n    Final line: { event: \"doctor_result\", tick, action, ts,\n    summary: {full DoctorPrSummary} }.\n(f) Text mode: print one-line status per tick to stderr (not\n    stdout) for progress indication; final DoctorPrSummary to\n    stdout as pretty JSON (same as current doctor behavior).\n(g) Signal handler: install SIGINT/SIGTERM handler (via ctrlc\n    crate or signal_hook). On signal, run one final\n    run_doctor_inner(), emit the DoctorPrSummary as the final\n    line, exit 0. This guarantees the orchestrator always gets\n    a usable snapshot.\n(h) Exit code: 0 in all cases except doctor evaluation failure\n    or precondition violation.\n"
        },
        {
          "id": "STEP_11",
          "title": "Audit subcommand_requests_machine_output() — no false arms",
          "detail": "After STEP_02-STEP_08, verify that every arm of\nsubcommand_requests_machine_output() checks a subcommand-level\njson flag. Remove the catch-all false arm entirely — every\nvariant must be explicitly handled.\n"
        },
        {
          "id": "STEP_12",
          "title": "Flip default: FacCommand.json = true, add --text opt-in",
          "detail": "(a) Change FacCommand.json default_value from \"false\" to \"true\".\n(b) Add text: bool to FacCommand.\n(c) Resolve format as: if text { text } else { json }.\n(d) Verify all text-mode paths still work when --text is passed.\n"
        },
        {
          "id": "STEP_13",
          "title": "cargo fmt, clippy, doc, test",
          "detail": "Mandatory pre-commit checks."
        }
      ]
    },
    "definition_of_done": {
      "evidence_ids": [],
      "criteria": [
        "Every `apm2 fac` subcommand accepts `--json` without clap rejection.",
        "When `--json` is active, every fac command outputs valid JSON or valid JSONL to stdout.",
        "Short-lived commands (restart, lane status/reset, review dispatch, review findings, review verdict, doctor, etc.) output a single pretty-printed JSON object.",
        "Long-running commands (gates, push, review run, worker, pipeline) stream compact JSONL to stdout — one JSON object per line, flushed after each event.",
        "Every JSONL stream has a final summary line that contains the complete result (GatesSummary, PushSummary, etc.).",
        "JSONL events include an `event` field (string discriminator) and a `ts` field (ISO-8601 timestamp).",
        "Error events in JSONL streams are JSON objects with `event: \"..._error\"` — not bare text on stderr.",
        "subcommand_requests_machine_output() has no catch-all `false` arm — every FacSubcommand variant is explicitly handled.",
        "FacCommand.json defaults to true — agents get structured output without passing any flag.",
        "No `--text` flag exists. No human-readable text output path exists. All stdout is JSON or JSONL unconditionally.",
        "`fac gates --json` streams per-gate JSONL events (gate_started, gate_completed) followed by a gates_summary line.",
        "`fac push --json` streams per-stage JSONL events (git_push, gates, pr_update, dispatch) followed by a push_summary line.",
        "`fac restart --json` outputs a single RestartResponse JSON object.",
        "`fac lane status --json` outputs a JSON array of lane objects.",
        "`fac lane reset --json` outputs a single LaneResetResponse JSON object.",
        "`fac review run --json` streams JSONL review progress events.",
        "`fac review dispatch --json` outputs a single DispatchResponse JSON object.",
        "`fac review tail --json` is accepted without error (already NDJSON).",
        "`fac worker --json` streams per-job JSONL lifecycle events.",
        "`fac pr auth-check --json` outputs a structured auth status JSON object.",
        "`fac pr auth-setup --json` outputs a structured setup result JSON object.",
        "`apm2 fac review verdict show --json` includes `model_id` and `backend_id` per dimension, identifying which model produced each verdict.",
        "`apm2 fac review verdict set` persists `model_id` and `backend_id` in the DecisionEntry when provided by the calling reviewer.",
        "`apm2 fac review findings --json` includes `model_id` and `backend_id` on each StoredFinding when available.",
        "`apm2 fac review finding` accepts `--model-id` and `--backend-id` optional args to tag findings with model provenance.",
        "Auto-verdict (reaper-derived verdicts) populates model_id/backend_id from the reaped agent's ReviewRunState.",
        "GitHub-projected decision comments include model provenance per dimension in the YAML payload.",
        "New model_id/backend_id fields use `#[serde(default, skip_serializing_if = \"Option::is_none\")]` for backwards compatibility with existing stored artifacts.",
        "`apm2 fac doctor --pr <N> --wait-for-recommended-action` blocks until recommended_action is not 'wait' (or matches `--exit-on` filter), then exits with the full DoctorPrSummary JSON.",
        "`--wait-for-recommended-action` without `--pr` is rejected with a clear error message.",
        "`--wait-for-recommended-action` exits immediately when the first doctor evaluation returns an action matching the exit-on set (default: all non-wait actions).",
        "`--exit-on` accepts a comma-separated list of actions from the closed vocabulary (fix, escalate, merge, dispatch_implementor, restart_reviews). Unknown action names are rejected at parse time.",
        "`--exit-on` omitted means all non-wait actions trigger exit (backwards-compatible default).",
        "`--wait-for-recommended-action` exits after `--wait-timeout-seconds` (default 60, hard max 180) if the action remains 'wait'. On timeout, the full DoctorPrSummary JSON is emitted (identical to a normal doctor invocation) with exit code 0.",
        "`--wait-timeout-seconds` is clamped to [5, 180] at parse time. Values outside this range are rejected by clap.",
        "`--wait-for-recommended-action` polls at `--poll-interval-seconds` (default 1, min 1, max 10). 1s polling is safe because `run_doctor_inner()` reads only local files and completes in single-digit milliseconds.",
        "`--wait-for-recommended-action` + `--json` streams minimal JSONL heartbeat lines (`doctor_poll`) per tick containing only event, tick, action, and ts fields.",
        "On exit (action resolved, timeout, or signal), the final JSONL line is `doctor_result` containing the complete DoctorPrSummary in a `summary` field.",
        "`--wait-for-recommended-action` + `--fix` is rejected with an error (mutually exclusive flags).",
        "`--wait-for-recommended-action` exit code is 0 for action resolved, timeout expired, or signal received; exit code 1 only for doctor evaluation failures or precondition violations.",
        "SIGINT and SIGTERM during `--wait-for-recommended-action` trigger a graceful exit: one final `run_doctor_inner()` call, emit the full DoctorPrSummary, exit 0. The orchestrator always gets a usable snapshot.",
        "All response and event structs derive Serialize (and Deserialize where appropriate).",
        "All evidence gates and tests pass.",
        "No FAC command emits unstructured text to stdout under any flag combination. `stdout` is exclusively JSON/JSONL.",
        "All human-readable text output paths (tables, progress messages, human_log! to stdout) are removed.",
        "Diagnostic/progress messages to stderr are permitted but never parsed by consumers.",
        "GitHub-projected verdict comments use a fenced code block with a guaranteed newline before the closing fence.",
        "YAML values embedded in GitHub comment code fences are sanitized: triple backticks within YAML string fields cannot prematurely close the markdown code fence.",
        "extract_fenced_yaml() correctly identifies the closing fence even when YAML content contains backtick sequences.",
        "CI status comments (ci_status.rs) apply the same code fence fix as verdict comments.",
        "For any FAC command invocation: `apm2 fac <cmd> [args] 2>/dev/null | jq . >/dev/null` exits 0 regardless of command success or failure.",
        "Failed commands emit a JSON error object to stdout (`{\"error\": \"<code>\", \"message\": \"<detail>\"}`) — not bare text.",
        "Errors mid-JSONL-stream are valid JSONL event lines with an `event` field ending in `_error` — the stream remains parseable line-by-line.",
        "No `println!` call in any FAC command emits non-JSON content to stdout.",
        "Shared error emission helpers (`emit_json_error`, `emit_jsonl_error`) exist in the JSONL helper module for consistent error formatting.",
        "Error information previously carried by text-mode println! paths (error lists in verdict show, findings, verdict projection) is preserved as `errors: [...]` arrays within JSON response structs."
      ]
    },
    "notes": {
      "context": "This ticket addresses a usability bug that affects every LLM agent\ninteracting with the `apm2 fac` CLI. Agents uniformly assume `--json`\nexists on all fac subcommands because it exists on most of them. The\ninconsistency is the bug, not the agent behavior.\n\nThe JSONL streaming dimension solves a second problem: long-running\ncommands (gates, push, review run, worker) produce no output for\nminutes in JSON mode, giving agents zero signal about progress. JSONL\ngives real-time per-stage observability without requiring a separate\npolling mechanism.\n\nThe centerpiece feature is `--wait-for-recommended-action` on the\ndoctor command (S10). This eliminates the orchestrator polling loop\nentirely. Instead of the LLM being invoked every 30-60s to call\ndoctor, parse output, decide whether to act, and sleep — the Rust\nCLI does the polling and only returns when there's something to do.\nThe orchestrator becomes: call doctor --wait-for-recommended-action,\nread the action field, dispatch. One API call per actionable event\ninstead of one per tick.\n\nDesign invariants:\n- JSONL uses compact serialization (one object per line, no pretty-print).\n  Single-object responses use pretty-print for human debuggability.\n- Every JSONL stream ends with a summary line. Consumers can ignore\n  intermediate events and read only the last line for the final result.\n- stderr is reserved for diagnostics that should never be parsed.\n  All structured output goes to stdout.\n- There is no --text flag. JSON is the only output format. S12\n  supersedes S11's --text opt-in approach: all consumers are agents,\n  dual output paths are dead code and a maintenance hazard.\n\nPriority: P0 (--wait-for-recommended-action), P1 (JSON parity,\nmodel provenance, GitHub comment fix).\nComplexity: Medium-high — the JSON parity work is mechanical, but\n--wait-for-recommended-action requires careful poll loop design,\nJSONL heartbeat streaming, timeout handling, and exit code semantics.\n"
    }
  }
}
