{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-25",
    "template_version": "2026-01-25",
    "ticket": {
      "id": "TCK-00079",
      "title": "Fix check --watch Terminal State Handling"
    },
    "binds": {
      "prd_id": "NONE",
      "rfc_id": "RFC-0006",
      "requirements": [
        {
          "requirement_id": "CHECK-001",
          "requirement_ref": "documents/rfcs/RFC-0006/01_problem_and_imports.yaml#rfc_local_requirements.requirements[20]"
        }
      ],
      "evidence_artifacts": []
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_BUILD_RELEASE"
      ]
    },
    "dependencies": {
      "tickets": []
    },
    "scope": {
      "in_scope": [
        "Add exit on PrState::Closed with exit code 1",
        "Add exit on CiStatus::Failure with exit code 1",
        "Add exit on ReviewStatus::ChangesRequested with exit code 1",
        "Add 180s default timeout (non-configurable)",
        "On timeout exit with code 2 and suggest manually restart",
        "Print clear message indicating why watch exited"
      ],
      "out_of_scope": [
        "Configurable timeout duration",
        "Partial success exit codes",
        "Notification on timeout"
      ]
    },
    "plan": {
      "steps": [
        "Add WATCH_TIMEOUT_SECS constant = 180",
        "Track elapsed time in watch loop using Instant::now()",
        "Check for terminal states in watch loop",
        "Exit on PrState::Closed with message and exit code 1",
        "Exit on CiStatus::Failure with message and exit code 1",
        "Exit on ReviewStatus::ChangesRequested with message and exit code 1",
        "Check elapsed time each iteration",
        "Exit on timeout with code 2 and remediation message",
        "Message: Timeout after 180s. Suggestion: manually restart slow checks",
        "Update run() to return Result<ExitCode>",
        "Verify cargo build succeeds",
        "Verify cargo test passes",
        "Verify cargo clippy passes with no warnings"
      ]
    },
    "definition_of_done": {
      "evidence_ids": [],
      "criteria": [
        "check --watch exits on PrState::Closed (exit code 1)",
        "check --watch exits on CiStatus::Failure (exit code 1)",
        "check --watch exits on ReviewStatus::ChangesRequested (exit code 1)",
        "check --watch exits after 180s timeout (exit code 2)",
        "Timeout message suggests manually restarting slow checks",
        "Clear message printed for each exit condition",
        "cargo build succeeds",
        "cargo test passes",
        "cargo clippy passes with no warnings"
      ]
    },
    "notes": {
      "security": "The 180s timeout prevents indefinite hangs that could:\n- Block CI resources indefinitely\n- Leave terminal sessions unattended\n- Mask underlying infrastructure issues\n",
      "implementation_details": "```rust\n// xtask/src/tasks/check.rs additions\n\nuse std::time::Instant;\nuse std::process::ExitCode;\n\n/// Watch mode timeout in seconds.\nconst WATCH_TIMEOUT_SECS: u64 = 180;\n\n/// Exit code for watch timeout.\nconst EXIT_TIMEOUT: u8 = 2;\n\n/// Result of watch mode with exit information.\n#[derive(Debug)]\npub enum WatchExitReason {\n    Merged,\n    Closed,\n    CiFailed(Vec<String>),\n    ChangesRequested,\n    Timeout,\n}\n\nimpl WatchExitReason {\n    pub fn exit_code(&self) -> ExitCode {\n        match self {\n            Self::Merged => ExitCode::SUCCESS,\n            Self::Closed | Self::CiFailed(_) | Self::ChangesRequested => {\n                ExitCode::from(1)\n            }\n            Self::Timeout => ExitCode::from(EXIT_TIMEOUT),\n        }\n    }\n\n    pub fn message(&self) -> String {\n        match self {\n            Self::Merged => \"PR merged successfully!\".to_string(),\n            Self::Closed => \"PR was closed without merging.\".to_string(),\n            Self::CiFailed(checks) => format!(\n                \"CI failed: {}\\nFix the failures and push again.\",\n                checks.join(\", \")\n            ),\n            Self::ChangesRequested => {\n                \"Changes requested by reviewer.\\n\\\n                 Address feedback and push again.\".to_string()\n            }\n            Self::Timeout => format!(\n                \"Timeout after {}s waiting for checks.\\n\\\n                 Suggestion: Manually restart slow checks or investigate CI.\",\n                WATCH_TIMEOUT_SECS\n            ),\n        }\n    }\n}\n\n// In run() watch loop:\nif watch {\n    let start = Instant::now();\n\n    loop {\n        let status = check_status(&sh, &branch_name)?;\n        print_status(&status);\n        display_reviewer_health(&sh)?;\n\n        // Check terminal states\n        if status.pr_state == Some(PrState::Merged) {\n            let reason = WatchExitReason::Merged;\n            println!(\"\\n{}\", reason.message());\n            return Ok(reason.exit_code());\n        }\n\n        if status.pr_state == Some(PrState::Closed) {\n            let reason = WatchExitReason::Closed;\n            println!(\"\\n{}\", reason.message());\n            return Ok(reason.exit_code());\n        }\n\n        if let Some(CiStatus::Failure(checks)) = &status.ci {\n            let reason = WatchExitReason::CiFailed(checks.clone());\n            println!(\"\\n{}\", reason.message());\n            return Ok(reason.exit_code());\n        }\n\n        if status.review == Some(ReviewStatus::ChangesRequested) {\n            let reason = WatchExitReason::ChangesRequested;\n            println!(\"\\n{}\", reason.message());\n            return Ok(reason.exit_code());\n        }\n\n        // Check timeout\n        if start.elapsed().as_secs() >= WATCH_TIMEOUT_SECS {\n            let reason = WatchExitReason::Timeout;\n            println!(\"\\n{}\", reason.message());\n            return Ok(reason.exit_code());\n        }\n\n        println!(\"\\nPolling in 10s... (Ctrl+C to stop)\");\n        thread::sleep(Duration::from_secs(10));\n    }\n}\n```\n",
      "affected_files": "Modified: xtask/src/tasks/check.rs (add terminal state handling and timeout)\n"
    }
  }
}
