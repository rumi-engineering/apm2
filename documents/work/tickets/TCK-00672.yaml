ticket_meta:
  schema_version: '2026-01-29'
  template_version: '2026-01-29'
  ticket:
    id: TCK-00672
    title: 'FAC vNext: end-to-end changeset identity wiring (remove synthetic changeset_digest; gates/review/merge consume ChangeSetPublished)'
    status: OPEN
  binds:
    prd_id: PRD-PLACEHOLDER
    rfc_id: RFC-0032
    requirements: []
    evidence_artifacts: []
  custody:
    agent_roles:
    - AGENT_IMPLEMENTER
    responsibility_domains:
    - DOMAIN_DAEMON
    - DOMAIN_PROTOCOL
    - DOMAIN_CORE
    - DOMAIN_ORCHESTRATION
    - DOMAIN_CLI
    - DOMAIN_DATA
    - DOMAIN_SECURITY
    - DOMAIN_OBSERVABILITY
  dependencies:
    tickets:
    - ticket_id: TCK-00631
      reason: Canonical ledger append path is available for ChangeSetPublished + downstream events (no legacy dual-write surprises).
    - ticket_id: TCK-00640
      reason: '`apm2 fac push --work-id` publishes ChangeSetBundleV1 + terminal contract markers + PR association.'
    - ticket_id: TCK-00641
      reason: CI processor consumes ChangeSetPublished and maintains `work_latest_changeset` projection + emits CI state transitions.
    - ticket_id: TCK-00647
      reason: Implementer/reviewer dispatch is daemon-owned so `fac push` runs inside a session attempt with well-defined terminal contract markers.
    - ticket_id: TCK-00671
      reason: OrchestratorKernel harness exists (cursor-driven, restart-safe orchestrators) for wiring ChangeSetPublished -> gates -> review -> merge.
root_cause_analysis:
  summary: |-
    The current FAC wiring still contains a synthetic `changeset_digest` derived from (session_id, work_id) at session termination time.
    That digest is not the digest of any published ChangeSetBundleV1 and therefore breaks:
      - binding of gates/reviews/merges to a real, reproducible patch,
      - topic derivation + projections keyed by changeset identity,
      - safety checks that rely on "latest changeset for work" semantics (RFC-0032 ยง11.2).
    The result is a pipeline that can appear to work while silently operating on non-existent or stale changesets.
  current_behavior: |-
    - On SessionTerminated, daemon synthesizes changeset_digest = BLAKE3(session_id || work_id).
    - GateOrchestrator is invoked with this synthetic digest.
    - Any downstream receipts/leases keyed by this digest cannot be verified against CAS or ChangeSetPublished and are not replay-safe.
  desired_behavior: |-
    - The ONLY admissible changeset_digest is `ChangeSetBundleV1.compute_digest()` over canonical bundle bytes.
    - The authoritative binding work_id <-> changeset_digest <-> cas_hash is `ChangeSetPublished`.
    - Gates/review/merge orchestration is triggered from (or reconciled against) ChangeSetPublished and must apply the "latest changeset" rule.
    - Session termination MUST NOT invent changeset identity.
scope:
  in_scope:
  - id: CSID-001
    title: Eliminate synthetic changeset_digest derivation
    detail: |-
      Remove any code path that derives a changeset digest from session_id/work_id (or any other non-bundle source).
      All orchestration inputs must originate from ChangeSetPublished (or from loading a ChangeSetBundleV1 from CAS and computing its digest).
  - id: CSID-002
    title: Make ChangeSetPublished the single source of truth for work<->changeset identity
    detail: |-
      Ensure every component that needs (work_id, changeset_digest, cas_hash) obtains it from:
        - the ChangeSetPublished kernel event payload, or
        - a projection derived exclusively from ChangeSetPublished (e.g., work_latest_changeset).
      No other event may introduce a new mapping between work_id and changeset_digest.
  - id: CSID-003
    title: Trigger gate orchestration from ChangeSetPublished (authoritative, restart-safe)
    detail: |-
      Gates must start when a new ChangeSetPublished is committed.
      The gate orchestration MUST be restart-safe and idempotent on (work_id, changeset_digest) using OrchestratorKernel effect journaling.
      SessionTerminated may still exist for lifecycle/accounting, but MUST NOT be used as the primary gate trigger.
  - id: CSID-004
    title: Downstream consumers (CI transitions, review, merge) enforce the latest-changeset rule
    detail: |-
      For any work_id, only receipts/leasing outcomes bound to the current `work_latest_changeset` digest are admissible for:
        - CiPending -> ReadyForReview / Blocked
        - starting review
        - merge + WorkCompleted
      Receipts for older digests must be ignored (and optionally recorded as stale evidence).
  - id: CSID-005
    title: End-to-end integration coverage
    detail: |-
      Add an end-to-end test (single-process harness) that publishes a changeset and observes:
        ChangeSetPublished -> gate leases -> gate receipts -> CI state transition -> review receipt -> merge receipt.
      The test must assert that every stage uses the SAME changeset_digest from ChangeSetPublished and that no synthetic digest path is invoked.
  out_of_scope:
  - id: CSID-OOS-001
    title: New gate types / expanding CI policy surface
    detail: This ticket wires identity; it does not add new gates, a new policy DSL, or new gate executor implementations.
  - id: CSID-OOS-002
    title: Distributed/multi-machine orchestration rollout
    detail: |-
      The implementation must be compatible with multi-machine scaling (cursor-driven orchestration, idempotency, no in-memory-only truth),
      but does not need to ship cross-host coordination, sharded runners, or networked CAS.
plan:
  steps:
  - id: STEP_01
    title: Delete synthetic changeset_digest generation and any SessionTerminated->gates coupling
    detail: |-
      Code removal (fail-closed, no transitional fallback):

      1. Remove the synthetic digest derivation in the SessionTerminated path.
         - Current location (pre-cutover): `crates/apm2-daemon/src/protocol/session_dispatch.rs` in the
           `handle_session_terminated` section.
         - Delete the block that does:
             - `blake3::Hasher::new(); hasher.update(session_id); hasher.update(work_id); ...`
             - `GateOrchestrator::on_session_terminated(SessionTerminatedInfo{ changeset_digest: <synthetic> ... })`
             - emits `gate.*` as session-scoped events.

      2. Replace with one of the following (choose A as default):
         A) No-op: SessionTerminated remains a lifecycle event only; gates are triggered elsewhere (STEP_04).
         B) Transitional lookup (ONLY if required for backwards-compat during cutover):
            - Look up `work_latest_changeset` projection for work_id.
            - If missing, do not start gates; emit a structured defect record (see STEP_09) and keep work in InProgress.
            - If present, call the new gate-start API using the *published* digest.
            - Guard behind an explicit config flag (default OFF) so the system is not silently dependent on session termination.

      3. Delete any remaining call sites that attempt to bootstrap CI/gates from SessionTerminated without going through
         ChangeSetPublished.

      Acceptance for this step:
      - `rg "Derive changeset_digest"` returns nothing.
      - There is no code that constructs changeset digests from session_id/work_id.
      - A SessionTerminated event can occur with zero effect on gate start.
  - id: STEP_02
    title: Standardize the changeset identity object and retrieval path (work<->changeset is only from ChangeSetPublished)
    detail: |-
      Introduce a single, shared struct representing the authoritative identity of a changeset *as published*:

      - `ChangesetPublication` (suggested fields):
          - `work_id: String`
          - `changeset_digest: [u8; 32]` (raw bytes, not hex)
          - `bundle_cas_hash: [u8; 32]` (raw bytes)
          - `published_at_ms: u64`
          - `publisher_actor_id: String`
          - `changeset_published_event_id: String`

      Required constructors:
        - `try_from(ChangeSetPublishedKernelEventPayload)` (authoritative)
        - `try_from(WorkLatestChangesetProjectionRecord)` (derived; must include the ChangeSetPublished event_id)

      Required invariants:
        - `changeset_digest == ChangeSetBundleV1::compute_digest(bundle_bytes)` when bundle is loaded from CAS.
        - `bundle_cas_hash` MUST refer to a CAS blob that decodes to a ChangeSetBundleV1.
        - `bundle.diff_hash` MUST exist in CAS (because Workspace::apply_changeset_bundle retrieves diff bytes by diff_hash).

      Implementation guidance:
        - Keep the struct in a place accessible to orchestrators (likely `apm2-core::fac` or `apm2-daemon::fac`).
        - Prefer raw `[u8; 32]` internally; only hex encode at the boundary.
        - Add a small helper `load_and_validate_bundle(publication, cas) -> ChangeSetBundleV1` that:
            1) retrieves bundle bytes from CAS
            2) decodes bundle
            3) recomputes digest and compares (constant time)
            4) verifies diff_hash exists in CAS and is <= MAX_CAS_READ_SIZE
            5) returns bundle

      This step is primarily about forcing every downstream consumer to obtain identity through the same API.
  - id: STEP_03
    title: Refactor GateOrchestrator entrypoint to start from ChangeSetPublished (not SessionTerminated)
    detail: |-
      Gate orchestration must be keyed by the published changeset identity.

      1. Replace the SessionTerminated-specific API:
         - Deprecate/remove `SessionTerminatedInfo` and `GateOrchestrator::on_session_terminated(...)`.
         - Introduce `GateStartInfo` or reuse `ChangesetPublication` as the input.

      2. Idempotency semantics:
         - The idempotency key MUST be stable across restarts and MUST be a pure function of authoritative input.
         - Use: `idempotency_key = "gate_start:" + work_id + ":" + hex(changeset_digest)`
           (or equivalent using raw bytes).
         - Remove session_id from the idempotency key.

      3. State model:
         - The orchestration record MUST store the changeset_digest and the ChangeSetPublished event_id it was derived from.
         - Any gate leases/receipts emitted by the orchestrator must include changeset_digest.

      4. Staleness handling (latest-changeset rule):
         - On receipt ingestion, the orchestrator (or the CI processor if that owns transitions) MUST compare
           receipt.changeset_digest to `work_latest_changeset.changeset_digest`.
         - If mismatch: ignore receipt as stale; optionally emit a `defect.stale_receipt` record.

      5. Compatibility:
         - If there are any remaining code paths that call the old API, they must be migrated in this step.
         - There must be exactly one gate-start API in the daemon codebase after this step.
  - id: STEP_04
    title: Wire ChangeSetPublished -> gate start via OrchestratorKernel (cursor-driven, restart-safe)
    detail: |-
      Implement an internal daemon orchestrator that *authoritatively* triggers gate start from ChangeSetPublished.

      Key requirements:
        - MUST consume authoritative ledger events (not best-effort pulses).
        - MUST persist a cursor/checkpoint.
        - MUST persist effect journal entries so a crash after issuing leases does not duplicate work on restart.

      Implementation sketch (post-TCK-00671):
        - New orchestrator: `GateStartOrchestrator` (or fold into CI processor if already present).
        - Reducer input: `KernelEvent` stream.
        - Reducer reacts to `KernelEvent.payload == ChangeSetPublished`:
            - derive `ChangesetPublication`
            - emit effect `StartGates(publication)`
        - Effect handler for `StartGates`:
            - (optional) validate CAS bundle + diff exist using helper from STEP_02
            - call `GateOrchestrator::start_for_changeset(publication)`
            - append canonical events produced by the orchestrator (policy resolved, gate leases, etc.)

      Idempotency:
        - OrchestratorKernel effect key: (work_id, changeset_digest, "StartGates").
        - If the same ChangeSetPublished is replayed, the effect handler must be a no-op.

      Failure behavior (fail closed):
        - If StartGates fails (CAS missing, decode fails, policy resolution fails):
            - Do NOT emit partial gate leases.
            - Emit a structured defect record tied to (work_id, changeset_digest).
            - Ensure work does not incorrectly advance to ReadyForReview.
              (Depending on existing CI processor semantics: keep CiPending + mark Blocked, or transition directly to Blocked.)
  - id: STEP_05
    title: 'Ensure canonical event emission: PolicyResolved / GateLeaseIssued / GateReceiptRecorded bind to published digest'
    detail: |-
      This step is the mechanical wiring that makes the identity chain real and replayable.

      Requirements:
        - Every event that references a changeset MUST include `changeset_digest`.
        - Every event MUST be append-only to the canonical ledger (KernelEvent payload), not session-local ad hoc logs.
        - All signatures must use the correct domain prefix and include the digest bytes.

      Concrete outputs:
        - On gate start:
            - append `PolicyResolvedForChangeSet { work_id, changeset_digest, ... }`
            - append `GateLeaseIssued { lease_id, work_id, changeset_digest, gate_type, ... }` (one per required gate)
        - On gate completion:
            - append `GateReceiptRecorded { lease_id, work_id, changeset_digest, outcome, evidence_refs, ... }`

      Sanity checks:
        - The GateLeaseIssued payload must be sufficient for a gate executor to reconstruct the workspace
          by loading bundle+diff from CAS (via changeset_digest -> ChangeSetPublished -> cas_hash).
        - Receipt verification must reject receipts where (lease_id, changeset_digest) mismatch.

      NOTE: If any of these canonical events already exist post-open-TCK cutover, this step becomes:
        - Delete the remaining legacy/session event emissions and ensure the canonical path is the only one.
  - id: STEP_06
    title: Wire CI transitions, review start, and merge admission to the latest published digest
    detail: |-
      Enforce RFC-0032 ยง11.2 at every stage boundary.

      1) CI transitions (post-TCK-00641):
        - When observing GateReceiptRecorded for work_id:
            - load `work_latest_changeset` (must be derived from ChangeSetPublished)
            - if receipt.changeset_digest != latest.changeset_digest:
                - ignore (stale)
                - optionally emit defect
            - else process receipt and emit:
                - WorkTransitioned(CiPending -> ReadyForReview) if all required gates passed
                - WorkTransitioned(CiPending -> Blocked) if any required gate failed

      2) Review start:
        - Review orchestrator must only start when work state is ReadyForReview.
        - It must bind the review lease/request to `work_latest_changeset.changeset_digest`.
        - ReviewReceiptRecorded must include the digest and must be ignored as stale if digest != latest at processing time.

      3) Merge admission:
        - Merge executor/admitter must require:
            - all required gates passed for latest digest
            - review approved for latest digest
            - (optional) PR association exists for work_id and still points to same commit basis
        - If the merge is attempted for a non-latest digest, abort and emit a defect.

      The outcome of this step is that "latest digest" is not a convention, it is enforced.
  - id: STEP_07
    title: 'Projection + topic derivation: index changeset->work directly from ChangeSetPublished (early, authoritative)'
    detail: |-
      Ensure every consumer can discover work_id for a given changeset_digest without waiting for policy resolution.

      1) ChangesetWorkIndex:
        - Update the changeset->work mapping to be populated from ChangeSetPublished directly.
        - If PolicyResolvedForChangeSet also carries the mapping, keep it as a redundant/consistency signal but not the primary.
        - Add an invariant check: if PolicyResolvedForChangeSet claims a (work_id, changeset_digest) mapping that differs from
          the mapping recorded from ChangeSetPublished, treat as corruption and fail closed.

      2) Topic derivation:
        - Ensure ChangeSetPublished derives topics:
            - `work.<work_id>.events`
            - `changeset.<hex(digest)>.events`
            - (optional) `fac.events`
        - Ensure downstream events (leases/receipts/reviews/merge) also emit both work and changeset topics.

      3) Pulse plane:
        - If pulses are used for UI/CLI, ensure a ChangeSetPublished pulse is emitted.
        - Pulses remain best-effort; correctness must never depend on pulses.
  - id: STEP_08
    title: 'End-to-end integration test: publish changeset -> gates -> review -> merge; verify digest continuity'
    detail: |-
      Add a single-process integration test that proves end-to-end wiring and eliminates the synthetic digest regression permanently.

      Test name (suggested): `hef_fac_vnext_changeset_identity_e2e`.

      Test setup:
        - Start daemon in-process (or using existing harness) with a durable CAS + ledger.
        - Create/claim a work item W.
        - Create a real diff in a scratch repo or fixture workspace.
        - Store diff bytes in CAS (so bundle.diff_hash resolves).
        - Construct ChangeSetBundleV1 with:
            - correct diff_hash
            - file_manifest matching diff
            - base_ref and other required metadata
        - Call PublishChangeSet(work_id=W, lease_id=L, bundle_bytes=<canonical JSON>).
        - Capture response changeset_digest D and cas_hash H.

      Assertions (authoritative ledger events):
        1) A ChangeSetPublished event exists for (W, D) and contains cas_hash == H.
        2) work_latest_changeset(W) == D.
        3) Gate leases exist and every GateLeaseIssued has changeset_digest == D.
        4) Gate receipts recorded for the work have changeset_digest == D.
        5) Work transitions to ReadyForReview only due to receipts bound to D.
        6) Review receipt recorded has changeset_digest == D.
        7) Merge receipt recorded (or merge decision) has changeset_digest == D.

      Regression assertions:
        - There is no reference anywhere in the event stream to a digest equal to BLAKE3(session_id || work_id).
          (Implement as: confirm that all digests referenced by gate/review/merge events are discoverable via ChangeSetPublished.)

      Staleness sub-test:
        - Publish a second changeset D2 for the same work.
        - Ensure receipts for D do NOT transition work after D2 is published.
        - Ensure only D2 can drive ReadyForReview/merge.
  - id: STEP_09
    title: 'Defect recording for identity-chain violations (fail closed, self-debuggable)'
    detail: |-
      Because the pipeline is autonomous, failures must be machine-triageable.

      Add a structured defect event/record type (or reuse existing defect channel) with at least:
        - defect_code (enum):
            - MISSING_CHANGESET_PUBLISHED
            - CAS_BUNDLE_NOT_FOUND
            - CAS_DIFF_NOT_FOUND
            - BUNDLE_DIGEST_MISMATCH
            - STALE_RECEIPT_IGNORED
            - MERGE_NON_LATEST_ABORTED
        - work_id
        - changeset_digest (when applicable)
        - triggering_event_id
        - human-readable summary (bounded)

      Emit defects when:
        - a stage boundary cannot resolve the latest changeset
        - a receipt arrives for a stale digest
        - a merge/review attempt targets non-latest digest
        - CAS content is missing/mismatched

      Defects must be append-only and must not block the daemon.
  - id: STEP_10
    title: 'Operator + agent UX: surface the identity chain in `apm2 work status` / `apm2 fac status`'
    detail: |-
      Add minimal diagnostics so agents can self-correct without reading code:

      For a given work_id, show:
        - latest changeset digest (hex)
        - changeset_published event_id
        - cas hash for bundle
        - gate status (pending/passed/failed) for latest digest
        - review status for latest digest
        - merge status / completed

      This can be implemented as either:
        - a new privileged IPC `GetWorkFacStatus` returning a bounded JSON payload, or
        - an extension of existing `apm2 daemon doctor` / `apm2 work inspect`.

      Must be safe-by-default: do not dump full diffs; only identifiers + bounded summaries.
definition_of_done:
  evidence_ids:
  - EXEC-TCK00672-NO-SYNTHETIC-DIGEST
  - EXEC-TCK00672-GATE-START-FROM-CHANGESET-PUBLISHED
  - EXEC-TCK00672-LATEST-DIGEST-ENFORCED
  - EXEC-TCK00672-E2E-IDENTITY-CHAIN
  - EXEC-TCK00672-DEFECT-RECORDING
  criteria:
  - No code path derives `changeset_digest` from session_id/work_id (or any non-bundle source).
  - ChangeSetPublished is the single authoritative mapping between (work_id, changeset_digest) and `bundle_cas_hash`.
  - Gate start is triggered from ChangeSetPublished via a cursor-driven, restart-safe orchestrator (OrchestratorKernel).
  - GateOrchestrator exposes exactly one gate-start entrypoint that takes a published changeset identity (not SessionTerminated).
  - All PolicyResolved / GateLeaseIssued / GateReceiptRecorded events include `changeset_digest` and bind to the published digest.
  - CI transitions to ReadyForReview/Blocked only when receipts correspond to `work_latest_changeset` (stale receipts ignored).
  - Review start and ReviewReceiptRecorded are bound to `work_latest_changeset` and stale review receipts are ignored.
  - Merge admission/merge receipts are bound to `work_latest_changeset` and any non-latest merge attempt is aborted/fails closed.
  - changeset->work index is populated directly from ChangeSetPublished (topic derivation/projection), not only from policy resolution.
  - End-to-end integration test passes and asserts digest continuity from ChangeSetPublished through gates/review/merge.
  - 'Staleness regression test passes: after a second changeset is published for a work, receipts for the first digest cannot advance state.'
  - Identity-chain violations produce structured defect records with bounded summaries (no silent fallback).
  - A CLI/doctor/status surface exists that shows the latest changeset digest and FAC stage status for a work without dumping sensitive diff content.
notes:
  context: |-
    Target authoritative event chain (kernel events; replay-safe):

      1) Implementer modifies repo in daemon-owned workspace.
      2) Implementer runs `apm2 fac push --work-id W` which:
           - stores diff bytes in CAS -> diff_hash
           - builds ChangeSetBundleV1 referencing diff_hash -> computes changeset_digest D
           - calls PublishChangeSet(work_id=W, lease_id=L, bundle_bytes=...)
      3) Daemon appends `ChangeSetPublished{work_id=W, changeset_digest=D, cas_hash=H, ...}`.
      4) GateStartOrchestrator consumes ChangeSetPublished and starts gates for (W,D):
           - PolicyResolvedForChangeSet{W,D,...}
           - GateLeaseIssued{W,D,...} x N
      5) Gate executors emit GateReceiptRecorded{W,D,...}.
      6) CI processor observes receipts for latest digest and transitions work:
           - CiPending -> ReadyForReview | Blocked
      7) Review orchestrator issues review and records ReviewReceiptRecorded{W,D,...}.
      8) Merge executor merges and records MergeReceipt{W,D,...} and WorkCompleted.

    Hard invariants:
      - Every digest referenced downstream must be discoverable via ChangeSetPublished.
      - No stage boundary may invent or guess a digest.
      - Latest digest wins: stale receipts cannot advance work state.
  security: |-
    Default-deny; fail-closed on identity mismatch.
    Never advance work state based on receipts that cannot be bound to a published changeset.
    Do not expose full diffs in diagnostics; only bounded identifiers/summaries.
  risk: |-
    Main risk is accidentally retaining a hidden fallback to session termination that reintroduces synthetic digest behavior.
    Mitigation: dedicated e2e regression that asserts every referenced digest has a corresponding ChangeSetPublished mapping.
fac_security_contract:
  source: documents/work/tickets/FAC_SECURITY_MODEL_INVARIANTS_V1.yaml
  profile: FAC-RFC0032-BASELINE
  required_invariants:
    - INV-FAC-TRUTH-001
    - INV-FAC-WORK-BIND-001
    - INV-FAC-CLAIM-BIND-001
    - INV-FAC-ACTOR-BIND-001
    - INV-FAC-IDEMP-001
    - INV-FAC-EVID-001
  enforcement_requirements:
    - Any new requirement, code path, or test added under this ticket must map to one or more required_invariants.
    - Any invariant relaxation requires explicit amendment in this ticket and the shared security model document.
    - Reviewer denial is expected for invariant-unmapped behavior changes.
