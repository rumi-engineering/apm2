{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-29",
    "template_version": "2026-01-29",
    "ticket": {
      "id": "TCK-00676",
      "title": "apm2-daemon: add OrchestratorKernel SQLite adapter kit (cursor store + intent store + effect journal) with spawn_blocking and refactor gate timeout kernel to use it",
      "status": "OPEN"
    },
    "binds": {
      "prd_id": "PRD-PLACEHOLDER",
      "rfc_id": "RFC-0020",
      "requirements": [],
      "evidence_artifacts": []
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER",
        "AGENT_REVIEWER"
      ],
      "responsibility_domains": [
        "DOMAIN_DAEMON",
        "DOMAIN_RUNTIME",
        "DOMAIN_DATA"
      ]
    },
    "dependencies": {
      "tickets": [
        {
          "id": "TCK-00677",
          "reason": "Adapter kit should implement the finalized orchestrator_kernel trait surface (cursor-generic)."
        }
      ]
    }
  },
  "root_cause_analysis": {
    "summary": "The OrchestratorKernel pattern (observe -> plan -> execute -> receipt with durable cursor,\ndurable intent buffer, and idempotent effect journal) is now used in at least one place:\nthe gate timeout kernel (crates/apm2-daemon/src/gate/timeout_kernel.rs).\n\nHowever, gate_timeout_kernel currently implements bespoke persistence building blocks:\n  - SqliteTimeoutCursorStore (table: gate_timeout_kernel_cursor)\n  - SqliteTimeoutIntentStore (table: gate_timeout_intents)\n  - GateTimeoutEffectJournal (separate sqlite file gate_timeout_effect_journal.sqlite)\nand does so with direct rusqlite calls inside async trait methods (no spawn_blocking).\n\nIf we start adopting OrchestratorKernel broadly (FAC review, gate orchestration loops, queue reapers),\nimplementors will clone these bespoke stores, proliferating subtly different schemas and\nreintroducing blocking-in-async hazards.\n\nWe need one daemon-side \"adapter kit\" that:\n  - is mechanically extracted from existing patterns (projection intent_buffer is a strong anchor),\n  - centralizes schema and semantics,\n  - is easy to use correctly and hard to bypass.\n"
  },
  "scope": {
    "in_scope": [
      {
        "id": "OK-ADAPT-001",
        "title": "Create daemon-side OrchestratorRuntime SQLite schema + adapters",
        "detail": "Add a new module namespace, e.g.:\n  crates/apm2-daemon/src/orchestrator_runtime/\n    mod.rs\n    sqlite.rs\n    memory.rs\n    AGENTS.md\n\nProvide a single initialization entrypoint:\n  - fn init_orchestrator_runtime_schema(conn: &Connection) -> Result<(), String>\n\nCreate shared tables (single table per concern, keyed by orchestrator_id):\n  1) Cursor store table:\n     CREATE TABLE IF NOT EXISTS orchestrator_kernel_cursors (\n       orchestrator_id TEXT PRIMARY KEY,\n       cursor_json TEXT NOT NULL,\n       updated_at_ns INTEGER NOT NULL\n     );\n\n  2) Intent store table:\n     CREATE TABLE IF NOT EXISTS orchestrator_kernel_intents (\n       orchestrator_id TEXT NOT NULL,\n       intent_key TEXT NOT NULL,\n       intent_json TEXT NOT NULL,\n       state TEXT NOT NULL CHECK (state IN ('pending','blocked','completed')),\n       created_at_ns INTEGER NOT NULL,\n       updated_at_ns INTEGER NOT NULL,\n       blocked_reason TEXT,\n       PRIMARY KEY(orchestrator_id, intent_key)\n     );\n     CREATE INDEX IF NOT EXISTS ok_intents_pending_idx\n       ON orchestrator_kernel_intents(orchestrator_id, state, created_at_ns, intent_key);\n\n  3) Effect journal table:\n     CREATE TABLE IF NOT EXISTS orchestrator_kernel_effect_journal (\n       orchestrator_id TEXT NOT NULL,\n       intent_key TEXT NOT NULL,\n       state TEXT NOT NULL CHECK (state IN ('started','completed','unknown')),\n       updated_at_ns INTEGER NOT NULL,\n       PRIMARY KEY(orchestrator_id, intent_key)\n     );\n\nAdapter implementations (must satisfy apm2-core orchestrator_kernel traits):\n  - SqliteCursorStore<C: KernelCursor>\n      * load_cursor() -> Option<C> from cursor_json (serde_json)\n      * store_cursor(&C)\n  - SqliteIntentStore<I: Serialize+DeserializeOwned + Send + Sync + 'static>\n      * enqueue_many(&[I]) idempotent (INSERT OR IGNORE)\n      * dequeue_batch(limit) returns pending intents ordered by created_at_ns, intent_key\n      * mark_done / mark_blocked / mark_retryable with correct state transitions\n      * mark_retryable MUST move intent \"to the back\" by setting created_at_ns = now\n        (preserve existing semantics relied on by current tests).\n  - SqliteEffectJournal<K: ToString + ...> keyed by intent_key string\n      * query_state / record_started / record_completed / record_retryable\n      * resolve_in_doubt MUST fail-closed (Deny with reason) unless domain-specific reconciliation exists.\n\nAsync correctness requirement:\n  - Every rusqlite operation in these adapters MUST be performed in spawn_blocking.\n  - The adapters should expose only async methods to callers so they cannot accidentally\n    call blocking operations on the tokio executor.\n"
      },
      {
        "id": "OK-ADAPT-002",
        "title": "Provide memory adapters for deterministic unit tests",
        "detail": "Provide MemoryCursorStore, MemoryIntentStore, MemoryEffectJournal implementing the same traits,\nand add conformance tests that compare behavior with sqlite adapters (state transitions, ordering,\nidempotent enqueue, retryable moves-to-back).\n"
      },
      {
        "id": "OK-ADAPT-003",
        "title": "Refactor gate timeout kernel to use orchestrator_runtime adapters",
        "detail": "Update crates/apm2-daemon/src/gate/timeout_kernel.rs to remove:\n  - SqliteTimeoutCursorStore / MemoryTimeoutCursorStore\n  - SqliteTimeoutIntentStore / MemoryTimeoutIntentStore\n  - GateTimeoutEffectJournal (and gate_timeout_effect_journal.sqlite file usage)\n\nReplace them with orchestrator_runtime adapters:\n  - Orchestrator ID constant: \"gate_timeout_kernel\"\n  - Cursor store uses shared orchestrator_kernel_cursors table\n  - Intent store uses shared orchestrator_kernel_intents table\n  - Effect journal uses shared orchestrator_kernel_effect_journal table\n\nMigration strategy (must be safe and idempotent):\n  - If legacy tables/files exist (gate_timeout_kernel_cursor, gate_timeout_intents,\n    gate_timeout_effect_journal.sqlite), migrate their rows into the shared tables on startup\n    *once* (only if shared tables have no rows for orchestrator_id).\n  - After successful migration, either:\n      A) leave legacy artifacts in place but unused, OR\n      B) rename legacy artifacts to *.migrated (preferred for clarity) to prevent accidental reuse.\n  - Migration must not emit duplicate receipts. Prefer conservative migration:\n      - For effect journal: treat unknown/started as Unknown (fail-closed) in new table.\n\nEnsure tests in timeout_kernel.rs are updated to target the new adapters.\n"
      },
      {
        "id": "OK-ADAPT-004",
        "title": "Documentation + enforcement against per-orchestrator sqlite tables",
        "detail": "Documentation:\n  - Add crates/apm2-daemon/src/orchestrator_runtime/AGENTS.md explaining:\n      * what the adapter kit provides,\n      * required table schema (single shared tables),\n      * how to instantiate stores with orchestrator_id,\n      * spawn_blocking requirement for rusqlite in async.\n\nEnforcement:\n  - Update code-quality reviewer prompt (or via TCK-00678) with an invariant:\n      \"If a PR introduces a new orchestrator kernel consumer, it MUST use orchestrator_runtime\n       adapters for cursor/intent/effect journal. New per-orchestrator tables for these\n       concerns are a MAJOR finding.\"\n  - Provide reviewer checklist + greppable triggers:\n      * \"CREATE TABLE IF NOT EXISTS .*_cursor\"\n      * \"CREATE TABLE IF NOT EXISTS .*_intent\"\n      * \"effect_journal_state\"\n      * \"Connection::open(\" used to create new sqlite files for effect journal\n"
      }
    ],
    "out_of_scope": [
      "Porting FAC review or other orchestrators onto the kernel (follow-on tickets).",
      "Building a generic workflow engine beyond the kernel adapters.",
      "Changing domain-specific state stores (e.g., observed leases) that are not kernel-generic."
    ]
  },
  "implementation_notes": {
    "critical_structural_boundaries": [
      {
        "id": "IMPL-OK-ADAPT-01",
        "title": "Do not block the tokio runtime",
        "detail": "The adapter kit exists in part to prevent the existing anti-pattern:\n  async fn ... { rusqlite query ... } // blocking on executor\nAll adapters must use spawn_blocking internally.\n"
      },
      {
        "id": "IMPL-OK-ADAPT-02",
        "title": "Orchestrator ID is part of the durability boundary",
        "detail": "Orchestrator ID must be a stable constant; changing it loses cursor and intent durability.\nDocument this as an invariant in AGENTS.md and in code comments.\n"
      }
    ]
  },
  "documentation_and_enforcement": {
    "documentation_deliverables": [
      "New orchestrator_runtime/AGENTS.md with usage examples and invariants.",
      "Update gate timeout kernel comments to point to orchestrator_runtime adapters."
    ],
    "enforcement_deliverables": [
      "Code-quality reviewer invariant updated to forbid per-orchestrator cursor/intent/effect journal stores.",
      "Safe-patterns doc updated with 'OrchestratorKernel Storage Kit' pattern."
    ]
  },
  "plan": {
    "steps": [
      "Create orchestrator_runtime module with sqlite schema init + adapters.",
      "Implement memory adapters and conformance tests.",
      "Implement migration from legacy gate_timeout_* artifacts to shared tables.",
      "Refactor GateTimeoutKernel::new to use orchestrator_runtime stores and remove gate_timeout_effect_journal.sqlite usage.",
      "Update/replace existing timeout_kernel tests to cover new adapters and migration behavior.",
      "Write documentation + add reviewer enforcement artifacts."
    ]
  },
  "definition_of_done": {
    "criteria": [
      "Gate timeout kernel uses orchestrator_runtime adapters for cursor/intent/effect journal.",
      "No rusqlite operations remain on async paths without spawn_blocking in these adapters.",
      "Conformance tests exist for sqlite vs memory store semantics (enqueue idempotency, dequeue ordering, retryable move-to-back, state transitions).",
      "Migration from legacy artifacts is safe, idempotent, and documented.",
      "Docs and reviewer enforcement guidance exist to prevent reintroduction of per-orchestrator kernel tables."
    ]
  },
  "risks": [
    {
      "id": "R-OK-ADAPT-01",
      "title": "Schema migration could inadvertently drop pending intents or effect states",
      "mitigation": "Use additive migration: copy into new tables only when the new tables are empty for the orchestrator_id.\nNever delete old artifacts automatically in the first iteration; prefer rename to *.migrated after successful copy.\n"
    }
  ]
}
