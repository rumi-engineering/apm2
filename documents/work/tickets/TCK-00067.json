{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-24",
    "template_version": "2026-01-24",
    "ticket": {
      "id": "TCK-00067",
      "title": "Add Reviewer Agent Health Monitoring"
    },
    "binds": {
      "prd_id": "NONE",
      "rfc_id": "RFC-0006",
      "requirements": [
        {
          "requirement_id": "MAINT-014",
          "requirement_ref": "documents/rfcs/RFC-0006/01_problem_and_imports.yaml#rfc_local_requirements.requirements[8]"
        }
      ],
      "evidence_artifacts": []
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_BUILD_RELEASE",
        "DOMAIN_OBSERVABILITY"
      ]
    },
    "dependencies": {
      "tickets": [
        "TCK-00066"
      ]
    },
    "scope": {
      "in_scope": [
        "Create xtask/src/reviewer_state.rs module with ReviewerEntry and ReviewerStateFile structs",
        "Implement serde serialization/deserialization for state file",
        "Implement atomic state file writes (temp file + rename pattern)",
        "Implement PID alive check using nix::sys::signal::kill with None signal",
        "Implement log file mtime-based activity detection",
        "Define HealthStatus enum with Healthy, Stale, and Dead variants",
        "Add health monitoring display to cargo xtask check command",
        "Implement auto-remediation: SIGTERM, wait 5s, SIGKILL if needed",
        "Re-trigger reviews using PR URL and HEAD SHA from state file",
        "Update push.rs to write state on reviewer spawn and redirect output to log",
        "Update review.rs to write state on reviewer spawn and redirect output to log",
        "Add reviewer_state module to xtask/src/main.rs",
        "Add nix and directories dependencies to xtask/Cargo.toml",
        "Handle edge case: missing state file (treat as no active reviewers)",
        "Handle edge case: corrupt JSON (log warning, delete, start fresh)",
        "Handle edge case: PID reuse (check /proc/<pid>/cmdline for gemini or script)",
        "Handle edge case: concurrent access (use flock during remediation)",
        "Handle edge case: log file deleted (treat as stale)",
        "Handle edge case: both reviewers stale (remediate sequentially, security first)",
        "Log file cleanup on successful review completion"
      ],
      "out_of_scope": [
        "Changes to AI reviewer prompt content",
        "Changes to GitHub API interactions",
        "Adding new reviewer types beyond security and quality",
        "Persistent log storage (logs are temporary for health monitoring only)",
        "Dashboard or web UI for reviewer health",
        "Alerting or notification systems"
      ]
    },
    "plan": {
      "steps": [
        "Add nix = { workspace = true } and directories = { workspace = true } to xtask/Cargo.toml dependencies",
        "Create xtask/src/reviewer_state.rs with ReviewerEntry struct containing: pid (u32), started_at (DateTime<Utc>), log_file (PathBuf), pr_url (String), head_sha (String)",
        "Add #[derive(Debug, Clone, Serialize, Deserialize)] to ReviewerEntry",
        "Create HealthStatus enum with Healthy, Stale, Dead variants and derive Debug, Clone, Copy, PartialEq, Eq",
        "Create ReviewerStateFile struct with reviewers: HashMap<String, ReviewerEntry> field",
        "Add #[derive(Debug, Default, Serialize, Deserialize)] to ReviewerStateFile",
        "Implement ReviewerStateFile::path() returning ~/.apm2/reviewer_state.json using directories::BaseDirs",
        "Implement ReviewerStateFile::load() that handles missing file (return default) and reads/deserializes JSON",
        "Implement ReviewerStateFile::save() with atomic write pattern: create parent dir with 0700, write to .tmp, rename to final",
        "Implement ReviewerEntry::check_health() using nix::sys::signal::kill(pid, None) for alive check",
        "In check_health(), get log file mtime and compare to current time; return Dead if process not alive, Stale if mtime >= 300s ago, Healthy otherwise",
        "Add pub mod reviewer_state; to xtask/src/main.rs",
        "Update push.rs trigger_ai_reviews() to create log file using tempfile::Builder with prefix apm2_review_<type>_ and suffix .log",
        "Update push.rs to use script -q <log_path> -c <command> pattern for log capture",
        "Update push.rs to record ReviewerEntry in state file after spawning each reviewer",
        "Update push.rs to std::mem::forget(log_file) to prevent premature cleanup",
        "Update review.rs run_ai_review() similarly for synchronous review log capture",
        "Update review.rs to record ReviewerEntry in state file after spawning",
        "Add display_reviewer_health() function to check.rs that loads state and displays status table",
        "Format health display as: Security: PID <pid> | Last activity: <elapsed> ago | Status: HEALTHY/STALE/DEAD",
        "Add remediate_reviewer() function to check.rs that kills stale/dead process and restarts review",
        "In remediate_reviewer(), send SIGTERM, poll for exit with 100ms intervals up to 5s, then SIGKILL",
        "In remediate_reviewer(), remove old log file, remove entry from state, call spawn_review() with saved pr_url and head_sha",
        "Call display_reviewer_health() from run_check() after other checks complete",
        "Auto-trigger remediation when status is Stale or Dead",
        "Add flock-based file locking to prevent concurrent remediation",
        "Handle corrupt JSON by logging warning, deleting file, and returning default state",
        "Add PID reuse detection by checking /proc/<pid>/cmdline contains gemini or script",
        "Update cleanup logic to delete log file when review completes successfully",
        "Add unit tests for ReviewerStateFile::load() with missing, valid, and corrupt files",
        "Add unit tests for ReviewerEntry::check_health() with mocked process states",
        "Verify cargo build succeeds",
        "Verify cargo test passes",
        "Verify cargo clippy passes with no warnings",
        "Test end-to-end: spawn reviewer via push, verify state file created, run check, verify health displayed"
      ]
    },
    "definition_of_done": {
      "evidence_ids": [],
      "criteria": [
        "xtask/src/reviewer_state.rs exists with ReviewerEntry and ReviewerStateFile structs",
        "ReviewerEntry has fields: pid, started_at, log_file, pr_url, head_sha",
        "ReviewerStateFile has load() and save() methods with atomic write pattern",
        "State file path is ~/.apm2/reviewer_state.json",
        "check_health() returns Dead when process not alive (kill(pid, None) fails)",
        "check_health() returns Stale when log file mtime >= 300s old",
        "check_health() returns Healthy when process alive and mtime < 60s",
        "cargo xtask check displays reviewer health section",
        "Health display shows: PID, last activity elapsed time, status for each reviewer",
        "Unhealthy reviewers (Stale or Dead) trigger auto-remediation",
        "Remediation sends SIGTERM, waits up to 5s, then SIGKILL if needed",
        "Remediation restarts review using pr_url and head_sha from state file",
        "Remediation logs action: [!] <type> reviewer stale (<seconds>s), restarting...",
        "push.rs writes state file on reviewer spawn",
        "push.rs redirects reviewer output to log file for mtime tracking",
        "review.rs writes state file on reviewer spawn",
        "review.rs redirects reviewer output to log file for mtime tracking",
        "Missing state file handled gracefully (no error, empty reviewers)",
        "Corrupt JSON handled gracefully (warning logged, file deleted, fresh state)",
        "PID reuse detected by checking /proc/<pid>/cmdline",
        "Concurrent access prevented by flock during remediation",
        "nix and directories dependencies added to xtask/Cargo.toml",
        "reviewer_state module declared in xtask/src/main.rs",
        "cargo build succeeds",
        "cargo test passes",
        "cargo clippy passes with no warnings"
      ]
    },
    "notes": {
      "security": "State file contains PIDs and PR URLs which are not sensitive.\nState directory created with 0700 permissions to prevent other users from reading.\nAtomic writes prevent partial/corrupt state files.\nPID reuse detection prevents killing unrelated processes.\nFile locking prevents race conditions during concurrent remediation.\n",
      "implementation_details": "Health checking uses log file mtime as primary activity indicator because:\n- Gemini writes to stdout/stderr which is captured in the log via script\n- Any tool execution produces output that updates mtime\n- No need to parse Gemini's output format (which may change)\n\nThe script command is used instead of direct process spawn because:\n- Gemini requires a PTY for proper operation\n- script -q suppresses start/done messages\n- script -c specifies the command to run\n- Log file mtime updates whenever new output is written\n\nAuto-remediation uses SIGTERM first to allow graceful shutdown:\n- SIGTERM gives process chance to clean up\n- 5s timeout with 100ms polling is responsive but not aggressive\n- SIGKILL ensures dead processes are cleaned up\n",
      "affected_files": "New: xtask/src/reviewer_state.rs\nModified: xtask/src/tasks/check.rs (health monitoring display and auto-remediation)\nModified: xtask/src/tasks/push.rs (state write on spawn, log redirect)\nModified: xtask/src/tasks/review.rs (state write on spawn, log redirect)\nModified: xtask/src/main.rs (reviewer_state module)\nModified: xtask/Cargo.toml (nix and directories dependencies)\n"
    }
  }
}
