{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-29",
    "template_version": "2026-01-29",
    "ticket": {
      "id": "TCK-00384",
      "title": "Session telemetry tracking: wire tool_calls, events_emitted, and started_at counters",
      "status": "CLOSED"
    },
    "binds": {
      "prd_id": "PRD-0009",
      "rfc_id": "RFC-0018"
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_RUNTIME"
      ]
    },
    "dependencies": {
      "tickets": [
        {
          "ticket_id": "TCK-00383",
          "reason": "Session dispatcher must have broker/ledger/CAS wired for tool execution and event emission to actually occur."
        }
      ]
    },
    "scope": {
      "in_scope": [
        "Track tool_calls count in session state, increment on each RequestTool dispatch.",
        "Track events_emitted count in session state, increment on each EmitEvent dispatch.",
        "Track started_at_ns timestamp in session state, set when session is spawned.",
        "Return real values in SessionStatusResponse instead of hardcoded zeros.",
        "Compute duration_ms as (now - started_at_ns) instead of raw epoch milliseconds."
      ],
      "out_of_scope": [
        "Token consumption tracking (separate concern, depends on agent adapter reporting).",
        "Streaming telemetry (StreamTelemetry handler, separate ticket)."
      ]
    },
    "plan": {
      "steps": [
        "Add `tool_calls: AtomicU64`, `events_emitted: AtomicU64`, and `started_at_ns: u64` fields to the session entry in the session registry.",
        "In SpawnEpisode handler, set `started_at_ns = SystemTime::now()` when creating session entry.",
        "In SessionDispatcher::handle_request_tool, increment `tool_calls` counter after successful dispatch.",
        "In SessionDispatcher::handle_emit_event, increment `events_emitted` counter after successful dispatch.",
        "In SessionDispatcher::handle_session_status, read real values from session state instead of hardcoded zeros.",
        "Compute duration_ms as `(current_time_ns - started_at_ns) / 1_000_000`.",
        "Add unit tests verifying counters increment correctly.",
        "Add integration test: spawn session, execute tools, emit events, query status, verify non-zero counters."
      ]
    },
    "definition_of_done": {
      "criteria": [
        "`apm2 episode session-status` returns accurate tool_calls count (not 0).",
        "`apm2 episode session-status` returns accurate events_emitted count (not 0).",
        "`apm2 episode session-status` returns real started_at_ns timestamp.",
        "duration_ms reflects actual session duration, not raw epoch time.",
        "Counters are thread-safe (atomic operations)."
      ]
    },
    "notes": {
      "context": "The SessionStatus handler in session_dispatch.rs (lines 1675-1677) returns\nhardcoded zeros for all telemetry fields:\n\n  tool_calls: 0,     // TODO: Track in session telemetry\n  events_emitted: 0, // TODO: Track in session telemetry\n  started_at_ns: 0,  // TODO: Track session start time\n\nThe duration_ms field (line 1678) is set to SystemTime::now() as epoch\nmilliseconds, which is NOT the session duration -- it's the current wall\ntime since 1970 (~1.77 trillion ms). This makes the coordinate command's\ntoken estimation unreliable.\n\nAAT finding: `apm2 episode session-status` returned:\n  Tool Calls:     0\n  Events Emitted: 0\n  Duration (ms):  1770326257976\nThe duration value is clearly raw epoch nanoseconds, not session duration.\n",
      "files": "- crates/apm2-daemon/src/protocol/session_dispatch.rs (lines 1675-1678: hardcoded zeros)\n- crates/apm2-daemon/src/protocol/dispatch.rs (SpawnEpisode handler sets up session state)\n- crates/apm2-daemon/src/session/ (session registry with session state entries)\n"
    }
  }
}
