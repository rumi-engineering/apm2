{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-26",
    "template_version": "2026-01-26",
    "ticket": {
      "id": "TCK-00113",
      "title": "Implement CCP index and CLI command",
      "status": "READY"
    },
    "binds": {
      "rfc_id": "RFC-0010",
      "requirements": [
        {
          "requirement_id": "REQ-0001"
        },
        {
          "requirement_id": "REQ-0002"
        }
      ]
    }
  },
  "dependencies": {
    "tickets": [
      {
        "ticket_id": "TCK-00111"
      },
      {
        "ticket_id": "TCK-00112"
      }
    ]
  },
  "implementation": {
    "summary": "Create the CCP index that combines component atlas and crate graph into\na unified, content-addressed artifact. Implement the CLI command\n`apm2 factory ccp build` that generates the CCP index at the standard\nevidence location with BLAKE3 content hashes for integrity verification.\n",
    "files_to_modify": [
      {
        "path": "crates/apm2-cli/src/main.rs",
        "changes": "Register the factory ccp subcommand in the CLI command tree"
      },
      {
        "path": "crates/apm2-cli/src/commands/factory.rs",
        "changes": "Add ccp submodule and wire up CcpCommand"
      }
    ],
    "files_to_create": [
      {
        "path": "crates/apm2-core/src/ccp/index.rs",
        "purpose": "CCP index generation: combine atlas and graph, compute content hashes, support incremental rebuild"
      },
      {
        "path": "crates/apm2-cli/src/commands/factory/ccp.rs",
        "purpose": "CLI command implementation for apm2 factory ccp build"
      }
    ],
    "implementation_steps": [
      {
        "step": 1,
        "action": "Define CCP index data structures",
        "details": "In index.rs, define:\n\npub struct CcpIndex {\n    pub schema_version: String,\n    pub generated_at: DateTime<Utc>,\n    pub prd_id: String,\n    pub content_hash: String,      // BLAKE3 hash of canonical content\n    pub component_atlas: ComponentAtlas,\n    pub crate_graph: CrateGraph,\n    pub file_inventory: FileInventory,\n}\n\npub struct FileInventory {\n    pub total_files: usize,\n    pub by_extension: HashMap<String, usize>,\n    pub source_files: Vec<SourceFile>,\n}\n\npub struct SourceFile {\n    pub path: PathBuf,\n    pub content_hash: String,      // BLAKE3 hash\n    pub size_bytes: u64,\n    pub component_id: Option<String>,\n}\n"
      },
      {
        "step": 2,
        "action": "Implement content hashing",
        "details": "fn hash_content(content: &[u8]) -> String\n- Use BLAKE3 for fast, secure hashing\n- Return hex-encoded hash (first 16 chars for short form, full for verification)\n- This provides content-addressing for incremental rebuild detection\n\nfn compute_index_hash(index: &CcpIndex) -> String\n- Serialize atlas and graph to canonical YAML\n- Hash the combined content\n- This is the overall CCP hash used in RFC grounding\n"
      },
      {
        "step": 3,
        "action": "Implement file inventory generation",
        "details": "fn build_file_inventory(repo_root: &Path, atlas: &ComponentAtlas) -> Result<FileInventory, CcpError>\n- Glob for source files: **/*.rs, **/*.yaml, **/*.md in crates/\n- For each file, compute BLAKE3 hash\n- Associate files with components based on path prefix\n- Sort files by path for determinism\n"
      },
      {
        "step": 4,
        "action": "Implement incremental rebuild logic",
        "details": "fn needs_rebuild(repo_root: &Path, existing_index: &CcpIndex) -> bool\n- Check if any source file hashes have changed\n- Check if Cargo.toml or Cargo.lock have changed\n- Check if any AGENTS.md files have changed\n- Return true if any changes detected\n\npub fn build_ccp_index(repo_root: &Path, prd_id: &str, force: bool) -> Result<CcpIndex, CcpError>\n1. Check for existing index at evidence/prd/<prd_id>/ccp/ccp_index.json\n2. If exists and not force, check needs_rebuild\n3. If no rebuild needed, return existing index\n4. Otherwise, build atlas, graph, and file inventory\n5. Compute content hash\n6. Write to evidence path using atomic_write\n"
      },
      {
        "step": 5,
        "action": "Implement CLI command",
        "details": "In ccp.rs, implement:\n\n#[derive(Parser)]\npub struct CcpCommand {\n    #[command(subcommand)]\n    pub command: CcpSubcommand,\n}\n\n#[derive(Subcommand)]\npub enum CcpSubcommand {\n    Build(CcpBuildArgs),\n}\n\n#[derive(Args)]\npub struct CcpBuildArgs {\n    #[arg(long)]\n    pub prd: String,           // PRD ID (e.g., PRD-0005)\n\n    #[arg(long, default_value = \".\")]\n    pub repo_root: PathBuf,\n\n    #[arg(long)]\n    pub force: bool,           // Force rebuild even if cached\n\n    #[arg(long)]\n    pub dry_run: bool,         // Show what would be written\n}\n\npub fn run_ccp_build(args: CcpBuildArgs) -> Result<(), CliError>\n"
      },
      {
        "step": 6,
        "action": "Wire up CLI command",
        "details": "In crates/apm2-cli/src/commands/factory.rs, add:\npub mod ccp;\n\nIn the factory command enum, add:\nCcp(ccp::CcpCommand),\n\nIn main.rs, ensure factory subcommands are properly routed.\n"
      },
      {
        "step": 7,
        "action": "Implement output path logic",
        "details": "Output location: evidence/prd/<PRD-ID>/ccp/\nFiles to write:\n- ccp_index.json (main index with all data)\n- component_atlas.yaml (standalone atlas for human reading)\n- crate_graph.yaml (standalone graph for human reading)\n\nUse atomic_write from determinism module for all writes.\n"
      }
    ],
    "code_examples": [
      {
        "description": "CLI usage",
        "code": "# Build CCP for PRD-0005\napm2 factory ccp build --prd PRD-0005\n\n# Force rebuild ignoring cache\napm2 factory ccp build --prd PRD-0005 --force\n\n# Dry run to see what would be written\napm2 factory ccp build --prd PRD-0005 --dry-run\n"
      },
      {
        "description": "Programmatic usage",
        "code": "use apm2_core::ccp::build_ccp_index;\nuse std::path::Path;\n\nlet index = build_ccp_index(\n    Path::new(\"/repo/root\"),\n    \"PRD-0005\",\n    false, // don't force rebuild\n)?;\nprintln!(\"CCP index hash: {}\", index.content_hash);\n"
      }
    ]
  },
  "acceptance_criteria": [
    {
      "criterion": "CLI command produces CCP at evidence/prd/<PRD-ID>/ccp/",
      "verification": "Run apm2 factory ccp build --prd PRD-0005 and verify files exist at expected paths with correct structure"
    },
    {
      "criterion": "Content hashes validate correctly",
      "verification": "Manually hash the atlas and graph content, verify it matches content_hash in index"
    },
    {
      "criterion": "Incremental rebuild skips unchanged artifacts",
      "verification": "Run build twice without changes - second run should be fast and report 'no changes detected'"
    }
  ],
  "test_requirements": [
    {
      "test_id": "UT-113-01",
      "description": "Test CCP index content hash is deterministic",
      "verification_command": "cargo test -p apm2-core ccp::index::tests::test_index_hash_deterministic"
    },
    {
      "test_id": "UT-113-02",
      "description": "Test file inventory captures all source files",
      "verification_command": "cargo test -p apm2-core ccp::index::tests::test_file_inventory_complete"
    },
    {
      "test_id": "UT-113-03",
      "description": "Test incremental rebuild detection",
      "verification_command": "cargo test -p apm2-core ccp::index::tests::test_incremental_rebuild_detection"
    },
    {
      "test_id": "UT-113-04",
      "description": "Test force rebuild ignores cache",
      "verification_command": "cargo test -p apm2-core ccp::index::tests::test_force_rebuild"
    },
    {
      "test_id": "IT-113-01",
      "description": "Integration test: full CCP index build",
      "verification_command": "cargo test -p apm2-core ccp::index"
    },
    {
      "test_id": "CLI-113-01",
      "description": "CLI help text displays correctly",
      "verification_command": "cargo run --bin apm2 -- factory ccp build --help"
    },
    {
      "test_id": "CLI-113-02",
      "description": "CLI dry-run mode works",
      "verification_command": "cargo run --bin apm2 -- factory ccp build --prd PRD-TEST --dry-run"
    }
  ],
  "notes": "The CCP index is the primary artifact consumed by downstream compiler stages\n(Impact Map, RFC Framer). Its content hash provides a stable reference that\ncan be embedded in RFCs to prove they were generated against a specific\ncodebase state.\n\nThe incremental rebuild feature is important for developer experience - a\nfull CCP build can take several seconds on large codebases, so skipping\nunchanged artifacts significantly improves iteration time.\n\nBlocked by TCK-00111 (component atlas) and TCK-00112 (crate graph) as the\nindex combines both artifacts. This ticket completes Phase 1 of RFC-0010.\n"
}
