{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-29",
    "template_version": "2026-01-29",
    "ticket": {
      "id": "TCK-00626",
      "title": "Implement cache reuse explainability: hit/miss with first mismatch dimension",
      "status": "MERGED"
    },
    "binds": {
      "prd_id": "PRD-PLACEHOLDER",
      "rfc_id": "RFC-0019",
      "requirements": [
        "REQ-0037"
      ],
      "evidence_artifacts": []
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_RUNTIME",
        "DOMAIN_CI"
      ]
    },
    "dependencies": {
      "tickets": [
        {
          "ticket_id": "TCK-00623",
          "reason": "closure_hash dimension requires the closure artifact to be defined."
        },
        {
          "ticket_id": "TCK-00625",
          "reason": "cache_decision is emitted within the gate_finished event; JSONL schema must exist."
        }
      ]
    }
  },
  "root_cause_analysis": {
    "summary": "Gate cache misses are currently silent: the gate re-runs without any\nindication of why the cache was not reused. This makes it impossible to\ndistinguish an expected miss (toolchain changed) from an unexpected one\n(policy hash instability, receipt binding regression). Operators and\norchestrators have no way to verify that cache reuse is working correctly\non the warm path, and cannot diagnose slow repeated runs without reading\ninternal cache YAML files.\n"
  },
  "scope": {
    "in_scope": [
      {
        "id": "S1_CACHE_DECISION_RECORD",
        "title": "Define CacheDecision struct with all required fields",
        "detail": "struct CacheDecision {\n  hit: bool,\n  reason_code: CacheReasonCode,   // enum (see REQ-0037 for full list)\n  first_mismatch_dimension: Option<CacheReasonCode>,\n  cached_sha: Option<String>,\n}\nenum CacheReasonCode: 11 variants as listed in REQ-0037\n"
      },
      {
        "id": "S2_CHECK_REUSE_ATTRIBUTION",
        "title": "Return CacheDecision from check_reuse() with first mismatch dimension",
        "detail": "Refactor gate_cache.rs::check_reuse() to return CacheDecision instead\nof ReuseDecision. On miss, record first_mismatch_dimension as the first\ncheck that failed (policy_hash before toolchain, toolchain before\nclosure_hash, etc.) using a defined check order:\n  1. sha_miss / gate_miss\n  2. signature_invalid\n  3. receipt_binding_missing\n  4. policy_drift\n  5. toolchain_drift\n  6. closure_drift\n  7. input_drift\n  8. network_policy_drift\n  9. sandbox_drift\n  10. ttl_expired\n"
      },
      {
        "id": "S3_INLINE_IN_GATE_FINISHED",
        "title": "Inline CacheDecision in gate_finished event",
        "detail": "Populate the cache_decision field in gate_finished (from TCK-00625)\nwith the CacheDecision returned by check_reuse(). The cache_decision\nevent type from REQ-0036 is satisfied by this inline record.\n"
      },
      {
        "id": "S4_REGRESSION_TESTS",
        "title": "Regression tests for all 11 reason codes",
        "detail": "- Test: cache hit -> reason_code=cache_hit, first_mismatch_dimension=null.\n- Test: each of the 10 miss codes -> correct reason_code and\n  first_mismatch_dimension in gate_finished event.\n- Test: policy_drift miss does NOT also report toolchain_drift\n  (first mismatch stops at policy_drift).\n- Test: stdout event stream alone identifies miss cause (no file reads needed).\n"
      },
      {
        "id": "BF_001_DISPATCH_DIAGNOSTIC",
        "title": "Auto-trigger review dispatch after push: PID liveness check + structured diagnostics",
        "detail": "Push dispatch returns 'joined' for dead PIDs due to stale idempotency.\nAdd PID liveness verification for non-terminal 'joined' results.\nEmit structured dispatch_failed JSONL events with recovery commands.\nImprove human-readable error messages with explicit recovery actions.\n"
      },
      {
        "id": "BF_002_WAIT_MERGED_DETECTION",
        "title": "Wait loop detects externally-merged PRs via periodic GitHub API poll",
        "detail": "The --wait-for-recommended-action loop uses lightweight=true exclusively,\nwhich skips GitHub API. PRs merged externally are never detected. Fix by\nperiodically using non-lightweight polls (every 5th tick) and injecting\nmerged lifecycle events when GitHub API confirms merge.\n"
      }
    ],
    "out_of_scope": [
      "Changing cache eviction or TTL policy.",
      "Adding new reason codes beyond the 11 defined (requires new requirement).",
      "Retroactive re-attribution of existing cache entries."
    ]
  },
  "plan": {
    "steps": [
      {
        "id": "STEP_01",
        "title": "Define CacheDecision and CacheReasonCode types",
        "detail": "In gate_cache_v3.rs. Add CacheDecision struct and CacheReasonCode\nenum with 11+1 variants. Add check_reuse_decision() wrapper and\nmap_reason_to_code() helper.\n"
      },
      {
        "id": "STEP_02",
        "title": "Refactor check_reuse() to produce CacheDecision with first_mismatch_dimension",
        "detail": "Implement ordered dimension checks; set first_mismatch_dimension at\nfirst failing check. Return CacheDecision with full attribution.\n"
      },
      {
        "id": "STEP_03",
        "title": "Inline CacheDecision in gate_finished event",
        "detail": "Pass CacheDecision to the gate_finished event constructor. Wire\nthrough evidence pipeline via reuse_decision_with_v3_fallback return\ntuple, GateProgressEvent::Completed, and EvidenceGateResult.\n"
      },
      {
        "id": "STEP_04",
        "title": "Add regression tests and workspace validation",
        "detail": "cargo fmt --all && cargo clippy --workspace --all-targets --all-features -- -D warnings\ncargo doc --workspace --no-deps && cargo test --workspace\n"
      },
      {
        "id": "STEP_05",
        "title": "BF-001: Push dispatch PID liveness + structured diagnostics",
        "detail": "Verify PID liveness for 'joined' dispatch results. Emit dispatch_failed\nJSONL events on failure. Improve stderr messages with recovery commands.\n"
      },
      {
        "id": "STEP_06",
        "title": "BF-002: Wait loop merged state detection",
        "detail": "Add fetch_pr_merged_at to github_reads. Inject merged lifecycle event\nin run_doctor_inner when GitHub API confirms merge. Periodically use\nnon-lightweight mode in wait loop CollectSummary state.\n"
      }
    ]
  },
  "definition_of_done": {
    "evidence_ids": [
      "EXEC-TCK00626-CACHE-DECISION",
      "EXEC-TCK00626-ALL-REASON-CODES",
      "EXEC-TCK00626-WORKSPACE-VALIDATION",
      "EXEC-TCK00626-BF001-DISPATCH",
      "EXEC-TCK00626-BF002-MERGED"
    ],
    "criteria": [
      "CacheDecision struct with all required fields replaces ReuseDecision.",
      "check_reuse() returns first_mismatch_dimension for every miss type.",
      "gate_finished event includes cache_decision with hit, reason_code, first_mismatch_dimension.",
      "All 11 reason_code values are reachable and tested.",
      "Cache miss cause is identifiable from stdout event stream without reading gate_cache_v2 files.",
      "Regression tests cover all 11 codes and verify correct first_mismatch_dimension.",
      "Workspace validation completes successfully.",
      "Push dispatch verifies PID liveness for 'joined' results and emits structured dispatch_failed events.",
      "Wait loop periodically detects externally-merged PRs via GitHub API and exits with terminal 'done' action."
    ]
  },
  "notes": {
    "context": "This ticket refactors the existing ReuseDecision type in gate_cache.rs\ninto the richer CacheDecision type. The ordered dimension check logic\nalready exists implicitly in check_reuse(); this ticket makes the ordering\nexplicit and captures the first failing dimension. The removal of the\nallow_legacy_cache bypass (TCK-00619) simplifies the check order by\neliminating the legacy_cache_override_unsafe path.\n",
    "security": "cache_decision exposes only non-sensitive dimension names; no key material in output"
  }
}
