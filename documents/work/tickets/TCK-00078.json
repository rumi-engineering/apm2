{
  "schema": "apm2.ticket.v1",
  "ticket_meta": {
    "schema_version": "2026-01-25",
    "template_version": "2026-01-25",
    "ticket": {
      "id": "TCK-00078",
      "title": "Add Evidence Script and PR Format Validation"
    },
    "binds": {
      "prd_id": "NONE",
      "rfc_id": "RFC-0006",
      "requirements": [
        {
          "requirement_id": "AAT-006",
          "requirement_ref": "documents/rfcs/RFC-0006/01_problem_and_imports.yaml#rfc_local_requirements.requirements[19]"
        }
      ],
      "evidence_artifacts": []
    },
    "custody": {
      "agent_roles": [
        "AGENT_IMPLEMENTER"
      ],
      "responsibility_domains": [
        "DOMAIN_BUILD_RELEASE"
      ]
    },
    "dependencies": {
      "tickets": []
    },
    "scope": {
      "in_scope": [
        "Validate evidence script path exists and is executable",
        "Validate Usage section contains at least 1 code block",
        "Validate Expected Outcomes contain BOTH When AND Then keywords",
        "Return actionable errors for each validation failure"
      ],
      "out_of_scope": [
        "Execution of evidence script during validation",
        "Schema validation of PR description YAML",
        "Auto-fix for malformed PR descriptions"
      ]
    },
    "plan": {
      "steps": [
        "Add validate_evidence_script() to parser.rs",
        "Check path exists using std::path::Path::exists()",
        "Check executable bit using std::os::unix::fs::PermissionsExt",
        "Add validate_usage_section() to parser.rs",
        "Check for at least 1 markdown code block (``` delimiters)",
        "Add validate_expected_outcomes() to parser.rs",
        "Check outcomes contain BOTH When AND Then keywords",
        "Create ValidationError enum with specific variants",
        "Return Vec<ValidationError> with actionable messages",
        "Integrate validation into aat.rs after parsing",
        "Display validation errors before proceeding",
        "Verify cargo build succeeds",
        "Verify cargo test passes",
        "Verify cargo clippy passes with no warnings"
      ]
    },
    "definition_of_done": {
      "evidence_ids": [],
      "criteria": [
        "validate_evidence_script() checks existence and executable",
        "validate_usage_section() requires at least 1 code block",
        "validate_expected_outcomes() requires BOTH When AND Then keywords",
        "Actionable error messages for each validation failure",
        "Validation integrated into AAT run flow",
        "cargo build succeeds",
        "cargo test passes",
        "cargo clippy passes with no warnings"
      ]
    },
    "notes": {
      "implementation_details": "```rust\n// xtask/src/aat/parser.rs additions\n\nuse std::path::Path;\n\n#[derive(Debug, Clone)]\npub enum ValidationError {\n    EvidenceScriptNotFound { path: String },\n    EvidenceScriptNotExecutable { path: String },\n    UsageMissingCodeBlock,\n    OutcomeMissingWhenThen { outcome: String },\n}\n\nimpl ValidationError {\n    pub fn message(&self) -> String {\n        match self {\n            Self::EvidenceScriptNotFound { path } => {\n                format!(\n                    \"Evidence script not found: {}\\n\\\n                     Fix: Create the script or update the path in PR description\",\n                    path\n                )\n            }\n            Self::EvidenceScriptNotExecutable { path } => {\n                format!(\n                    \"Evidence script not executable: {}\\n\\\n                     Fix: Run `chmod +x {}`\",\n                    path, path\n                )\n            }\n            Self::UsageMissingCodeBlock => {\n                \"Usage section missing code block\\n\\\n                 Fix: Add a code block with usage example:\\n\\\n                 ```bash\\n\\\n                 cargo xtask aat <PR_URL>\\n\\\n                 ```\".to_string()\n            }\n            Self::OutcomeMissingWhenThen { outcome } => {\n                format!(\n                    \"Expected outcome missing When/Then format: {}\\n\\\n                     Fix: Use format like: \\\"When X, then Y\\\"\",\n                    outcome\n                )\n            }\n        }\n    }\n}\n\npub fn validate_pr_description(\n    parsed: &ParsedPRDescription,\n    repo_root: &Path,\n) -> Vec<ValidationError> {\n    let mut errors = Vec::new();\n\n    // Validate evidence script\n    if let Some(script_path) = &parsed.evidence_script {\n        let full_path = repo_root.join(script_path);\n        if !full_path.exists() {\n            errors.push(ValidationError::EvidenceScriptNotFound {\n                path: script_path.clone(),\n            });\n        } else {\n            #[cfg(unix)]\n            {\n                use std::os::unix::fs::PermissionsExt;\n                if let Ok(metadata) = full_path.metadata() {\n                    let mode = metadata.permissions().mode();\n                    if mode & 0o111 == 0 {\n                        errors.push(ValidationError::EvidenceScriptNotExecutable {\n                            path: script_path.clone(),\n                        });\n                    }\n                }\n            }\n        }\n    }\n\n    // Validate usage has code block\n    if !parsed.usage.contains(\"```\") {\n        errors.push(ValidationError::UsageMissingCodeBlock);\n    }\n\n    // Validate outcomes have both When AND Then (require both keywords)\n    for outcome in &parsed.expected_outcomes {\n        let text_lower = outcome.text.to_lowercase();\n        if !text_lower.contains(\"when\") || !text_lower.contains(\"then\") {\n            errors.push(ValidationError::OutcomeMissingWhenThen {\n                outcome: outcome.text.clone(),\n            });\n        }\n    }\n\n    errors\n}\n```\n",
      "affected_files": "Modified: xtask/src/aat/parser.rs (add validation functions)\nModified: xtask/src/tasks/aat.rs (integrate validation)\n"
    }
  }
}
