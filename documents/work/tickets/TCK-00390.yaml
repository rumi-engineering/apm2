ticket_meta:
  schema_version: "2026-01-29"
  template_version: "2026-01-29"
  ticket:
    id: "TCK-00390"
    title: "Daemon-side merge executor: autonomous merge after gate approval"
    status: "OPEN"
  binds:
    prd_id: "PRD-0009"
    rfc_id: "RFC-0018"
  custody:
    agent_roles:
      - "AGENT_IMPLEMENTER"
    responsibility_domains:
      - "DOMAIN_RUNTIME"
      - "DOMAIN_ORCHESTRATION"
      - "DOMAIN_SECURITY"
  dependencies:
    tickets:
      - ticket_id: "TCK-00388"
        reason: "Gate orchestrator must produce gate receipts that the merge executor observes for approval."
      - ticket_id: "TCK-00389"
        reason: "Review receipt ingestion must produce ReviewReceiptRecorded events that confirm gate passage."
  scope:
    in_scope:
      - "Implement MergeExecutor module in daemon that watches for all required gate receipts reaching PASS verdict."
      - "Verify all policy requirements are met (policy_hash matches PolicyResolvedForChangeSet)."
      - "Execute merge via GitHub API (squash merge of associated PR) through GitHubProjectionAdapter."
      - "Observe merge result (commit SHA on target branch) from GitHub API response."
      - "Create and sign MergeReceipt via create_after_observation binding inputs to observed result."
      - "Emit merge_receipt ledger event."
      - "Transition work state to Completed via WorkCompleted event."
      - "Handle merge conflicts by emitting ReviewBlockedRecorded with appropriate reason code."
    out_of_scope:
      - "GitHub token management (use existing credential profiles from daemon configuration)."
      - "Divergence watchdog changes (already monitors MergeReceipt vs trunk HEAD independently)."
      - "Manual merge approval workflow (this is autonomous merge for FAC-managed changesets)."
      - "Gate orchestration and lease issuance (TCK-00388)."
      - "Review receipt ingestion (TCK-00389)."
  plan:
    steps:
      - "Create MergeExecutor struct in crates/apm2-daemon/src/merge/ with ledger tailer for gate_receipt events."
      - "On each gate_receipt event: check if all required gates for the work_id have PASS verdict."
      - "Required gates are determined from the PolicyResolvedForChangeSet for the work_id (aat, quality, security)."
      - "When all gates pass: look up associated PR metadata from work index."
      - "Verify policy_hash on each gate receipt matches the PolicyResolvedForChangeSet resolved_policy_hash."
      - "Execute squash merge via GitHubProjectionAdapter (replaces xtask's `gh pr merge --auto --squash`)."
      - "Observe the merge result: extract the new commit SHA (result_selector) from GitHub API response."
      - "Build MergeReceipt via create_after_observation with base_selector, changeset_digest, sorted gate_receipt_ids, policy_hash, result_selector."
      - "Sign the MergeReceipt with daemon signer using MERGE_RECEIPT: domain separator."
      - "Emit merge_receipt event to ledger."
      - "Emit WorkCompleted event to transition work state from Review to Completed."
      - "On merge conflict: emit ReviewBlockedRecorded with ReasonCode::ApplyFailed and log details."
      - "Add integration test: emit gate receipts with PASS verdicts, verify MergeExecutor produces MergeReceipt and WorkCompleted."
  definition_of_done:
    criteria:
      - "All required gate receipts with PASS verdict trigger autonomous merge execution."
      - "Policy hash is verified against PolicyResolvedForChangeSet before merge (anti-downgrade)."
      - "Merge is executed via GitHub API as squash merge through GitHubProjectionAdapter."
      - "MergeReceipt atomically binds inputs (base_selector, changeset_digest, gate_receipt_ids, policy_hash) to observed result (result_selector)."
      - "MergeReceipt is signed with MERGE_RECEIPT: domain separator."
      - "merge_receipt event is emitted to ledger."
      - "Work state transitions to Completed via WorkCompleted event."
      - "Merge conflicts produce ReviewBlockedRecorded event, not silent failure."
      - "gate_receipt_ids in MergeReceipt are sorted canonically (deterministic serialization)."
      - "Divergence watchdog can observe the MergeReceipt HEAD and compare against external trunk (existing behavior, verified)."
  notes:
    context: |
      This is the final step in the FAC state machine:
      review_receipt -> MERGE -> merge_receipt -> WORK_COMPLETE

      The MergeReceipt type (crates/apm2-core/src/fac/merge_receipt.rs) already exists with full
      cryptographic binding. The create_after_observation method (line 144) validates inputs,
      constructs the receipt, computes canonical encoding, and signs with MERGE_RECEIPT: domain
      separator. Fields include: base_selector, changeset_digest, gate_receipt_ids (sorted
      canonical, max 64 via MAX_GATE_RECEIPTS), policy_hash, result_selector, merged_at,
      gate_actor_id.

      Currently, xtask/src/tasks/push.rs line 148 uses `gh pr merge --auto --squash` to trigger
      merge outside the FAC pipeline. This means merges are not recorded in the ledger, not
      cryptographically bound to gate receipts, and not observable by the divergence watchdog.

      The divergence watchdog (crates/apm2-daemon/src/projection/divergence_watchdog.rs) already
      compares MergeReceipt HEAD against external trunk HEAD and emits InterventionFreeze on
      divergence. Once the MergeExecutor produces MergeReceipt events, the watchdog can detect
      unauthorized external merges (merge happened on GitHub but no MergeReceipt exists in ledger).

      The work state machine (crates/apm2-core/src/work/reducer.rs line 166) supports the
      Review -> Completed transition via WorkCompleted event. The WorkCompleted event payload
      (line 578) binds the completion to the work_id.

      The GitHubProjectionAdapter (crates/apm2-daemon/src/projection/github_sync.rs line 1242)
      provides GitHub API access through the projection layer. The merge operation should go
      through this adapter rather than shelling out to `gh` CLI, ensuring all GitHub interactions
      are managed through the daemon's authenticated adapter with proper error handling.

      After this ticket, the complete FAC pipeline operates autonomously:
      session_terminated -> gate_lease -> gate_receipt -> review_receipt -> merge_receipt -> work_completed
    files: |
      - crates/apm2-core/src/fac/merge_receipt.rs (MergeReceipt, create_after_observation at line 144, MERGE_RECEIPT: domain separator)
      - crates/apm2-core/src/work/reducer.rs (WorkCompleted event, Review -> Completed transition at line 166)
      - crates/apm2-core/src/fac/policy_resolution.rs (PolicyResolvedForChangeSet for policy hash verification)
      - crates/apm2-daemon/src/projection/github_sync.rs (GitHubProjectionAdapter at line 1242 for GitHub API merge)
      - crates/apm2-daemon/src/projection/divergence_watchdog.rs (monitors MergeReceipt HEAD vs external trunk)
      - crates/apm2-core/src/fac/review_blocked.rs (ReviewBlockedRecorded for merge conflict handling)
      - crates/apm2-daemon/src/ledger.rs (SqliteLedgerEventEmitter for event emission)
      - xtask/src/tasks/push.rs (current `gh pr merge --auto --squash` at line 148, to be superseded)
    security: |
      The MergeReceipt's atomic binding (FAC-REQ-0020) is the critical security property: it
      prevents equivocation where a merge is claimed but the result points to a different commit.
      The create_after_observation pattern enforces this by requiring the merge to be OBSERVED
      before the receipt is created - the result_selector comes from the actual GitHub API response,
      not from a prediction. Policy hash verification before merge prevents policy downgrade attacks
      where gates passed under one policy but merge happens under a weaker one. The gate_receipt_ids
      must be sorted canonically to ensure deterministic serialization and prevent receipt
      substitution. Merge conflicts must be handled explicitly (emit ReviewBlockedRecorded) rather
      than silently retrying, which could mask concurrent modification attacks. The divergence
      watchdog provides defense-in-depth: even if the MergeExecutor is compromised, unauthorized
      merges will be detected by comparing ledger state against external trunk.
