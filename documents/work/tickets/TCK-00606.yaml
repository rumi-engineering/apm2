ticket_meta:
  schema_version: "2026-01-29"
  template_version: "2026-01-29"
  ticket:
    id: "TCK-00606"
    title: "FAC CLI JSON parity — every fac subcommand outputs JSON by default, long-running commands stream JSONL"
    status: "OPEN"
  binds:
    prd_id: "PRD-PLACEHOLDER"
    rfc_id: "RFC-0019"
    requirements: []
    evidence_artifacts: []
  custody:
    agent_roles: ["AGENT_IMPLEMENTER"]
    responsibility_domains: ["DOMAIN_CLI"]
  dependencies:
    tickets: []
  root_cause_analysis:
    summary: |
      LLM agents interacting with the `apm2 fac` CLI uniformly assume that
      every subcommand accepts `--json` and produces structured output. This
      is rational inference — most FAC commands already have `--json` — but
      several commands silently ignore the flag or don't accept it at all,
      causing agent workflows to break or produce unparseable output.

      Two distinct problems:

      1. MISSING --json FLAG ON SEVERAL FAC COMMANDS
         The following FAC subcommands return `false` from
         `subcommand_requests_machine_output()` and either lack a `--json`
         arg entirely or silently ignore the parent `FacCommand.json`:

         - `fac gates` — has no `--json` on GatesArgs; uses parent json flag
           via `json_output` local, but is listed in the hard-coded `false`
           arm of `subcommand_requests_machine_output()`, so the parent
           flag doesn't propagate correctly in all call paths.
         - `fac push` — PushArgs has no `--json` flag. Output is a mix of
           println! and eprintln! text with no structured alternative. The
           parent `FacCommand.json` is threaded through some paths but not
           all, and `subcommand_requests_machine_output` returns false.
         - `fac restart` — RestartArgs has no `--json` flag. Output is text-
           only. Agent must parse human prose to determine restart outcome.
         - `fac lane status` — LaneStatusArgs has no `--json` flag. Output
           is a text table. Agent cannot programmatically read lane state.
         - `fac lane reset` — LaneResetArgs has no `--json` flag.
         - `fac worker` — WorkerArgs has no `--json` flag. Long-running
           process with text-only log output.
         - `fac pipeline` — PipelineArgs has no `--json` flag. Internal but
           still needs structured output for orchestration.
         - `fac review run` — ReviewRunArgs has no `--json` flag. Long-
           running review orchestration with text-only progress output.
         - `fac review dispatch` — ReviewDispatchArgs has no `--json` flag.
           Returns dispatch result as text.
         - `fac review tail` — ReviewTailArgs has no `--json` flag (already
           NDJSON by nature, but no explicit flag).
         - `fac pr auth-setup` / `fac pr auth-check` — no `--json` flag.
         - `fac episode inspect` — uses parent json flag but not listed in
           machine_output detection.
         - `fac receipt show` — uses parent json flag but not listed.
         - `fac context rebuild` — uses parent json flag but not listed.
         - `fac resume` — uses parent json flag but not listed.

         When an agent calls `apm2 fac push --json`, clap rejects the flag
         because PushArgs doesn't define it. The parent FacCommand.json
         exists but is consumed before subcommand dispatch — the agent
         cannot know which commands accept it at the parent level vs the
         subcommand level. This inconsistency is the hallucination vector.

      2. LONG-RUNNING COMMANDS OUTPUT NOTHING UNTIL COMPLETION
         `fac gates` runs 5+ sequential gates (fmt, clippy, doc, test,
         merge-conflicts) taking 2-10 minutes total. The text path prints
         progress inline, but the JSON path produces a single JSON blob
         only on completion. An agent waiting for gates gets zero signal
         for minutes, then either a full JSON object or an error.

         Same problem for `fac push` (git push + gates + PR + dispatch),
         `fac review run` (full review orchestration), `fac worker`
         (continuous job processing), and `fac pipeline` (background
         evidence + review).

         These commands should stream JSONL (one JSON object per line)
         by default, with each event representing a meaningful progress
         checkpoint. The final line is the summary/result object. This
         gives agents real-time observability without polling.

      Root causes:
      1. ORGANIC FLAG GROWTH: --json was added per-subcommand over time.
         Commands that predated the convention or were considered "human-
         only" (push, restart, lane) never got it.
      2. DUAL-LEVEL FLAG CONFUSION: FacCommand.json exists at the parent
         level but subcommand_requests_machine_output() only checks
         subcommand-level flags. Some commands use the parent flag, some
         don't, some use both with `json_output || args.json`.
      3. BATCH-ONLY JSON: The existing JSON pattern assumes commands are
         short-lived and can buffer the entire response. Long-running
         commands were left as text-only because the pattern didn't fit.
  scope:
    scope_clarification: |
      Removing non-machine-parseable output (dead text-mode branches,
      unstructured eprintln, human-readable println) is a best-effort goal
      scoped to `fac` subcommands. Follow-up tickets will address residual
      text output paths in non-FAC areas of the codebase.
    in_scope:
      - id: S1_GATES_JSON_AND_JSONL
        title: "`fac gates` — add --json flag to GatesArgs, stream JSONL progress by default"
        detail: |
          Current state: GatesArgs has no --json flag. The parent
          FacCommand.json is threaded to run_gates() as json_output, but
          subcommand_requests_machine_output() returns false for Gates.
          Gates run 5+ sequential checks (merge_conflicts, fmt, clippy,
          doc, test) taking 2-10 minutes. In JSON mode, nothing is emitted
          until all gates finish.

          Required changes:
          (a) Add `#[arg(long, default_value_t = false)] pub json: bool`
              to GatesArgs.
          (b) Update subcommand_requests_machine_output() to return
              args.json for FacSubcommand::Gates.
          (c) Resolve the effective json flag as `json_output || args.json`
              at the dispatch site (already the pattern for doctor, logs).
          (d) In run_gates_inner(), when JSON mode is active, emit one
              JSONL line to stdout as each gate completes:
              ```
              {"event":"gate_started","gate":"fmt","ts":"..."}
              {"event":"gate_completed","gate":"fmt","status":"pass","duration_secs":3,"ts":"..."}
              {"event":"gate_started","gate":"clippy","ts":"..."}
              {"event":"gate_completed","gate":"clippy","status":"pass","duration_secs":12,"ts":"..."}
              ...
              {"event":"gates_summary","sha":"abc123","passed":true,"bounded":true,...,"gates":[...]}
              ```
              The final line is the existing GatesSummary struct serialized
              as compact JSON (not pretty-printed — JSONL requires one
              object per line).
          (e) In text mode, preserve existing behavior (human table).
          (f) Error events are also JSONL:
              `{"event":"gate_error","gate":"test","error":"...","ts":"..."}`

          Affected files:
          - crates/apm2-cli/src/commands/fac.rs (GatesArgs, dispatch, machine_output)
          - crates/apm2-cli/src/commands/fac_review/gates.rs (run_gates, run_gates_inner)

      - id: S2_PUSH_JSON_AND_JSONL
        title: "`fac push` — add --json flag, stream JSONL for multi-stage pipeline"
        detail: |
          Current state: PushArgs has no --json flag. Output is a mix of
          println!/eprintln! across ~1500 lines in push.rs. The push
          pipeline has 4+ stages (git push, gates, PR create/update,
          dispatch) each taking significant time.

          Required changes:
          (a) Add `#[arg(long, default_value_t = false)] pub json: bool`
              to PushArgs.
          (b) Update subcommand_requests_machine_output() for Push.
          (c) When JSON mode is active, stream JSONL progress:
              ```
              {"event":"push_started","branch":"...","remote":"...","ts":"..."}
              {"event":"git_push_completed","status":"pass","duration_secs":2,"ts":"..."}
              {"event":"gates_started","ts":"..."}
              {"event":"gate_completed","gate":"fmt","status":"pass","duration_secs":3,"ts":"..."}
              ... (gate events as in S1)
              {"event":"gates_completed","passed":true,"duration_secs":120,"ts":"..."}
              {"event":"pr_updated","pr_number":615,"url":"...","ts":"..."}
              {"event":"dispatch_completed","status":"pass","ts":"..."}
              {"event":"push_summary","sha":"...","pr_number":615,"passed":true,...}
              ```
          (d) If dispatch fails but push+gates+PR succeed, the summary
              still reports overall success with a `dispatch_warning` field
              (ties into TCK-00605 P1_PUSH_EXIT_CODE_SEPARATION).
          (e) In text mode, preserve existing behavior.

          Affected files:
          - crates/apm2-cli/src/commands/fac.rs (PushArgs, dispatch, machine_output)
          - crates/apm2-cli/src/commands/fac_review/push.rs

      - id: S3_RESTART_JSON
        title: "`fac restart` — add --json flag with structured outcome"
        detail: |
          Current state: RestartArgs has no --json flag. Output is text
          describing which stages were restarted.

          Required changes:
          (a) Add `#[arg(long, default_value_t = false)] pub json: bool`
              to RestartArgs.
          (b) Update subcommand_requests_machine_output() for Restart.
          (c) Define RestartResponse struct:
              { pr_number, sha, strategy, stages_restarted: [...],
                gates_skipped: bool, dispatch_result, duration_secs }
          (d) Output as single JSON object (restart is fast enough to not
              need JSONL streaming).

          Affected files:
          - crates/apm2-cli/src/commands/fac.rs (RestartArgs, dispatch, machine_output)
          - crates/apm2-cli/src/commands/fac_review/restart.rs

      - id: S4_LANE_JSON
        title: "`fac lane status` and `fac lane reset` — add --json flag"
        detail: |
          Current state: LaneStatusArgs and LaneResetArgs have no --json
          flag. Lane status outputs a text table; lane reset outputs a
          confirmation message.

          Required changes:
          (a) Add `#[arg(long, default_value_t = false)] pub json: bool`
              to both LaneStatusArgs and LaneResetArgs.
          (b) Update subcommand_requests_machine_output() for Lane.
          (c) Lane status JSON: array of lane objects with { lane_id,
              state, pid, lease_holder, lease_expires_at, workspace_path }.
          (d) Lane reset JSON: { lane_id, reset, force, cleanup_result }.

          Affected files:
          - crates/apm2-cli/src/commands/fac.rs (LaneStatusArgs, LaneResetArgs, dispatch, machine_output)

      - id: S5_REVIEW_RUN_DISPATCH_JSON
        title: "`fac review run` and `fac review dispatch` — add --json flag"
        detail: |
          Current state: ReviewRunArgs and ReviewDispatchArgs have no
          --json flag. `review run` is long-running (full review
          orchestration). `review dispatch` is a fire-and-forget spawn.

          Required changes:
          (a) Add `#[arg(long, default_value_t = false)] pub json: bool`
              to both ReviewRunArgs and ReviewDispatchArgs.
          (b) Update subcommand_requests_machine_output() for both.
          (c) `review dispatch` JSON: single object with { pr_number,
              review_type, dispatched_pids: [...], sha, model }.
              Dispatch is fast — no JSONL needed.
          (d) `review run` JSON: JSONL stream — this is a long-running
              orchestration. Events should mirror the existing NDJSON
              telemetry stream that `review tail` reads, with a final
              summary line.
          (e) `review tail` already outputs NDJSON. Add explicit --json
              flag to ReviewTailArgs for consistency (noop since output
              is already JSONL, but prevents clap rejection when agents
              pass --json).

          Affected files:
          - crates/apm2-cli/src/commands/fac.rs (ReviewRunArgs, ReviewDispatchArgs, ReviewTailArgs, machine_output)
          - crates/apm2-cli/src/commands/fac_review/mod.rs (dispatch, run)

      - id: S6_WORKER_PIPELINE_JSONL
        title: "`fac worker` and `fac pipeline` — add --json flag, stream JSONL"
        detail: |
          Current state: WorkerArgs and PipelineArgs have no --json flag.
          Worker is a continuous long-running process. Pipeline is an
          internal background process.

          Required changes:
          (a) Add `#[arg(long, default_value_t = false)] pub json: bool`
              to WorkerArgs and PipelineArgs.
          (b) Update subcommand_requests_machine_output() for both.
          (c) Worker JSONL: one line per job processed:
              { event: "job_started"|"job_completed"|"job_failed",
                job_id, duration_secs, exit_code, ... }
          (d) Pipeline JSONL: stage progress events similar to push.

          Affected files:
          - crates/apm2-cli/src/commands/fac.rs (WorkerArgs, PipelineArgs, machine_output)
          - crates/apm2-cli/src/commands/fac_worker.rs

      - id: S7_PR_AUTH_JSON
        title: "`fac pr auth-setup` and `fac pr auth-check` — add --json flag"
        detail: |
          Current state: PrArgs routes to fac_pr module. Auth-setup and
          auth-check output text instructions/status.

          Required changes:
          (a) Add --json flag to auth-setup and auth-check args.
          (b) Auth-check JSON: { authenticated, login, token_expires_at,
              permissions: { ... } }.
          (c) Auth-setup JSON: { setup_completed, steps: [...] }.

          Affected files:
          - crates/apm2-cli/src/commands/fac_pr/mod.rs
          - crates/apm2-cli/src/commands/fac_pr/auth_setup.rs
          - crates/apm2-cli/src/commands/fac_pr/auth_check.rs

      - id: S8_DECISION_MODEL_PROVENANCE
        title: "Review decisions and findings must include the model that produced them"
        detail: |
          The review run state (ReviewRunState, ReviewStateEntry in types.rs)
          already tracks `model_id` (e.g. "gpt-5.3-codex") and `backend_id`
          (e.g. "codex") for the reviewer that performed the work. But this
          provenance information is absent from the artifacts that agents and
          orchestrators actually read:

          1. DecisionEntry (decision.rs:56) — the per-dimension verdict record
             stored locally and projected to GitHub. Has decision, reason,
             set_by, set_at — but no model_id or backend_id. An orchestrator
             reading `verdict show` cannot tell which model produced the verdict
             without cross-referencing review run state files.

          2. DimensionDecisionView (decision.rs:131) — the view struct returned
             by `apm2 fac review verdict show`. Has dimension, decision, reason,
             set_by, set_at, sha — but no model_id or backend_id.

          3. DecisionShowReport (decision.rs:115) — the top-level verdict show
             report. Contains dimensions array of DimensionDecisionView but no
             model info at either level.

          4. StoredFinding (findings_store.rs:68) — individual review findings.
             Has reviewer_id but no model_id or backend_id. When an orchestrator
             reads findings, it cannot attribute them to a specific model without
             joining on reviewer_id and reverse-mapping through state files.

          5. GitHub-projected decision comment — the YAML payload projected to
             GitHub PR comments via verdict_projection.rs. Contains the
             DecisionComment schema which lacks model provenance.

          Required changes:
          (a) Add `model_id: Option<String>` and `backend_id: Option<String>`
              to DecisionEntry. These are set when `verdict set` is called
              (the calling reviewer knows its own model) or when the auto-verdict
              reaper derives a verdict (it can read model_id from the
              ReviewRunState of the reaped agent).
          (b) Add `model_id` and `backend_id` to DimensionDecisionView so
              `verdict show --json` includes the model in its output.
          (c) Add `model_id` and `backend_id` to StoredFinding. The `finding`
              subcommand already accepts `--reviewer-id`; add `--model-id`
              and `--backend-id` optional args to ReviewFindingArgs. The
              orchestrator (review run) passes these when emitting findings.
          (d) Update the GitHub decision comment projection to include model
              provenance in the YAML payload per dimension.
          (e) Update DecisionShowReport to surface model info in the
              dimensions array.
          (f) Use `#[serde(default, skip_serializing_if = "Option::is_none")]`
              on all new fields for backwards compatibility with existing
              stored artifacts that lack the fields.

          This is a provenance bug: the system knows which model did the work
          but strips that information from the artifacts that consumers read.
          Orchestrators need model provenance to make fallback/retry decisions
          (e.g. "security was reviewed by gemini-3-flash, retry with codex")
          and for audit trails.

          Affected files:
          - crates/apm2-cli/src/commands/fac_review/decision.rs (DecisionEntry, DimensionDecisionView, DecisionShowReport, run_verdict_set)
          - crates/apm2-cli/src/commands/fac_review/findings_store.rs (StoredFinding)
          - crates/apm2-cli/src/commands/fac_review/finding.rs (FindingSummary, append logic)
          - crates/apm2-cli/src/commands/fac_review/verdict_projection.rs (GitHub comment payload)
          - crates/apm2-cli/src/commands/fac.rs (ReviewFindingArgs — add --model-id, --backend-id)

      - id: S9_REMAINING_SUBCOMMANDS_MACHINE_OUTPUT_FIX
        title: "Fix subcommand_requests_machine_output() for all remaining commands"
        detail: |
          Several commands already use the parent FacCommand.json flag via
          the json_output local but are listed in the `false` arm of
          subcommand_requests_machine_output(). This means the parent
          flag doesn't suppress human-formatted stderr/warning output
          in those code paths.

          Commands that use parent json but return false from machine_output:
          - Gates, Work, Services, Gc, RoleLaunch, Episode, Receipt,
            Context, Resume, Lane, Push, Restart, Worker, Pipeline, Pr.

          After S1-S7 add per-subcommand --json flags, update
          subcommand_requests_machine_output() to check the subcommand-
          level flag for every arm. No arm should unconditionally return
          false. Commands with both parent and subcommand --json flags
          resolve as `parent_json || subcommand_json`.

          Affected file:
          - crates/apm2-cli/src/commands/fac.rs (subcommand_requests_machine_output)

      - id: S10_DOCTOR_WAIT_FOR_RECOMMENDED_ACTION
        title: "`fac doctor --pr <N> --wait-for-recommended-action` — blocking poll loop that exits on actionable state"
        detail: |
          This is the main value-add of the ticket. Orchestrators currently
          poll `apm2 fac doctor --pr <N> --json` in a tight loop, parsing
          the output, checking recommended_action, sleeping, and repeating.
          This is expensive (LLM reasoning per tick), unreliable (agents
          misparse or skip polling), and wasteful (most polls return "wait").

          `--wait-for-recommended-action` moves this polling loop into
          deterministic Rust: doctor repeatedly evaluates PR state and
          blocks until the recommended_action is something OTHER than
          "wait", then exits with the full doctor JSON output. The
          orchestrator calls one command and gets back a ready-to-act
          doctor snapshot.

          CLI interface:
          ```
          apm2 fac doctor --pr 615 --wait-for-recommended-action [--json]
          ```

          Preconditions:
          (a) `--pr <N>` is REQUIRED when `--wait-for-recommended-action`
              is set. Doctor without `--pr` returns system health, not a
              per-PR recommended_action — there's nothing to wait for.
              If `--pr` is missing, exit immediately with a clear error:
              "`--wait-for-recommended-action` requires `--pr <N>`".
          (b) Incompatible with `--fix`: if both flags are passed, exit
              immediately with an error. `--fix` is a one-shot repair;
              `--wait-for-recommended-action` is a blocking observer.
              They serve opposite purposes.

          Behavior:
          (c) On invocation, run `run_doctor_inner()` immediately to get
              the current DoctorPrSummary.
          (d) Check `summary.recommended_action.action`:
              - If NOT "wait" → the PR needs attention. Emit the full
                DoctorPrSummary JSON and exit immediately.
              - If "wait" → the PR is in a steady state (reviews running,
                nothing broken). Enter the poll loop.
          (e) Poll loop:
              - Sleep for a configurable interval (default 1 second,
                controlled by `--poll-interval-seconds`). The 1-second
                default is intentional: `run_doctor_inner()` reads local
                files only (no network, no subprocess) and completes in
                single-digit milliseconds. Polling at 1s gives sub-second
                reaction time to state changes (reviewer crash, verdict
                written, findings appended) with negligible CPU cost.
              - Re-run `run_doctor_inner()` to get fresh state.
              - Check recommended_action against the exit-on set.
              - If action matches → emit the DoctorPrSummary JSON and exit.
              - If "wait" → continue polling.
          (f) Timeout: the poll loop has a wall-clock timeout (default 60s,
              controlled by `--wait-timeout-seconds`, hard max 180s). If
              the timeout expires without the action leaving "wait",
              doctor emits the FULL DoctorPrSummary JSON (identical to a
              normal doctor invocation) and exits with code 0. This
              forces the orchestrator back into its dispatch loop — it
              must re-evaluate, handle other PRs, and re-invoke. The
              180s hard cap prevents orchestrators from using a huge
              timeout to avoid doing work.
              Clap validation: `--wait-timeout-seconds` must be in [5, 180].
              Values outside this range are rejected at parse time.
          (g) Exit-on filter (`--exit-on`): by default, ANY non-"wait"
              action causes immediate exit (fix, escalate, merge,
              dispatch_implementor, restart_reviews). The `--exit-on` flag
              narrows this to a specific subset:
              ```
              apm2 fac doctor --pr 615 --wait-for-recommended-action \
                --exit-on fix,escalate,merge
              ```
              This would keep polling through `dispatch_implementor` and
              `restart_reviews` — useful when those actions are handled by
              separate background automation and the orchestrator only
              wants to wake for terminal or emergency states.
              If omitted, all non-wait actions trigger exit (default
              behavior, backwards compatible).
              Validation: values must be from the closed action vocabulary.
              Unknown actions are rejected at parse time.
          (h) JSONL streaming mode: when `--json` is active alongside
              `--wait-for-recommended-action`, emit one JSONL line per
              poll tick. Intermediate lines are intentionally minimal —
              just enough for liveness detection and log timestamps:
              ```
              {"event":"doctor_poll","tick":0,"action":"wait","ts":"2026-02-14T12:00:01Z"}
              {"event":"doctor_poll","tick":1,"action":"wait","ts":"2026-02-14T12:00:02Z"}
              {"event":"doctor_poll","tick":2,"action":"wait","ts":"2026-02-14T12:00:03Z"}
              ...
              ```
              The intermediate `doctor_poll` lines carry only four fields:
              event, tick, action, ts. No summary, no diagnostics.
              This is a heartbeat, not a report.

              On exit (action resolved OR timeout), the final line is a
              `doctor_result` containing the FULL DoctorPrSummary:
              ```
              {"event":"doctor_result","tick":14,"action":"dispatch_implementor","ts":"2026-02-14T12:00:15Z","summary":{...full DoctorPrSummary...}}
              ```
              On timeout, the final line is identical but action is "wait"
              and the summary reflects current state — the orchestrator
              gets a complete snapshot either way.

              An orchestrator that doesn't need heartbeats can ignore all
              lines except the last.
          (i) Signal handling (SIGINT / SIGTERM): the poll loop installs
              a signal handler (e.g. via `ctrlc` crate or `signal_hook`).
              On interrupt:
              - Run one final `run_doctor_inner()` to get current state.
              - Emit the DoctorPrSummary as the final JSONL `doctor_result`
                line (or pretty JSON in text mode).
              - Exit with code 0.
              This guarantees the orchestrator always gets a usable
              snapshot, even on Ctrl-C or process manager kill. Without
              this, an interrupted wait produces truncated/empty output
              and the orchestrator has no state to work with.
          (j) Exit codes:
              - 0: recommended_action resolved to a matching exit-on
                   action, OR timeout expired, OR signal received.
              - 1: doctor evaluation itself failed (state unreadable,
                   file corruption, etc.), OR precondition violation
                   (missing --pr, incompatible --fix).
              The exit code does NOT distinguish between action types.
              The action field in the JSON output is the discriminator.

          Why this matters:
          - Eliminates the polling loop from the LLM orchestrator entirely.
            The orchestrator calls `doctor --pr <N> --wait-for-recommended-action`
            and blocks. When it returns, the action field tells the
            orchestrator exactly what to do next.
          - Reduces orchestrator API cost by ~60x: instead of the LLM
            being invoked every 30-60s to check status and re-reason,
            it's invoked once when there's actually something to do.
          - Eliminates the "orchestrator fell asleep" failure mode: the
            Rust poll loop is deterministic and doesn't forget to check.
          - Eliminates the "orchestrator misinterpreted doctor output"
            failure mode: the action vocabulary is closed and machine-
            readable, and the orchestrator never sees intermediate "wait"
            states.
          - The 60-second default timeout (hard max 180s) is a forcing
            function: the orchestrator MUST come back into its dispatch
            loop regularly. Even if reviews take hours, it gets control
            back to handle other PRs, check global state, log progress.
            The hard cap prevents lazy orchestrators from setting a 1-hour
            timeout and going to sleep.
          - Signal safety means the orchestrator always gets a doctor
            snapshot on return, regardless of how the wait ended (action
            resolved, timeout, interrupt). No code path produces empty
            or truncated output.

          New CLI args on DoctorArgs:
          - `--wait-for-recommended-action` (bool flag)
          - `--poll-interval-seconds` (u64, default 1, min 1, max 10)
          - `--wait-timeout-seconds` (u64, default 60, min 5, max 180)
          - `--exit-on` (comma-separated list of actions from the closed
            vocabulary: fix, escalate, merge, dispatch_implementor,
            restart_reviews; default: all non-wait actions)

          Affected files:
          - crates/apm2-cli/src/commands/fac.rs (DoctorArgs — new flags)
          - crates/apm2-cli/src/commands/fac_review/mod.rs (run_doctor — poll loop, JSONL streaming, signal handler)

      - id: S11_DEFAULT_JSON_OUTPUT
        title: "Make JSON the default output for all fac commands"
        detail: |
          After S1-S8 ensure every fac subcommand has a --json flag and
          machine_output detection, flip the default so agents don't need
          to remember to pass --json.

          Approach:
          (a) Change FacCommand.json default from "false" to "true".
          (b) Add `#[arg(long, default_value_t = false)] pub text: bool`
              to FacCommand for human-readable opt-in.
          (c) Effective format = if text { text } else { json }.
          (d) Per-subcommand --json flags remain as aliases / overrides
              but are effectively noops when the parent defaults to json.
          (e) JSONL-streaming commands (gates, push, review run, worker,
              pipeline) stream compact JSONL by default. The `--text`
              flag switches them to their existing human-formatted output.

          This is the terminal state: every `apm2 fac` invocation produces
          machine-parseable output without any flag. Agents work correctly
          out of the box. Humans pass `--text` when they want a table.

          Affected file:
          - crates/apm2-cli/src/commands/fac.rs (FacCommand)

      - id: S12_REMOVE_HUMAN_READABLE_OUTPUT
        title: "Remove all human-readable text output paths — JSON-only invariant"
        detail: |
          End support for human-readable (text/table) output across all
          FAC commands. Every FAC command must emit JSON or JSONL to
          stdout unconditionally. There is no `--text` escape hatch.

          This supersedes S11's `--text` opt-in approach. The reasoning:
          FAC commands are consumed exclusively by agents and automation.
          Maintaining dual output paths (text + JSON) doubles the testing
          surface, introduces format-drift bugs where one path is updated
          but not the other, and adds dead code that no consumer uses.

          Required changes:
          (a) Remove the `--text` flag from FacCommand (if added by S11)
              and all per-subcommand text-mode output branches.
          (b) Remove all `if !json_output { println!(...) }` text-mode
              formatting paths, human tables, and human_log! invocations
              that write to stdout.
          (c) Diagnostic/progress messages may still go to stderr (they
              are not parsed by consumers), but stdout is reserved
              exclusively for JSON/JSONL.
          (d) Short-lived commands emit a single pretty-printed JSON
              object to stdout.
          (e) Long-running commands emit compact JSONL to stdout (one
              object per line, flushed after each event).
          (f) Error responses are JSON objects on stdout with an `error`
              field — not bare text on stderr.

          Invariant: `apm2 fac <any-subcommand> | jq .` must always
          succeed (single-object commands) or `apm2 fac <any-subcommand>
          | while read line; do echo "$line" | jq .; done` must succeed
          (JSONL-streaming commands).

          Affected files:
          - crates/apm2-cli/src/commands/fac.rs (remove --text, remove text branches)
          - crates/apm2-cli/src/commands/fac_review/gates.rs (remove human table)
          - crates/apm2-cli/src/commands/fac_review/push.rs (remove text output)
          - crates/apm2-cli/src/commands/fac_review/restart.rs (remove text output)
          - crates/apm2-cli/src/commands/fac_review/mod.rs (remove text branches in doctor, wait, status, etc.)
          - All other fac_review/*.rs and fac_*.rs files with text-mode branches

      - id: S13_GITHUB_COMMENT_CODE_FENCE_ESCAPE
        title: "Fix code fence truncation in GitHub PR comment projection"
        detail: |
          GitHub-projected comments (verdict decisions, CI status) use
          YAML inside a markdown fenced code block:

              <!-- marker -->
              ```yaml
              # marker
              {serde_yaml output}```

          Two bugs cause code blocks to be truncated or sliced:

          1. MISSING NEWLINE BEFORE CLOSING FENCE
             render_decision_comment_body() in both decision.rs and
             verdict_projection.rs, and to_comment_body() in ci_status.rs,
             produce the closing fence as `{yaml}``` ` without a guaranteed
             newline separator. While serde_yaml::to_string() typically
             emits a trailing `\n`, the format string does not defensively
             ensure one. If any edge case omits it, the closing fence is
             not on its own line and GitHub does not close the code block.

          2. YAML VALUES CONTAINING TRIPLE BACKTICKS
             Reviewer-generated text fields (reason, finding summary,
             finding details) may contain markdown code fences (```)
             within their values. serde_yaml serializes these as-is in
             block or flow scalars. When embedded inside the outer
             ```yaml fence, GitHub's markdown parser sees the inner
             backticks as the closing fence, truncating everything after.
             The read-side parser extract_fenced_yaml() (decision.rs:441)
             has the same vulnerability — it searches for "\n```" and
             matches the first occurrence, which may be inside a YAML
             value rather than the actual closing fence.

          Required changes:
          (a) Fix the format string in all three render functions to
              defensively ensure a newline before the closing fence:
              `format!("<!-- {MARKER} -->\n```yaml\n# {MARKER}\n{yaml}\n```\n")`
              (The extra \n before ``` is harmless if yaml already ends
              with \n, producing a blank line which is valid markdown.)
          (b) Sanitize YAML string values before serialization: replace
              any occurrence of ``` (triple backtick) within string
              fields with a safe alternative (e.g., replace backticks
              with Unicode fullwidth grave accent U+FF40, or HTML entity
              &#96;&#96;&#96;) to prevent premature fence closure.
              Alternatively, use a unique fence marker (e.g.,
              `````yaml ... ````` with 5 backticks) that is statistically
              unlikely to appear in reviewer text.
          (c) Harden extract_fenced_yaml() to match the closing fence
              using the same backtick count as the opening fence, and
              require the closing fence to be on a line by itself (no
              leading content other than optional whitespace).
          (d) Apply the same fix to ci_status.rs::to_comment_body().

          Affected files:
          - crates/apm2-cli/src/commands/fac_review/decision.rs (render_decision_comment_body, extract_fenced_yaml)
          - crates/apm2-cli/src/commands/fac_review/verdict_projection.rs (render_decision_comment_body)
          - crates/apm2-cli/src/commands/fac_review/ci_status.rs (to_comment_body)

      - id: S14_STRUCTURED_ERROR_OUTPUT
        title: "All errors and warnings on stdout must be valid JSON — never break jq"
        detail: |
          Several FAC commands currently emit unstructured error/warning
          text to stdout, which corrupts the JSON stream and breaks
          `jq` parsing. This is the #1 way agents lose parseable output.

          Current violation patterns:

          1. UNSTRUCTURED ERROR LISTS ON STDOUT
             decision.rs:945-947, findings.rs:438-440, and
             verdict_projection.rs:1575-1577 print human-formatted error
             listings to stdout via println!:
               println!("  Errors:");
               println!("    - {error}");
             These lines land in the same stream as JSON output and
             break any `| jq .` pipeline.

          2. MIXED STRUCTURED/UNSTRUCTURED IN SAME COMMAND
             Some commands emit a JSON payload via println! for the
             success path but fall through to eprintln!/println! for
             error paths. An agent piping stdout to jq gets either
             valid JSON or garbage — no reliable error contract.

          3. JSONL STREAM CORRUPTION
             For JSONL-streaming commands (gates, push, worker), if an
             error occurs mid-stream, the error must be a valid JSONL
             line, not bare text. A bare `eprintln!("ERROR: ...")` is
             safe (stderr, not parsed), but a `println!("ERROR: ...")`
             mid-JSONL-stream produces an unparseable line.

          Required changes:

          (a) Establish the stdout-is-JSON invariant:
              - stdout MUST contain only valid JSON (single object) or
                valid JSONL (one JSON object per line). No exceptions.
              - stderr is the sink for human-readable diagnostics,
                progress messages, and warnings. These are never parsed
                by consumers and cannot break jq.

          (b) For single-object commands, errors become JSON error
              objects on stdout:
                {"error": "<error_code>", "message": "<detail>"}
              This is already the pattern in gates.rs (line 106-113)
              and lifecycle.rs (line 2907). Normalize all commands to
              use this pattern.

          (c) For JSONL-streaming commands, errors become JSONL event
              lines on stdout:
                {"event": "<command>_error", "error": "<detail>", "ts": "..."}
              The stream remains parseable line-by-line. The consumer
              detects the error via the event field discriminator.

          (d) Audit and fix every println! call in fac_review/ that
              emits non-JSON content. Specific known violations:
              - decision.rs:945-947 (error list in text verdict show)
              - findings.rs:431, 438-440 (error details in text findings)
              - verdict_projection.rs:1575-1577 (error list in text show)
              These are text-mode paths that S12 removes entirely.
              After S12, these code paths no longer exist — but the
              error information they carried must be preserved as
              fields within the JSON response (e.g., an `errors: [...]`
              array in the response struct).

          (e) Provide a shared error emission helper alongside the
              JSONL helper in jsonl.rs:
              - `fn emit_json_error(code: &str, message: &str)` for
                single-object error responses.
              - `fn emit_jsonl_error(event_prefix: &str, message: &str)`
                for error events within a JSONL stream.
              Both write to stdout and flush.

          (f) Exit codes remain meaningful:
              - 0: command succeeded (JSON response contains result)
              - 1: command failed (JSON response contains error)
              The consumer reads the exit code first, then parses the
              JSON payload. Both paths produce valid JSON.

          Contract: for any FAC command invocation, the following must
          hold:
            `apm2 fac <cmd> [args] 2>/dev/null | jq . >/dev/null`
          must exit 0 (valid JSON) regardless of whether the command
          itself succeeded or failed. Failures produce JSON error
          objects, not parse failures.

          Affected files:
          - crates/apm2-cli/src/commands/fac_review/jsonl.rs (error helpers)
          - crates/apm2-cli/src/commands/fac_review/decision.rs (remove println! error lists)
          - crates/apm2-cli/src/commands/fac_review/findings.rs (remove println! error lists)
          - crates/apm2-cli/src/commands/fac_review/verdict_projection.rs (remove println! error lists)
          - crates/apm2-cli/src/commands/fac_review/gates.rs (normalize error path)
          - crates/apm2-cli/src/commands/fac_review/push.rs (normalize error path)
          - crates/apm2-cli/src/commands/fac_review/restart.rs (normalize error path)
          - crates/apm2-cli/src/commands/fac_review/mod.rs (normalize error paths)
          - crates/apm2-cli/src/commands/fac_gc.rs (normalize error path)
          - crates/apm2-cli/src/commands/fac_broker.rs (normalize error path)

    out_of_scope:
      - "Non-FAC commands (process management, creds, daemon). Those are a separate ticket."
      - "Changing the semantic content of any command's output — only the wire format changes."
      - "Adding new subcommands."
      - "Changing exit codes or error semantics."
      - "Modifying the NDJSON telemetry file format under ~/.apm2/ — only stdout output changes."
      - "Pretty-printing JSONL — JSONL lines are compact (one object per line); pretty JSON is only for single-object responses."
      - "Human-readable text output — S12 removes all text output paths; no --text flag will exist."
  plan:
    steps:
      - id: STEP_01
        title: "Define JSONL event types and streaming helper"
        detail: |
          Create a small helper module or function for JSONL output:
          - `fn emit_jsonl(event: &impl Serialize)` — serializes to compact
            JSON + newline, writes to stdout, flushes.
          - Define event envelope: every JSONL line has `event` (string),
            `ts` (ISO-8601 timestamp), plus event-specific fields.
          - Define shared event types: GateStarted, GateCompleted,
            GateError, StageStarted, StageCompleted, for reuse across
            gates/push/pipeline.
          - Place in a shared location accessible to fac_review submodules
            (e.g. fac_review/jsonl.rs or a function in fac_review/types.rs).
      - id: STEP_02
        title: "Gates: add --json to GatesArgs and stream JSONL progress"
        detail: |
          (a) Add json: bool to GatesArgs.
          (b) Thread the flag through run_gates() and run_gates_inner().
          (c) At each gate boundary in run_gates_inner(), emit JSONL
              gate_started/gate_completed events.
          (d) Final line: GatesSummary serialized as compact JSONL.
          (e) Update subcommand_requests_machine_output() for Gates.
      - id: STEP_03
        title: "Push: add --json to PushArgs and stream JSONL progress"
        detail: |
          (a) Add json: bool to PushArgs.
          (b) Identify the stage boundaries in push.rs (git push, gates,
              PR update, dispatch).
          (c) Emit JSONL stage events at each boundary.
          (d) Final line: PushSummary with overall result.
          (e) Update subcommand_requests_machine_output() for Push.
      - id: STEP_04
        title: "Restart: add --json to RestartArgs"
        detail: |
          (a) Add json: bool to RestartArgs.
          (b) Define RestartResponse struct.
          (c) Single JSON object output (not JSONL — restart is fast).
          (d) Update subcommand_requests_machine_output() for Restart.
      - id: STEP_05
        title: "Lane: add --json to LaneStatusArgs and LaneResetArgs"
        detail: |
          (a) Add json: bool to both.
          (b) Define LaneStatusResponse (array of lane entries) and
              LaneResetResponse.
          (c) Update subcommand_requests_machine_output() for Lane.
      - id: STEP_06
        title: "Review run/dispatch/tail: add --json flags"
        detail: |
          (a) Add json: bool to ReviewRunArgs, ReviewDispatchArgs,
              ReviewTailArgs.
          (b) Review dispatch: single JSON object response.
          (c) Review run: JSONL stream (mirrors telemetry events).
          (d) Review tail: --json is a noop (already NDJSON) but prevents
              clap rejection.
          (e) Update subcommand_requests_machine_output() for all three.
      - id: STEP_07
        title: "Worker/pipeline: add --json flags with JSONL"
        detail: |
          (a) Add json: bool to WorkerArgs and PipelineArgs.
          (b) Worker: JSONL line per job lifecycle event.
          (c) Pipeline: JSONL stage events.
          (d) Update subcommand_requests_machine_output() for both.
      - id: STEP_08
        title: "PR auth-setup/auth-check: add --json flags"
        detail: |
          (a) Add json: bool to auth-setup and auth-check args.
          (b) Define response structs.
          (c) Update subcommand_requests_machine_output() for Pr.
      - id: STEP_09
        title: "Decision model provenance: add model_id/backend_id to verdicts and findings"
        detail: |
          (a) Add model_id, backend_id (Option<String>) to DecisionEntry
              and DimensionDecisionView in decision.rs.
          (b) In run_verdict_set(), propagate model_id/backend_id from the
              calling context (ReviewRunState) into the DecisionEntry.
          (c) Add model_id, backend_id to StoredFinding in findings_store.rs.
          (d) Add --model-id and --backend-id optional args to ReviewFindingArgs
              in fac.rs; thread through to finding append logic.
          (e) Update verdict_projection.rs to include model provenance in
              the GitHub decision comment YAML payload.
          (f) Use #[serde(default, skip_serializing_if = "Option::is_none")]
              on all new fields.
      - id: STEP_10
        title: "Doctor --wait-for-recommended-action: poll loop with JSONL heartbeats"
        detail: |
          (a) Add `--wait-for-recommended-action`, `--poll-interval-seconds`
              (default 1, clap range 1..=10), `--wait-timeout-seconds`
              (default 60, clap range 5..=180), `--exit-on` (optional
              comma-separated action list) to DoctorArgs in fac.rs.
          (b) Precondition validation in run_doctor():
              - Reject if --pr is missing ("requires --pr <N>").
              - Reject if --fix is also set ("incompatible with --fix").
              - Parse and validate --exit-on values against closed vocab.
          (c) In run_doctor(), when wait_for_recommended_action is true:
              - Run initial run_doctor_inner(). If action matches exit-on
                set, emit full DoctorPrSummary and return immediately.
              - Enter poll loop: sleep(1s), re-run run_doctor_inner(),
                check action against exit-on set. Emit minimal JSONL
                heartbeat per tick when json_output is true.
              - On match OR timeout: emit final DoctorPrSummary (as JSONL
                doctor_result with full summary, or pretty JSON) and exit.
                Both action-resolved and timeout produce the full snapshot.
          (d) The poll loop must be a simple synchronous thread::sleep loop
              (same pattern as run_wait_inner in the same module). No async.
          (e) JSONL heartbeat: { event: "doctor_poll", tick, action, ts }.
              Minimal — just liveness + timestamp. No diagnostics, no
              summary payload.
              Final line: { event: "doctor_result", tick, action, ts,
              summary: {full DoctorPrSummary} }.
          (f) Text mode: print one-line status per tick to stderr (not
              stdout) for progress indication; final DoctorPrSummary to
              stdout as pretty JSON (same as current doctor behavior).
          (g) Signal handler: install SIGINT/SIGTERM handler (via ctrlc
              crate or signal_hook). On signal, run one final
              run_doctor_inner(), emit the DoctorPrSummary as the final
              line, exit 0. This guarantees the orchestrator always gets
              a usable snapshot.
          (h) Exit code: 0 in all cases except doctor evaluation failure
              or precondition violation.
      - id: STEP_11
        title: "Audit subcommand_requests_machine_output() — no false arms"
        detail: |
          After STEP_02-STEP_08, verify that every arm of
          subcommand_requests_machine_output() checks a subcommand-level
          json flag. Remove the catch-all false arm entirely — every
          variant must be explicitly handled.
      - id: STEP_12
        title: "Flip default: FacCommand.json = true, add --text opt-in"
        detail: |
          (a) Change FacCommand.json default_value from "false" to "true".
          (b) Add text: bool to FacCommand.
          (c) Resolve format as: if text { text } else { json }.
          (d) Verify all text-mode paths still work when --text is passed.
      - id: STEP_13
        title: "cargo fmt, clippy, doc, test"
        detail: "Mandatory pre-commit checks."
  definition_of_done:
    evidence_ids: []
    criteria:
      - "Every `apm2 fac` subcommand accepts `--json` without clap rejection."
      - "When `--json` is active, every fac command outputs valid JSON or valid JSONL to stdout."
      - "Short-lived commands (restart, lane status/reset, review dispatch, review findings, review verdict, doctor, etc.) output a single pretty-printed JSON object."
      - "Long-running commands (gates, push, review run, worker, pipeline) stream compact JSONL to stdout — one JSON object per line, flushed after each event."
      - "Every JSONL stream has a final summary line that contains the complete result (GatesSummary, PushSummary, etc.)."
      - "JSONL events include an `event` field (string discriminator) and a `ts` field (ISO-8601 timestamp)."
      - "Error events in JSONL streams are JSON objects with `event: \"..._error\"` — not bare text on stderr."
      - "subcommand_requests_machine_output() has no catch-all `false` arm — every FacSubcommand variant is explicitly handled."
      - "FacCommand.json defaults to true — agents get structured output without passing any flag."
      - "No `--text` flag exists. No human-readable text output path exists. All stdout is JSON or JSONL unconditionally."
      - "`fac gates --json` streams per-gate JSONL events (gate_started, gate_completed) followed by a gates_summary line."
      - "`fac push --json` streams per-stage JSONL events (git_push, gates, pr_update, dispatch) followed by a push_summary line."
      - "`fac restart --json` outputs a single RestartResponse JSON object."
      - "`fac lane status --json` outputs a JSON array of lane objects."
      - "`fac lane reset --json` outputs a single LaneResetResponse JSON object."
      - "`fac review run --json` streams JSONL review progress events."
      - "`fac review dispatch --json` outputs a single DispatchResponse JSON object."
      - "`fac review tail --json` is accepted without error (already NDJSON)."
      - "`fac worker --json` streams per-job JSONL lifecycle events."
      - "`fac pr auth-check --json` outputs a structured auth status JSON object."
      - "`fac pr auth-setup --json` outputs a structured setup result JSON object."
      - "`apm2 fac review verdict show --json` includes `model_id` and `backend_id` per dimension, identifying which model produced each verdict."
      - "`apm2 fac review verdict set` persists `model_id` and `backend_id` in the DecisionEntry when provided by the calling reviewer."
      - "`apm2 fac review findings --json` includes `model_id` and `backend_id` on each StoredFinding when available."
      - "`apm2 fac review finding` accepts `--model-id` and `--backend-id` optional args to tag findings with model provenance."
      - "Auto-verdict (reaper-derived verdicts) populates model_id/backend_id from the reaped agent's ReviewRunState."
      - "GitHub-projected decision comments include model provenance per dimension in the YAML payload."
      - "New model_id/backend_id fields use `#[serde(default, skip_serializing_if = \"Option::is_none\")]` for backwards compatibility with existing stored artifacts."
      - "`apm2 fac doctor --pr <N> --wait-for-recommended-action` blocks until recommended_action is not 'wait' (or matches `--exit-on` filter), then exits with the full DoctorPrSummary JSON."
      - "`--wait-for-recommended-action` without `--pr` is rejected with a clear error message."
      - "`--wait-for-recommended-action` exits immediately when the first doctor evaluation returns an action matching the exit-on set (default: all non-wait actions)."
      - "`--exit-on` accepts a comma-separated list of actions from the closed vocabulary (fix, escalate, merge, dispatch_implementor, restart_reviews). Unknown action names are rejected at parse time."
      - "`--exit-on` omitted means all non-wait actions trigger exit (backwards-compatible default)."
      - "`--wait-for-recommended-action` exits after `--wait-timeout-seconds` (default 60, hard max 180) if the action remains 'wait'. On timeout, the full DoctorPrSummary JSON is emitted (identical to a normal doctor invocation) with exit code 0."
      - "`--wait-timeout-seconds` is clamped to [5, 180] at parse time. Values outside this range are rejected by clap."
      - "`--wait-for-recommended-action` polls at `--poll-interval-seconds` (default 1, min 1, max 10). 1s polling is safe because `run_doctor_inner()` reads only local files and completes in single-digit milliseconds."
      - "`--wait-for-recommended-action` + `--json` streams minimal JSONL heartbeat lines (`doctor_poll`) per tick containing only event, tick, action, and ts fields."
      - "On exit (action resolved, timeout, or signal), the final JSONL line is `doctor_result` containing the complete DoctorPrSummary in a `summary` field."
      - "`--wait-for-recommended-action` + `--fix` is rejected with an error (mutually exclusive flags)."
      - "`--wait-for-recommended-action` exit code is 0 for action resolved, timeout expired, or signal received; exit code 1 only for doctor evaluation failures or precondition violations."
      - "SIGINT and SIGTERM during `--wait-for-recommended-action` trigger a graceful exit: one final `run_doctor_inner()` call, emit the full DoctorPrSummary, exit 0. The orchestrator always gets a usable snapshot."
      - "All response and event structs derive Serialize (and Deserialize where appropriate)."
      - "All evidence gates and tests pass."
      - "No FAC command emits unstructured text to stdout under any flag combination. `stdout` is exclusively JSON/JSONL."
      - "All human-readable text output paths (tables, progress messages, human_log! to stdout) are removed."
      - "Diagnostic/progress messages to stderr are permitted but never parsed by consumers."
      - "GitHub-projected verdict comments use a fenced code block with a guaranteed newline before the closing fence."
      - "YAML values embedded in GitHub comment code fences are sanitized: triple backticks within YAML string fields cannot prematurely close the markdown code fence."
      - "extract_fenced_yaml() correctly identifies the closing fence even when YAML content contains backtick sequences."
      - "CI status comments (ci_status.rs) apply the same code fence fix as verdict comments."
      - "For any FAC command invocation: `apm2 fac <cmd> [args] 2>/dev/null | jq . >/dev/null` exits 0 regardless of command success or failure."
      - "Failed commands emit a JSON error object to stdout (`{\"error\": \"<code>\", \"message\": \"<detail>\"}`) — not bare text."
      - "Errors mid-JSONL-stream are valid JSONL event lines with an `event` field ending in `_error` — the stream remains parseable line-by-line."
      - "No `println!` call in any FAC command emits non-JSON content to stdout."
      - "Shared error emission helpers (`emit_json_error`, `emit_jsonl_error`) exist in the JSONL helper module for consistent error formatting."
      - "Error information previously carried by text-mode println! paths (error lists in verdict show, findings, verdict projection) is preserved as `errors: [...]` arrays within JSON response structs."
  notes:
    context: |
      This ticket addresses a usability bug that affects every LLM agent
      interacting with the `apm2 fac` CLI. Agents uniformly assume `--json`
      exists on all fac subcommands because it exists on most of them. The
      inconsistency is the bug, not the agent behavior.

      The JSONL streaming dimension solves a second problem: long-running
      commands (gates, push, review run, worker) produce no output for
      minutes in JSON mode, giving agents zero signal about progress. JSONL
      gives real-time per-stage observability without requiring a separate
      polling mechanism.

      The centerpiece feature is `--wait-for-recommended-action` on the
      doctor command (S10). This eliminates the orchestrator polling loop
      entirely. Instead of the LLM being invoked every 30-60s to call
      doctor, parse output, decide whether to act, and sleep — the Rust
      CLI does the polling and only returns when there's something to do.
      The orchestrator becomes: call doctor --wait-for-recommended-action,
      read the action field, dispatch. One API call per actionable event
      instead of one per tick.

      Design invariants:
      - JSONL uses compact serialization (one object per line, no pretty-print).
        Single-object responses use pretty-print for human debuggability.
      - Every JSONL stream ends with a summary line. Consumers can ignore
        intermediate events and read only the last line for the final result.
      - stderr is reserved for diagnostics that should never be parsed.
        All structured output goes to stdout.
      - There is no --text flag. JSON is the only output format. S12
        supersedes S11's --text opt-in approach: all consumers are agents,
        dual output paths are dead code and a maintenance hazard.

      Priority: P0 (--wait-for-recommended-action), P1 (JSON parity,
      model provenance, GitHub comment fix).
      Complexity: Medium-high — the JSON parity work is mechanical, but
      --wait-for-recommended-action requires careful poll loop design,
      JSONL heartbeat streaming, timeout handling, and exit code semantics.
