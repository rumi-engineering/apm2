acceptance_criteria:
  - criterion: CgroupReader for cpu, memory, io stats
    verification: Reader returns valid metrics for process
  - criterion: Per-episode cgroup placement
    verification: Episode process runs in isolated cgroup
  - criterion: Fallback to /proc for non-cgroup metrics
    verification: Degraded mode returns /proc values
implementation:
  code_examples:
    - description: CgroupReader structure
      code: |
        pub struct CgroupReader {
            cgroup_path: PathBuf,
            fallback_pid: Option<Pid>,
        }

        impl CgroupReader {
            pub fn for_episode(episode_id: &EpisodeId) -> Result<Self>;

            pub fn read_cpu(&self) -> Result<CpuStats> {
                // cpu.stat: usage_usec, user_usec, system_usec
            }

            pub fn read_memory(&self) -> Result<MemoryStats> {
                // memory.current, memory.peak, memory.stat
            }

            pub fn read_io(&self) -> Result<IoStats> {
                // io.stat: rbytes, wbytes, rios, wios
            }
        }
  files_to_create:
    - path: crates/apm2-daemon/src/telemetry/cgroup.rs
      purpose: CgroupReader and cgroup v2 integration
    - path: crates/apm2-daemon/src/telemetry/stats.rs
      purpose: CpuStats, MemoryStats, IoStats types
    - path: crates/apm2-daemon/src/telemetry/proc_fallback.rs
      purpose: /proc fallback for degraded mode
  files_to_modify:
    - changes: Export cgroup, stats, proc_fallback modules
      path: crates/apm2-daemon/src/telemetry/mod.rs
  implementation_steps:
    - step: 1
      action: Define stats types
      details: |
        Create metric types per AD-TEL-001:
        - CpuStats: usage_ns, user_ns, system_ns
        - MemoryStats: rss_bytes, peak_bytes, page_faults
        - IoStats: read_bytes, write_bytes, read_ops, write_ops
    - step: 2
      action: Implement cgroup path resolution
      details: |
        Per AD-CGROUP-001, episodes run in:
        /sys/fs/cgroup/apm2.slice/episode-{uuid}.scope/

        Resolve path from episode_id:
        - Check cgroup v2 unified hierarchy
        - Verify controllers available
    - step: 3
      action: Implement stat readers
      details: |
        Read cgroup v2 files:
        - cpu.stat for CPU metrics
        - memory.current, memory.peak for memory
        - io.stat for I/O metrics
        Parse key=value format
    - step: 4
      action: Implement /proc fallback
      details: |
        For degraded mode (no cgroup):
        - /proc/{pid}/stat for CPU
        - /proc/{pid}/statm for memory
        - /proc/{pid}/io for I/O
        Mark metrics with degraded flag
    - step: 5
      action: Create episode cgroup scope
      details: |
        Per AD-CGROUP-001:
        - Primary: systemd transient API via zbus
        - Fallback: direct cgroup v2 writes
        - Freeze trick: create frozen, assign PID, unfreeze
  summary: |
    Implement cgroups v2 reader for resource metrics per AD-TEL-001 and AD-CGROUP-001.
    Reads cpu, memory, io stats from per-episode cgroup scopes.
    Includes /proc fallback for degraded mode.
notes: |
  Phase: PHASE-2C (Telemetry Collection)
  Generated from RFC RFC-0013 DECOMPOSE session on 2026-01-27.
  Maps to TCK-PEND-011.
schema_version: "2026-01-27"
template_version: "2026-01-27"
test_requirements:
  - description: Cgroup stat reading
    test_id: UT-00168-01
    verification_command: cargo test -p apm2-daemon cgroup_read
  - description: Proc fallback
    test_id: UT-00168-02
    verification_command: cargo test -p apm2-daemon proc_fallback
  - description: Episode cgroup creation
    test_id: IT-00168-01
    verification_command: cargo test -p apm2-daemon --test integration cgroup_create
ticket:
  depends_on:
    - TCK-00160
  id: TCK-00168
  requirement_ids:
    - REQ-TEL-001
  rfc_id: RFC-0013
  status: READY
  title: Implement cgroups v2 reader for resource metrics
