prd_solution_overview:
  schema_version: "2026-01-23"
  template_version: "2026-01-23"
  proposed_solution:
    overview: |
      Implement an "Idea Compiler" pipeline orchestrated by the core `apm2` CLI.
      The pipeline treats spec artifacts as compilation outputs and makes the repository itself a mandatory compilation input via a generated Codebase Context Pack (CCP). Each compiler stage runs as a bounded holonic episode (crash-only, restartable), emits structured findings, and writes deterministic artifacts (CCP, Impact Map, RFC, tickets).

      Multi-model execution is handled by a Model Router with explicit, versioned routing profiles. Every run emits a signed run manifest (content hashes, routing choices, timings, lint receipts) to support reproducibility and controlled upgrades.

      The north-star behavior is: a human can relay intent, then a supervising compiler holon produces a coherent extension contract grounded in existing abstractions; implementer agents then succeed in first-pass review by following those abstraction entrypoints instead of reinventing utilities.

    design_space_exploration:
      goal: |
        Identify an architecture that maximizes determinism and repository grounding while minimizing operational coupling and enabling future federation.
      options:
        - option_id: OPT-A
          name: Monolithic CLI-only compiler
          description: |
            Implement the entire pipeline inside the `apm2` CLI as pure local transforms.
            LLM calls are invoked by ProcessRunner where needed; no daemon integration required.
          strengths:
            - "Lowest coupling and easiest local iteration."
            - "Naturally idempotent with filesystem-based caching; minimal moving parts."
          weaknesses:
            - "Weaker central enforcement: harder to share caches and attest execution across machines."
            - "Harder to gate/lease across multiple concurrent compiler runs without shared state."

        - option_id: OPT-B
          name: Daemon-resident compiler service
          description: |
            Implement pipeline stages as daemon services, with CLI as a thin client.
            The daemon provides leases, auth, caching, and consistent run manifests.
          strengths:
            - "Strongest enforcement of auth/leases and consistent provenance."
            - "Naturally supports shared caches and future multi-node federation."
          weaknesses:
            - "Higher operational overhead; slows iteration if daemon lifecycle is heavy."
            - "Tighter coupling between spec compilation and runtime availability."

        - option_id: OPT-C
          name: Declarative pipeline spec + pluggable stage runtime
          description: |
            Define a PipelineSpec IR (YAML) describing stages, inputs, outputs, routing, and completion predicates.
            Implement a stage runtime in the CLI that can execute stages locally or via daemon in the future.
          strengths:
            - "Maximal flexibility: stages are explicit, versioned, and composable."
            - "Enables controlled evolution and partial runs; supports multi-model routing per stage."
          weaknesses:
            - "Requires careful IR design to preserve determinism and simplicity."

      selected_approach:
        choice: OPT-C
        rationale: |
          Use a declarative PipelineSpec with a pluggable stage runtime implemented in the core CLI.
          This captures the strengths of CLI-first iteration while avoiding a monolithic, implicit workflow.
          It also creates a clean seam for later daemon-backed execution and federation.

    key_components:
      - name: "PipelineSpec IR"
        description: |
          A versioned, machine-readable IR that defines pipeline stages, their required inputs, outputs,
          deterministic completion predicates, and routing policy. The IR is itself a governed document,
          enabling stable reproducibility and controlled upgrades.
        responsibilities:
          - "Declare stages: CCP_Build, Impact_Map, RFC_Frame, Ticket_Emit, Skill_Sync, Refactor_Radar."
          - "Declare input roots (repo, PRD dir) and output roots (documents/, evidence/)."
          - "Declare cache keys and idempotency rules for each stage."

      - name: "StageRunner"
        description: |
          The runtime that executes PipelineSpec stages. Each stage executes as a bounded holonic episode:
          it receives a lease, reads declared inputs, writes declared outputs, emits structured findings,
          and exits. Stages are crash-only and resumable.
        responsibilities:
          - "Execute stages individually or end-to-end."
          - "Enforce deterministic write semantics and stable ordering."
          - "Fail closed on lint failures and schema violations."

      - name: "Codebase Context Pack (CCP)"
        description: |
          A set of deterministic artifacts derived from the current repo state:
          component atlas (stable IDs, invariants), crate graph, public API inventory,
          hotspots/churn summary, and prior decisions index.
        responsibilities:
          - "Index AGENTS.md invariants and bind them to stable component IDs."
          - "Capture cargo metadata as a deterministic crate graph artifact."
          - "Extract public API entrypoints and map them to component IDs."
          - "Emit a CCP index with content hashes for all CCP sub-artifacts."

      - name: "Impact Map"
        description: |
          A deterministic mapping from PRD requirements to existing components and extension points.
          Unmappable requirements are classified as net-new substrate and must be adjudicated.
        responsibilities:
          - "For each requirement: candidate components, selected extension point, and rationale."
          - "Emit duplication-risk findings when multiple viable extension points exist."

      - name: "RFC Framer"
        description: |
          A compiler stage that emits an RFC skeleton grounded in the Impact Map and CCP.
          It prefers reuse-by-default, and any new abstraction requires explicit justification.
        responsibilities:
          - "Produce RFC sections with references to concrete crates/modules/files."
          - "Produce an alternatives section reflecting the explored design space."
          - "Emit ticket decomposition inputs (interfaces, files, tests, migration/deletion)."

      - name: "RFC/Ticket Lint Extensions"
        description: |
          Additional lint rules that prevent clutter and enforce coherence.
        responsibilities:
          - "No-new-module without justification."
          - "Cousin abstraction detector (heuristic) -> explicit duplication-risk finding."
          - "Deletion/migration plan required when new surfaces are introduced."

      - name: "Model Router"
        description: |
          A routing engine that selects model/provider/version per stage based on a versioned routing profile.
          Routing decisions are recorded in run manifests and can be overridden per run.
        responsibilities:
          - "Profile-based routing with pinned provider+version identifiers."
          - "Canary mode: run two providers for a stage and compare structured outputs."
          - "Fail-closed on invalid structures; retry with stricter prompting constraints."

      - name: "Run Manifest + Receipt"
        description: |
          A signed, content-addressed receipt for each compilation run.
          It records: inputs (hashes), outputs (hashes), routing (model/provider/version), stage timings,
          lint results, and any adjudications/waivers.
        responsibilities:
          - "Provide deterministic replay and provenance auditing."
          - "Support human acceptance of material diffs before overwriting outputs."

      - name: "Skill Sync"
        description: |
          A stage that updates or generates SKILL.md integration points so agents can invoke the pipeline
          and consume CCP guidance while implementing tickets.
        responsibilities:
          - "Create/maintain a new idea-compiler skill."
          - "Update rfc-council skill to require CCP/Impact Map inputs."

      - name: "Refactor Radar"
        description: |
          A continuous refactor stage that emits maintenance recommendations based on CCP signals:
          churn hotspots, duplication heuristics, dependency cycles, and recurring findings.
        responsibilities:
          - "Emit a bounded set of maintenance tickets and/or a maintenance RFC proposal."
          - "Track recurrence signatures to validate refactor effectiveness."

    external_dependencies:
      - "APM2 CLI core: command framework, logging, auth abstractions, ProcessRunner."
      - "Rust toolchain: cargo metadata and deterministic formatting/lint harnesses."
      - "Inference providers: model routing profiles and CLI adapters."

  mvp_contract:
    contract_id: CTR-0001
    name: "Anti-cousin compiler (MVP)"
    primary_objective: "Prevent cousin abstractions (private + public) by default."
    summary: |
      The MVP is a repository-grounded compiler that produces CCP + Impact Map + low-noise tickets.
      It fails closed when emitted work introduces new abstraction surfaces without an explicit
      reuse-by-default justification and (when applicable) a deletion/migration plan.

      All compilation outputs are written to evidence/ first; governed documents/ are updated only
      via an explicit promote step.

    cli:
      compile:
        usage:
          - "apm2 factory compile --prd PRD-XXXX [--path <dir>] [--profile <routing_profile>] [--dry-run]"
          - "apm2 factory compile --rfc RFC-XXXX [--path <dir>] [--profile <routing_profile>] [--dry-run]"
      stages:
        stage_order:
          - CCP_Build
          - Impact_Map
          - Ticket_Emit
      promote:
        usage:
          - "apm2 factory promote --run <RUN_ID> --to documents/ [--dry-run]"
        safety_requirements:
          - "Promote MUST verify run manifest signature and gate passage before proceeding."
          - "Promote MUST acquire exclusive lock on target directory; concurrent operations fail-fast."
          - "Promote MUST create atomic backup in evidence/backups/<TIMESTAMP>/ before writes."
          - "Promote executes as atomic transaction: stage writes in temp dir, verify, rename; failure triggers rollback."

    io:
      repo_state:
        default: "Require clean working tree for determinism."
        override: "Allow dirty trees only with explicit `--allow-dirty` (hashes include tracked + untracked file contents)."
        dirty_tree_constraints:
          - "Reject untracked files >10MB, symlinks outside repo root, and files matching secret patterns (.env, *_key, credentials.json)."
          - "Dirty-tree hashing respects .gitignore and includes submodule commit hashes (not uncommitted submodule changes)."
          - "A manifest warning is emitted for dirty runs indicating non-reproducibility risk."
      outputs:
        run_root: "evidence/prd/<PRD-ID>/runs/<RUN_ID>/"
        caches:
          ccp_root: "evidence/prd/<PRD-ID>/ccp/"
          impact_map_root: "evidence/prd/<PRD-ID>/impact_map/"
      governed_targets_written_only_by_promote:
        tickets_root: "documents/work/tickets/"
        optional_rfc_root: "documents/rfcs/"

    routing:
      default_profile: local
      local_provider:
        execution: "subprocess (no ambient creds; no network by default)"
        prompt_transport: "stdin or temp file"
        network_access: DISALLOWED

    determinism_envelope:
      writes: "Canonical YAML/JSON, stable ordering, atomic replace."
      model_outputs: "Structured IR only; minimal free-text fields."

    fail_closed_gates:
      - gate_id: GATE-FACTORY-NEW-SURFACE
        trigger: "Any emitted ticket introduces a new abstraction surface (including private)."
        requires:
          - "Impact Map lists considered extension points and rejection rationale."
          - "Ticket set includes deletion/migration plan OR explicit no-deletion rationale."
      - gate_id: GATE-FACTORY-REQ-COVERAGE
        trigger: "Any PRD requirement is unmapped."
        requires:
          - "Classify as net-new substrate and emit adjudication stub before RFC emission."

    surface_definition:
      rust_includes_private:
        - "New crate/package."
        - "New module file (any new `*.rs` in the module tree)."
        - "New top-level named item: struct, enum, trait, type alias (regardless of visibility)."
        - "New function or method with public-equivalent visibility (used by >1 call site outside its defining module)."
      other:
        - "New CLI subcommand surface."
        - "New protocol message/field (when applicable)."
        - "New shared helper (any function called from multiple modules that didn't exist before)."

    deferred_to_phase_2:
      - "Dual-route canary execution."
      - "Signed manifests + daemon-issued leases."
      - "Material-diff acceptance workflow (beyond diff reporting)."

  interfaces:
    user_surfaces:
      - "apm2 factory compile --prd PRD-XXXX [--path <dir>] [--profile <routing_profile>] [--dry-run]"
      - "apm2 factory compile --rfc RFC-XXXX [--path <dir>] [--profile <routing_profile>] [--dry-run]"
      - "apm2 factory ccp build --prd PRD-XXXX [--cache-dir <path>]"
      - "apm2 factory impact-map build --prd PRD-XXXX"
      - "apm2 factory rfc frame --prd PRD-XXXX --rfc RFC-XXXX"
      - "apm2 factory tickets emit --rfc RFC-XXXX"
      - "apm2 factory skill sync"
      - "apm2 factory refactor radar --window 7d"
    machine_outputs:
      - "NDJSON event log per run"
      - "JSON run manifest"
      - "Stable exit codes per failure class"
