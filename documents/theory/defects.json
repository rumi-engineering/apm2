{
  "schema": "cac.holonic_defect_bundle.v1",
  "schema_version": "1.0.0",
  "kind": "holonic.defect_bundle",
  "meta": {
    "stable_id": "dcp://apm2.agents/defects/bundle@1",
    "classification": "PUBLIC",
    "created_at": "2026-02-04T22:18:28.403136Z",
    "description": "The authoritative normative framework for identifying, recording, and remediating defects within holonic agent networks."
  },
  "payload": {
    "version": "1.0.0",
    "taxonomy": {
      "defect_domain": [
        "CONTEXT",
        "ENGINEERING",
        "SPECIFICATION_GAP",
        "VERIFICATION",
        "SECURITY_CAPABILITY",
        "PRODUCT_VALUE",
        "OPERATIONS",
        "ECONOMICS"
      ],
      "stage_detected": [
        "INTENT",
        "REFINEMENT",
        "PLANNING",
        "IMPLEMENTATION",
        "REVIEW",
        "CI",
        "UAT",
        "RELEASE",
        "RUNTIME",
        "INCIDENT",
        "GOVERNANCE"
      ],
      "surface": [
        "CLI",
        "DAEMON_API",
        "LEDGER",
        "EVIDENCE",
        "PRIMITIVE",
        "TEMPLATE",
        "DOCS",
        "POLICY",
        "CAPABILITY",
        "SKILL",
        "INFRA",
        "OBSERVABILITY",
        "RELEASE_CHANNEL",
        "ECONOMICS",
        "ORACLE"
      ],
      "severity": [
        "S0_STOP_THE_LINE",
        "S1_CRITICAL",
        "S2_MAJOR",
        "S3_MINOR",
        "S4_INFO"
      ],
      "reproducibility": [
        "DETERMINISTIC",
        "PROBABILISTIC",
        "FLAKY",
        "UNKNOWN"
      ],
      "disposition": [
        "OPEN",
        "ACKNOWLEDGED",
        "FIX_IN_PROGRESS",
        "FIXED",
        "WONT_FIX",
        "DUPLICATE",
        "NEEDS_INFO"
      ],
      "confidence": [
        "LOW",
        "MEDIUM",
        "HIGH"
      ],
      "inefficiency_class": [
        "EXTRA_TOOL_CALLS",
        "CONTEXT_OVERBUDGET",
        "REDUNDANT_COMPUTE",
        "REDUNDANT_COMMUNICATION",
        "UNNECESSARY_REVIEW_CYCLES",
        "UNNECESSARY_ROLLOUT_RISK",
        "AMBIGUOUS_OUTPUT",
        "WEAK_VERIFIER_SIGNAL",
        "CAPABILITY_OVERGRANT",
        "CAPABILITY_UNDERGRANT",
        "UNBOUNDED_SEARCH",
        "SCHEMA_DRIFT"
      ],
      "violation_code": [
        "SILENT_MEMORY_MUTATION",
        "MONITOR_GAMING",
        "CONTEXT_BLEED",
        "UNBOUNDED_SEARCH",
        "EVALUATOR_DRIFT",
        "REASONING_DEGENERATION",
        "POLICY_VIOLATION",
        "MEASUREMENT_INTEGRITY",
        "SCHEMA_VIOLATION"
      ],
      "action_type": [
        "UPDATE_DOCS",
        "UPDATE_TEMPLATES",
        "UPDATE_CLI_CONTRACT",
        "UPDATE_POLICY",
        "UPDATE_CAPABILITIES",
        "ADD_GATE",
        "FIX_GATE",
        "ADD_TEST",
        "FIX_IMPLEMENTATION",
        "CREATE_OR_EXTEND_PRIMITIVE",
        "REFACTOR_SCOPE",
        "REVISE_REFINEMENT",
        "REVISE_INTENT",
        "IMPROVE_OBSERVABILITY",
        "IMPROVE_RELEASE_PROCESS",
        "OPTIMIZE_ECONOMICS"
      ]
    },
    "record_schema": {
      "schema_id": "apm2.defects.record.schema.v1",
      "description": "DefectRecord is an evidence-backed counterexample linked to intent/contracts and pipeline artifacts. Primary uses: dedupe, clustering, automated remediation, governance.\n",
      "required": [
        "schema_version",
        "id",
        "created_at",
        "defect_domain",
        "stage_detected",
        "surface",
        "severity",
        "title",
        "statement",
        "actor",
        "environment",
        "links",
        "evidence",
        "fingerprint"
      ],
      "properties": {
        "schema_version": {
          "type": "string",
          "const": "apm2.defects.record.v1"
        },
        "id": {
          "type": "string",
          "pattern": "^DFT-[0-9]{6}$"
        },
        "created_at": {
          "type": "string",
          "format": "date-time"
        },
        "defect_domain": {
          "$ref": "apm2.defects.taxonomy.v1#/enums/defect_domain"
        },
        "violation_code": {
          "$ref": "apm2.defects.taxonomy.v1#/enums/violation_code",
          "description": "Specific Law/Mechanism violation code if applicable."
        },
        "stage_detected": {
          "$ref": "apm2.defects.taxonomy.v1#/enums/stage_detected"
        },
        "surface": {
          "$ref": "apm2.defects.taxonomy.v1#/enums/surface"
        },
        "severity": {
          "$ref": "apm2.defects.taxonomy.v1#/enums/severity"
        },
        "reproducibility": {
          "$ref": "apm2.defects.taxonomy.v1#/enums/reproducibility",
          "default": "UNKNOWN"
        },
        "disposition": {
          "$ref": "apm2.defects.taxonomy.v1#/enums/disposition",
          "default": "OPEN"
        },
        "inefficiency": {
          "description": "Optional inefficiency annotations; defects MAY be classified as pure inefficiency.",
          "properties": {
            "inefficiency_class": {
              "$ref": "apm2.defects.taxonomy.v1#/enums/inefficiency_class"
            },
            "delta_cost": {
              "type": "object",
              "properties": {
                "tokens": {
                  "type": "integer",
                  "minimum": 0
                },
                "tool_calls": {
                  "type": "integer",
                  "minimum": 0
                },
                "wall_ms": {
                  "type": "integer",
                  "minimum": 0
                },
                "cpu_ms": {
                  "type": "integer",
                  "minimum": 0
                },
                "bytes_io": {
                  "type": "integer",
                  "minimum": 0
                },
                "risk_score": {
                  "type": "number",
                  "minimum": 0.0
                }
              }
            }
          }
        },
        "title": {
          "type": "string",
          "max_length": 140
        },
        "statement": {
          "description": "Counterexample form: expected predicate/contract vs observed behavior; include minimal context needed for interpretation; avoid narrative.\n",
          "type": "string",
          "max_length": 2000
        },
        "actor": {
          "required": [
            "holon_id",
            "role"
          ],
          "properties": {
            "holon_id": {
              "type": "string"
            },
            "role": {
              "type": "string"
            },
            "lease_ref": {
              "type": "string"
            },
            "budget_ref": {
              "type": "string"
            },
            "capability_set_ref": {
              "type": "string"
            }
          }
        },
        "environment": {
          "required": [
            "system_version",
            "git_rev",
            "platform"
          ],
          "properties": {
            "system_version": {
              "type": "string"
            },
            "git_rev": {
              "type": "string"
            },
            "platform": {
              "type": "string"
            },
            "config_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "links": {
          "required": [
            "intent_refs"
          ],
          "properties": {
            "intent_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "contract_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "rfc_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "ticket_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "pr_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "release_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "gate_run_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "oracle_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        },
        "evidence": {
          "required": [
            "evidence_refs"
          ],
          "properties": {
            "evidence_refs": {
              "type": "array",
              "items": {
                "type": "string"
              }
            },
            "repro": {
              "type": "array",
              "items": {
                "required": [
                  "cmd"
                ],
                "properties": {
                  "cmd": {
                    "type": "string"
                  },
                  "cwd": {
                    "type": "string"
                  },
                  "env": {
                    "type": "object"
                  },
                  "expected": {
                    "type": "string"
                  },
                  "observed": {
                    "type": "string"
                  }
                }
              }
            }
          }
        },
        "analysis": {
          "description": "Optional; added by classifier agents post-intake.",
          "properties": {
            "hypotheses": {
              "type": "array",
              "items": {
                "required": [
                  "type",
                  "confidence"
                ],
                "properties": {
                  "type": {
                    "type": "string"
                  },
                  "confidence": {
                    "$ref": "apm2.defects.taxonomy.v1#/enums/confidence"
                  },
                  "supporting_evidence_refs": {
                    "type": "array",
                    "items": {
                      "type": "string"
                    }
                  }
                }
              }
            },
            "recommended_actions": {
              "type": "array",
              "items": {
                "required": [
                  "action_type"
                ],
                "properties": {
                  "action_type": {
                    "$ref": "apm2.defects.taxonomy.v1#/enums/action_type"
                  },
                  "target_ref": {
                    "type": "string"
                  },
                  "notes": {
                    "type": "string",
                    "max_length": 600
                  }
                }
              }
            }
          }
        },
        "fingerprint": {
          "description": "Deterministic hash over normalized fields for dedupe/clustering. Minimum inputs: defect_domain + surface + normalized title + key links + repro[0].cmd.\n",
          "type": "string"
        }
      }
    },
    "textbook": [
      {
        "title": "Normative Model and Vocabulary",
        "sections": [
          {
            "id": "0.1",
            "title": "Defect as Counterexample",
            "content": "A defect is an evidence-backed counterexample that falsifies an intent predicate or a contract under a verifier. A defect is not limited to functional incorrectness; any avoidable work, avoidable risk, avoidable ambiguity, or avoidable non-determinism is a defect. A defect record MUST be replayable in principle; if full replay is impossible, the defect record MUST capture the exact boundary of non-replayability and the minimum evidence needed to confirm recurrence.\n\nDefects subsume:\n- inefficiency defects (avoidable tool calls, redundant compute, excessive context),\n- process defects (missing receipts, missing gates, unbounded exploration),\n- operations defects (SLO violations, rollback failures, non-observable failures),\n- security/capability defects (overgrant, confused deputy, SoD violations),\n- product value defects (wrong objective, misleading affordances)."
          },
          {
            "id": "0.2",
            "title": "Holons, Boundaries, and Channel Classes",
            "content": "A holon is a bounded agent whose internal state is ephemeral. Holons interact only via sensory states (inputs) and active states (outputs) across explicit channels. Channels MUST be classified (discovery, handshake, work, evidence) and governed by leases and budgets. Any implicit channel (e.g., ad hoc repository browsing, unbounded web search, undocumented sideband state) is a defect surface."
          },
          {
            "id": "0.3",
            "title": "Intent, Contract, Verifier, Evidence",
            "content": "Intent is a predicate over system state and/or traces. Contracts are normative interface constraints (CLI output, daemon API semantics, schema shape, policy rules). Verifiers are procedures that produce Pass or Fail(counterexample). Evidence is the replayable artifact set bound to a verifier outcome. An autonomous SDLC is a refinement compiler that maps intents into verifiers and change sets, then uses counterexamples to strengthen both."
          },
          {
            "id": "0.4",
            "title": "Universal Defect Principle",
            "content": "Every failure of a verifier is a defect. A CI failure is always a defect, even if the underlying code is correct, because it still consumed avoidable cycle time and indicates weak specification, weak determinism, or weak gating. \n\nManual intervention required to reconcile state or interpret ambiguous output is generally a defect. However, in high-entropy states where environmental complexity exceeds a holon's requisite variety, an explicit request for **Human-as-Oracle** adjudication is treated as a **Specification Gap** (Engineering domain). This event is used to refine the upstream compiler rather than penalize the implementation holon."
          }
        ],
        "volume_id": 0
      },
      {
        "title": "Substrate: Schemas, Ledger, and Evidence",
        "sections": [
          {
            "id": "1.1",
            "title": "The DefectRecord Contract",
            "content": "Defect analysis requires a stable, machine-readable schema. The schema MUST be strict enough to support deterministic deduplication and clustering while remaining extensible. Fields that MUST be stable identifiers: intent references, contract references, release references, gate run references, evidence references, actor identity, and fingerprint.\n\nA DefectRecord MUST contain:\n- a single statement of falsified intent/contract (expected vs observed),\n- minimal reproduction recipe (commands over prose),\n- content-addressed evidence references,\n- links into upstream planning artifacts (PRD/RFC/ticket/PR),\n- classification fields (domain, stage, surface, severity)."
          },
          {
            "id": "1.2",
            "title": "Ledger DAG and Causality",
            "content": "A defect system MUST be event-sourced: defects, findings, gate runs, releases, and incidents are events appended to a ledger. Events MUST be causally linked, forming a DAG of truth. Causality enables:\n- immutable provenance of defect discovery and remediation,\n- replay of the exact verifier that produced a counterexample,\n- safe merging of distributed defect streams.\n\nTo optimize performance, the system SHOULD support **Sub-Episode Checkpointing** (recording intermediate tool outputs) for fine-grained recovery and **Canonical State Snapshots** to prune historical replay requirements."
          },
          {
            "id": "1.3",
            "title": "EvidenceBundles and Replay Semantics",
            "content": "EvidenceBundles are content-addressed collections of artifacts sufficient to validate a claim. Evidence includes: command transcripts, environment snapshots, configuration hashes, logs, traces, and output hashes. Replay semantics MUST specify determinism class:\n- deterministic replay (same inputs \u21d2 same outcome),\n- probabilistic replay (bounded randomness with confidence),\n- non-replayable (explicitly documented boundary and surrogate evidence).\n\nNon-replayable defects are permitted but MUST be treated as verification defects until stabilized."
          },
          {
            "id": "1.4",
            "title": "Normalization and Fingerprinting",
            "content": "A fingerprint is a deterministic hash over normalized fields used to merge duplicates. Normalization MUST remove irrelevant variance (timestamps, random IDs, ordering noise) while preserving causal uniqueness. The system SHOULD compute multiple fingerprints:\n- strict fingerprint (exact repro and environment),\n- semantic fingerprint (same surface + same failure signature).\n\nFingerprints drive recurrence metrics and remediation prioritization without requiring large-scale statistical rollouts."
          },
          {
            "id": "1.5",
            "title": "ContextPacks as Evidence and as Inputs",
            "content": "A ContextPack is a compiled, bounded set of context artifacts required to execute work. ContextPacks MUST be:\n- bounded by a ContextBudget,\n- content-addressed and referenced from tickets/PRs,\n- enforceable at runtime (deny-by-default reads outside the pack),\n- sufficient for task completion without unplanned discovery.\n\nAny discrepancy between ContextPack contents and actual reads performed MUST be recorded as a context defect."
          }
        ],
        "volume_id": 1
      },
      {
        "title": "Taxonomy: Domains, Stages, Surfaces, Severity",
        "sections": [
          {
            "id": "2.1",
            "title": "Orthogonal Classification",
            "content": "Classification MUST be orthogonal:\n- domain: nature of failure,\n- stage: where detected,\n- surface: which interface boundary failed,\n- severity: stop-the-line impact and blast radius,\n- reproducibility: determinism class.\n\nOrthogonality prevents the taxonomy from collapsing into incident-specific labels."
          },
          {
            "id": "2.2",
            "title": "Broad Domains",
            "content": "Domains are designed for longevity:\n- CONTEXT: missing/misleading information; stale docs; overscoped work; unnecessary tool calls.\n- ENGINEERING: incorrect mechanisms; missing abstractions; unsafe code; nondeterminism.\n- VERIFICATION: weak or flaky verifiers; missing gates; incorrect oracles; false positives/negatives.\n- SECURITY_CAPABILITY: capability overgrant/undergrant; policy bypass; SoD violations; distracted agents.\n- PRODUCT_VALUE: objectives not met; features mis-specified; misleading affordances.\n- OPERATIONS: runtime instability; rollout failure; observability gaps; incident response failure.\n- ECONOMICS: wasted compute; poor budget allocation; redundant work; non-optimal throughput."
          },
          {
            "id": "2.3",
            "title": "Stages and Escapes",
            "content": "A defect detected in a later stage implies an escape from earlier verifiers. Stage analysis focuses on why the defect was not detected earlier and which verifier must be strengthened. The system SHOULD treat \u201cdetected at runtime\u201d as a failure of upstream refinement and verification, unless the property is inherently runtime-only."
          },
          {
            "id": "2.4",
            "title": "Surfaces and Contracts",
            "content": "Surfaces correspond to contracts:\n- CLI: output, exit codes, structured mode, UX affordances.\n- DAEMON_API: protocol semantics and idempotency.\n- LEDGER/EVIDENCE: immutability, addressing, retention, replay.\n- POLICY/CAPABILITY: grants, leases, SoD, audit.\n- PRIMITIVE: invariant-preserving operators and their APIs.\n- TEMPLATE/DOCS: refinement scaffolding and discoverability.\n- INFRA/OBSERVABILITY: deployment, monitoring, telemetry contracts.\n\nA surface defect is a contract defect until proven otherwise."
          },
          {
            "id": "2.5",
            "title": "Severity and Blast Radius",
            "content": "Severity is defined by propagation potential, not by local inconvenience. In holonic networks, capability and verification defects often outrank correctness defects because they allow systemic drift. A stop-the-line defect is any defect that breaks fail-closed posture, enables privilege escalation, corrupts evidence/ledger integrity, or allows unbounded exploration."
          }
        ],
        "volume_id": 2
      },
      {
        "title": "Detection: Oracles, Gates, Dogfood, Runtime",
        "sections": [
          {
            "id": "3.1",
            "title": "Verifiers as Capital",
            "content": "Verifiers are assets that reduce future work. Every verifier MUST output structured counterexamples. A verifier with high cost and low discrimination is an economics defect; it must be replaced or augmented with cheaper, higher-signal checks. Verifier design is a core engineering discipline in holonic systems."
          },
          {
            "id": "3.2",
            "title": "GateRuns and Receipts",
            "content": "A GateRun is a deterministic execution of verifiers over a change set. GateRuns MUST produce receipts (content-addressed, signed) that prove which verifiers ran, against which inputs, with which outputs. Comment-only approvals are defects; all approvals/denials MUST be state transitions backed by receipts.\n\nAll CI failures are defects. CI may fail due to code, flakiness, environment drift, or missing contracts; all cases consume resources and must be corrected."
          },
          {
            "id": "3.3",
            "title": "Dogfood Holons as High-Signal UAT",
            "content": "Dogfood holons execute scenario suites against releases and release candidates. Scenarios are executable specifications with required evidence outputs. Dogfood is the bridge between \u201cpasses CI\u201d and \u201cworks operationally,\u201d and it converts usability failures (misleading output, confusing workflows, missing affordances) into structured counterexamples.\n\nDogfood MUST run in a sealed environment and emit only evidence, not sideband state. Trusted tunnels are treated as elevated-risk channels and must be explicitly authorized by policy."
          },
          {
            "id": "3.4",
            "title": "Runtime Telemetry as Verifier Stream",
            "content": "Production telemetry is a verifier stream for properties not simulable in CI: SLOs, cost envelopes, performance under real data distributions, and operational reliability. Runtime defects MUST be captured as DefectRecords with links to releases and intents and with sufficient evidence to enable triage. Observability gaps are themselves defects: any incident without enough telemetry to diagnose is a verification defect."
          }
        ],
        "volume_id": 3
      },
      {
        "title": "Triage and Root Cause: Causal Graphs and Uncertainty",
        "sections": [
          {
            "id": "4.1",
            "title": "Intake and Enrichment",
            "content": "Defect intake MUST be canonical and machine readable. Free-form channels MAY exist but MUST be mapped into DefectRecords. Intake enrichers attach upstream references, compute fingerprints, extract repro steps from logs, and link evidence. Intake MUST reject defects lacking minimal reproducibility unless the defect is explicitly an observability/verification defect."
          },
          {
            "id": "4.2",
            "title": "Classification Agents",
            "content": "Classification uses deterministic rules first; probabilistic inference is advisory. Misclassification is corrected by appending new analysis, never rewriting history. Classification drift is monitored by tracking changes in classifier outputs and by validating against known canonical examples."
          },
          {
            "id": "4.3",
            "title": "Root Cause as Causal Edge Set",
            "content": "Root cause is represented as a set of causal edges from the defect to candidate upstream failures:\n- missing intent predicate,\n- weak contract,\n- missing refinement decision,\n- missing primitive,\n- incorrect implementation,\n- missing or flaky verifier,\n- capability overgrant/undergrant,\n- context pack insufficiency.\n\nA causal edge is valid only with supporting evidence references."
          },
          {
            "id": "4.4",
            "title": "Uncertainty Handling",
            "content": "Defects are assigned reproducibility classes. FLAKY defects default to VERIFICATION domain until stabilized; remediation focuses on eliminating nondeterminism and improving evidence capture. Probabilistic defects MUST record confidence and sampling conditions. Unknown-class defects are prioritized by severity and blast radius until classified."
          },
          {
            "id": "4.5",
            "title": "Dedupe and Recurrence",
            "content": "Duplicate defects are merged into a single canonical record with multiple occurrences. Recurrence is measured by occurrence counts and time-to-recurrence, not by subjective severity. A rapidly recurring defect is treated as systemic and triggers primitive/verifier upgrades."
          }
        ],
        "volume_id": 4
      },
      {
        "title": "Containment and Safety: Capabilities, SoD, Context Firewalls",
        "sections": [
          {
            "id": "5.1",
            "title": "Default-Deny Capability Model",
            "content": "Holons MUST operate under least privilege: explicit capabilities, short leases, and bounded budgets. Any implicit authority channel is a security defect. Capability sets are first-class artifacts referenced in defect records and gate receipts."
          },
          {
            "id": "5.2",
            "title": "Separation of Duties (SoD)",
            "content": "Authoring, reviewing, approving, and promoting are distinct roles. The system MUST enforce SoD mechanically at merge and at promotion gates. \u201cSame principal can both propose and approve\u201d is always a SECURITY_CAPABILITY defect, regardless of whether abuse occurred.\n\nSoD should be enforced by identity lineage rules: a holon MUST NOT approve artifacts originating from itself or its controlled sub-holons."
          },
          {
            "id": "5.3",
            "title": "Context Firewalls",
            "content": "A ContextPack is an allowlist for reads and tool usage. Runtime MUST deny reads outside the pack unless the plan explicitly authorizes escalation. Any escalation MUST emit a defect record with the precise missing context reference. Context firewalls prevent derailment by irrelevant inputs and reduce accidental leakage of stale or misleading documentation."
          },
          {
            "id": "5.4",
            "title": "Attention Budgets and Termination",
            "content": "Holons MUST terminate when they exceed attention budgets or encounter irreconcilable ambiguity. Crash-only behavior is a correctness and safety measure: it avoids partial completion under corrupted context. Terminations must produce DefectRecords if caused by missing context, missing contracts, or capability constraints."
          },
          {
            "id": "5.5",
            "title": "Release Safety and Rollback",
            "content": "Release processes are verifiers. Promotion MUST be gated by evidence: GateRun receipts, dogfood results, and runtime guardrail checks. Rollback mechanisms MUST be tested and are themselves defect surfaces. Any manual rollback is a defect unless policy explicitly allows it under emergency modes with recorded evidence."
          }
        ],
        "volume_id": 5
      },
      {
        "title": "Remediation: Plans, ChangeSets, and Closure Rules",
        "sections": [
          {
            "id": "6.1",
            "title": "Remediation as Compilation",
            "content": "Remediation converts DefectRecords into RemediationPlans, which compile into bounded tickets and change sets. A plan MUST specify:\n- the contract or predicate to be restored or introduced,\n- the verifier to prevent recurrence,\n- the smallest safe change set sequence,\n- the evidence required for closure."
          },
          {
            "id": "6.2",
            "title": "Remediation Classes",
            "content": "Remediation must choose among:\n- Implementation patch: fix code/config.\n- Primitive creation/extension: create invariant-preserving operator to eliminate a class of defects.\n- Verifier strengthening: add/fix gate, stabilize oracle, add negative tests.\n- Refinement update: update PRD/RFC/ticket templates to emit required constraints.\n- Policy/capability fix: adjust permissions, SoD, leases.\n- UX/contract fix: change CLI output/contracts with golden tests.\n\nMisrouting remediation (e.g., patching symptoms when a primitive is missing) is itself a defect."
          },
          {
            "id": "6.3",
            "title": "Closure Criteria",
            "content": "A defect is closed only when:\n- a verifier exists that fails on the original counterexample,\n- the verifier passes on the fixed state,\n- evidence receipts are captured and referenced,\n- the relevant contract/intent references are updated when applicable.\n\n\u201cWorks on my machine\u201d is a defect. Closure is evidence-backed."
          },
          {
            "id": "6.4",
            "title": "Economic Closure",
            "content": "Defects may be purely economic: redundant compute, unnecessary tool calls, excessive context. Economic defects close when the system demonstrates reduced resource consumption under equal or stronger verifier coverage. Economic closure requires measurement harnesses and reproducible benchmarks."
          },
          {
            "id": "6.5",
            "title": "Preventing Regression",
            "content": "All fixes MUST include regression prevention: tests, gates, or policies. Regression monitoring windows are specified per severity. If recurrence occurs within the monitoring window, the defect is reopened and severity escalated."
          }
        ],
        "volume_id": 6
      },
      {
        "title": "Learning Loop: Primitives, Refinement, Verifier Portfolio",
        "sections": [
          {
            "id": "7.1",
            "title": "Primitives as System Memory",
            "content": "Primitives are invariant-preserving operators with explicit contracts and packaged evidence. A primitive exists to eliminate repeated defect classes by construction. Primitives MUST be discoverable (registry), testable (proof obligations), and composable (small stable APIs). Duplicate cousin abstractions are defects."
          },
          {
            "id": "7.2",
            "title": "Refinement Compiler Upgrades",
            "content": "Defects update the refinement compiler: PRD/RFC/ticket generation rules evolve to preempt counterexamples. Context defects produce ContextPack rules and budget constraints. Engineering defects produce required primitive usage and proof obligations. Verification defects produce new gates and stabilization work. Security defects produce capability and SoD constraints."
          },
          {
            "id": "7.3",
            "title": "Verifier Portfolio Optimization",
            "content": "A verifier portfolio is optimized for signal per unit cost. The system MUST track:\n- verifier cost (time, compute, flake rate),\n- verifier value (prevented recurrences, earlier detection),\n- portfolio coverage by domain/surface/stage.\n\nLow-value verifiers are replaced by cheaper, sharper checks or by primitives that eliminate the need to verify certain properties repeatedly."
          },
          {
            "id": "7.4",
            "title": "Recurrence-Driven Roadmaps",
            "content": "Roadmaps are derived from clustered defects: the largest recurrence clusters define where primitives and verifiers should be invested. This replaces anecdotal prioritization with counterexample economics. The roadmap itself is governed: it must cite defect cluster fingerprints and evidence counts."
          }
        ],
        "volume_id": 7
      },
      {
        "title": "Tooling Reference: CLI, Schemas, Playbooks",
        "sections": [
          {
            "id": "8.1",
            "title": "Defect CLI Surface",
            "content": "The defect CLI MUST support: submit, attach evidence, compute fingerprint, merge duplicates, generate reports, and compile remediation plans. The CLI MUST have a stable structured-output mode for agents and a human-readable mode for audits. Output contracts are versioned and golden-tested."
          },
          {
            "id": "8.2",
            "title": "ContextPack Tooling",
            "content": "Tooling MUST support: build pack, lint pack, enforce pack at runtime, and measure pack token size. Packs must include explicit allowlists for files, commands, and network access. Pack enforcement is deny-by-default."
          },
          {
            "id": "8.3",
            "title": "Gate and Receipt Tooling",
            "content": "Gate tooling MUST generate receipts and store them in evidence stores. Receipts MUST include all inputs needed to validate claims of execution. Receipt verification MUST be available as a deterministic CLI command."
          },
          {
            "id": "8.4",
            "title": "Operational Playbooks",
            "content": "Playbooks are executable remediation sequences for runtime incidents, capability revocation, rollback, and quarantine. Playbooks MUST declare inputs, outputs, permissions, evidence requirements, and stop conditions. A playbook that cannot emit evidence is defective."
          },
          {
            "id": "8.5",
            "title": "Reporting and Aggregation",
            "content": "Reports are generated from defect events, not from free-form summaries. Reports MUST include: top clusters, recurrence rates, time-to-detection, time-to-fix, verifier flake rate, and context inefficiency metrics. Reports drive roadmap selection and refinement compiler updates."
          }
        ],
        "volume_id": 8
      },
      {
        "title": "Appendices: Checklists, Invariants, Reference Formats",
        "sections": [
          {
            "id": "9.1",
            "title": "Minimal Invariants (Non-Negotiable)",
            "content": "- Evidence integrity: content addressing, retention, replay.\n- Fail-closed gates: no merge/promotion without required receipts.\n- Capability least privilege and SoD enforcement.\n- ContextPack enforcement and budget adherence.\n- Deterministic structured outputs for automation surfaces.\n- Regression prevention for every fix."
          },
          {
            "id": "9.2",
            "title": "Defect-Handling Checklists",
            "content": "### Intake checklist\n- Contains expected vs observed statement.\n- Contains repro recipe or explicitly classified as observability defect.\n- Contains evidence references.\n- Links to intent/contract references.\n- Fingerprint computed.\n\n### Remediation checklist\n- Choose remediation class correctly.\n- Add or fix verifier.\n- Update contract/spec/template if needed.\n- Provide closure evidence."
          },
          {
            "id": "9.3",
            "title": "Reference Schemas",
            "content": "See `schemas/taxonomy.yaml` and `schemas/defect_record_schema.yaml`. Schemas are normative; changes must be versioned. Schema evolution is additive-only in place; breaking changes require new schema IDs."
          },
          {
            "id": "9.4",
            "title": "Inefficiency Catalog (Defects as Waste)",
            "content": "Inefficiency defects include:\n- any additional context discovery tool call beyond the ContextPack for a **scoped implementation task** (**Research tasks** and **Verification tools** used for active inference are exempt),\n- repeated CI failures due to flake or missing determinism,\n- redundant compilation of identical artifacts without caching,\n- ambiguous CLI output requiring interpretation,\n- repeated review cycles due to missing proof obligations,\n- unbounded exploration without leases/stop rules,\n- missing or delayed observability preventing fast triage.\n\nInefficiency defects are prioritized by cumulative cost and by their amplification effect on downstream stages."
          }
        ],
        "volume_id": 9
      }
    ]
  }
}