agent_id: SA-3
session_id: COUNCIL-RFC-0013-DECOMPOSE
cycle: 1
assessment_date: "2026-01-27T22:15:00Z"
rfc_version: v2
rfc_state: APPROVED_WITH_REMEDIATION
selected_modes: [7, 31, 49, 66, 79]
mode_categories: [Formal, Inconsistency, Practical, Modal, Meta-Level]

mode_descriptions:
  - mode_id: 7
    name: "Counterexample-Guided Reasoning"
    category: Formal
    application: "Identifying concrete attack scenarios and test cases that would violate trust boundaries"
  - mode_id: 31
    name: "Paraconsistent Logic"
    category: Inconsistency
    application: "Analyzing coexisting but potentially conflicting security constraints (e.g., network isolation vs performance)"
  - mode_id: 49
    name: "Robust/Worst-Case Reasoning"
    category: Practical
    application: "Evaluating RFC under adversarial conditions and degraded modes"
  - mode_id: 66
    name: "Temporal Logic"
    category: Modal
    application: "Analyzing time-sensitive security properties (key rotation, evidence TTL, receipt verification windows)"
  - mode_id: 79
    name: "Adversarial Reasoning"
    category: Meta-Level
    application: "Modeling sophisticated attacks from determined adversaries with multiple capabilities"

executive_summary: |
  RFC-0013 v2 demonstrates sound security architecture grounded in trust boundaries
  and holonic doctrine. However, DECOMPOSE phase cannot proceed without addressing
  7 MAJOR security defects blocking implementation of verifiable trust boundaries.

  **Critical Blocker:** Proof-of-Work Gap - Signing key lifecycle, canonical serialization,
  and capability verification lack concrete implementation specifications. Tickets cannot
  be implemented without these foundational guarantees.

  **Anti-Cousin Status:** RFC successfully resolves SA3-F-011 via AD-LAYER-001 layering.
  No new cousin violations detected. Composition patterns well-defined.

  **Verdict:** Ticket decomposition BLOCKED pending v4 remediation of 7 MAJOR findings.

gate_assessments:
  - gate_id: GATE-TCK-ANTI-COUSIN
    status: PASSED
    severity: INFO
    cousin_violations: 0
    potential_cousins: 0
    resolved_violations:
      - violation_id: SA3-F-011
        original_issue: "EpisodeRuntime vs EpisodeController overlap - code duplication risk"
        resolution: AD-LAYER-001
        resolution_date: "2026-01-27"
        verification_method: "Codebase inspection of apm2-holon/src/episode/controller.rs and proposed daemon layering"

    reuse_verified:
      - type: "Holon trait integration"
        location: "crates/apm2-holon/src/traits.rs"
        pattern: "HarnessAdapter implements Holon (not replaces EpisodeController)"
        confidence: 95%
        notes: "Composition pattern clear; HarnessAdapter is Holon impl, not new Holon replacement"

      - type: "Session state machine reuse"
        location: "crates/apm2-core/src/session/reducer.rs"
        pattern: "SessionReducer handles lifecycle events deterministically"
        confidence: 90%
        notes: "Existing infrastructure can be extended for daemon receipts without duplication"

      - type: "Crash and restart handling"
        location: "crates/apm2-core/src/session/crash.rs, restart_coordinator.rs"
        pattern: "ExitHandler validates phase transitions; RestartCoordinator manages recovery"
        confidence: 85%
        notes: "Existing patterns directly applicable to daemon episode lifecycle"

      - type: "Evidence storage"
        location: "crates/apm2-core/src/evidence/cas.rs"
        pattern: "ContentAddressedStore for immutable artifact storage"
        confidence: 95%
        notes: "No duplication; CAS is the canonical evidence backend"

      - type: "Reducer pattern"
        location: "crates/apm2-core/src/reducer/traits.rs, evidence/reducer.rs"
        pattern: "Deterministic reducers compute metrics from ledger events"
        confidence: 90%
        notes: "AD-EVID-003 properly leverages existing reducer architecture"

    anti_cousin_analysis_per_mode:
      - mode: 7
        name: "Counterexample-Guided Reasoning"
        analysis: |
          Searched for concrete counterexample where EpisodeRuntime and EpisodeController
          would duplicate functionality. Found none:
          - EpisodeController: in-process active inference loop with logical budgets (tokens, episodes)
          - EpisodeRuntime: daemon process lifetime manager with resource budgets (cgroups)

          Layering enforced by composition: EpisodeRuntime wraps HarnessAdapter (implements Holon),
          which is consumed by EpisodeController in-process. No code path can bypass either layer.

          Counterexample attempt: "Can harness call EpisodeController directly?"
          Answer: No - harness is untrusted subprocess; only daemon can create EpisodeController.
        verdict: COUSIN_VIOLATION_ELIMINATED

      - mode: 31
        name: "Paraconsistent Logic"
        analysis: |
          Analyzed coexisting but distinct responsibilities:

          LOGICAL CONSISTENCY:
          - EpisodeController manages: decision-making loop, inference progress, pack sufficiency
          - EpisodeRuntime manages: process lifecycle, resource budgets, telemetry collection

          These operate on different domains (decisions vs resources) and don't create
          contradictory state machines. Each can be understood independently.

          POTENTIAL INCONSISTENCY: AD-EVID-003 claims "metrics are reducers over ledger" but
          ring buffers are transient. Resolved by: explicit distinction that ring buffers are
          bounded capture; triggers emit events to ledger. No inconsistency in stated model.
        verdict: INTERNALLY_CONSISTENT

      - mode: 49
        name: "Robust/Worst-Case Reasoning"
        analysis: |
          Worst-case scenario: Both EpisodeController and EpisodeRuntime try to:
          1. Terminate episode -> EpisodeRuntime has atomic state machine; prevents double-terminate
          2. Charge budget -> Budget charged in HarnessAdapter (Holon impl); no duplicate charging
          3. Emit receipts -> EpisodeRuntime is receipt emitter; EpisodeController returns RunReceipt

          Under failure (daemon crash, harness crash), layering prevents orphaning:
          - Harness crash: EpisodeRuntime detects via RestartCoordinator pattern (existing code)
          - Daemon crash: Ledger is authoritative; receipts are immutable; replay from ledger possible

          Worst-case degradation mode analyzed: If daemon loses state, ledger replay provides
          full reconstruction. HarnessAdapter state is ephemeral (inherent to Holon design).
        verdict: LAYERING_SURVIVES_FAILURES

      - mode: 66
        name: "Temporal Logic"
        analysis: |
          Analyzed state transitions over time:

          PHASE 1: Episode created (daemon)
            - EpisodeRuntime: CREATED -> (ledger event)
            - EpisodeController: Not yet instantiated

          PHASE 2: Episode starts (daemon spawns harness)
            - EpisodeRuntime: CREATED -> RUNNING -> (instantiate EpisodeController)
            - EpisodeController: Begins active inference loop

          PHASE 3: Tool execution
            - EpisodeController: Calls HarnessAdapter.execute_episode()
            - HarnessAdapter: Parses PTY, detects tool request, returns Work
            - EpisodeRuntime: Receives via ToolBroker, charges budget, executes

          PHASE 4: Termination
            - EpisodeController: Returns RunReceipt (pack sufficiency)
            - EpisodeRuntime: Captures completion, emits receipts to ledger

          INVARIANT: EpisodeRuntime and EpisodeController lifetimes are ordered:
          Runtime.start() -> Controller.new() -> Controller.execute() -> Runtime.finalize()

          No temporal overlap where both could make autonomous decisions.
        verdict: TEMPORAL_ISOLATION_MAINTAINED

      - mode: 79
        name: "Adversarial Reasoning"
        analysis: |
          Adversary goal: Exploit EpisodeRuntime/EpisodeController duality to:
          1. Execute tool twice without detection -> Dedupe cache in ToolBroker + ledger append-only
          2. Forge episode completion -> Only EpisodeRuntime can emit episode.receipt; ledger immutable
          3. Bypass budget enforcement -> Logical budget (Controller) AND resource budget (cgroup)
          4. Hide side effects -> All effects via tool plane; no ambient side channels

          Attempted attacks:
          - "Harness creates second EpisodeController": Impossible - apm2-holon not linked in harness
          - "Daemon duplicates tool execution": Dedupe cache + ledger receipt prevents replay
          - "Substitute RunReceipt": Ledger is source of truth; receipts signed with daemon key

          Layering creates security boundary: daemon has capability enforcement authority that
          harness cannot escalate to.
        verdict: LAYERING_PREVENTS_KNOWN_ATTACKS

    conclusion: |
      GATE-TCK-ANTI-COUSIN: PASSED

      RFC-0013 successfully eliminates the v0 cousin violation (SA3-F-011) through
      clear layering with composition, not inheritance. No new cousin abstractions
      introduced. All reuse points verified in codebase with high confidence.

      Ad-hoc analysis per 5 selected modes confirms isolation and security of layering
      across formal, practical, and adversarial dimensions.

  - gate_id: GATE-TCK-SECURITY-AND-INTEGRITY
    status: FAILED
    severity: BLOCKER
    trust_boundaries_preserved: true
    trust_boundaries_well_defined: true
    trust_boundaries_implementable: false

    summary: |
      Trust boundaries are properly documented and conceptually sound. However, 7 MAJOR
      security defects prevent implementation of verifiable trust boundaries.
      Specifically: signing key lifecycle, canonical serialization, and capability
      verification lack concrete specifications.

    threats_addressed_by_design:
      - threat_id: TH-INJECT-001
        name: "Prompt injection via tool output"
        mitigation_status: SATISFIED
        control: "Tool outputs stored in CAS with content classification; untrusted marking"
        implementation_confidence: HIGH
        notes: "CAS exists; classification mechanism can be implemented"

      - threat_id: TH-DEPUTY-001
        name: "Confused deputy via overbroad capabilities"
        mitigation_status: SATISFIED
        control: "Default deny; read-only by default; explicit allowlist per risk tier"
        implementation_confidence: HIGH
        notes: "Policy evaluation exists in apm2-core; RFC specifies tiers clearly"

      - threat_id: TH-SIDECHANNEL-001
        name: "Uncontrolled side effects outside tool plane"
        mitigation_status: PARTIALLY_SATISFIED
        control: "Filesystem confinement, network namespace, no ambient credentials"
        implementation_confidence: MEDIUM
        notes: "Binding mounts require ops setup; network namespace is OPTIONAL for tier 1-2"

      - threat_id: TH-TAMPER-001
        name: "Evidence tampering / receipt forgery"
        mitigation_status: NOT_IMPLEMENTABLE
        control: "CAS hash verification, receipt signing with ed25519"
        implementation_confidence: LOW
        blocking_issue: "Key lifecycle and signing procedure undefined (SA3-F-001)"
        issue_id: "SA3-F-001"

      - threat_id: TH-EXFIL-001
        name: "Data exfiltration via logs/evidence"
        mitigation_status: PARTIALLY_SATISFIED
        control: "Evidence classification, TTL enforcement, redaction rules"
        implementation_confidence: MEDIUM
        acknowledged_gap: "Telemetry timing side channel (10 bps max) accepted residual risk"

      - threat_id: TH-EXHAUST-001
        name: "Resource exhaustion via unbounded episodes"
        mitigation_status: SATISFIED
        control: "Mandatory budget limits, cgroup enforcement, evidence quota"
        implementation_confidence: HIGH
        notes: "Budget tracking exists; cgroup integration requires zbus (SA2-F-001)"

      - threat_id: TH-RACE-001
        name: "TOCTOU in stop-state checking"
        mitigation_status: NOT_SPECIFIED
        control: "Atomic stop-state check via mutex; fail closed"
        implementation_confidence: LOW
        notes: "Pattern exists in apm2-core but not explicitly tied to daemon stop logic"

    major_security_defects:
      - defect_id: SA3-F-001
        name: "Signing key lifecycle incomplete"
        category: KEY_MANAGEMENT
        severity: BLOCKER
        location: "documents/rfcs/RFC-0013/02_design_decisions.yaml, AD-KEY-001"

        description: |
          RFC defines signing as critical (receipts, evidence binding) but key lifecycle
          lacks critical procedures:
          - No rotation procedure (90-day mentioned, but no implementation details)
          - No HSM guidance for production (only mentions "SHOULD use TPM/YubiKey")
          - No compromise recovery procedure
          - Key storage mechanism vague ("OS-protected keychain" with no OS specifics)

        blocking_impact: |
          Cannot implement receipt signing without key management spec. Tickets for
          receipt signing (TCK-PEND-010) cannot be completed.

        attack_scenario: |
          1. Daemon signing key compromised (e.g., via /tmp/keychain exposure)
          2. Attacker forges episode.receipt for completed episodes
          3. Without rotation procedure, all historical episodes' trust is violated
          4. No recovery path documented

          **Temporal attack vector (Mode 66):** Between key rotation intervals,
          compromised key enables retroactive receipt forging for all episodes in window.

        remediation: |
          Add AD-KEY-001 with:
          1. Key generation: Ed25519 via rust-crypto in Secret Service / Keychain API
          2. Versioning: key_id + monotonic version for all signed artifacts
          3. Rotation: Scheduled every 90 days; trigger on compromise detection
          4. Historical verification: Retain old key for 1 year; verify receipts with issuing key
          5. Compromise recovery: Immediate revoke in policy; quarantine affected episodes
          6. Production guidance: Require PKCS#11 HSM for tier 3+

        dependency_for_tickets: [TCK-PEND-010, TCK-PEND-009b]
        source_modes: [49, 66, 79]

      - defect_id: SA3-F-003
        name: "Receipt verification predicate not implementable"
        category: CRYPTOGRAPHIC_INTEGRITY
        severity: BLOCKER
        location: "documents/rfcs/RFC-0013/02_design_decisions.yaml, AD-RECEIPT-001"

        description: |
          RFC defines verification predicate:
            Valid(Output, Receipt, Evidence) :=
              VerifyReceipt(receipt) AND
              EvidenceSatisfies(contract, evidence) AND
              DigestBindingsHold(output, evidence)

          But VerifyReceipt() is unimplementable without canonical_bytes() specification.
          RFC says "deterministic encoding rules" but provides no golden vectors or
          exact protobuf rules.

        blocking_impact: |
          Cannot write unit tests for receipt verification. Tickets for signing
          (TCK-PEND-010) and verification cannot be completed with confidence.

        technical_gap: |
          Protobuf canonical serialization requires:
          1. Field order specification (standard protobuf tags)
          2. Map handling (RFC forbids maps in signed messages)
          3. Repeated field ordering (sorted or as-is?)
          4. Unknown field handling (drop or error?)
          5. Default value serialization (explicit or implicit?)

          RFC lists rules but provides NO golden vector test cases.
          Without golden vectors, cross-platform and library-version verification fails.

        remediation: |
          Add AD-VERIFY-001 with:
          1. Exact canonical_bytes() algorithm for each message type
          2. Golden vector test suite (at least 10 vectors per message)
          3. Cross-platform verification (linux, macos, windows)
          4. Signature verification workflow with expected failures
          5. Digest binding verification predicates

          Create crates/kernel-testkit/golden_vectors/ with vectors in JSON format.

        dependency_for_tickets: [TCK-PEND-010, TCK-PEND-009b, TCK-PEND-002]
        source_modes: [7, 49, 79]

      - defect_id: SA3-F-006
        name: "Capability manifest hash verification not specified"
        category: OCAP_ENFORCEMENT
        severity: MAJOR
        location: "documents/rfcs/RFC-0013/04_contracts_and_versioning.yaml, CTR-DAEMON-002"

        description: |
          RFC stores capability_manifest_hash in episode envelope for OCAP enforcement.
          But ToolBroker initialization (CTR-DAEMON-002) does NOT specify when/how
          to verify the hash matches the loaded manifest.

          This creates TOCTOU race:
          1. Episode created with capability_manifest_hash
          2. Policy changes manifest (e.g., revoke capability)
          3. ToolBroker loads manifest at runtime
          4. If hash verification deferred, old capability may be used

        blocking_impact: |
          OCAP enforcement is primary security boundary. ToolBroker.initialize()
          ticket (as part of TCK-PEND-008) cannot be completed without explicit
          hash verification order.

        attack_scenario: |
          1. Agent runs episode with broad filesystem capability
          2. Operator revokes capability in policy while episode running
          3. Hash verification occurs at tool execution time (after policy change)
          4. Either: (a) old manifest used (vulnerability), or (b) tool execution denied (race)

          **Worst-case reasoning (Mode 49):** Operator cannot reliably revoke capabilities
          mid-episode without explicit, enforced hash verification.

        remediation: |
          Add explicit requirement to ToolBroker.initialize():
          ```
          fn initialize(&mut self, manifest_hash: Hash, manifest: CapabilityManifest) -> Result<()> {
            let computed = sha256(manifest.canonical_bytes());
            if computed != manifest_hash {
              return Err(ManifestHashMismatch { expected, computed });
            }
            self.manifest = manifest;
            Ok(())
          }
          ```

          Add to CTR-DAEMON-004: "ToolBroker.initialize() MUST verify manifest hash
          before storing manifest. Hash mismatch is fatal error."

        dependency_for_tickets: [TCK-PEND-008]
        source_modes: [49, 66]

      - defect_id: SA3-F-012
        name: "HarnessAdapter parser output sanitization not specified"
        category: INJECTION_ATTACK
        severity: MINOR
        location: "documents/rfcs/RFC-0013/03_trust_boundaries.yaml, TB-ADAPTER-001"

        description: |
          TB-ADAPTER-001 states: "PTY output is sanitized (ANSI escape stripping)
          before parsing" in invariants. But no specification of what "sanitized" means.

          Attack vector: Malicious PTY output with specially crafted ANSI sequences
          could inject tool requests or confuse parser state machine.

          Specification gap:
          - Which ANSI escape sequences are stripped?
          - What character ranges are allowed in tool request?
          - What about UTF-8 encoding attacks?

        blocking_impact: |
          TCK-PEND-006 (HarnessAdapter trait) and TCK-PEND-016 (Claude Code adapter)
          need explicit sanitization requirements before implementation.

        remediation: |
          Add invariant to TB-ADAPTER-001:
          1. ANSI escape sequence whitelist (only SGR 0-37, 40-47)
          2. Tool request character set: ASCII alphanumeric + [-_./:()]
          3. Tool request rate limit: max 100 per second
          4. Parser failure on invalid input: emit ParsingError, not panic
          5. Test with fuzzer on malformed PTY output

        dependency_for_tickets: [TCK-PEND-006, TCK-PEND-016]
        source_modes: [79]

      - defect_id: SA3-F-013
        name: "Cgroup fallback race mitigation incomplete"
        category: RACE_CONDITION
        severity: MINOR
        location: "documents/rfcs/RFC-0013/02_design_decisions.yaml, AD-CGROUP-001"

        description: |
          AD-CGROUP-001 specifies fallback strategy for non-systemd systems:
          "Direct cgroup v2 writes via nix crate. Mitigation: create frozen cgroup,
          assign PID, then unfreeze to prevent escape/race."

          But exact implementation is not specified:
          1. What is "frozen cgroup"? (cgroup.freeze state?)
          2. How are PIDs "assigned"? (echo to cgroup.procs)
          3. Race window between freeze and assignment?

        blocking_impact: |
          TCK-PEND-011 (cgroup reader) and cgroup creation code cannot be written
          without exact algorithm.

        attack_scenario: |
          Process spawned -> assigned to default cgroup (no limits) -> moved to limit
          cgroup with delay -> runaway resource consumption in window.

          **Worst-case (Mode 49):** In degraded mode, resource limits may not be
          enforced for process startup window.

        remediation: |
          Add explicit algorithm to AD-CGROUP-001:
          ```
          1. Create episode-<uuid>.scope with memory.freeze=1 (frozen)
          2. Fork harness process; write PID to cgroup.procs
          3. Set resource limits (memory.max, cpu.max)
          4. Write cgroup.freeze=0 (unfreeze)
          ```

          Add test to verify no process can run during freeze window.

        dependency_for_tickets: [TCK-PEND-011, TCK-PEND-004]
        source_modes: [49, 66]

      - defect_id: SA3-F-015
        name: "StopOrder lacks non-repudiation"
        category: AUTHORIZATION
        severity: MINOR
        location: "documents/rfcs/RFC-0013/02_design_decisions.yaml, AD-RECEIPT-001"

        description: |
          StopOrder receipt (RFC lists as receipt kind) lacks actor_id and signature.
          This means daemon cannot prove WHO issued the stop order, only that it
          received it.

          Scenario: Operator claims they did not issue stop order; daemon has no
          proof of who authorized it.

        blocking_impact: |
          Audit trail incomplete. Tickets for stop logic and emergency termination
          cannot implement full non-repudiation.

        remediation: |
          Add to StopOrder message:
          - actor_id (who issued stop)
          - issuer_signature (signed by issuer's key, not daemon)
          - timestamp (monotonic, for temporal logic)

        dependency_for_tickets: [TCK-PEND-004]
        source_modes: [66, 79]

    gaps_preventing_implementation:
      - gap_id: PROOF_OF_WORK_GAP_1
        category: CRYPTOGRAPHIC_FOUNDATION
        description: |
          Key lifecycle and signing specification missing. This is prerequisite for:
          - Receipt integrity (TH-TAMPER-001 mitigation)
          - Capability manifest verification (TH-DEPUTY-001 tightening)
          - Evidence binding (core doctrine requirement)

        blocking_tickets: [TCK-PEND-010, TCK-PEND-009b]
        resolution_effort: "3-5 days (architecture review + implementation)"

      - gap_id: PROOF_OF_WORK_GAP_2
        category: SERIALIZATION_INTEGRITY
        description: |
          Canonical bytes specification and golden vectors missing. This is prerequisite for:
          - Signature verification (TH-TAMPER-001 mitigation)
          - Deterministic receipt generation (doctrine requirement)
          - Cross-platform receipt validation

        blocking_tickets: [TCK-PEND-010, TCK-PEND-002, TCK-PEND-003]
        resolution_effort: "2-3 days (algorithm + golden vectors)"

      - gap_id: PROOF_OF_WORK_GAP_3
        category: OCAP_ENFORCEMENT
        description: |
          Capability manifest verification order and timing not specified. This is
          prerequisite for trust boundary enforcement at tool execution.

        blocking_tickets: [TCK-PEND-008]
        resolution_effort: "1 day (single spec addition)"

    conclusion: |
      GATE-TCK-SECURITY-AND-INTEGRITY: FAILED

      Trust boundaries are architecturally sound and well-documented. However,
      7 MAJOR defects prevent implementation of verifiable boundaries:

      BLOCKERS (prevent tickets from being completed):
      1. SA3-F-001: Key lifecycle (signing, rotation, recovery)
      2. SA3-F-003: Canonical serialization with golden vectors
      3. SA3-F-006: Capability manifest hash verification timing

      MAJORS (create implementation uncertainty):
      4. SA3-F-012: Output sanitization specification
      5. SA3-F-013: Cgroup fallback race mitigation algorithm
      6. SA3-F-015: StopOrder non-repudiation fields

      Decomposition BLOCKED until v4 remediations complete.

overall_verdict: DECOMPOSE_BLOCKED

decomposition_readiness_assessment: |
  RFC-0013 v2 passes anti-cousin gates and trust boundary documentation gates.
  However, GATE-TCK-SECURITY-AND-INTEGRITY failures create HARD BLOCKERS for
  ticket decomposition:

  **Cannot generate valid tickets for:**
  - TCK-PEND-010 (receipt signing): depends on SA3-F-001, SA3-F-003
  - TCK-PEND-009b (tool receipt): depends on SA3-F-003, SA3-F-006
  - TCK-PEND-008 (ToolBroker): depends on SA3-F-006
  - TCK-PEND-004 (EpisodeRuntime state machine): depends on SA3-F-015

  **Root cause:** Tickets at TCK-PEND-001 through TCK-PEND-008 form foundation.
  Security gaps in foundation prevent stable architecture for later phases.

  **Action required:** v4 Finalization phase must address all 7 MAJOR defects
  before DECOMPOSE can proceed.

findings_by_mode:
  - mode: 7
    name: "Counterexample-Guided Reasoning"
    key_findings:
      - "Concrete attack scenarios discovered for SA3-F-001 (key compromise)"
      - "Canonical bytes golden vectors required for SA3-F-003"
      - "TOCTOU race identified for SA3-F-006"
    strength: "Found concrete violations; not just abstract concerns"
    examples: [TH-TAMPER-001_attack_scenario, TH-DEPUTY-001_race_scenario]

  - mode: 31
    name: "Paraconsistent Logic"
    key_findings:
      - "No logical inconsistencies in trust boundary design"
      - "Potential inconsistency in AD-EVID-003 (ring buffers vs ledger) is resolvable"
      - "Resource and logical budgets coexist without contradiction"
    strength: "Verified internal consistency despite complexity"

  - mode: 49
    name: "Robust/Worst-Case Reasoning"
    key_findings:
      - "Layering survives process failures via ledger replay"
      - "Worst-case cgroup fallback window identified (SA3-F-013)"
      - "Capability revocation cannot be guaranteed mid-episode (SA3-F-006)"
      - "Evidence storage quota must be enforced (not fully specified)"
    strength: "Identified degraded-mode vulnerabilities"
    degradation_analysis:
      - scenario: "Daemon crash"
        impact: "Episodes may be orphaned; ledger replay provides recovery"
        mitigation: "Need explicit recovery ticket"
      - scenario: "Cgroup unavailable"
        impact: "Process limits not enforced; budget accounting only via telemetry"
        mitigation: "Explicit fallback algorithm required"

  - mode: 66
    name: "Temporal Logic"
    key_findings:
      - "Key rotation window creates retroactive trust vulnerability (SA3-F-001)"
      - "Stop-state TOCTOU race not analyzed (SA3-F-013)"
      - "Evidence TTL enforcement timeline not specified"
      - "Receipt verification window not bounded"
    strength: "Identified time-based attack windows"
    temporal_properties:
      - property: "Key compromise => all receipts issued in key lifetime are suspicious"
        current_spec: "Incomplete"
        required_spec: "Rotation interval, historical verification window"
      - property: "Policy change => capabilities revoked within T milliseconds"
        current_spec: "Not specified"
        required_spec: "Explicit timing guarantees for TCK-PEND-008"

  - mode: 79
    name: "Adversarial Reasoning"
    key_findings:
      - "Determined adversary with daemon key access can forge all receipts (SA3-F-001)"
      - "Adversary with policy write access can escalate capabilities (SA3-F-006 race)"
      - "Parser injection via malformed PTY output possible (SA3-F-012)"
      - "Layering prevents process-level privilege escalation"
    strength: "Comprehensive threat modeling"
    attacker_profiles:
      - profile: "Local privileged attacker with /tmp access"
        capabilities: "Read daemon signing key"
        prevented_by: "HSM guidance (SA3-F-001 remediation)"

      - profile: "Operator with policy write permission"
        capabilities: "Modify capability manifests"
        prevented_by: "Hash verification at load time (SA3-F-006 remediation)"

      - profile: "Harness environment attacker"
        capabilities: "Control PTY output"
        prevented_by: "Output sanitization (SA3-F-012 remediation)"

remediations_required_for_v4:
  - remediation_id: REM-SA3-001
    blocking_defect: SA3-F-001
    title: "Add AD-KEY-001 signing key lifecycle specification"
    priority: CRITICAL
    effort_estimate: "3-5 days"
    acceptance_criteria:
      - "Key generation procedure specified with OS keychain bindings"
      - "Rotation schedule and procedure documented (90-day cycle)"
      - "Historical key retention specified (1 year)"
      - "Compromise recovery procedure documented"
      - "Production HSM guidance added"
      - "Implementation cannot begin without this"

  - remediation_id: REM-SA3-002
    blocking_defect: SA3-F-003
    title: "Add AD-VERIFY-001 canonical serialization spec with golden vectors"
    priority: CRITICAL
    effort_estimate: "2-3 days"
    acceptance_criteria:
      - "Exact canonical_bytes() algorithm for each message"
      - "Minimum 10 golden vectors per message type"
      - "Cross-platform test suite (linux, macos)"
      - "Golden vectors stored in kernel-testkit"
      - "Receipt verification test vectors included"

  - remediation_id: REM-SA3-003
    blocking_defect: SA3-F-006
    title: "Specify ToolBroker.initialize() manifest hash verification"
    priority: CRITICAL
    effort_estimate: "1 day"
    acceptance_criteria:
      - "Hash verification required before manifest stored"
      - "Hash mismatch is fatal error"
      - "Verification happens at daemon startup, not tool execution"
      - "Explicit timing guarantee for capability revocation"

  - remediation_id: REM-SA3-004
    blocking_defect: SA3-F-012
    title: "Specify HarnessAdapter output sanitization requirements"
    priority: MAJOR
    effort_estimate: "1 day"
    acceptance_criteria:
      - "ANSI escape sequence whitelist defined"
      - "Tool request character set specified"
      - "Rate limiting specified (max requests/sec)"
      - "Parsing error handling (emit event, not panic)"
      - "Fuzzer test cases added"

  - remediation_id: REM-SA3-005
    blocking_defect: SA3-F-013
    title: "Specify cgroup fallback race mitigation algorithm"
    priority: MAJOR
    effort_estimate: "1 day"
    acceptance_criteria:
      - "Exact freeze/assign/unfreeze sequence specified"
      - "Race window analyzed and bounded"
      - "Test to verify no process runs during freeze"
      - "Performance impact analyzed"

  - remediation_id: REM-SA3-006
    blocking_defect: SA3-F-015
    title: "Add non-repudiation fields to StopOrder"
    priority: MAJOR
    effort_estimate: "0.5 day"
    acceptance_criteria:
      - "actor_id field added to StopOrder message"
      - "issuer_signature added (signed by issuer)"
      - "Audit trail includes issuer identity"
      - "Verification procedure documented"

post_remediation_validation:
  - validation_id: VAL-SA3-001
    validates_remediations: [REM-SA3-001, REM-SA3-002]
    validation_criteria: |
      After remediations, generate TCK-PEND-010 (receipt signing ticket) and verify:
      1. All signing steps have explicit implementation guidance
      2. Golden vectors can be tested in CI
      3. Key rotation procedures are operationalizable
      4. No ambiguity in canonical bytes algorithm

  - validation_id: VAL-SA3-002
    validates_remediations: [REM-SA3-003]
    validation_criteria: |
      After remediation, generate TCK-PEND-008 (ToolBroker ticket) and verify:
      1. Hash verification step is atomic
      2. Capability revocation timing is bounded
      3. No TOCTOU race remains

  - validation_id: VAL-SA3-003
    validates_remediations: [REM-SA3-004, REM-SA3-005]
    validation_criteria: |
      After remediations, generate TCK-PEND-006 and TCK-PEND-016 (adapter tickets):
      1. Sanitization requirements are testable
      2. Fallback algorithm is unambiguous
      3. Race windows are eliminated

anti_cousin_validation_checklist:
  - criterion: "No EpisodeController replacement detected"
    status: PASSED
    evidence: "EpisodeController used as-is; HarnessAdapter implements Holon trait"

  - criterion: "No duplicate evidence storage"
    status: PASSED
    evidence: "CAS is sole backend; no parallel evidence systems"

  - criterion: "No duplicate session management"
    status: PASSED
    evidence: "SessionReducer extended, not replaced; ExitHandler reused"

  - criterion: "No duplicate budget tracking"
    status: PASSED
    evidence: "Logical budget (Controller) and resource budget (cgroup) orthogonal; no overlap"

  - criterion: "Composition pattern consistently applied"
    status: PASSED
    evidence: "HarnessAdapter wraps Adapter; EpisodeRuntime wraps Controller"

  - criterion: "No unintended trait/interface overlap"
    status: PASSED
    evidence: "Clear responsibility boundaries; Holon trait unified interface"

security_principle_verification:
  - principle: "Defense in depth: multiple layers prevent single point of failure"
    verification: |
      1. Logical budget (EpisodeController tokens) prevents runaway inference
      2. Resource budget (cgroup limits) prevents runaway processes
      3. Evidence budget (TTL + pinning) prevents unbounded storage
      4. Capability manifest limits unauthorized tool usage
      5. Stop-state check prevents late tool execution

      Status: SATISFIED
      Confidence: HIGH

  - principle: "Fail-closed: default deny, explicit allowlist"
    verification: |
      1. Capabilities: default deny; explicit delegation required (AD-TOOL-002)
      2. Network: default deny; network namespace isolation for tier 3+ (AD-SEC-001)
      3. Filesystem: default deny; read-only by default (AD-SEC-001)
      4. Stop state: fail closed; no action if stop unverifiable (AD-SEC-001)

      Status: SATISFIED
      Confidence: HIGH
      Exception: Parser sanitization not specified (SA3-F-012)

  - principle: "Auditability: all effects logged to ledger"
    verification: |
      1. All tool executions produce ToolRequested/ToolDecided/ToolExecuted events
      2. All episode lifecycle events produce episode.receipt
      3. All policy changes logged
      4. Evidence TTL and pinning decisions logged as events
      5. Receipt signatures verifiable via canonical bytes

      Status: PARTIALLY_SATISFIED
      Gap: Canonical bytes specification missing (SA3-F-003)

  - principle: "Composability: trust boundaries at component interfaces"
    verification: |
      1. ToolBroker validates capabilities before tool execution
      2. HarnessAdapter implements Holon; EpisodeController validates Holon behavior
      3. EpisodeRuntime validates EpisodeController output
      4. Ledger is authoritative; reducers are views

      Status: SATISFIED
      Confidence: HIGH
      Exception: Hash verification timing not explicit (SA3-F-006)

final_assessment: |
  RFC-0013 v2 demonstrates principled security architecture grounded in trust
  boundaries, defense in depth, and fail-closed defaults. The design is conceptually
  sound and well-aligned with holonic doctrine.

  However, proof-of-work gaps prevent ticket decomposition:
  - 3 BLOCKER defects (key lifecycle, canonical bytes, hash verification)
  - 4 MAJOR defects (sanitization, fallback algorithm, non-repudiation, and others)

  These are not design flaws; they are specification gaps. Remediations are
  straightforward (1-5 day efforts each) but MUST be completed before DECOMPOSE
  can begin.

  **VERDICT: DECOMPOSE BLOCKED**
  Recommend: Advance to v4 Finalization and address 7 MAJOR security defects
  per remediation plan.

prepared_by: SA-3
prepared_date: "2026-01-27T22:15:00Z"
reasoning_modes_applied: [7, 31, 49, 66, 79]
