# Regression fixture for review_artifact_lint.sh
# Each non-comment line below is a pattern that MUST be detected as a violation.
# The test_review_artifact_lint_fixtures.sh script verifies these are all caught.

# Pattern A: explicit POST to statuses with security context
gh api --method POST "/repos/{owner}/{repo}/statuses/$reviewed_sha" -f state="success" -f context="ai-review/security"

# Pattern B: gh pr review --approve bypass
gh pr review --approve $PR_URL

# Pattern C: check-runs with explicit POST and security context
gh api --method POST "/repos/{owner}/{repo}/check-runs" -f name="ai-review/security" -f conclusion="success"

# Pattern D: check-runs with implicit write flags (no explicit POST)
gh api "/repos/{owner}/{repo}/check-runs/$sha" -f state="failure" -f context="ai-review/security"

# Pattern E: statuses with implicit write flags (no explicit --method POST)
gh api "/repos/{owner}/{repo}/statuses/$sha" -f state="success" -f context="ai-review/security"

# Pattern F: gh api with --field flag targeting security context
gh api "/repos/{owner}/{repo}/statuses/$sha" --field state="success" --field context="ai-review/security"

# Pattern G: implicit write via -X POST to check-runs
gh api -X POST "/repos/{owner}/{repo}/check-runs" -f name="ai-review/security"

# Pattern H: mixed-context bypass — security + code-quality on same statuses line
gh api "/repos/{owner}/{repo}/statuses/$sha" -f context="ai-review/security" -f context="ai-review/code-quality"

# Pattern I: mixed-context bypass — dual -f context= targeting both security and code-quality
gh api --method POST "/repos/{owner}/{repo}/statuses/$sha" -f state="success" -f context="ai-review/security" -f context="ai-review/code-quality"

# Pattern J: mixed-context bypass — security in check-runs with code-quality also present
gh api "/repos/{owner}/{repo}/check-runs" -f name="ai-review/security" -f name="ai-review/code-quality" -f conclusion="success"

# Pattern K: curl bypass — direct POST to statuses endpoint with security context
curl -X POST "https://api.github.com/repos/{owner}/{repo}/statuses/$sha" -d '{"context":"ai-review/security","state":"success"}'

# Pattern L: variable indirection bypass — endpoint and context in variables
endpoint="/repos/{owner}/{repo}/statuses/$sha"; ctx="ai-review/security"; gh api "$endpoint" -f context="$ctx"

# Pattern M: curl with check-runs endpoint and security context
curl -H "Authorization: token $TOKEN" -X POST "https://api.github.com/repos/{owner}/{repo}/check-runs" -d '{"name":"ai-review/security","conclusion":"success"}'

# Pattern N: variable indirection with check-runs — no gh api on same line as ai-review/security
statuses_url="/repos/{owner}/{repo}/check-runs"; gh api "$statuses_url" -f name="ai-review/security" -f conclusion="success"

# Pattern O: split-line endpoint+variable — the ai-review/security literal on any line catches the indirection
endpoint="/repos/{owner}/{repo}/statuses/$sha"; ctx="ai-review/security"; gh api "$endpoint" -f context="$ctx"
