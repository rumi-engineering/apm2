name: Forge Admission Cycle

on:
  workflow_run:
    workflows: ["Forge Admission Barrier"]
    types: [completed]
  workflow_dispatch:
    inputs:
      pr_number:
        description: "Pull request number to process"
        required: true
        type: string

concurrency:
  group: forge-admission-cycle-${{ github.event_name == 'workflow_run' && github.event.workflow_run.pull_requests[0].number || github.event.inputs.pr_number || github.run_id }}
  cancel-in-progress: true

permissions:
  contents: read
  issues: read

jobs:
  dispatch-auth:
    name: Guardian Intelligence / Dispatch Auth
    if: ${{ github.event_name == 'workflow_dispatch' }}
    runs-on: ubuntu-24.04
    timeout-minutes: 5
    steps:
      - name: Validate workflow_dispatch trust boundary (fast path)
        env:
          GH_TOKEN: ${{ github.token }}
          GITHUB_ACTOR: ${{ github.actor }}
          GITHUB_EVENT_PATH: ${{ github.event_path }}
          GITHUB_REF_NAME: ${{ github.ref_name }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          set -euo pipefail

          fail() {
            echo "dispatch-auth: $1" >&2
            exit 1
          }

          repo="$GITHUB_REPOSITORY"
          actor="$GITHUB_ACTOR"
          pr_number="$(jq -r '.inputs.pr_number // .client_payload.pr_number // empty' "$GITHUB_EVENT_PATH")"
          [[ -n "$pr_number" ]] || fail "workflow_dispatch requires inputs.pr_number"

          pr_json="$(gh api "repos/$repo/pulls/$pr_number")" || fail "failed to load PR #$pr_number"
          base_ref="$(jq -r '.base.ref // empty' <<<"$pr_json")"
          [[ -n "$base_ref" ]] || fail "PR #$pr_number missing base.ref"

          default_branch="$(gh api "repos/$repo" --jq '.default_branch')"
          dispatch_ref="${GITHUB_REF_NAME:-}"
          [[ -n "$dispatch_ref" ]] || fail "missing GITHUB_REF_NAME for workflow_dispatch"
          if [[ "$dispatch_ref" != "$base_ref" && "$dispatch_ref" != "$default_branch" ]]; then
            fail "workflow_dispatch ref=$dispatch_ref is not trusted (base=$base_ref default=$default_branch)"
          fi

          permission="$(gh api "repos/$repo/collaborators/$actor/permission" --jq '.permission // empty' 2>/dev/null || true)"
          case "$permission" in
            admin|maintain|write) ;;
            *)
              fail "workflow_dispatch actor=$actor lacks permission (need write|maintain|admin, got ${permission:-none})"
              ;;
          esac
          echo "dispatch-auth: authorized workflow_dispatch pr=$pr_number ref=$dispatch_ref actor_permission=$permission"

  forge-admission-cycle:
    name: apm2 / Forge Admission Cycle
    needs: [dispatch-auth]
    if: >
      ${{
        always() &&
        (
          (github.event_name == 'workflow_run' &&
           github.event.workflow_run.conclusion == 'success' &&
           github.event.workflow_run.event == 'pull_request_target') ||
          (github.event_name == 'workflow_dispatch' &&
           needs.dispatch-auth.result == 'success')
        )
      }}
    runs-on: ubuntu-24.04
    timeout-minutes: 90
    steps:
      - name: Resolve PR context
        id: pr-context
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail
          if [[ "${{ github.event_name }}" == "workflow_run" ]]; then
            pr_number="${{ github.event.workflow_run.pull_requests[0].number }}"
            if [[ -z "$pr_number" || "$pr_number" == "null" || "$pr_number" == "0" ]]; then
              echo "ERROR: workflow_run event has no associated pull_requests â€” cannot resolve PR context" >&2
              exit 1
            fi
            head_sha="$(gh api "repos/${{ github.repository }}/pulls/${pr_number}" --jq '.head.sha')"
            if [[ -z "$head_sha" || "$head_sha" == "null" ]]; then
              echo "ERROR: could not resolve head SHA for PR #${pr_number}" >&2
              exit 1
            fi
          else
            pr_number="${{ github.event.inputs.pr_number }}"
            head_sha="$(gh api "repos/${{ github.repository }}/pulls/${pr_number}" --jq '.head.sha')"
          fi
          echo "pr_number=${pr_number}" >> "$GITHUB_OUTPUT"
          echo "head_sha=${head_sha}" >> "$GITHUB_OUTPUT"
          echo "fac-context: pr=${pr_number} sha=${head_sha}"

      - name: Poll review gate
        env:
          GH_TOKEN: ${{ github.token }}
        run: |
          set -euo pipefail

          repo="${{ github.repository }}"
          pr_number="${{ steps.pr-context.outputs.pr_number }}"
          head_sha="${{ steps.pr-context.outputs.head_sha }}"
          max_wait=4800
          poll_interval=30

          # Load trusted reviewer logins from repo
          trusted_json="$(gh api "repos/${repo}/contents/.github/review-gate/trusted-reviewers.json" \
            --jq '.content' | base64 -d)"
          security_logins="$(echo "$trusted_json" | jq -r '[.reviewers.security[].github_logins[]] | join("|")')"
          quality_logins="$(echo "$trusted_json" | jq -r '[.reviewers.code_quality[].github_logins[]] | join("|")')"

          # Extract the latest review verdict for a given type from PR comments.
          # Validates: trusted author, correct head_sha, correct pr_number.
          # Prints one of: PASS, FAIL, or pending.
          check_verdict() {
            local review_type="$1"
            local trusted_re="$2"
            local marker="apm2-review-metadata:v1:${review_type}"

            # Get body of the latest comment from a trusted author containing the marker
            local body
            body="$(gh api "repos/${repo}/issues/${pr_number}/comments" --paginate --jq "
              [.[] |
               select(.user.login | test(\"^(${trusted_re})$\")) |
               select(.body | test(\"${marker}\"))
              ] | last | .body // empty")"

            [[ -n "$body" ]] || { echo "pending"; return; }

            # Extract the JSON metadata block following the marker
            local json_block
            json_block="$(echo "$body" | \
              sed -n "/${marker}/,\$p" | \
              sed -n '/```json/,/```/p' | sed '1d;$d')"

            [[ -n "$json_block" ]] || { echo "pending"; return; }

            # Validate SHA + PR binding, return verdict
            echo "$json_block" | jq -r \
              --arg sha "$head_sha" \
              --argjson pr "$pr_number" \
              'if .head_sha == $sha and .pr_number == $pr then .verdict
               else "pending" end'
          }

          deadline=$((SECONDS + max_wait))
          echo "fac-gate: polling pr=${pr_number} sha=${head_sha} deadline=${max_wait}s"

          while [[ $SECONDS -lt $deadline ]]; do
            sec_v="$(check_verdict "security" "$security_logins")"
            qual_v="$(check_verdict "code-quality" "$quality_logins")"

            ts="$(date -u '+%Y-%m-%dT%H:%M:%SZ')"
            echo "ts=${ts} sha=${head_sha} security=${sec_v} quality=${qual_v}"

            if [[ "$sec_v" == "FAIL" || "$qual_v" == "FAIL" ]]; then
              echo "fac-gate: FAIL security=${sec_v} quality=${qual_v}"
              exit 1
            fi
            if [[ "$sec_v" == "PASS" && "$qual_v" == "PASS" ]]; then
              echo "fac-gate: PASS security=PASS quality=PASS"
              exit 0
            fi

            sleep "$poll_interval"
          done

          echo "fac-gate: FAIL reason=timeout after ${max_wait}s"
          exit 1
