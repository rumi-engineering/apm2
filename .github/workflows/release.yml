# Stable release workflow
# Promotes artifacts from beta (or dev) and signs with Sigstore
# Triggered by release-plz creating a version tag

name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write
  id-token: write
  attestations: write
  actions: read

env:
  CARGO_TERM_COLOR: always
  GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}

jobs:
  # Promote artifacts from beta (or dev) and sign
  release:
    name: Promote and Sign
    # Do not run for pre-release tags (e.g. vX.Y.Z-beta.N).
    if: ${{ !contains(github.ref_name, '-') }}
    runs-on: &primary_runner [self-hosted, linux, x64, fac-ovh]
    outputs:
      hashes: ${{ steps.hash.outputs.hashes }}
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
        with:
          fetch-depth: 0

      - name: Extract version
        id: version
        run: |
          VERSION="${GITHUB_REF_NAME#v}"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          echo "Releasing version: $VERSION"

      - name: Find source release
        id: source
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          mkdir -p artifacts

          # Try to find a matching beta release (vX.Y.Z-beta.N)
          BETA_PATTERN="v${VERSION}-beta"
          echo "Looking for beta releases matching: ${BETA_PATTERN}*"

          BETA_RELEASE=$(gh release list --limit 20 | grep -E "^v${VERSION}-beta\.[0-9]+" | head -1 | cut -f1 || true)

          if [[ -n "$BETA_RELEASE" ]]; then
            echo "Found beta release: $BETA_RELEASE"
            echo "source=$BETA_RELEASE" >> "$GITHUB_OUTPUT"
            echo "source_type=beta" >> "$GITHUB_OUTPUT"
          else
            echo "No beta release found, falling back to dev"
            echo "source=dev" >> "$GITHUB_OUTPUT"
            echo "source_type=dev" >> "$GITHUB_OUTPUT"
          fi

      - name: Download source artifacts
        run: |
          SOURCE="${{ steps.source.outputs.source }}"
          echo "Downloading artifacts from: $SOURCE"
          cd artifacts
          gh release download "$SOURCE" --pattern '*'
          # Remove any existing signatures (dev/beta don't have them, but just in case)
          rm -f *.sig *.pem sbom.spdx.json provenance.intoto.jsonl 2>/dev/null || true
          ls -la

      - name: Verify checksums
        run: |
          cd artifacts
          echo "Verifying artifact checksums..."
          sha256sum -c checksums-sha256.txt
          echo "All checksums verified successfully"

      # Vulnerability scan
      - name: Vulnerability Scan
        uses: anchore/scan-action@64a33b277ea7a1215a3c142735a1091341939ff5 # v4
        with:
          path: "."
          fail-build: true
          severity-cutoff: high

      # Install Cosign for keyless signing
      - name: Install Cosign
        uses: sigstore/cosign-installer@f713795cb21599bc4e5c4b58cbad1da852d7eeb9 # v3

      # Sign all binary artifacts with Cosign (keyless via OIDC)
      - name: Sign artifacts with Cosign
        run: |
          cd artifacts
          for file in *; do
            if [[ -f "$file" && ! "$file" =~ \.(sig|pem|txt|json|jsonl)$ ]]; then
              echo "Signing $file..."
              cosign sign-blob --yes \
                --output-signature "${file}.sig" \
                --output-certificate "${file}.pem" \
                "$file"
            fi
          done

      # Verify Rekor transparency entries (CTR-1913) and OIDC claim-lock (CTR-1912)
      - name: Verify Rekor transparency entries
        run: |
          cd artifacts
          OIDC_ISSUER="https://token.actions.githubusercontent.com"
          CERT_IDENTITY="https://github.com/${{ github.repository }}/.*"

          for file in *.sig; do
            base="${file%.sig}"
            if [[ -f "$base" && -f "${base}.pem" ]]; then
              echo "Verifying Rekor entry for $base..."
              cosign verify-blob \
                --certificate "${base}.pem" \
                --signature "${file}" \
                --certificate-identity-regexp "$CERT_IDENTITY" \
                --certificate-oidc-issuer "$OIDC_ISSUER" \
                "$base" || { echo "ERROR: Rekor verification failed for $base"; exit 1; }
            fi
          done
          echo "All artifacts verified in Rekor transparency log"

      # Generate SBOM
      - name: Generate SBOM
        uses: anchore/sbom-action@62ad5284b8ced813296287a0b63906cb364b73ee # v0
        with:
          artifact-name: sbom.spdx.json
          output-file: artifacts/sbom.spdx.json

      # Generate hashes for SLSA provenance
      - name: Generate artifact hashes
        id: hash
        run: |
          cd artifacts
          # Generate hashes for all binary files (not signatures/certs/metadata)
          hashes=$(sha256sum $(find . -type f ! -name "*.sig" ! -name "*.pem" ! -name "*.txt" ! -name "*.json" ! -name "*.jsonl") | base64 -w0)
          echo "hashes=$hashes" >> "$GITHUB_OUTPUT"

      - name: Generate attestations
        uses: actions/attest-build-provenance@92c65d2898f1f53cfdc910b962cecff86e7f8fcc # v1
        with:
          subject-path: 'artifacts/*'

      - name: Create release
        run: |
          VERSION="${{ steps.version.outputs.version }}"
          SOURCE="${{ steps.source.outputs.source }}"
          SOURCE_TYPE="${{ steps.source.outputs.source_type }}"
          NOTES_START_TAG=$(git describe --tags --abbrev=0 HEAD^ 2>/dev/null || true)

          if [[ -n "$NOTES_START_TAG" ]]; then
            NOTES_ARGS=(--notes-start-tag "$NOTES_START_TAG")
          else
            NOTES_ARGS=()
          fi

          gh release create "v${VERSION}" \
            --title "v${VERSION}" \
            --generate-notes \
            "${NOTES_ARGS[@]}" \
            artifacts/*

          echo "Created stable release: v${VERSION}"
          echo "Promoted from: ${SOURCE} (${SOURCE_TYPE})"

  # Generate SLSA provenance
  provenance:
    name: SLSA Provenance
    needs: release
    permissions:
      actions: read
      id-token: write
      contents: write
    uses: slsa-framework/slsa-github-generator/.github/workflows/generator_generic_slsa3.yml@5a775b367a56d5bd118a224a811bba288150a563 # v2.0.0
    with:
      base64-subjects: "${{ needs.release.outputs.hashes }}"
      upload-assets: true

  # Publish to crates.io
  publish:
    name: Publish to crates.io
    needs: release
    runs-on: *primary_runner
    steps:
      - uses: actions/checkout@34e114876b0b11c390a56381ad16ebd13914f8d5 # v4
      - uses: dtolnay/rust-toolchain@f7ccc83f9ed1e5b9c81d8a67d7ad1a747e22a561 # nightly
        with:
          toolchain: nightly
      - name: Install protoc
        run: sudo apt-get update && sudo apt-get install -y protobuf-compiler
      - uses: Swatinem/rust-cache@ad397744b0d591a723ab90405b7247fac0e6b8db # v2

      - name: Publish apm2-core
        run: cargo publish -p apm2-core --allow-dirty || echo "apm2-core already published or publish failed"
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

      - name: Wait for crates.io index
        run: sleep 30

      - name: Publish apm2-daemon
        run: cargo publish -p apm2-daemon --allow-dirty || echo "apm2-daemon already published or publish failed"
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}

      - name: Wait for crates.io index
        run: sleep 30

      - name: Publish apm2-cli
        run: cargo publish -p apm2-cli --allow-dirty || echo "apm2-cli already published or publish failed"
        env:
          CARGO_REGISTRY_TOKEN: ${{ secrets.CARGO_REGISTRY_TOKEN }}
