// This file is @generated by prost-build.
/// Tool request from agent to kernel.
///
/// Each request includes a unique request_id for correlation with responses,
/// a session_token for authentication, and an optional dedupe_key to prevent
/// duplicate execution of identical requests.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolRequest {
    /// Unique identifier for this request (UUID format recommended).
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// Session token for authentication and authorization.
    /// Must match an active session in the kernel.
    #[prost(string, tag = "2")]
    pub session_token: ::prost::alloc::string::String,
    /// Optional deduplication key.
    /// If set, the kernel will return cached results for identical keys
    /// within the same session.
    #[prost(string, tag = "3")]
    pub dedupe_key: ::prost::alloc::string::String,
    /// Whether the request is part of a consumption workflow (read-only/strict).
    #[prost(bool, tag = "4")]
    pub consumption_mode: bool,
    /// The specific tool operation requested.
    #[prost(oneof = "tool_request::Tool", tags = "10, 11, 12, 13, 14, 15, 16, 17")]
    pub tool: ::core::option::Option<tool_request::Tool>,
}
/// Nested message and enum types in `ToolRequest`.
pub mod tool_request {
    /// The specific tool operation requested.
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Tool {
        #[prost(message, tag = "10")]
        FileRead(super::FileRead),
        #[prost(message, tag = "11")]
        FileWrite(super::FileWrite),
        #[prost(message, tag = "12")]
        FileEdit(super::FileEdit),
        #[prost(message, tag = "13")]
        ShellExec(super::ShellExec),
        #[prost(message, tag = "14")]
        GitOp(super::GitOperation),
        #[prost(message, tag = "15")]
        Inference(super::InferenceCall),
        #[prost(message, tag = "16")]
        ArtifactPublish(super::ArtifactPublish),
        #[prost(message, tag = "17")]
        ArtifactFetch(super::ArtifactFetch),
    }
}
/// Request to read file contents.
///
/// Policy may restrict:
/// - Allowed paths (glob patterns)
/// - Maximum read size
/// - Excluded paths (secrets, system files)
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileRead {
    /// Absolute or relative path to read.
    /// Relative paths are resolved against the session's working directory.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Byte offset to start reading from (0 = beginning of file).
    #[prost(uint64, tag = "2")]
    pub offset: u64,
    /// Maximum number of bytes to read (0 = read entire file).
    #[prost(uint64, tag = "3")]
    pub limit: u64,
}
/// Request to write file contents.
///
/// Policy may restrict:
/// - Allowed paths (glob patterns)
/// - Maximum file size
/// - Prohibited content patterns
/// - Overwrite vs create-only
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileWrite {
    /// Absolute or relative path to write.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Content to write to the file.
    #[prost(bytes = "vec", tag = "2")]
    pub content: ::prost::alloc::vec::Vec<u8>,
    /// If true, only create the file if it doesn't exist (fail on overwrite).
    #[prost(bool, tag = "3")]
    pub create_only: bool,
    /// If true, append to existing file instead of overwriting.
    #[prost(bool, tag = "4")]
    pub append: bool,
}
/// Request to edit file contents using search/replace.
///
/// This operation is atomic: either the edit succeeds completely or fails
/// without modifying the file. The old_content must match exactly once.
///
/// Policy may restrict:
/// - Allowed paths (glob patterns)
/// - Maximum edit size
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FileEdit {
    /// Path to the file to edit.
    #[prost(string, tag = "1")]
    pub path: ::prost::alloc::string::String,
    /// Content to search for (must match exactly once in the file).
    #[prost(string, tag = "2")]
    pub old_content: ::prost::alloc::string::String,
    /// Content to replace with.
    #[prost(string, tag = "3")]
    pub new_content: ::prost::alloc::string::String,
}
/// Request to execute a shell command.
///
/// SECURITY: Shell execution is high-risk and subject to strict policy.
///
/// Policy may restrict:
/// - Allowed commands (allowlist patterns)
/// - Prohibited commands (denylist patterns)
/// - Working directory constraints
/// - Timeout limits
/// - Network access
/// - Environment variables
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ShellExec {
    /// Command to execute (passed to shell).
    #[prost(string, tag = "1")]
    pub command: ::prost::alloc::string::String,
    /// Working directory for command execution.
    /// If empty, uses the session's working directory.
    #[prost(string, tag = "2")]
    pub cwd: ::prost::alloc::string::String,
    /// Timeout in milliseconds (0 = use default timeout).
    #[prost(uint64, tag = "3")]
    pub timeout_ms: u64,
    /// Whether network access is required.
    /// Policy may deny network access even if requested.
    #[prost(bool, tag = "4")]
    pub network_access: bool,
    /// Environment variables to set for the command.
    /// Note: This is a repeated field of key=value strings to avoid maps.
    /// Example: \["PATH=/usr/bin", "HOME=/home/user"\]
    #[prost(string, repeated, tag = "5")]
    pub env: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request to perform a git operation.
///
/// Git operations are mediated separately from shell execution to enable
/// more granular policy (e.g., allow git diff but not git push).
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitOperation {
    /// Git operation type.
    ///
    /// CLONE, FETCH, DIFF, COMMIT, PUSH, STATUS, LOG, BRANCH, CHECKOUT, MERGE, REBASE
    #[prost(string, tag = "1")]
    pub operation: ::prost::alloc::string::String,
    /// Arguments for the operation.
    #[prost(string, repeated, tag = "2")]
    pub args: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Working directory (repository root).
    #[prost(string, tag = "3")]
    pub cwd: ::prost::alloc::string::String,
}
/// Request to make an inference call to an AI provider.
///
/// Policy may restrict:
/// - Allowed providers
/// - Allowed models
/// - Token limits
/// - Cost limits per session
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InferenceCall {
    /// Provider identifier (e.g., "anthropic", "openai", "google").
    #[prost(string, tag = "1")]
    pub provider: ::prost::alloc::string::String,
    /// Model identifier (e.g., "claude-3-opus", "gpt-4").
    #[prost(string, tag = "2")]
    pub model: ::prost::alloc::string::String,
    /// Hash of the prompt (full prompt stored in CAS).
    /// This avoids transmitting large prompts in the protocol.
    #[prost(bytes = "vec", tag = "3")]
    pub prompt_hash: ::prost::alloc::vec::Vec<u8>,
    /// Maximum tokens to generate.
    #[prost(uint64, tag = "4")]
    pub max_tokens: u64,
    /// Temperature for sampling, scaled by 100 (e.g., 70 = 0.70).
    /// Using uint32 instead of float to ensure Hash derivation compatibility.
    #[prost(uint32, tag = "5")]
    pub temperature_scaled: u32,
    /// System prompt hash (optional, stored in CAS).
    #[prost(bytes = "vec", tag = "6")]
    pub system_prompt_hash: ::prost::alloc::vec::Vec<u8>,
}
/// Request to publish an artifact to the content-addressed store.
///
/// Artifacts are immutable once published and referenced by hash.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactPublish {
    /// Unique identifier for this artifact within the work context.
    #[prost(string, tag = "1")]
    pub artifact_id: ::prost::alloc::string::String,
    /// Hash of the artifact content (content already stored or being uploaded).
    #[prost(bytes = "vec", tag = "2")]
    pub content_hash: ::prost::alloc::vec::Vec<u8>,
    /// Category for organizing artifacts (e.g., "test_results", "logs", "code").
    #[prost(string, tag = "3")]
    pub category: ::prost::alloc::string::String,
    /// Optional metadata as key=value strings.
    #[prost(string, repeated, tag = "4")]
    pub metadata: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
/// Request to fetch an artifact by stable ID or content hash.
///
/// In consumption mode, policy enforces that only allowlisted stable_ids
/// can be fetched to ensure hermeticity.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactFetch {
    /// Stable identifier for resolution (e.g., "org:ticket:TCK-001").
    /// If set, the kernel resolves this to a content hash.
    #[prost(string, tag = "1")]
    pub stable_id: ::prost::alloc::string::String,
    /// Direct content hash reference (BLAKE3, 32 bytes).
    /// Policy may restrict usage in consumption mode to prevent side-channel bypass.
    /// Note: Changed from string (hex) to bytes for consistency with ArtifactPublish.
    #[prost(bytes = "vec", tag = "2")]
    pub content_hash: ::prost::alloc::vec::Vec<u8>,
    /// Expected content hash for validation when using stable_id (BLAKE3, 32 bytes).
    /// If resolution yields a different hash, the fetch fails.
    /// Note: Changed from string (hex) to bytes for consistency with content_hash.
    #[prost(bytes = "vec", tag = "3")]
    pub expected_hash: ::prost::alloc::vec::Vec<u8>,
    /// Maximum bytes to return (inline or total).
    #[prost(uint64, tag = "4")]
    pub max_bytes: u64,
    /// Requested format (e.g., "json", "yaml", "raw").
    /// The kernel may perform transcoding if supported.
    #[prost(string, tag = "5")]
    pub format: ::prost::alloc::string::String,
}
/// Tool response from kernel to agent.
///
/// Every ToolRequest receives exactly one ToolResponse.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolResponse {
    /// Request ID this response corresponds to.
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// The result of the tool execution.
    #[prost(oneof = "tool_response::Result", tags = "2, 3, 4")]
    pub result: ::core::option::Option<tool_response::Result>,
}
/// Nested message and enum types in `ToolResponse`.
pub mod tool_response {
    /// The result of the tool execution.
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Result {
        #[prost(message, tag = "2")]
        Success(super::ToolSuccess),
        #[prost(message, tag = "3")]
        Denied(super::ToolDenied),
        #[prost(message, tag = "4")]
        Error(super::ToolError),
    }
}
/// Successful tool execution result.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolSuccess {
    /// Hash of the full result (stored in CAS if large).
    #[prost(bytes = "vec", tag = "1")]
    pub result_hash: ::prost::alloc::vec::Vec<u8>,
    /// Small results can be returned inline (up to 1MB).
    #[prost(bytes = "vec", tag = "2")]
    pub inline_result: ::prost::alloc::vec::Vec<u8>,
    /// Budget consumed by this operation.
    #[prost(uint64, tag = "3")]
    pub budget_consumed: u64,
    /// Duration of the operation in milliseconds.
    #[prost(uint64, tag = "4")]
    pub duration_ms: u64,
}
/// Tool request was denied by policy.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolDenied {
    /// Rule ID that caused the denial.
    #[prost(string, tag = "1")]
    pub rule_id: ::prost::alloc::string::String,
    /// Machine-readable rationale code.
    #[prost(string, tag = "2")]
    pub rationale_code: ::prost::alloc::string::String,
    /// Human-readable message explaining the denial.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
/// Tool execution failed with an error.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolError {
    /// Error code for programmatic handling.
    #[prost(string, tag = "1")]
    pub error_code: ::prost::alloc::string::String,
    /// Human-readable error message.
    #[prost(string, tag = "2")]
    pub message: ::prost::alloc::string::String,
    /// Whether the error is retryable.
    #[prost(bool, tag = "3")]
    pub retryable: bool,
    /// Suggested retry delay in milliseconds (if retryable).
    #[prost(uint64, tag = "4")]
    pub retry_after_ms: u64,
}
/// Validation error details for malformed requests.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ValidationError {
    /// Field that failed validation.
    #[prost(string, tag = "1")]
    pub field: ::prost::alloc::string::String,
    /// Validation rule that was violated.
    #[prost(string, tag = "2")]
    pub rule: ::prost::alloc::string::String,
    /// Human-readable description of the error.
    #[prost(string, tag = "3")]
    pub message: ::prost::alloc::string::String,
}
