//! Coordination event types and payloads.
//!
//! This module defines the event types for the coordination layer:
//! - [`CoordinationEvent`]: Enum of all coordination event variants
//! - Event payload types for each variant
//!
//! Per AD-COORD-009: Events use JSON serialization via `serde_json`.
//! Events follow the existing pattern used by `SessionStarted`,
//! `WorkTransitioned`, and other event payloads.

use serde::{Deserialize, Serialize};

use super::state::{AbortReason, BudgetUsage, CoordinationBudget, SessionOutcome, StopCondition};

/// Event type constant for coordination started.
pub const EVENT_TYPE_STARTED: &str = "coordination.started";

/// Event type constant for session bound.
pub const EVENT_TYPE_SESSION_BOUND: &str = "coordination.session_bound";

/// Event type constant for session unbound.
pub const EVENT_TYPE_SESSION_UNBOUND: &str = "coordination.session_unbound";

/// Event type constant for coordination completed.
pub const EVENT_TYPE_COMPLETED: &str = "coordination.completed";

/// Event type constant for coordination aborted.
pub const EVENT_TYPE_ABORTED: &str = "coordination.aborted";

/// Payload for `coordination.started` events.
///
/// Emitted when a coordination begins processing its work queue.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CoordinationStarted {
    /// Unique identifier for this coordination.
    pub coordination_id: String,

    /// Work item IDs in the queue.
    pub work_ids: Vec<String>,

    /// Budget constraints for this coordination.
    pub budget: CoordinationBudget,

    /// Maximum attempts per work item.
    pub max_attempts_per_work: u32,

    /// Timestamp when coordination started (nanoseconds since epoch).
    pub started_at: u64,
}

impl CoordinationStarted {
    /// Creates a new coordination started payload.
    #[must_use]
    pub const fn new(
        coordination_id: String,
        work_ids: Vec<String>,
        budget: CoordinationBudget,
        max_attempts_per_work: u32,
        started_at: u64,
    ) -> Self {
        Self {
            coordination_id,
            work_ids,
            budget,
            max_attempts_per_work,
            started_at,
        }
    }
}

/// Payload for `coordination.session_bound` events.
///
/// Per AD-COORD-003: This event MUST be emitted before `session.started`.
/// Per AD-COORD-007: Session ID is generated before this event is emitted.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CoordinationSessionBound {
    /// Coordination ID this session is bound to.
    pub coordination_id: String,

    /// Session ID that will process the work item.
    ///
    /// Per AD-COORD-007: Generated by controller before binding.
    pub session_id: String,

    /// Work item ID being processed.
    pub work_id: String,

    /// Attempt number for this work item (1-indexed).
    pub attempt_number: u32,

    /// Ledger sequence ID at which work freshness was verified.
    ///
    /// Per AD-COORD-006: Work state was checked at this sequence.
    pub freshness_seq_id: u64,

    /// Timestamp when binding was created (nanoseconds since epoch).
    pub bound_at: u64,
}

impl CoordinationSessionBound {
    /// Creates a new session bound payload.
    #[must_use]
    pub const fn new(
        coordination_id: String,
        session_id: String,
        work_id: String,
        attempt_number: u32,
        freshness_seq_id: u64,
        bound_at: u64,
    ) -> Self {
        Self {
            coordination_id,
            session_id,
            work_id,
            attempt_number,
            freshness_seq_id,
            bound_at,
        }
    }
}

/// Payload for `coordination.session_unbound` events.
///
/// Per AD-COORD-003: This event MUST be emitted after `session.terminated`.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CoordinationSessionUnbound {
    /// Coordination ID this session was bound to.
    pub coordination_id: String,

    /// Session ID that processed the work item.
    pub session_id: String,

    /// Work item ID that was processed.
    pub work_id: String,

    /// Outcome of the session.
    pub outcome: SessionOutcome,

    /// Tokens consumed by this session (from `final_entropy`).
    ///
    /// Per AD-COORD-011: Aggregated from `SessionTerminated` payload.
    pub tokens_consumed: u64,

    /// Timestamp when session was unbound (nanoseconds since epoch).
    pub unbound_at: u64,
}

impl CoordinationSessionUnbound {
    /// Creates a new session unbound payload.
    #[must_use]
    pub const fn new(
        coordination_id: String,
        session_id: String,
        work_id: String,
        outcome: SessionOutcome,
        tokens_consumed: u64,
        unbound_at: u64,
    ) -> Self {
        Self {
            coordination_id,
            session_id,
            work_id,
            outcome,
            tokens_consumed,
            unbound_at,
        }
    }
}

/// Payload for `coordination.completed` events.
///
/// Emitted when a coordination finishes processing (success or stop condition).
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CoordinationCompleted {
    /// Coordination ID that completed.
    pub coordination_id: String,

    /// Stop condition that caused completion.
    pub stop_condition: StopCondition,

    /// Final budget usage.
    pub budget_usage: BudgetUsage,

    /// Total sessions spawned.
    pub total_sessions: u32,

    /// Number of successful sessions.
    pub successful_sessions: u32,

    /// Number of failed sessions.
    pub failed_sessions: u32,

    /// BLAKE3 hash of the coordination receipt.
    ///
    /// Per AD-COORD-012: Hash computed before event emission, stored in CAS.
    pub receipt_hash: Vec<u8>,

    /// Timestamp when coordination completed (nanoseconds since epoch).
    pub completed_at: u64,
}

impl CoordinationCompleted {
    /// Creates a new coordination completed payload.
    #[must_use]
    #[allow(clippy::too_many_arguments)]
    pub const fn new(
        coordination_id: String,
        stop_condition: StopCondition,
        budget_usage: BudgetUsage,
        total_sessions: u32,
        successful_sessions: u32,
        failed_sessions: u32,
        receipt_hash: Vec<u8>,
        completed_at: u64,
    ) -> Self {
        Self {
            coordination_id,
            stop_condition,
            budget_usage,
            total_sessions,
            successful_sessions,
            failed_sessions,
            receipt_hash,
            completed_at,
        }
    }
}

/// Payload for `coordination.aborted` events.
///
/// Emitted when a coordination is aborted before completion.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct CoordinationAborted {
    /// Coordination ID that was aborted.
    pub coordination_id: String,

    /// Reason for abortion.
    pub reason: AbortReason,

    /// Budget usage at time of abort.
    pub budget_usage: BudgetUsage,

    /// Timestamp when coordination was aborted (nanoseconds since epoch).
    pub aborted_at: u64,
}

impl CoordinationAborted {
    /// Creates a new coordination aborted payload.
    #[must_use]
    pub const fn new(
        coordination_id: String,
        reason: AbortReason,
        budget_usage: BudgetUsage,
        aborted_at: u64,
    ) -> Self {
        Self {
            coordination_id,
            reason,
            budget_usage,
            aborted_at,
        }
    }
}

/// Coordination event enum.
///
/// Contains all coordination event variants as a tagged union for
/// convenient pattern matching.
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
#[serde(tag = "type", content = "payload")]
#[non_exhaustive]
pub enum CoordinationEvent {
    /// Coordination started processing work queue.
    Started(CoordinationStarted),

    /// Session bound to work item.
    SessionBound(CoordinationSessionBound),

    /// Session unbound from work item.
    SessionUnbound(CoordinationSessionUnbound),

    /// Coordination completed.
    Completed(CoordinationCompleted),

    /// Coordination aborted.
    Aborted(CoordinationAborted),
}

impl CoordinationEvent {
    /// Returns the event type string for this event.
    #[must_use]
    pub const fn event_type(&self) -> &'static str {
        match self {
            Self::Started(_) => EVENT_TYPE_STARTED,
            Self::SessionBound(_) => EVENT_TYPE_SESSION_BOUND,
            Self::SessionUnbound(_) => EVENT_TYPE_SESSION_UNBOUND,
            Self::Completed(_) => EVENT_TYPE_COMPLETED,
            Self::Aborted(_) => EVENT_TYPE_ABORTED,
        }
    }

    /// Returns the coordination ID for this event.
    #[must_use]
    pub fn coordination_id(&self) -> &str {
        match self {
            Self::Started(e) => &e.coordination_id,
            Self::SessionBound(e) => &e.coordination_id,
            Self::SessionUnbound(e) => &e.coordination_id,
            Self::Completed(e) => &e.coordination_id,
            Self::Aborted(e) => &e.coordination_id,
        }
    }

    /// Serializes the event payload to JSON bytes.
    ///
    /// # Errors
    ///
    /// Returns an error if serialization fails.
    pub fn to_json_bytes(&self) -> Result<Vec<u8>, serde_json::Error> {
        serde_json::to_vec(self)
    }

    /// Deserializes an event from JSON bytes.
    ///
    /// # Errors
    ///
    /// Returns an error if deserialization fails.
    pub fn from_json_bytes(bytes: &[u8]) -> Result<Self, serde_json::Error> {
        serde_json::from_slice(bytes)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::coordination::state::BudgetType;

    // ========================================================================
    // CoordinationStarted Tests
    // ========================================================================

    #[test]
    fn test_coordination_started_new() {
        let budget = CoordinationBudget::new(10, 60_000, Some(100_000));
        let event = CoordinationStarted::new(
            "coord-123".to_string(),
            vec!["work-1".to_string(), "work-2".to_string()],
            budget,
            3,
            1_000_000_000,
        );

        assert_eq!(event.coordination_id, "coord-123");
        assert_eq!(event.work_ids.len(), 2);
        assert_eq!(event.max_attempts_per_work, 3);
        assert_eq!(event.started_at, 1_000_000_000);
    }

    #[test]
    fn test_coordination_started_serde_roundtrip() {
        let budget = CoordinationBudget::new(10, 60_000, Some(100_000));
        let event = CoordinationStarted::new(
            "coord-123".to_string(),
            vec!["work-1".to_string()],
            budget,
            3,
            1_000_000_000,
        );

        let json = serde_json::to_string(&event).unwrap();
        let restored: CoordinationStarted = serde_json::from_str(&json).unwrap();
        assert_eq!(event, restored);
    }

    // ========================================================================
    // CoordinationSessionBound Tests
    // ========================================================================

    #[test]
    fn test_coordination_session_bound_new() {
        let event = CoordinationSessionBound::new(
            "coord-123".to_string(),
            "session-456".to_string(),
            "work-789".to_string(),
            1,
            100,
            2_000_000_000,
        );

        assert_eq!(event.coordination_id, "coord-123");
        assert_eq!(event.session_id, "session-456");
        assert_eq!(event.work_id, "work-789");
        assert_eq!(event.attempt_number, 1);
        assert_eq!(event.freshness_seq_id, 100);
        assert_eq!(event.bound_at, 2_000_000_000);
    }

    #[test]
    fn test_coordination_session_bound_serde_roundtrip() {
        let event = CoordinationSessionBound::new(
            "coord-123".to_string(),
            "session-456".to_string(),
            "work-789".to_string(),
            2,
            150,
            2_000_000_000,
        );

        let json = serde_json::to_string(&event).unwrap();
        let restored: CoordinationSessionBound = serde_json::from_str(&json).unwrap();
        assert_eq!(event, restored);
    }

    // ========================================================================
    // CoordinationSessionUnbound Tests
    // ========================================================================

    #[test]
    fn test_coordination_session_unbound_new() {
        let event = CoordinationSessionUnbound::new(
            "coord-123".to_string(),
            "session-456".to_string(),
            "work-789".to_string(),
            SessionOutcome::Success,
            5000,
            3_000_000_000,
        );

        assert_eq!(event.coordination_id, "coord-123");
        assert_eq!(event.session_id, "session-456");
        assert_eq!(event.work_id, "work-789");
        assert_eq!(event.outcome, SessionOutcome::Success);
        assert_eq!(event.tokens_consumed, 5000);
        assert_eq!(event.unbound_at, 3_000_000_000);
    }

    #[test]
    fn test_coordination_session_unbound_serde_roundtrip() {
        let event = CoordinationSessionUnbound::new(
            "coord-123".to_string(),
            "session-456".to_string(),
            "work-789".to_string(),
            SessionOutcome::Failure,
            1000,
            3_000_000_000,
        );

        let json = serde_json::to_string(&event).unwrap();
        let restored: CoordinationSessionUnbound = serde_json::from_str(&json).unwrap();
        assert_eq!(event, restored);
    }

    // ========================================================================
    // CoordinationCompleted Tests
    // ========================================================================

    #[test]
    fn test_coordination_completed_new() {
        let budget_usage = BudgetUsage {
            consumed_episodes: 5,
            elapsed_ms: 30_000,
            consumed_tokens: 50_000,
        };
        let event = CoordinationCompleted::new(
            "coord-123".to_string(),
            StopCondition::WorkCompleted,
            budget_usage,
            5,
            4,
            1,
            vec![1, 2, 3, 4],
            4_000_000_000,
        );

        assert_eq!(event.coordination_id, "coord-123");
        assert_eq!(event.stop_condition, StopCondition::WorkCompleted);
        assert_eq!(event.total_sessions, 5);
        assert_eq!(event.successful_sessions, 4);
        assert_eq!(event.failed_sessions, 1);
        assert_eq!(event.receipt_hash, vec![1, 2, 3, 4]);
        assert_eq!(event.completed_at, 4_000_000_000);
    }

    #[test]
    fn test_coordination_completed_serde_roundtrip() {
        let budget_usage = BudgetUsage {
            consumed_episodes: 5,
            elapsed_ms: 30_000,
            consumed_tokens: 50_000,
        };
        let event = CoordinationCompleted::new(
            "coord-123".to_string(),
            StopCondition::CircuitBreakerTriggered {
                consecutive_failures: 3,
            },
            budget_usage,
            3,
            0,
            3,
            vec![0xde, 0xad, 0xbe, 0xef],
            4_000_000_000,
        );

        let json = serde_json::to_string(&event).unwrap();
        let restored: CoordinationCompleted = serde_json::from_str(&json).unwrap();
        assert_eq!(event, restored);
    }

    // ========================================================================
    // CoordinationAborted Tests
    // ========================================================================

    #[test]
    fn test_coordination_aborted_new() {
        let budget_usage = BudgetUsage::new();
        let event = CoordinationAborted::new(
            "coord-123".to_string(),
            AbortReason::NoEligibleWork,
            budget_usage,
            1_000_000_000,
        );

        assert_eq!(event.coordination_id, "coord-123");
        assert_eq!(event.reason, AbortReason::NoEligibleWork);
        assert_eq!(event.aborted_at, 1_000_000_000);
    }

    #[test]
    fn test_coordination_aborted_serde_roundtrip() {
        let budget_usage = BudgetUsage {
            consumed_episodes: 2,
            elapsed_ms: 10_000,
            consumed_tokens: 5000,
        };
        let event = CoordinationAborted::new(
            "coord-123".to_string(),
            AbortReason::Cancelled {
                reason: "user requested".to_string(),
            },
            budget_usage,
            2_000_000_000,
        );

        let json = serde_json::to_string(&event).unwrap();
        let restored: CoordinationAborted = serde_json::from_str(&json).unwrap();
        assert_eq!(event, restored);
    }

    // ========================================================================
    // CoordinationEvent Tests
    // ========================================================================

    #[test]
    fn test_coordination_event_type() {
        let started = CoordinationEvent::Started(CoordinationStarted::new(
            "c".to_string(),
            vec![],
            CoordinationBudget::new(10, 60_000, None),
            3,
            1000,
        ));
        assert_eq!(started.event_type(), EVENT_TYPE_STARTED);

        let bound = CoordinationEvent::SessionBound(CoordinationSessionBound::new(
            "c".to_string(),
            "s".to_string(),
            "w".to_string(),
            1,
            1,
            1000,
        ));
        assert_eq!(bound.event_type(), EVENT_TYPE_SESSION_BOUND);

        let unbound = CoordinationEvent::SessionUnbound(CoordinationSessionUnbound::new(
            "c".to_string(),
            "s".to_string(),
            "w".to_string(),
            SessionOutcome::Success,
            100,
            2000,
        ));
        assert_eq!(unbound.event_type(), EVENT_TYPE_SESSION_UNBOUND);

        let completed = CoordinationEvent::Completed(CoordinationCompleted::new(
            "c".to_string(),
            StopCondition::WorkCompleted,
            BudgetUsage::new(),
            1,
            1,
            0,
            vec![],
            3000,
        ));
        assert_eq!(completed.event_type(), EVENT_TYPE_COMPLETED);

        let aborted = CoordinationEvent::Aborted(CoordinationAborted::new(
            "c".to_string(),
            AbortReason::NoEligibleWork,
            BudgetUsage::new(),
            4000,
        ));
        assert_eq!(aborted.event_type(), EVENT_TYPE_ABORTED);
    }

    #[test]
    fn test_coordination_event_coordination_id() {
        let budget = CoordinationBudget::new(10, 60_000, None);
        let event = CoordinationEvent::Started(CoordinationStarted::new(
            "coord-test".to_string(),
            vec![],
            budget,
            3,
            1000,
        ));
        assert_eq!(event.coordination_id(), "coord-test");
    }

    #[test]
    fn test_coordination_event_json_roundtrip() {
        let events = vec![
            CoordinationEvent::Started(CoordinationStarted::new(
                "c".to_string(),
                vec!["w1".to_string(), "w2".to_string()],
                CoordinationBudget::new(10, 60_000, Some(100_000)),
                3,
                1000,
            )),
            CoordinationEvent::SessionBound(CoordinationSessionBound::new(
                "c".to_string(),
                "s".to_string(),
                "w1".to_string(),
                1,
                10,
                2000,
            )),
            CoordinationEvent::SessionUnbound(CoordinationSessionUnbound::new(
                "c".to_string(),
                "s".to_string(),
                "w1".to_string(),
                SessionOutcome::Success,
                500,
                3000,
            )),
            CoordinationEvent::Completed(CoordinationCompleted::new(
                "c".to_string(),
                StopCondition::WorkCompleted,
                BudgetUsage {
                    consumed_episodes: 2,
                    elapsed_ms: 5000,
                    consumed_tokens: 1000,
                },
                2,
                2,
                0,
                vec![0xab, 0xcd],
                4000,
            )),
            CoordinationEvent::Aborted(CoordinationAborted::new(
                "c".to_string(),
                AbortReason::Error {
                    message: "test error".to_string(),
                },
                BudgetUsage::new(),
                5000,
            )),
        ];

        for event in events {
            let bytes = event.to_json_bytes().unwrap();
            let restored = CoordinationEvent::from_json_bytes(&bytes).unwrap();
            assert_eq!(event, restored);
        }
    }

    // ========================================================================
    // TCK-00148 Specific Tests (Serde Round-Trip)
    // ========================================================================

    /// TCK-00148: Verify all event types serialize and deserialize correctly.
    #[test]
    fn tck_00148_events_serde_roundtrip() {
        // CoordinationStarted
        let started = CoordinationStarted::new(
            "coord-1".to_string(),
            vec!["work-1".to_string()],
            CoordinationBudget::new(10, 60_000, Some(100_000)),
            3,
            1000,
        );
        let json = serde_json::to_string(&started).unwrap();
        assert_eq!(started, serde_json::from_str(&json).unwrap());

        // CoordinationSessionBound
        let bound = CoordinationSessionBound::new(
            "coord-1".to_string(),
            "sess-1".to_string(),
            "work-1".to_string(),
            1,
            50,
            2000,
        );
        let json = serde_json::to_string(&bound).unwrap();
        assert_eq!(bound, serde_json::from_str(&json).unwrap());

        // CoordinationSessionUnbound (both outcomes)
        for outcome in [SessionOutcome::Success, SessionOutcome::Failure] {
            let unbound = CoordinationSessionUnbound::new(
                "coord-1".to_string(),
                "sess-1".to_string(),
                "work-1".to_string(),
                outcome,
                500,
                3000,
            );
            let json = serde_json::to_string(&unbound).unwrap();
            assert_eq!(unbound, serde_json::from_str(&json).unwrap());
        }

        // CoordinationCompleted (various stop conditions)
        for stop in [
            StopCondition::WorkCompleted,
            StopCondition::BudgetExhausted(BudgetType::Duration),
            StopCondition::CircuitBreakerTriggered {
                consecutive_failures: 3,
            },
        ] {
            let completed = CoordinationCompleted::new(
                "coord-1".to_string(),
                stop,
                BudgetUsage {
                    consumed_episodes: 5,
                    elapsed_ms: 30_000,
                    consumed_tokens: 50_000,
                },
                5,
                4,
                1,
                vec![1, 2, 3],
                4000,
            );
            let json = serde_json::to_string(&completed).unwrap();
            assert_eq!(completed, serde_json::from_str(&json).unwrap());
        }

        // CoordinationAborted (various reasons)
        for reason in [
            AbortReason::NoEligibleWork,
            AbortReason::Cancelled {
                reason: "test".to_string(),
            },
            AbortReason::Error {
                message: "err".to_string(),
            },
        ] {
            let aborted =
                CoordinationAborted::new("coord-1".to_string(), reason, BudgetUsage::new(), 5000);
            let json = serde_json::to_string(&aborted).unwrap();
            assert_eq!(aborted, serde_json::from_str(&json).unwrap());
        }

        // CoordinationEvent (tagged union)
        let event = CoordinationEvent::Started(started);
        let json = serde_json::to_string(&event).unwrap();
        assert_eq!(event, serde_json::from_str(&json).unwrap());
    }
}
