// This file is @generated by prost-build.
/// Content hash reference to a TimeEnvelopeV1 artifact in CAS.
/// Used by critical events to bind HTF time authority without embedding
/// the full envelope in hot-path messages.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TimeEnvelopeRef {
    /// Content hash (SHA-256) of the TimeEnvelopeV1 artifact (32 bytes).
    /// The referenced envelope can be retrieved from CAS for verification.
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
}
/// Common envelope for all kernel events
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelEvent {
    /// Monotonic sequence number within this ledger
    #[prost(uint64, tag = "1")]
    pub sequence: u64,
    /// Hash of the previous event.
    /// For genesis events: use 32 zero bytes (canonical representation).
    /// Note: The ledger may store NULL for genesis as a storage optimization,
    /// but it must be normalized to 32 zero bytes at API boundaries.
    #[prost(bytes = "vec", tag = "2")]
    pub previous_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when event was created
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Actor ID that produced this event
    #[prost(string, tag = "4")]
    pub actor_id: ::prost::alloc::string::String,
    /// Session ID (if applicable)
    #[prost(string, tag = "5")]
    pub session_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes of this message
    #[prost(bytes = "vec", tag = "6")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// Schema version for forward/backward compatibility
    /// Current version: 1
    #[prost(uint32, tag = "7")]
    pub schema_version: u32,
    /// Event payload (oneof)
    #[prost(
        oneof = "kernel_event::Payload",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34"
    )]
    pub payload: ::core::option::Option<kernel_event::Payload>,
}
/// Nested message and enum types in `KernelEvent`.
pub mod kernel_event {
    /// Event payload (oneof)
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Session(super::SessionEvent),
        #[prost(message, tag = "11")]
        Work(super::WorkEvent),
        #[prost(message, tag = "12")]
        Tool(super::ToolEvent),
        #[prost(message, tag = "13")]
        Lease(super::LeaseEvent),
        #[prost(message, tag = "14")]
        Policy(super::PolicyEvent),
        #[prost(message, tag = "15")]
        Adjudication(super::AdjudicationEvent),
        #[prost(message, tag = "16")]
        Evidence(super::EvidenceEvent),
        #[prost(message, tag = "17")]
        Key(super::KeyEvent),
        #[prost(message, tag = "18")]
        Capability(super::CapabilityEvent),
        #[prost(message, tag = "19")]
        GithubLease(super::GitHubLeaseEvent),
        #[prost(message, tag = "20")]
        PolicyResolvedForChangeset(super::PolicyResolvedForChangeSet),
        #[prost(message, tag = "21")]
        GateReceipt(super::GateReceipt),
        #[prost(message, tag = "22")]
        InterventionFreeze(super::InterventionFreeze),
        #[prost(message, tag = "23")]
        InterventionUnfreeze(super::InterventionUnfreeze),
        #[prost(message, tag = "24")]
        AatResultReused(super::AatResultReused),
        #[prost(message, tag = "25")]
        MergeReceipt(super::MergeReceipt),
        #[prost(message, tag = "26")]
        RunnerPoolQuarantined(super::RunnerPoolQuarantined),
        #[prost(message, tag = "27")]
        AatSpecQuarantined(super::AatSpecQuarantined),
        #[prost(message, tag = "28")]
        QuarantineCleared(super::QuarantineCleared),
        #[prost(message, tag = "29")]
        ChangesetPublished(super::ChangeSetPublished),
        #[prost(message, tag = "30")]
        IoArtifactPublished(super::IoArtifactPublished),
        #[prost(message, tag = "31")]
        DefectRecorded(super::DefectRecorded),
        #[prost(message, tag = "32")]
        ReviewBlockedRecorded(super::ReviewBlockedRecorded),
        #[prost(message, tag = "33")]
        ReviewReceiptRecorded(super::ReviewReceiptRecorded),
        #[prost(message, tag = "34")]
        ProjectionReceiptRecorded(super::ProjectionReceiptRecorded),
    }
}
/// ============================================================
/// SESSION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionEvent {
    #[prost(oneof = "session_event::Event", tags = "1, 2, 3, 4, 5, 6")]
    pub event: ::core::option::Option<session_event::Event>,
}
/// Nested message and enum types in `SessionEvent`.
pub mod session_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Started(super::SessionStarted),
        #[prost(message, tag = "2")]
        Progress(super::SessionProgress),
        #[prost(message, tag = "3")]
        Terminated(super::SessionTerminated),
        #[prost(message, tag = "4")]
        Quarantined(super::SessionQuarantined),
        #[prost(message, tag = "5")]
        CrashDetected(super::SessionCrashDetected),
        #[prost(message, tag = "6")]
        RestartScheduled(super::SessionRestartScheduled),
    }
}
/// Emitted when a session process exits unexpectedly or crashes.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionCrashDetected {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// CLEAN_EXIT, ERROR_EXIT, SIGNAL, TIMEOUT, ENTROPY_EXCEEDED
    #[prost(string, tag = "2")]
    pub crash_type: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub exit_code: i32,
    #[prost(int32, tag = "4")]
    pub signal: i32,
    #[prost(uint64, tag = "5")]
    pub uptime_ms: u64,
    #[prost(uint64, tag = "6")]
    pub last_cursor: u64,
    #[prost(uint32, tag = "7")]
    pub restart_count: u32,
}
/// Emitted when a restart has been scheduled for a crashed session.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionRestartScheduled {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub scheduled_at: u64,
    #[prost(uint64, tag = "3")]
    pub restart_at: u64,
    #[prost(uint64, tag = "4")]
    pub resume_cursor: u64,
    #[prost(uint32, tag = "5")]
    pub attempt_number: u32,
    /// FIXED, EXPONENTIAL, LINEAR
    #[prost(string, tag = "6")]
    pub backoff_type: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionStarted {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub adapter_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub entropy_budget: u64,
    /// For restarted sessions: cursor to resume from
    #[prost(uint64, tag = "7")]
    pub resume_cursor: u64,
    /// For restarted sessions: restart attempt number (0 = first start)
    #[prost(uint32, tag = "8")]
    pub restart_attempt: u32,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds this event to verifiable HTF time.
    #[prost(message, optional, tag = "9")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
    /// Empty string for non-episode sessions; populated from episode context.
    /// Enables episode.<episode_id>.lifecycle topic routing.
    #[prost(string, tag = "10")]
    pub episode_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionProgress {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub progress_sequence: u64,
    /// HEARTBEAT, TOOL_COMPLETE, MILESTONE
    #[prost(string, tag = "3")]
    pub progress_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub entropy_consumed: u64,
    /// Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
    /// Empty string for non-episode sessions; populated from episode context.
    /// Enables episode.<episode_id>.lifecycle topic routing.
    #[prost(string, tag = "5")]
    pub episode_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionTerminated {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT, ENTROPY_EXCEEDED
    #[prost(string, tag = "2")]
    pub exit_classification: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub final_entropy: u64,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds this event to verifiable HTF time.
    #[prost(message, optional, tag = "5")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
    /// Empty string for non-episode sessions; populated from episode context.
    /// Enables episode.<episode_id>.lifecycle topic routing.
    #[prost(string, tag = "6")]
    pub episode_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionQuarantined {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Retained for backwards compatibility and display purposes.
    #[prost(uint64, tag = "3")]
    pub quarantine_until: u64,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the quarantine event to verifiable HTF time.
    #[prost(message, optional, tag = "4")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Monotonic tick when the quarantine was issued (RFC-0016 HTF).
    /// Authoritative for timing decisions; immune to wall-clock manipulation.
    #[prost(uint64, tag = "5")]
    pub issued_at_tick: u64,
    /// Monotonic tick when the quarantine expires (RFC-0016 HTF).
    /// Authoritative for expiry checks; immune to wall-clock manipulation.
    #[prost(uint64, tag = "6")]
    pub expires_at_tick: u64,
    /// Tick rate in Hz for issued_at_tick and expires_at_tick.
    /// Required for interpreting tick values as durations.
    #[prost(uint64, tag = "7")]
    pub tick_rate_hz: u64,
    /// Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
    /// Empty string for non-episode sessions; populated from episode context.
    /// Enables episode.<episode_id>.lifecycle topic routing.
    #[prost(string, tag = "8")]
    pub episode_id: ::prost::alloc::string::String,
}
/// ============================================================
/// WORK EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkEvent {
    #[prost(oneof = "work_event::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<work_event::Event>,
}
/// Nested message and enum types in `WorkEvent`.
pub mod work_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Opened(super::WorkOpened),
        #[prost(message, tag = "2")]
        Transitioned(super::WorkTransitioned),
        #[prost(message, tag = "3")]
        Completed(super::WorkCompleted),
        #[prost(message, tag = "4")]
        Aborted(super::WorkAborted),
        #[prost(message, tag = "5")]
        PrAssociated(super::WorkPrAssociated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkOpened {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// TICKET, PRD_REFINEMENT, RFC_REFINEMENT, REVIEW
    #[prost(string, tag = "2")]
    pub work_type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub spec_snapshot_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "4")]
    pub requirement_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub parent_work_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkTransitioned {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub from_state: ::prost::alloc::string::String,
    /// Valid states: OPEN, CLAIMED, IN_PROGRESS, CI_PENDING, READY_FOR_REVIEW,
    /// BLOCKED, REVIEW, NEEDS_INPUT, NEEDS_ADJUDICATION
    #[prost(string, tag = "3")]
    pub to_state: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rationale_code: ::prost::alloc::string::String,
    /// Previous transition count for replay protection.
    /// MUST match work.transition_count before this transition.
    /// This field is strictly validated to prevent replay attacks.
    /// For the first transition (Open -> Claimed), use 0.
    #[prost(uint32, tag = "5")]
    pub previous_transition_count: u32,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkCompleted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub evidence_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "3")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub gate_receipt_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkAborted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// POLICY_DENY, TIMEOUT, ENTROPY_EXCEEDED, MANUAL
    #[prost(string, tag = "2")]
    pub abort_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
}
/// Emitted when a PR is created and associated with a work item.
/// This enables CI event matching for phase transitions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkPrAssociated {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub pr_number: u64,
    /// The commit SHA that triggered the CI workflow
    #[prost(string, tag = "3")]
    pub commit_sha: ::prost::alloc::string::String,
}
/// ============================================================
/// TOOL EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolEvent {
    #[prost(oneof = "tool_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<tool_event::Event>,
}
/// Nested message and enum types in `ToolEvent`.
pub mod tool_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::ToolRequested),
        #[prost(message, tag = "2")]
        Decided(super::ToolDecided),
        #[prost(message, tag = "3")]
        Executed(super::ToolExecuted),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolRequested {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tool_name: ::prost::alloc::string::String,
    /// Hash of arguments (full args stored in CAS)
    #[prost(bytes = "vec", tag = "4")]
    pub tool_args_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub dedupe_key: ::prost::alloc::string::String,
    /// Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
    /// Empty string for non-episode sessions; populated from episode context.
    /// Enables episode.<episode_id>.tool topic routing.
    #[prost(string, tag = "6")]
    pub episode_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolDecided {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// ALLOW, DENY
    #[prost(string, tag = "2")]
    pub decision: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub budget_consumed: u64,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the decision receipt to verifiable HTF time.
    #[prost(message, optional, tag = "7")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
    /// Empty string for non-episode sessions; populated from episode context.
    /// Enables episode.<episode_id>.tool topic routing.
    #[prost(string, tag = "8")]
    pub episode_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolExecuted {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT
    #[prost(string, tag = "2")]
    pub outcome: ::prost::alloc::string::String,
    /// Hash of result (full result stored in CAS)
    #[prost(bytes = "vec", tag = "3")]
    pub result_hash: ::prost::alloc::vec::Vec<u8>,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Duration is recorded for observational purposes only; authoritative
    /// timing uses HTF tick deltas from the time_envelope_ref.
    #[prost(uint64, tag = "4")]
    pub duration_ms: u64,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the execution receipt to verifiable HTF time.
    #[prost(message, optional, tag = "5")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
    /// Empty string for non-episode sessions; populated from episode context.
    /// Enables episode.<episode_id>.tool topic routing.
    #[prost(string, tag = "6")]
    pub episode_id: ::prost::alloc::string::String,
}
/// ============================================================
/// LEASE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseEvent {
    #[prost(oneof = "lease_event::Event", tags = "1, 2, 3, 4, 5, 6")]
    pub event: ::core::option::Option<lease_event::Event>,
}
/// Nested message and enum types in `LeaseEvent`.
pub mod lease_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Issued(super::LeaseIssued),
        #[prost(message, tag = "2")]
        Renewed(super::LeaseRenewed),
        #[prost(message, tag = "3")]
        Released(super::LeaseReleased),
        #[prost(message, tag = "4")]
        Expired(super::LeaseExpired),
        #[prost(message, tag = "5")]
        Conflict(super::LeaseConflict),
        #[prost(message, tag = "6")]
        IssueDenied(super::LeaseIssueDenied),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseIssued {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub actor_id: ::prost::alloc::string::String,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Retained for display/audit purposes; authoritative timing uses
    /// tick-based expiry from the time_envelope_ref.
    #[prost(uint64, tag = "4")]
    pub issued_at: u64,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Retained for display/audit purposes; authoritative expiry uses
    /// tick-based checks from the time_envelope_ref.
    #[prost(uint64, tag = "5")]
    pub expires_at: u64,
    #[prost(bytes = "vec", tag = "6")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the lease issuance to verifiable HTF time.
    #[prost(message, optional, tag = "7")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Monotonic tick when the lease was issued (RFC-0016 HTF).
    /// Authoritative for timing decisions; immune to wall-clock manipulation.
    #[prost(uint64, tag = "8")]
    pub issued_at_tick: u64,
    /// Monotonic tick when the lease expires (RFC-0016 HTF).
    /// Authoritative for expiry checks; immune to wall-clock manipulation.
    #[prost(uint64, tag = "9")]
    pub expires_at_tick: u64,
    /// Tick rate in Hz for issued_at_tick and expires_at_tick.
    /// Required for interpreting tick values as durations.
    #[prost(uint64, tag = "10")]
    pub tick_rate_hz: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseRenewed {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub new_expires_at: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the lease renewal to verifiable HTF time.
    #[prost(message, optional, tag = "4")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Monotonic tick when the renewed lease expires (RFC-0016 HTF).
    /// Authoritative for expiry checks; immune to wall-clock manipulation.
    #[prost(uint64, tag = "5")]
    pub new_expires_at_tick: u64,
    /// Tick rate in Hz for new_expires_at_tick.
    /// Required for interpreting tick values as durations.
    #[prost(uint64, tag = "6")]
    pub tick_rate_hz: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseReleased {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// COMPLETED, ABORTED, VOLUNTARY
    #[prost(string, tag = "2")]
    pub release_reason: ::prost::alloc::string::String,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the lease release to verifiable HTF time.
    #[prost(message, optional, tag = "3")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseExpired {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub expired_at: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseConflict {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub conflicting_lease_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// CANONICAL_ROOT, ADJUDICATION_REQUIRED
    #[prost(string, tag = "3")]
    pub resolution: ::prost::alloc::string::String,
}
/// Emitted when a lease issuance is denied for security policy reasons.
///
/// Per TCK-00258, this event is emitted when a SpawnEpisode request is
/// rejected due to policy violations such as custody domain overlap (SoD).
/// This provides an audit trail for denied lease requests.
///
/// Security: All denial events are logged for non-repudiation and
/// security audit purposes.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseIssueDenied {
    /// Work ID that was denied a lease.
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// Reason for denial: SOD_VIOLATION, POLICY_VIOLATION, EXPIRED_CLAIM
    #[prost(string, tag = "2")]
    pub denial_reason: ::prost::alloc::string::String,
    /// Human-readable details about the denial.
    #[prost(string, tag = "3")]
    pub denial_details: ::prost::alloc::string::String,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Retained for display/audit purposes; authoritative timing uses
    /// HTF time from the time_envelope_ref.
    #[prost(uint64, tag = "4")]
    pub denied_at: u64,
    /// Executor's custody domain that caused the SoD violation (if applicable).
    #[prost(string, tag = "5")]
    pub executor_domain: ::prost::alloc::string::String,
    /// Author's custody domain that caused the SoD violation (if applicable).
    #[prost(string, tag = "6")]
    pub author_domain: ::prost::alloc::string::String,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the denial event to verifiable HTF time.
    #[prost(message, optional, tag = "7")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
/// ============================================================
/// POLICY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyEvent {
    #[prost(oneof = "policy_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<policy_event::Event>,
}
/// Nested message and enum types in `PolicyEvent`.
pub mod policy_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Loaded(super::PolicyLoaded),
        #[prost(message, tag = "2")]
        Violation(super::PolicyViolation),
        #[prost(message, tag = "3")]
        BudgetExceeded(super::BudgetExceeded),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyLoaded {
    #[prost(bytes = "vec", tag = "1")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub policy_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub rule_count: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyViolation {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub violation_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub details: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BudgetExceeded {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// TOKEN, TIME, TOOL_CALLS
    #[prost(string, tag = "2")]
    pub budget_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    #[prost(uint64, tag = "4")]
    pub consumed: u64,
}
/// ============================================================
/// ADJUDICATION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationEvent {
    #[prost(oneof = "adjudication_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<adjudication_event::Event>,
}
/// Nested message and enum types in `AdjudicationEvent`.
pub mod adjudication_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::AdjudicationRequested),
        #[prost(message, tag = "2")]
        Vote(super::AdjudicationVote),
        #[prost(message, tag = "3")]
        Resolved(super::AdjudicationResolved),
        #[prost(message, tag = "4")]
        Timeout(super::AdjudicationTimeout),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationRequested {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// BOUNDED_CHOICE, WAIVER, GATE_REVIEW
    #[prost(string, tag = "3")]
    pub request_type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "5")]
    pub deadline: u64,
    #[prost(string, tag = "6")]
    pub fallback_policy: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationVote {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub voter_actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub voter_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationResolved {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub votes_for: u64,
    #[prost(uint64, tag = "4")]
    pub votes_against: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub quorum_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the adjudication decision to verifiable HTF time.
    #[prost(message, optional, tag = "6")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationTimeout {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub applied_fallback: ::prost::alloc::string::String,
}
/// ============================================================
/// EVIDENCE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidenceEvent {
    #[prost(oneof = "evidence_event::Event", tags = "1, 2")]
    pub event: ::core::option::Option<evidence_event::Event>,
}
/// Nested message and enum types in `EvidenceEvent`.
pub mod evidence_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Published(super::EvidencePublished),
        #[prost(message, tag = "2")]
        GateReceipt(super::GateReceiptGenerated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidencePublished {
    #[prost(string, tag = "1")]
    pub evidence_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub category: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub artifact_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "5")]
    pub verification_command_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Data classification: PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED
    #[prost(string, tag = "6")]
    pub classification: ::prost::alloc::string::String,
    /// Artifact size in bytes (for bundle size tracking)
    #[prost(uint64, tag = "7")]
    pub artifact_size: u64,
    /// Metadata key-value pairs as "key=value" strings
    #[prost(string, repeated, tag = "8")]
    pub metadata: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the evidence submission to verifiable HTF time.
    #[prost(message, optional, tag = "9")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateReceiptGenerated {
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gate_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub work_id: ::prost::alloc::string::String,
    /// PASS, FAIL
    #[prost(string, tag = "4")]
    pub result: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "6")]
    pub receipt_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityEvent {
    #[prost(oneof = "capability_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<capability_event::Event>,
}
/// Nested message and enum types in `CapabilityEvent`.
pub mod capability_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Required(super::CapabilityRequired),
        #[prost(message, tag = "2")]
        Granted(super::CapabilityGranted),
        #[prost(message, tag = "3")]
        Delegated(super::CapabilityDelegated),
        #[prost(message, tag = "4")]
        Revoked(super::CapabilityRevoked),
    }
}
/// Emitted during planning phase when a capability is required for a plan step.
/// This event enables capability negotiation and tracking.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityRequired {
    /// The capability ID that is required (e.g., "cac:patch:apply")
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// The work ID this requirement is associated with
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// Whether this capability is required (true) or optional (false)
    #[prost(bool, tag = "3")]
    pub required: bool,
    /// The status of the capability: AVAILABLE, UNAVAILABLE, DEGRADED
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
    /// Human-readable reason for the status
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
}
/// Emitted when a capability is granted to an actor by an authority.
/// This is the root of a delegation chain and must be signed by the registrar.
/// Links to the lease system: capability_id == lease_id.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityGranted {
    /// Unique identifier for this capability (equals lease_id for lease-backed capabilities)
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// Namespace this capability is bound to (prevents cross-namespace replay)
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor receiving the capability
    #[prost(string, tag = "3")]
    pub grantee_actor_id: ::prost::alloc::string::String,
    /// Actor granting the capability (must be an authority in the namespace)
    #[prost(string, tag = "4")]
    pub grantor_actor_id: ::prost::alloc::string::String,
    /// Hash of the serialized LeaseScope (stored in CAS)
    #[prost(bytes = "vec", tag = "5")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// Optional hash of the serialized Budget (stored in CAS)
    #[prost(bytes = "vec", tag = "6")]
    pub budget_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the capability was granted (Unix nanos)
    #[prost(uint64, tag = "7")]
    pub granted_at: u64,
    /// Timestamp when the capability expires (Unix nanos)
    #[prost(uint64, tag = "8")]
    pub expires_at: u64,
    /// Registrar signature over this grant (proves authority)
    #[prost(bytes = "vec", tag = "9")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
    /// Whether this capability can be delegated to others
    #[prost(bool, tag = "10")]
    pub delegatable: bool,
}
/// Emitted when a capability holder delegates their capability to another actor.
/// Forms part of the delegation chain for capability proofs.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityDelegated {
    /// New capability ID for the delegated capability
    #[prost(string, tag = "1")]
    pub delegated_capability_id: ::prost::alloc::string::String,
    /// Parent capability being delegated from
    #[prost(string, tag = "2")]
    pub parent_capability_id: ::prost::alloc::string::String,
    /// Hash of the parent CapabilityGranted or CapabilityDelegated event
    #[prost(bytes = "vec", tag = "3")]
    pub parent_capability_hash: ::prost::alloc::vec::Vec<u8>,
    /// Namespace this delegation is bound to (must match parent)
    #[prost(string, tag = "4")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor receiving the delegated capability
    #[prost(string, tag = "5")]
    pub delegatee_actor_id: ::prost::alloc::string::String,
    /// Actor delegating the capability (must hold parent capability)
    #[prost(string, tag = "6")]
    pub delegator_actor_id: ::prost::alloc::string::String,
    /// Hash of the serialized LeaseScope (must be subset of parent scope)
    #[prost(bytes = "vec", tag = "7")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// Optional hash of the serialized Budget (must be subset of parent budget)
    #[prost(bytes = "vec", tag = "8")]
    pub budget_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the delegation occurred (Unix nanos)
    #[prost(uint64, tag = "9")]
    pub delegated_at: u64,
    /// Timestamp when the delegated capability expires (Unix nanos, must be <= parent expires_at)
    #[prost(uint64, tag = "10")]
    pub expires_at: u64,
    /// Delegator's signature over this delegation (proves authority transfer)
    #[prost(bytes = "vec", tag = "11")]
    pub delegator_signature: ::prost::alloc::vec::Vec<u8>,
    /// Whether this delegated capability can be further delegated
    #[prost(bool, tag = "12")]
    pub delegatable: bool,
    /// Depth in the delegation chain (parent depth + 1)
    #[prost(uint32, tag = "13")]
    pub delegation_depth: u32,
}
/// Emitted when a capability is revoked before its natural expiration.
/// Revocation cascades to all delegated capabilities in the chain.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityRevoked {
    /// The capability being revoked
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// Namespace the capability belongs to
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor performing the revocation (must be grantor or authority)
    #[prost(string, tag = "3")]
    pub revoker_actor_id: ::prost::alloc::string::String,
    /// Reason for revocation: VOLUNTARY, POLICY_VIOLATION, KEY_COMPROMISE, SUPERSEDED
    #[prost(string, tag = "4")]
    pub revocation_reason: ::prost::alloc::string::String,
    /// Timestamp when the revocation occurred (Unix nanos)
    #[prost(uint64, tag = "5")]
    pub revoked_at: u64,
    /// Revoker's signature over this revocation
    #[prost(bytes = "vec", tag = "6")]
    pub revoker_signature: ::prost::alloc::vec::Vec<u8>,
    /// If true, revocation cascades to all delegated capabilities; if false, only this capability is revoked
    #[prost(bool, tag = "7")]
    pub cascade: bool,
}
/// ============================================================
/// KEY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyEvent {
    #[prost(oneof = "key_event::Event", tags = "1")]
    pub event: ::core::option::Option<key_event::Event>,
}
/// Nested message and enum types in `KeyEvent`.
pub mod key_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Rotated(super::KeyRotated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubLeaseEvent {
    #[prost(oneof = "git_hub_lease_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<git_hub_lease_event::Event>,
}
/// Nested message and enum types in `GitHubLeaseEvent`.
pub mod git_hub_lease_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Issued(super::GitHubLeaseIssued),
        #[prost(message, tag = "2")]
        Revoked(super::GitHubLeaseRevoked),
        #[prost(message, tag = "3")]
        OperationRecorded(super::GitHubOperationRecorded),
    }
}
/// Emitted when a GitHub installation access token is minted for an agent.
/// Links to the episode via episode_id and inherits risk tier constraints.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubLeaseIssued {
    /// Unique identifier for this GitHub lease
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// Episode this lease is bound to
    #[prost(string, tag = "2")]
    pub episode_id: ::prost::alloc::string::String,
    /// GitHub App ID (determines permission tier)
    #[prost(string, tag = "3")]
    pub github_app_id: ::prost::alloc::string::String,
    /// GitHub installation ID for the target repository/organization
    #[prost(string, tag = "4")]
    pub installation_id: ::prost::alloc::string::String,
    /// Risk tier of the requesting agent (0-4)
    /// Tier determines which GitHub App can be used:
    /// - T0: reader only
    /// - T1-T2: reader or developer
    /// - T3-T4: reader, developer, or operator
    #[prost(uint32, tag = "5")]
    pub risk_tier: u32,
    /// Hash of the requested GitHub scopes (scope list stored in CAS)
    #[prost(bytes = "vec", tag = "6")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// SHA-256 hash of the installation access token (NEVER store raw token)
    #[prost(bytes = "vec", tag = "7")]
    pub token_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the lease was issued (Unix nanos)
    #[prost(uint64, tag = "8")]
    pub issued_at: u64,
    /// Timestamp when the lease expires (Unix nanos)
    /// TTL is proportional to risk tier:
    /// - T0: 1 hour
    /// - T1-T2: 15-30 minutes
    /// - T3-T4: 2-5 minutes
    #[prost(uint64, tag = "9")]
    pub expires_at: u64,
    /// Hash of the capability manifest that authorized this lease
    #[prost(bytes = "vec", tag = "10")]
    pub capability_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// Issuer (registrar) signature over this event
    #[prost(bytes = "vec", tag = "11")]
    pub issuer_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted when a GitHub lease is revoked before expiration.
/// Revocation may be voluntary or forced (policy violation, key compromise).
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubLeaseRevoked {
    /// The lease being revoked
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// Episode the lease was bound to
    #[prost(string, tag = "2")]
    pub episode_id: ::prost::alloc::string::String,
    /// Reason for revocation: VOLUNTARY, EXPIRED, POLICY_VIOLATION, KEY_COMPROMISE
    #[prost(string, tag = "3")]
    pub revocation_reason: ::prost::alloc::string::String,
    /// Timestamp when the revocation occurred (Unix nanos)
    #[prost(uint64, tag = "4")]
    pub revoked_at: u64,
    /// Actor performing the revocation
    #[prost(string, tag = "5")]
    pub revoker_actor_id: ::prost::alloc::string::String,
    /// Revoker signature over this event
    #[prost(bytes = "vec", tag = "6")]
    pub revoker_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted for each GitHub API operation made with a leased token.
/// Provides audit trail for all GitHub interactions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubOperationRecorded {
    /// Unique identifier for this operation record
    #[prost(string, tag = "1")]
    pub operation_id: ::prost::alloc::string::String,
    /// The lease that authorized this operation
    #[prost(string, tag = "2")]
    pub lease_id: ::prost::alloc::string::String,
    /// Episode context
    #[prost(string, tag = "3")]
    pub episode_id: ::prost::alloc::string::String,
    /// GitHub API endpoint called (e.g., "POST /repos/{owner}/{repo}/pulls")
    #[prost(string, tag = "4")]
    pub api_endpoint: ::prost::alloc::string::String,
    /// HTTP method: GET, POST, PUT, PATCH, DELETE
    #[prost(string, tag = "5")]
    pub http_method: ::prost::alloc::string::String,
    /// Target repository in owner/repo format
    #[prost(string, tag = "6")]
    pub repository: ::prost::alloc::string::String,
    /// Hash of the request body (request body stored in CAS if needed)
    #[prost(bytes = "vec", tag = "7")]
    pub request_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the response body (response body stored in CAS if needed)
    #[prost(bytes = "vec", tag = "8")]
    pub response_hash: ::prost::alloc::vec::Vec<u8>,
    /// HTTP status code returned
    #[prost(uint32, tag = "9")]
    pub status_code: u32,
    /// Timestamp when the operation was performed (Unix nanos)
    #[prost(uint64, tag = "10")]
    pub performed_at: u64,
    /// Duration of the API call in milliseconds
    #[prost(uint64, tag = "11")]
    pub duration_ms: u64,
    /// GitHub rate limit remaining after this call
    #[prost(uint32, tag = "12")]
    pub rate_limit_remaining: u32,
}
/// Event emitted when an actor rotates their signing key.
/// This establishes a chain of custody for key transitions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyRotated {
    /// Actor whose key is being rotated
    #[prost(string, tag = "1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Hash of the old verifying key (for reference)
    #[prost(bytes = "vec", tag = "2")]
    pub old_key_hash: ::prost::alloc::vec::Vec<u8>,
    /// New verifying (public) key bytes
    #[prost(bytes = "vec", tag = "3")]
    pub new_verifying_key: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the rotation occurred (Unix nanos)
    #[prost(uint64, tag = "4")]
    pub rotated_at: u64,
    /// Signature from the OLD key over this message (proves control of old key)
    #[prost(bytes = "vec", tag = "5")]
    pub old_key_signature: ::prost::alloc::vec::Vec<u8>,
}
/// The anchor event that locks policy decisions for a changeset.
/// All subsequent lease issuance and receipt validation must reference
/// this anchor's resolved_policy_hash.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyResolvedForChangeSet {
    /// Work item this policy resolution applies to
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// Hash binding to specific changeset (32 bytes)
    #[prost(bytes = "vec", tag = "2")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the resolved policy tuple (32 bytes)
    /// Computed from: risk_tier || determinism_class || sorted(rcp_profile_ids) ||
    ///                 sorted(rcp_manifest_hashes) || sorted(verifier_policy_hashes)
    #[prost(bytes = "vec", tag = "3")]
    pub resolved_policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// Resolved risk tier (0-4)
    #[prost(uint32, tag = "4")]
    pub resolved_risk_tier: u32,
    /// Resolved determinism class (0=non, 1=soft, 2=fully)
    #[prost(uint32, tag = "5")]
    pub resolved_determinism_class: u32,
    /// Resolved RCP profile IDs (sorted for canonical encoding)
    #[prost(string, repeated, tag = "6")]
    pub resolved_rcp_profile_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Hashes of resolved RCP manifests (sorted, each 32 bytes)
    #[prost(bytes = "vec", repeated, tag = "7")]
    pub resolved_rcp_manifest_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// Hashes of resolved verifier policies (sorted, each 32 bytes)
    #[prost(bytes = "vec", repeated, tag = "8")]
    pub resolved_verifier_policy_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// Actor who performed the policy resolution
    #[prost(string, tag = "9")]
    pub resolver_actor_id: ::prost::alloc::string::String,
    /// Version of the resolver component
    #[prost(string, tag = "10")]
    pub resolver_version: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with POLICY_RESOLVED_FOR_CHANGESET: domain (64 bytes)
    #[prost(bytes = "vec", tag = "11")]
    pub resolver_signature: ::prost::alloc::vec::Vec<u8>,
}
/// GateReceipt envelope with versioning support.
/// This is the canonical receipt envelope that wraps gate-specific payloads.
/// The receipt binds a gate execution result to a specific lease and changeset.
///
/// Versioning:
/// - receipt_version: Envelope schema version (currently: 1)
/// - payload_kind: Type of payload ("aat", "quality", "security")
/// - payload_schema_version: Version of the payload schema
///
/// Security:
/// - receipt_signature uses GATE_RECEIPT: domain prefix
/// - All fields except signature are included in canonical bytes
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateReceipt {
    /// Unique identifier for this receipt
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    /// Gate that generated this receipt
    #[prost(string, tag = "2")]
    pub gate_id: ::prost::alloc::string::String,
    /// Lease that authorized this gate execution
    #[prost(string, tag = "3")]
    pub lease_id: ::prost::alloc::string::String,
    /// Hash binding to specific changeset (32 bytes)
    #[prost(bytes = "vec", tag = "4")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Actor who executed the gate
    #[prost(string, tag = "5")]
    pub executor_actor_id: ::prost::alloc::string::String,
    /// Envelope schema version (supported: 1)
    #[prost(uint32, tag = "6")]
    pub receipt_version: u32,
    /// Type of payload: "aat", "quality", "security"
    #[prost(string, tag = "7")]
    pub payload_kind: ::prost::alloc::string::String,
    /// Version of the payload schema
    #[prost(uint32, tag = "8")]
    pub payload_schema_version: u32,
    /// Hash of the payload content (32 bytes)
    #[prost(bytes = "vec", tag = "9")]
    pub payload_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the evidence bundle (32 bytes)
    #[prost(bytes = "vec", tag = "10")]
    pub evidence_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    /// Ed25519 signature over canonical bytes with GATE_RECEIPT: domain (64 bytes)
    #[prost(bytes = "vec", tag = "11")]
    pub receipt_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the gate receipt to verifiable HTF time.
    #[prost(message, optional, tag = "12")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Explicit pass/fail verdict declared by the gate executor.
    /// This is the authoritative verdict field - not derived from hash inspection.
    /// MUST be set by the executor; ambiguous payloads without an explicit verdict
    /// are rejected at the admission boundary (TCK-00388 Quality BLOCKER 2).
    #[prost(bool, tag = "13")]
    pub passed: bool,
}
/// Output from a terminal verifier.
/// Terminal verifiers provide ground truth (exit codes, snapshot diffs, etc.).
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalVerifierOutput {
    /// Kind of verifier: exit_code, snapshot_diff, structured_test_report, invariant_check
    #[prost(string, tag = "1")]
    pub verifier_kind: ::prost::alloc::string::String,
    /// Digest of the verifier output content (32 bytes).
    #[prost(bytes = "vec", tag = "2")]
    pub output_digest: ::prost::alloc::vec::Vec<u8>,
    /// Whether the machine predicate was satisfied.
    #[prost(bool, tag = "3")]
    pub predicate_satisfied: bool,
}
/// Attestation metadata for AAT execution environment.
/// Provides evidence chain for runtime environment verification.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatAttestation {
    /// Digest of the container image used (32 bytes).
    #[prost(bytes = "vec", tag = "1")]
    pub container_image_digest: ::prost::alloc::vec::Vec<u8>,
    /// Digests of toolchain components (each 32 bytes).
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub toolchain_digests: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Identity key ID of the runner.
    #[prost(string, tag = "3")]
    pub runner_identity_key_id: ::prost::alloc::string::String,
    /// Hash of the network policy profile (32 bytes).
    #[prost(bytes = "vec", tag = "4")]
    pub network_policy_profile_hash: ::prost::alloc::vec::Vec<u8>,
}
/// Typed payload for AAT gate receipts (22 required fields).
/// Stored in CAS and referenced by payload_hash from GateReceipt envelope.
///
/// Invariants:
/// - view_commitment_hash matches FAC-00 output
/// - rcp_manifest_hash matches FAC-02 output for profile
/// - run_receipt_hashes.len() == run_count
/// - transcript_chain_root_hash derivable from transcript_bundle_hash
/// - artifact_manifest_hash references CAS ArtifactManifest
/// - At least one terminal_verifier_output present for PASS
/// - predicate_satisfied == true for all verifier outputs when verdict == PASS
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatGateReceipt {
    /// ============== View commitment binding (fields 1-4) ==============
    /// Hash binding to view commitment from FAC-00 (32 bytes).
    #[prost(bytes = "vec", tag = "1")]
    pub view_commitment_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the RCP manifest for this profile (32 bytes).
    #[prost(bytes = "vec", tag = "2")]
    pub rcp_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// RCP profile identifier.
    #[prost(string, tag = "3")]
    pub rcp_profile_id: ::prost::alloc::string::String,
    /// Policy hash for anti-downgrade verification (32 bytes).
    #[prost(bytes = "vec", tag = "4")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// ============== Determinism tracking (fields 5-13) ==============
    /// Determinism class (0=non, 1=soft, 2=fully).
    #[prost(uint32, tag = "5")]
    pub determinism_class: u32,
    /// Whether terminal evidence was stable across runs.
    #[prost(enumeration = "DeterminismStatus", tag = "6")]
    pub determinism_status: i32,
    /// Classification of flakiness when mismatch occurs.
    #[prost(enumeration = "FlakeClass", tag = "7")]
    pub flake_class: i32,
    /// Number of AAT runs executed.
    #[prost(uint32, tag = "8")]
    pub run_count: u32,
    /// Hashes of individual run receipts (each 32 bytes, len == run_count).
    #[prost(bytes = "vec", repeated, tag = "9")]
    pub run_receipt_hashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Digest of machine-checkable terminal evidence (32 bytes).
    #[prost(bytes = "vec", tag = "10")]
    pub terminal_evidence_digest: ::prost::alloc::vec::Vec<u8>,
    /// Digest of observational evidence (logs, traces) - excluded from determinism (32 bytes).
    #[prost(bytes = "vec", tag = "11")]
    pub observational_evidence_digest: ::prost::alloc::vec::Vec<u8>,
    /// Digest of terminal verifier outputs (32 bytes).
    #[prost(bytes = "vec", tag = "12")]
    pub terminal_verifier_outputs_digest: ::prost::alloc::vec::Vec<u8>,
    /// Stability digest = hash(verdict, terminal_evidence_digest, terminal_verifier_outputs_digest) (32 bytes).
    #[prost(bytes = "vec", tag = "13")]
    pub stability_digest: ::prost::alloc::vec::Vec<u8>,
    /// ============== Verdict (field 14) ==============
    /// AAT outcome verdict.
    #[prost(enumeration = "AatVerdict", tag = "14")]
    pub verdict: i32,
    /// ============== Evidence binding (fields 15-19) ==============
    /// Root hash of the transcript chain (32 bytes).
    #[prost(bytes = "vec", tag = "15")]
    pub transcript_chain_root_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the transcript bundle in CAS (32 bytes).
    #[prost(bytes = "vec", tag = "16")]
    pub transcript_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the artifact manifest in CAS (32 bytes).
    #[prost(bytes = "vec", tag = "17")]
    pub artifact_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// Terminal verifier outputs with predicate satisfaction.
    #[prost(message, repeated, tag = "18")]
    pub terminal_verifier_outputs: ::prost::alloc::vec::Vec<TerminalVerifierOutput>,
    /// Hash of the verifier policy (32 bytes).
    #[prost(bytes = "vec", tag = "19")]
    pub verifier_policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// ============== Risk tier (fields 20-21) ==============
    /// Selection policy identifier.
    #[prost(string, tag = "20")]
    pub selection_policy_id: ::prost::alloc::string::String,
    /// Risk tier for AAT selection (0-4: Tier0-Tier4).
    /// Stored as uint32 for fidelity preservation across proto roundtrips.
    #[prost(uint32, tag = "21")]
    pub risk_tier: u32,
    /// ============== Attestation (field 22) ==============
    /// Execution environment attestation.
    #[prost(message, optional, tag = "22")]
    pub attestation: ::core::option::Option<AatAttestation>,
}
/// Emitted when divergence is detected between the ledger's MergeReceipt
/// and the external trunk HEAD. This freezes the specified scope to
/// prevent further admissions until adjudication.
///
/// Security: Divergence detection is critical for maintaining ledger integrity.
/// Any external modification of the trunk triggers immediate freeze.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterventionFreeze {
    /// Unique identifier for this freeze event.
    #[prost(string, tag = "1")]
    pub freeze_id: ::prost::alloc::string::String,
    /// Scope of the freeze (repository, work, namespace).
    #[prost(enumeration = "InterventionScope", tag = "2")]
    pub scope: i32,
    /// Value identifying the frozen scope (repo path, work_id, namespace).
    #[prost(string, tag = "3")]
    pub scope_value: ::prost::alloc::string::String,
    /// ID of the DefectRecord that triggered this freeze.
    #[prost(string, tag = "4")]
    pub trigger_defect_id: ::prost::alloc::string::String,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Retained for display/audit purposes; authoritative timing uses
    /// HTF time from the time_envelope_ref.
    #[prost(uint64, tag = "5")]
    pub frozen_at: u64,
    /// Expected trunk HEAD from the latest MergeReceipt.
    #[prost(bytes = "vec", tag = "6")]
    pub expected_trunk_head: ::prost::alloc::vec::Vec<u8>,
    /// Actual trunk HEAD observed externally.
    #[prost(bytes = "vec", tag = "7")]
    pub actual_trunk_head: ::prost::alloc::vec::Vec<u8>,
    /// Actor who detected the divergence and issued the freeze.
    #[prost(string, tag = "8")]
    pub gate_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with INTERVENTION_FREEZE: domain (64 bytes).
    #[prost(bytes = "vec", tag = "9")]
    pub gate_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the freeze event to verifiable HTF time.
    #[prost(message, optional, tag = "10")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
/// Emitted when a frozen scope is unfrozen after adjudication.
/// The unfreeze must reference a valid adjudication decision.
///
/// Security: Unfreeze cannot bypass adjudication. All unfreezes must
/// be traceable to a resolution decision.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterventionUnfreeze {
    /// ID of the InterventionFreeze being lifted.
    #[prost(string, tag = "1")]
    pub freeze_id: ::prost::alloc::string::String,
    /// How the freeze was resolved.
    #[prost(enumeration = "InterventionResolutionType", tag = "2")]
    pub resolution_type: i32,
    /// ID of the adjudication that resolved the freeze.
    #[prost(string, tag = "3")]
    pub adjudication_id: ::prost::alloc::string::String,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Retained for display/audit purposes; authoritative timing uses
    /// HTF time from the time_envelope_ref.
    #[prost(uint64, tag = "4")]
    pub unfrozen_at: u64,
    /// Actor who issued the unfreeze (must be authorized).
    #[prost(string, tag = "5")]
    pub gate_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with INTERVENTION_UNFREEZE: domain (64 bytes).
    #[prost(bytes = "vec", tag = "6")]
    pub gate_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the unfreeze event to verifiable HTF time.
    #[prost(message, optional, tag = "7")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
/// Digest and metadata for a single evidence artifact.
/// Each artifact is identified by its content digest and includes metadata
/// for access control, redaction tracking, and retention policy.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactDigest {
    /// Type of artifact (Log, Junit, Coverage, Snapshot, Binary).
    #[prost(enumeration = "ArtifactType", tag = "1")]
    pub artifact_type: i32,
    /// SHA-256 digest of the artifact content (32 bytes).
    #[prost(bytes = "vec", tag = "2")]
    pub digest: ::prost::alloc::vec::Vec<u8>,
    /// Data classification for access control.
    #[prost(enumeration = "DataClassification", tag = "3")]
    pub data_classification: i32,
    /// Whether redaction/sanitization was applied to this artifact.
    #[prost(bool, tag = "4")]
    pub redaction_applied: bool,
    /// Hash of the redaction profile used (32 bytes, required if redaction_applied).
    #[prost(bytes = "vec", tag = "5")]
    pub redaction_profile_hash: ::prost::alloc::vec::Vec<u8>,
    /// Reference to the retention window for this artifact.
    /// Uses HTF time envelope format (e.g., "htf:window:30d").
    #[prost(string, tag = "6")]
    pub retention_window_ref: ::prost::alloc::string::String,
}
/// Manifest of evidence artifacts for a gate receipt.
/// The manifest binds all evidence artifacts produced during gate execution,
/// enabling independent verification and retention management.
///
/// Invariants:
/// - Must contain at least one artifact (empty manifests are rejected)
/// - No duplicate digests allowed
/// - All artifacts must pass hygiene validation
///
/// Security: The manifest is referenced by artifact_manifest_hash in
/// AatGateReceipt and stored in CAS for independent verification.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactManifest {
    /// List of artifact digests and metadata.
    #[prost(message, repeated, tag = "1")]
    pub artifacts: ::prost::alloc::vec::Vec<ArtifactDigest>,
}
/// Provenance tuple identifying the context of an AAT execution.
/// Used to verify that a reused result is valid for the current context.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatProvenanceTuple {
    /// Hash binding to specific changeset (32 bytes).
    #[prost(bytes = "vec", tag = "1")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Hash binding to view commitment (32 bytes).
    #[prost(bytes = "vec", tag = "2")]
    pub view_commitment_hash: ::prost::alloc::vec::Vec<u8>,
    /// RCP profile identifier.
    #[prost(string, tag = "3")]
    pub rcp_profile_id: ::prost::alloc::string::String,
    /// Hash of the verifier policy (32 bytes).
    #[prost(bytes = "vec", tag = "4")]
    pub verifier_policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// Determinism class (0=non, 1=soft, 2=fully).
    #[prost(uint32, tag = "5")]
    pub determinism_class: u32,
}
/// Emitted when an AAT result is reused.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatResultReused {
    /// Hash of the original AatGateReceipt being reused (32 bytes).
    #[prost(bytes = "vec", tag = "1")]
    pub from_receipt_hash: ::prost::alloc::vec::Vec<u8>,
    /// Provenance tuple of the current context (must match original).
    #[prost(message, optional, tag = "2")]
    pub provenance: ::core::option::Option<AatProvenanceTuple>,
    /// Policy hash for the current admission attempt (32 bytes).
    #[prost(bytes = "vec", tag = "3")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// Human-readable justification for reuse.
    #[prost(string, tag = "4")]
    pub justification: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with AAT_RESULT_REUSED: domain (64 bytes).
    #[prost(bytes = "vec", tag = "5")]
    pub gate_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Namespace for harness sandbox types.
///
/// Intentionally empty - serves as namespace for nested types.
#[derive(Eq, Hash)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct HarnessSandbox {}
/// An individual egress rule defining allowed network access.
/// Each rule specifies a single (host, port, protocol) tuple that is
/// permitted for outbound network connections.
///
/// Security:
/// - Wildcards are NOT supported (explicit hosts only)
/// - Port ranges are NOT supported (explicit ports only)
/// - CIDR notation is NOT supported for hosts
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EgressRule {
    /// Target hostname or IP address (max 253 characters).
    /// Wildcards are not supported for security reasons.
    #[prost(string, tag = "1")]
    pub host: ::prost::alloc::string::String,
    /// Target port number (1-65535, port 0 is reserved).
    #[prost(uint32, tag = "2")]
    pub port: u32,
    /// Transport protocol (TCP or UDP).
    #[prost(enumeration = "Protocol", tag = "3")]
    pub protocol: i32,
}
/// Network policy profile for AAT harness sandboxing.
///
/// Defines the allowed egress rules for an AAT harness execution environment.
/// The profile uses a deny-by-default model where all egress is blocked unless
/// explicitly allowed by a rule.
///
/// Security:
/// - deny_by_default MUST be true (fail-closed security model)
/// - Egress rules are sorted by hash for canonical encoding
/// - Profile hash provides integrity verification
/// - Profile referenced by network_policy_profile_hash in AatAttestation
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkPolicyProfile {
    /// Unique identifier for this policy profile.
    #[prost(string, tag = "1")]
    pub profile_id: ::prost::alloc::string::String,
    /// BLAKE3 hash of the canonical profile representation (32 bytes).
    /// Computed from: profile_id || len(allowed_egress) || sorted(egress_hashes) || deny_by_default
    #[prost(bytes = "vec", tag = "2")]
    pub profile_hash: ::prost::alloc::vec::Vec<u8>,
    /// List of allowed egress rules (max 256 rules).
    /// Each rule specifies a (host, port, protocol) tuple that is permitted.
    #[prost(message, repeated, tag = "3")]
    pub allowed_egress: ::prost::alloc::vec::Vec<EgressRule>,
    /// Deny-by-default flag (MUST be true).
    /// When true, all egress not matching a rule is blocked.
    #[prost(bool, tag = "4")]
    pub deny_by_default: bool,
}
/// Emitted when a runner pool is quarantined due to infrastructure flakiness.
///
/// This event is triggered when FlakeClass::HarnessFlake routing determines
/// that flakiness is attributed to runner/infrastructure issues (timing,
/// resource contention, runner-specific bugs).
///
/// Security: Quarantined pools are excluded from future AAT runner selection
/// until the issue is investigated and QuarantineCleared is emitted.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RunnerPoolQuarantined {
    /// Unique identifier for this quarantine event.
    #[prost(string, tag = "1")]
    pub quarantine_id: ::prost::alloc::string::String,
    /// ID of the runner pool being quarantined.
    #[prost(string, tag = "2")]
    pub pool_id: ::prost::alloc::string::String,
    /// Human-readable reason for quarantine.
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
    /// References to evidence supporting the quarantine decision.
    #[prost(string, repeated, tag = "4")]
    pub evidence_refs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the quarantine event to verifiable HTF time.
    #[prost(message, optional, tag = "5")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Actor who issued the quarantine.
    #[prost(string, tag = "6")]
    pub issuer_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with QUARANTINE_EVENT: domain (64 bytes).
    #[prost(bytes = "vec", tag = "7")]
    pub issuer_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted when an AAT spec is quarantined due to test/code flakiness.
///
/// This event is triggered when FlakeClass::TestNonsemantic or
/// FlakeClass::CodeNonsemantic routing determines that flakiness is in the
/// test specification itself (output format changes, timestamps, random IDs).
///
/// Security: Quarantined specs are excluded from AAT selection until the
/// non-determinism is resolved and QuarantineCleared is emitted.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatSpecQuarantined {
    /// Unique identifier for this quarantine event.
    #[prost(string, tag = "1")]
    pub quarantine_id: ::prost::alloc::string::String,
    /// ID of the AAT spec being quarantined.
    #[prost(string, tag = "2")]
    pub spec_id: ::prost::alloc::string::String,
    /// Human-readable reason for quarantine.
    #[prost(string, tag = "3")]
    pub reason: ::prost::alloc::string::String,
    /// References to evidence supporting the quarantine decision.
    #[prost(string, repeated, tag = "4")]
    pub evidence_refs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the quarantine event to verifiable HTF time.
    #[prost(message, optional, tag = "5")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Actor who issued the quarantine.
    #[prost(string, tag = "6")]
    pub issuer_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with QUARANTINE_EVENT: domain (64 bytes).
    #[prost(bytes = "vec", tag = "7")]
    pub issuer_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted when a quarantine is cleared after investigation.
///
/// This event re-enables the previously quarantined pool or spec for selection.
/// The target_id must match either a pool_id from RunnerPoolQuarantined or a
/// spec_id from AATSpecQuarantined.
///
/// Security: Clearing requires investigation and is audited via signature.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QuarantineCleared {
    /// ID of the original quarantine event being cleared.
    #[prost(string, tag = "1")]
    pub quarantine_id: ::prost::alloc::string::String,
    /// ID of the target being cleared (pool_id or spec_id).
    #[prost(string, tag = "2")]
    pub target_id: ::prost::alloc::string::String,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Retained for display/audit purposes; authoritative timing uses
    /// HTF time from the time_envelope_ref.
    #[prost(uint64, tag = "3")]
    pub cleared_at: u64,
    /// Actor who cleared the quarantine.
    #[prost(string, tag = "4")]
    pub issuer_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with QUARANTINE_EVENT: domain (64 bytes).
    #[prost(bytes = "vec", tag = "5")]
    pub issuer_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the quarantine clearing event to verifiable HTF time.
    #[prost(message, optional, tag = "6")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
/// Emitted when a merge is executed atomically after observing the result_selector.
///
/// This receipt binds the inputs (base, changeset, policy, receipts) to the
/// observed outcome (result_selector), ensuring that the merge cannot be
/// claimed for a different result than what was actually produced.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct MergeReceipt {
    /// Base selector (e.g., branch name "main")
    #[prost(string, tag = "1")]
    pub base_selector: ::prost::alloc::string::String,
    /// Hash of the changeset being merged (32 bytes)
    #[prost(bytes = "vec", tag = "2")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// List of gate receipt IDs that authorized this merge
    #[prost(string, repeated, tag = "3")]
    pub gate_receipt_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// Policy hash that governed this merge decision (32 bytes)
    #[prost(bytes = "vec", tag = "4")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// Observed result selector (e.g., new commit SHA)
    #[prost(string, tag = "5")]
    pub result_selector: ::prost::alloc::string::String,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Retained for display/audit purposes; authoritative timing uses
    /// HTF time from the time_envelope_ref.
    #[prost(uint64, tag = "6")]
    pub merged_at: u64,
    /// Actor who performed the merge
    #[prost(string, tag = "7")]
    pub gate_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with MERGE_RECEIPT: domain (64 bytes)
    #[prost(bytes = "vec", tag = "8")]
    pub gate_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the merge receipt to verifiable HTF time.
    #[prost(message, optional, tag = "9")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
/// Emitted when a changeset is published to CAS and anchored in the ledger.
///
/// This event MUST be emitted before any review activities begin for a work item.
/// The changeset_digest is computed deterministically over the canonicalized
/// bundle bytes with the changeset_digest field itself excluded from the hash
/// input (to prevent circular dependency).
///
/// Security: The signature uses CHANGESET_PUBLISHED: domain prefix.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChangeSetPublished {
    /// Unique work item ID this changeset belongs to.
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// BLAKE3 digest of the canonical bundle (32 bytes).
    /// Computed over bundle bytes with this field excluded from hash input.
    #[prost(bytes = "vec", tag = "2")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// CAS hash of the full ChangeSetBundleV1 artifact (32 bytes).
    /// Used for content-addressed retrieval and integrity verification.
    #[prost(bytes = "vec", tag = "3")]
    pub cas_hash: ::prost::alloc::vec::Vec<u8>,
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    /// Retained for display/audit purposes; authoritative timing uses
    /// HTF time from the time_envelope_ref.
    #[prost(uint64, tag = "4")]
    pub published_at: u64,
    /// Actor who published the changeset.
    #[prost(string, tag = "5")]
    pub publisher_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with CHANGESET_PUBLISHED: domain (64 bytes).
    #[prost(bytes = "vec", tag = "6")]
    pub publisher_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the changeset publication to verifiable HTF time.
    #[prost(message, optional, tag = "7")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
/// Emitted when an IO artifact is published from an episode.
///
/// This event captures IO operations (reads, writes, stream outputs) from
/// episode execution, enabling the episode.<episode_id>.io pulse topic.
///
/// Security: IO artifacts may contain sensitive data. The artifact_hash
/// references CAS storage; access control is enforced at the CAS layer.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct IoArtifactPublished {
    /// Episode ID this artifact belongs to.
    /// Required; enables episode.<episode_id>.io topic routing.
    #[prost(string, tag = "1")]
    pub episode_id: ::prost::alloc::string::String,
    /// Session ID for correlation with session events.
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    /// Artifact type: STDIN, STDOUT, STDERR, FILE_READ, FILE_WRITE
    #[prost(string, tag = "3")]
    pub artifact_type: ::prost::alloc::string::String,
    /// BLAKE3 hash of the artifact content (32 bytes).
    /// Full content is stored in CAS for retrieval.
    #[prost(bytes = "vec", tag = "4")]
    pub artifact_hash: ::prost::alloc::vec::Vec<u8>,
    /// Size of the artifact in bytes.
    #[prost(uint64, tag = "5")]
    pub artifact_size: u64,
    /// Optional path for file-based artifacts.
    #[prost(string, tag = "6")]
    pub path: ::prost::alloc::string::String,
    /// Timestamp when the artifact was produced (Unix nanos).
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    #[prost(uint64, tag = "7")]
    pub produced_at: u64,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the artifact event to verifiable HTF time.
    #[prost(message, optional, tag = "8")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Data classification: PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED
    /// Defaults to INTERNAL if not specified.
    #[prost(string, tag = "9")]
    pub classification: ::prost::alloc::string::String,
}
/// Emitted when a defect is detected and recorded.
///
/// This event is emitted by defect producers (divergence watchdog, context miss
/// handlers, HTF regression producers) when a defect is detected. The full
/// DefectRecord is stored in CAS and referenced by cas_hash.
///
/// Security: DefectRecorded events must flow through the ledger before pulse
/// emission per REQ-HEF-0006 ordering invariant.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DefectRecorded {
    /// Unique identifier for this defect.
    /// Format: `DEF-{uuid}` or similar unique string.
    #[prost(string, tag = "1")]
    pub defect_id: ::prost::alloc::string::String,
    /// Classification of the defect type.
    /// Examples: PROJECTION_DIVERGENCE, UNPLANNED_CONTEXT_READ, AAT_FAIL
    #[prost(string, tag = "2")]
    pub defect_type: ::prost::alloc::string::String,
    /// BLAKE3 hash of the full DefectRecord artifact in CAS (32 bytes).
    /// The full DefectRecord can be retrieved from CAS for detailed analysis.
    #[prost(bytes = "vec", tag = "3")]
    pub cas_hash: ::prost::alloc::vec::Vec<u8>,
    /// Source that detected and emitted this defect.
    #[prost(enumeration = "DefectSource", tag = "4")]
    pub source: i32,
    /// Work ID associated with this defect (if applicable).
    #[prost(string, tag = "5")]
    pub work_id: ::prost::alloc::string::String,
    /// Severity level: S0 (critical), S1 (high), S2 (medium), S3 (low).
    #[prost(string, tag = "6")]
    pub severity: ::prost::alloc::string::String,
    /// Timestamp when the defect was detected (Unix nanos).
    /// OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
    #[prost(uint64, tag = "7")]
    pub detected_at: u64,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the defect event to verifiable HTF time.
    #[prost(message, optional, tag = "8")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
}
/// Emitted when a review is blocked due to workspace apply or tool failure.
///
/// This event captures the blocked outcome and stores it durably in the ledger.
/// It binds the failure to the changeset and provides CAS references for logs.
///
/// Security: The signature uses REVIEW_BLOCKED_RECORDED: domain prefix.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReviewBlockedRecorded {
    /// Unique identifier for this blocked event.
    /// Format: `BLK-{uuid}` or similar unique string.
    #[prost(string, tag = "1")]
    pub blocked_id: ::prost::alloc::string::String,
    /// BLAKE3 digest of the changeset that was being reviewed (32 bytes).
    #[prost(bytes = "vec", tag = "2")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Reason code classifying the failure.
    #[prost(int32, tag = "3")]
    pub reason_code: i32,
    /// BLAKE3 hash of the blocked logs stored in CAS (32 bytes).
    #[prost(bytes = "vec", tag = "4")]
    pub blocked_log_hash: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the blocked event to verifiable HTF time.
    #[prost(message, optional, tag = "5")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Actor who recorded the blocked event.
    #[prost(string, tag = "6")]
    pub recorder_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with REVIEW_BLOCKED_RECORDED: domain (64 bytes).
    #[prost(bytes = "vec", tag = "7")]
    pub recorder_signature: ::prost::alloc::vec::Vec<u8>,
    /// BLAKE3 hash of the CapabilityManifest in effect (32 bytes, TCK-00326).
    /// Binds the blocked event to the authority under which the review was attempted.
    #[prost(bytes = "vec", tag = "8")]
    pub capability_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// BLAKE3 hash of the sealed ContextPackManifest in effect (32 bytes, TCK-00326).
    /// Binds the blocked event to the context firewall configuration.
    #[prost(bytes = "vec", tag = "9")]
    pub context_pack_hash: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted when a review is successfully completed.
///
/// This event records the successful review outcome and stores it durably in the
/// ledger. It binds the review artifacts to the changeset and provides CAS
/// references for verification.
///
/// Security: The signature uses REVIEW_RECEIPT_RECORDED: domain prefix.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReviewReceiptRecorded {
    /// Unique identifier for this receipt.
    /// Format: `RR-{uuid}` or similar unique string.
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    /// BLAKE3 digest of the changeset that was reviewed (32 bytes).
    /// This is the same digest from the ChangeSetPublished event.
    #[prost(bytes = "vec", tag = "2")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// BLAKE3 hash of the ReviewArtifactBundleV1 stored in CAS (32 bytes).
    /// Contains review_text_hash, tool_log_hashes, and metadata.
    #[prost(bytes = "vec", tag = "3")]
    pub artifact_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the receipt to verifiable HTF time.
    #[prost(message, optional, tag = "4")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Actor who recorded the receipt (the reviewer).
    #[prost(string, tag = "5")]
    pub reviewer_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with REVIEW_RECEIPT_RECORDED: domain (64 bytes).
    #[prost(bytes = "vec", tag = "6")]
    pub reviewer_signature: ::prost::alloc::vec::Vec<u8>,
    /// BLAKE3 hash of the CapabilityManifest used during review (32 bytes, TCK-00326).
    /// Binds the review to the authority under which it was performed.
    #[prost(bytes = "vec", tag = "7")]
    pub capability_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// BLAKE3 hash of the sealed ContextPackManifest used during review (32 bytes, TCK-00326).
    /// Binds the review to the context firewall configuration.
    #[prost(bytes = "vec", tag = "8")]
    pub context_pack_hash: ::prost::alloc::vec::Vec<u8>,
    /// BLAKE3 hash of the RoleSpecV1 used during review (32 bytes, TCK-00331).
    /// Binds the review to the role specification for attribution and conformance verification.
    #[prost(bytes = "vec", tag = "9")]
    pub role_spec_hash: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted when a projection is successfully completed.
///
/// This event records the successful projection outcome and stores it durably
/// in the ledger. It binds the projection artifacts to the changeset and
/// provides CAS references for verification and idempotency.
///
/// Security: The signature uses PROJECTION_RECEIPT_RECORDED: domain prefix.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProjectionReceiptRecorded {
    /// Unique identifier for this receipt.
    /// Format: `PR-{uuid}` or similar unique string.
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    /// BLAKE3 digest of the changeset that was projected (32 bytes).
    /// This is the same digest from the ChangeSetPublished event.
    #[prost(bytes = "vec", tag = "2")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// BLAKE3 hash of the ProjectionArtifactBundleV1 stored in CAS (32 bytes).
    /// Contains projection_status, ledger_head, and metadata.
    #[prost(bytes = "vec", tag = "3")]
    pub artifact_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority (RFC-0016).
    /// Binds the receipt to verifiable HTF time.
    #[prost(message, optional, tag = "4")]
    pub time_envelope_ref: ::core::option::Option<TimeEnvelopeRef>,
    /// Actor who recorded the receipt (the projector).
    #[prost(string, tag = "5")]
    pub projector_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with PROJECTION_RECEIPT_RECORDED: domain (64 bytes).
    #[prost(bytes = "vec", tag = "6")]
    pub projector_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Determinism status for AAT runs.
/// Indicates whether multiple runs produced consistent terminal evidence.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeterminismStatus {
    /// Unspecified status (invalid).
    Unspecified = 0,
    /// All runs produced identical terminal evidence.
    Stable = 1,
    /// Runs produced different terminal evidence.
    Mismatch = 2,
}
impl DeterminismStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DETERMINISM_STATUS_UNSPECIFIED",
            Self::Stable => "DETERMINISM_STATUS_STABLE",
            Self::Mismatch => "DETERMINISM_STATUS_MISMATCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DETERMINISM_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "DETERMINISM_STATUS_STABLE" => Some(Self::Stable),
            "DETERMINISM_STATUS_MISMATCH" => Some(Self::Mismatch),
            _ => None,
        }
    }
}
/// Classification of flakiness when determinism mismatch occurs.
/// Used for routing to appropriate quarantine/remediation paths.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FlakeClass {
    /// Unspecified class (invalid).
    Unspecified = 0,
    /// Deterministic failure - consistent FAIL across all runs.
    DeterministicFail = 1,
    /// Flakiness due to test harness issues (e.g., timing, resource contention).
    HarnessFlake = 2,
    /// Flakiness due to environment drift (e.g., dependency version mismatch).
    EnvironmentDrift = 3,
    /// Test-level non-semantic difference (e.g., output format changes).
    TestNonsemantic = 4,
    /// Code-level non-semantic difference (e.g., timestamps, random IDs).
    CodeNonsemantic = 5,
    /// Unknown flakiness cause requiring investigation.
    Unknown = 6,
}
impl FlakeClass {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FLAKE_CLASS_UNSPECIFIED",
            Self::DeterministicFail => "FLAKE_CLASS_DETERMINISTIC_FAIL",
            Self::HarnessFlake => "FLAKE_CLASS_HARNESS_FLAKE",
            Self::EnvironmentDrift => "FLAKE_CLASS_ENVIRONMENT_DRIFT",
            Self::TestNonsemantic => "FLAKE_CLASS_TEST_NONSEMANTIC",
            Self::CodeNonsemantic => "FLAKE_CLASS_CODE_NONSEMANTIC",
            Self::Unknown => "FLAKE_CLASS_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FLAKE_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
            "FLAKE_CLASS_DETERMINISTIC_FAIL" => Some(Self::DeterministicFail),
            "FLAKE_CLASS_HARNESS_FLAKE" => Some(Self::HarnessFlake),
            "FLAKE_CLASS_ENVIRONMENT_DRIFT" => Some(Self::EnvironmentDrift),
            "FLAKE_CLASS_TEST_NONSEMANTIC" => Some(Self::TestNonsemantic),
            "FLAKE_CLASS_CODE_NONSEMANTIC" => Some(Self::CodeNonsemantic),
            "FLAKE_CLASS_UNKNOWN" => Some(Self::Unknown),
            _ => None,
        }
    }
}
/// AAT verdict outcome.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AatVerdict {
    /// Unspecified verdict (invalid).
    Unspecified = 0,
    /// All acceptance criteria passed.
    Pass = 1,
    /// One or more acceptance criteria failed.
    Fail = 2,
    /// Additional input required to determine outcome.
    NeedsInput = 3,
}
impl AatVerdict {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AAT_VERDICT_UNSPECIFIED",
            Self::Pass => "AAT_VERDICT_PASS",
            Self::Fail => "AAT_VERDICT_FAIL",
            Self::NeedsInput => "AAT_VERDICT_NEEDS_INPUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AAT_VERDICT_UNSPECIFIED" => Some(Self::Unspecified),
            "AAT_VERDICT_PASS" => Some(Self::Pass),
            "AAT_VERDICT_FAIL" => Some(Self::Fail),
            "AAT_VERDICT_NEEDS_INPUT" => Some(Self::NeedsInput),
            _ => None,
        }
    }
}
/// Risk tier for AAT selection policy.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AatRiskTier {
    /// Unspecified tier (invalid).
    Unspecified = 0,
    /// High risk - AAT always required.
    High = 1,
    /// Medium risk - AAT required for sensitive domains.
    Med = 2,
    /// Low risk - AAT sampled with nightly full coverage.
    Low = 3,
}
impl AatRiskTier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AAT_RISK_TIER_UNSPECIFIED",
            Self::High => "AAT_RISK_TIER_HIGH",
            Self::Med => "AAT_RISK_TIER_MED",
            Self::Low => "AAT_RISK_TIER_LOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AAT_RISK_TIER_UNSPECIFIED" => Some(Self::Unspecified),
            "AAT_RISK_TIER_HIGH" => Some(Self::High),
            "AAT_RISK_TIER_MED" => Some(Self::Med),
            "AAT_RISK_TIER_LOW" => Some(Self::Low),
            _ => None,
        }
    }
}
/// Scope of an intervention freeze.
/// Determines what is frozen by the intervention.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InterventionScope {
    /// Unspecified scope (invalid).
    Unspecified = 0,
    /// Freeze applies to a specific repository.
    Repository = 1,
    /// Freeze applies to a specific work item.
    Work = 2,
    /// Freeze applies to all repositories in a namespace.
    Namespace = 3,
}
impl InterventionScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INTERVENTION_SCOPE_UNSPECIFIED",
            Self::Repository => "INTERVENTION_SCOPE_REPOSITORY",
            Self::Work => "INTERVENTION_SCOPE_WORK",
            Self::Namespace => "INTERVENTION_SCOPE_NAMESPACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTERVENTION_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INTERVENTION_SCOPE_REPOSITORY" => Some(Self::Repository),
            "INTERVENTION_SCOPE_WORK" => Some(Self::Work),
            "INTERVENTION_SCOPE_NAMESPACE" => Some(Self::Namespace),
            _ => None,
        }
    }
}
/// Resolution type for intervention unfreeze.
/// Indicates how the freeze was resolved.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InterventionResolutionType {
    /// Unspecified resolution (invalid).
    InterventionResolutionUnspecified = 0,
    /// Resolved through adjudication process.
    InterventionResolutionAdjudication = 1,
    /// Resolved by manual operator intervention.
    InterventionResolutionManual = 2,
    /// Resolved by rollback to last known good state.
    InterventionResolutionRollback = 3,
    /// Resolved by accepting the divergent state as new baseline.
    InterventionResolutionAcceptDivergence = 4,
}
impl InterventionResolutionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InterventionResolutionUnspecified => {
                "INTERVENTION_RESOLUTION_UNSPECIFIED"
            }
            Self::InterventionResolutionAdjudication => {
                "INTERVENTION_RESOLUTION_ADJUDICATION"
            }
            Self::InterventionResolutionManual => "INTERVENTION_RESOLUTION_MANUAL",
            Self::InterventionResolutionRollback => "INTERVENTION_RESOLUTION_ROLLBACK",
            Self::InterventionResolutionAcceptDivergence => {
                "INTERVENTION_RESOLUTION_ACCEPT_DIVERGENCE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTERVENTION_RESOLUTION_UNSPECIFIED" => {
                Some(Self::InterventionResolutionUnspecified)
            }
            "INTERVENTION_RESOLUTION_ADJUDICATION" => {
                Some(Self::InterventionResolutionAdjudication)
            }
            "INTERVENTION_RESOLUTION_MANUAL" => Some(Self::InterventionResolutionManual),
            "INTERVENTION_RESOLUTION_ROLLBACK" => {
                Some(Self::InterventionResolutionRollback)
            }
            "INTERVENTION_RESOLUTION_ACCEPT_DIVERGENCE" => {
                Some(Self::InterventionResolutionAcceptDivergence)
            }
            _ => None,
        }
    }
}
/// Type of evidence artifact.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ArtifactType {
    /// Unspecified type (invalid).
    Unspecified = 0,
    /// Execution logs and traces.
    Log = 1,
    /// JUnit/xUnit test reports.
    Junit = 2,
    /// Code coverage reports.
    Coverage = 3,
    /// State snapshots for determinism verification.
    Snapshot = 4,
    /// Compiled artifacts (executables, libraries).
    Binary = 5,
}
impl ArtifactType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ARTIFACT_TYPE_UNSPECIFIED",
            Self::Log => "ARTIFACT_TYPE_LOG",
            Self::Junit => "ARTIFACT_TYPE_JUNIT",
            Self::Coverage => "ARTIFACT_TYPE_COVERAGE",
            Self::Snapshot => "ARTIFACT_TYPE_SNAPSHOT",
            Self::Binary => "ARTIFACT_TYPE_BINARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ARTIFACT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ARTIFACT_TYPE_LOG" => Some(Self::Log),
            "ARTIFACT_TYPE_JUNIT" => Some(Self::Junit),
            "ARTIFACT_TYPE_COVERAGE" => Some(Self::Coverage),
            "ARTIFACT_TYPE_SNAPSHOT" => Some(Self::Snapshot),
            "ARTIFACT_TYPE_BINARY" => Some(Self::Binary),
            _ => None,
        }
    }
}
/// Data classification level for evidence artifacts.
/// Determines access control and handling requirements.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataClassification {
    /// Unspecified classification (invalid).
    Unspecified = 0,
    /// No access restrictions.
    Public = 1,
    /// Organization-internal access only.
    Internal = 2,
    /// Restricted access with audit logging.
    Confidential = 3,
    /// Maximum security controls required.
    Restricted = 4,
}
impl DataClassification {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATA_CLASSIFICATION_UNSPECIFIED",
            Self::Public => "DATA_CLASSIFICATION_PUBLIC",
            Self::Internal => "DATA_CLASSIFICATION_INTERNAL",
            Self::Confidential => "DATA_CLASSIFICATION_CONFIDENTIAL",
            Self::Restricted => "DATA_CLASSIFICATION_RESTRICTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_CLASSIFICATION_UNSPECIFIED" => Some(Self::Unspecified),
            "DATA_CLASSIFICATION_PUBLIC" => Some(Self::Public),
            "DATA_CLASSIFICATION_INTERNAL" => Some(Self::Internal),
            "DATA_CLASSIFICATION_CONFIDENTIAL" => Some(Self::Confidential),
            "DATA_CLASSIFICATION_RESTRICTED" => Some(Self::Restricted),
            _ => None,
        }
    }
}
/// Transport protocol for egress rules.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum Protocol {
    /// Unspecified protocol (invalid).
    Unspecified = 0,
    /// Transmission Control Protocol (connection-oriented).
    Tcp = 1,
    /// User Datagram Protocol (connectionless).
    Udp = 2,
}
impl Protocol {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "PROTOCOL_UNSPECIFIED",
            Self::Tcp => "PROTOCOL_TCP",
            Self::Udp => "PROTOCOL_UDP",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROTOCOL_UNSPECIFIED" => Some(Self::Unspecified),
            "PROTOCOL_TCP" => Some(Self::Tcp),
            "PROTOCOL_UDP" => Some(Self::Udp),
            _ => None,
        }
    }
}
/// Source of the defect detection.
/// Identifies which producer emitted the DefectRecorded event.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DefectSource {
    /// Unspecified source (invalid).
    Unspecified = 0,
    /// Divergence watchdog detected trunk HEAD mismatch.
    DivergenceWatchdog = 1,
    /// Context miss detected unplanned context read.
    ContextMiss = 2,
    /// HTF regression producer detected test regression.
    HtfRegression = 3,
    /// Projection tamper detected status spoofing.
    ProjectionTamper = 4,
    /// Schema validation rejected an artifact.
    SchemaReject = 5,
    /// AAT failure detected.
    AatFail = 6,
    /// Required capability unavailable.
    CapabilityUnavailable = 7,
}
impl DefectSource {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DEFECT_SOURCE_UNSPECIFIED",
            Self::DivergenceWatchdog => "DEFECT_SOURCE_DIVERGENCE_WATCHDOG",
            Self::ContextMiss => "DEFECT_SOURCE_CONTEXT_MISS",
            Self::HtfRegression => "DEFECT_SOURCE_HTF_REGRESSION",
            Self::ProjectionTamper => "DEFECT_SOURCE_PROJECTION_TAMPER",
            Self::SchemaReject => "DEFECT_SOURCE_SCHEMA_REJECT",
            Self::AatFail => "DEFECT_SOURCE_AAT_FAIL",
            Self::CapabilityUnavailable => "DEFECT_SOURCE_CAPABILITY_UNAVAILABLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DEFECT_SOURCE_UNSPECIFIED" => Some(Self::Unspecified),
            "DEFECT_SOURCE_DIVERGENCE_WATCHDOG" => Some(Self::DivergenceWatchdog),
            "DEFECT_SOURCE_CONTEXT_MISS" => Some(Self::ContextMiss),
            "DEFECT_SOURCE_HTF_REGRESSION" => Some(Self::HtfRegression),
            "DEFECT_SOURCE_PROJECTION_TAMPER" => Some(Self::ProjectionTamper),
            "DEFECT_SOURCE_SCHEMA_REJECT" => Some(Self::SchemaReject),
            "DEFECT_SOURCE_AAT_FAIL" => Some(Self::AatFail),
            "DEFECT_SOURCE_CAPABILITY_UNAVAILABLE" => Some(Self::CapabilityUnavailable),
            _ => None,
        }
    }
}
/// Reason code for review blocked events.
/// Classifies the specific failure that caused the review to be blocked.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ReviewBlockedReasonCode {
    /// Unspecified reason (invalid).
    ReviewBlockedReasonUnspecified = 0,
    /// Workspace apply operation failed.
    ReviewBlockedReasonApplyFailed = 1,
    /// Tool execution failed during review.
    ReviewBlockedReasonToolFailed = 2,
    /// Binary file detected (unsupported in v0).
    ReviewBlockedReasonBinaryUnsupported = 3,
    /// Required artifact missing from CAS.
    ReviewBlockedReasonMissingArtifact = 4,
    /// Invalid changeset bundle format.
    ReviewBlockedReasonInvalidBundle = 5,
    /// Operation timed out.
    ReviewBlockedReasonTimeout = 6,
    /// Policy denied the operation.
    ReviewBlockedReasonPolicyDenied = 7,
    /// Context miss detected.
    ReviewBlockedReasonContextMiss = 8,
    /// Context pack not found in CAS (TCK-00326).
    ReviewBlockedReasonContextPackMissing = 9,
    /// Context pack seal verification failed (TCK-00326).
    ReviewBlockedReasonContextPackInvalid = 10,
}
impl ReviewBlockedReasonCode {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ReviewBlockedReasonUnspecified => "REVIEW_BLOCKED_REASON_UNSPECIFIED",
            Self::ReviewBlockedReasonApplyFailed => "REVIEW_BLOCKED_REASON_APPLY_FAILED",
            Self::ReviewBlockedReasonToolFailed => "REVIEW_BLOCKED_REASON_TOOL_FAILED",
            Self::ReviewBlockedReasonBinaryUnsupported => {
                "REVIEW_BLOCKED_REASON_BINARY_UNSUPPORTED"
            }
            Self::ReviewBlockedReasonMissingArtifact => {
                "REVIEW_BLOCKED_REASON_MISSING_ARTIFACT"
            }
            Self::ReviewBlockedReasonInvalidBundle => {
                "REVIEW_BLOCKED_REASON_INVALID_BUNDLE"
            }
            Self::ReviewBlockedReasonTimeout => "REVIEW_BLOCKED_REASON_TIMEOUT",
            Self::ReviewBlockedReasonPolicyDenied => {
                "REVIEW_BLOCKED_REASON_POLICY_DENIED"
            }
            Self::ReviewBlockedReasonContextMiss => "REVIEW_BLOCKED_REASON_CONTEXT_MISS",
            Self::ReviewBlockedReasonContextPackMissing => {
                "REVIEW_BLOCKED_REASON_CONTEXT_PACK_MISSING"
            }
            Self::ReviewBlockedReasonContextPackInvalid => {
                "REVIEW_BLOCKED_REASON_CONTEXT_PACK_INVALID"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "REVIEW_BLOCKED_REASON_UNSPECIFIED" => {
                Some(Self::ReviewBlockedReasonUnspecified)
            }
            "REVIEW_BLOCKED_REASON_APPLY_FAILED" => {
                Some(Self::ReviewBlockedReasonApplyFailed)
            }
            "REVIEW_BLOCKED_REASON_TOOL_FAILED" => {
                Some(Self::ReviewBlockedReasonToolFailed)
            }
            "REVIEW_BLOCKED_REASON_BINARY_UNSUPPORTED" => {
                Some(Self::ReviewBlockedReasonBinaryUnsupported)
            }
            "REVIEW_BLOCKED_REASON_MISSING_ARTIFACT" => {
                Some(Self::ReviewBlockedReasonMissingArtifact)
            }
            "REVIEW_BLOCKED_REASON_INVALID_BUNDLE" => {
                Some(Self::ReviewBlockedReasonInvalidBundle)
            }
            "REVIEW_BLOCKED_REASON_TIMEOUT" => Some(Self::ReviewBlockedReasonTimeout),
            "REVIEW_BLOCKED_REASON_POLICY_DENIED" => {
                Some(Self::ReviewBlockedReasonPolicyDenied)
            }
            "REVIEW_BLOCKED_REASON_CONTEXT_MISS" => {
                Some(Self::ReviewBlockedReasonContextMiss)
            }
            "REVIEW_BLOCKED_REASON_CONTEXT_PACK_MISSING" => {
                Some(Self::ReviewBlockedReasonContextPackMissing)
            }
            "REVIEW_BLOCKED_REASON_CONTEXT_PACK_INVALID" => {
                Some(Self::ReviewBlockedReasonContextPackInvalid)
            }
            _ => None,
        }
    }
}
