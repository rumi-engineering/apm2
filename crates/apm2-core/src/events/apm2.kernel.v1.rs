// This file is @generated by prost-build.
/// Common envelope for all kernel events
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelEvent {
    /// Monotonic sequence number within this ledger
    #[prost(uint64, tag = "1")]
    pub sequence: u64,
    /// Hash of the previous event.
    /// For genesis events: use 32 zero bytes (canonical representation).
    /// Note: The ledger may store NULL for genesis as a storage optimization,
    /// but it must be normalized to 32 zero bytes at API boundaries.
    #[prost(bytes = "vec", tag = "2")]
    pub previous_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when event was created
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Actor ID that produced this event
    #[prost(string, tag = "4")]
    pub actor_id: ::prost::alloc::string::String,
    /// Session ID (if applicable)
    #[prost(string, tag = "5")]
    pub session_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes of this message
    #[prost(bytes = "vec", tag = "6")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// Schema version for forward/backward compatibility
    /// Current version: 1
    #[prost(uint32, tag = "7")]
    pub schema_version: u32,
    /// Event payload (oneof)
    #[prost(
        oneof = "kernel_event::Payload",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24"
    )]
    pub payload: ::core::option::Option<kernel_event::Payload>,
}
/// Nested message and enum types in `KernelEvent`.
pub mod kernel_event {
    /// Event payload (oneof)
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Session(super::SessionEvent),
        #[prost(message, tag = "11")]
        Work(super::WorkEvent),
        #[prost(message, tag = "12")]
        Tool(super::ToolEvent),
        #[prost(message, tag = "13")]
        Lease(super::LeaseEvent),
        #[prost(message, tag = "14")]
        Policy(super::PolicyEvent),
        #[prost(message, tag = "15")]
        Adjudication(super::AdjudicationEvent),
        #[prost(message, tag = "16")]
        Evidence(super::EvidenceEvent),
        #[prost(message, tag = "17")]
        Key(super::KeyEvent),
        #[prost(message, tag = "18")]
        Capability(super::CapabilityEvent),
        #[prost(message, tag = "19")]
        GithubLease(super::GitHubLeaseEvent),
        #[prost(message, tag = "20")]
        PolicyResolvedForChangeset(super::PolicyResolvedForChangeSet),
        #[prost(message, tag = "21")]
        GateReceipt(super::GateReceipt),
        #[prost(message, tag = "22")]
        InterventionFreeze(super::InterventionFreeze),
        #[prost(message, tag = "23")]
        InterventionUnfreeze(super::InterventionUnfreeze),
        #[prost(message, tag = "24")]
        AatResultReused(super::AatResultReused),
    }
}
/// ============================================================
/// SESSION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionEvent {
    #[prost(oneof = "session_event::Event", tags = "1, 2, 3, 4, 5, 6")]
    pub event: ::core::option::Option<session_event::Event>,
}
/// Nested message and enum types in `SessionEvent`.
pub mod session_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Started(super::SessionStarted),
        #[prost(message, tag = "2")]
        Progress(super::SessionProgress),
        #[prost(message, tag = "3")]
        Terminated(super::SessionTerminated),
        #[prost(message, tag = "4")]
        Quarantined(super::SessionQuarantined),
        #[prost(message, tag = "5")]
        CrashDetected(super::SessionCrashDetected),
        #[prost(message, tag = "6")]
        RestartScheduled(super::SessionRestartScheduled),
    }
}
/// Emitted when a session process exits unexpectedly or crashes.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionCrashDetected {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// CLEAN_EXIT, ERROR_EXIT, SIGNAL, TIMEOUT, ENTROPY_EXCEEDED
    #[prost(string, tag = "2")]
    pub crash_type: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub exit_code: i32,
    #[prost(int32, tag = "4")]
    pub signal: i32,
    #[prost(uint64, tag = "5")]
    pub uptime_ms: u64,
    #[prost(uint64, tag = "6")]
    pub last_cursor: u64,
    #[prost(uint32, tag = "7")]
    pub restart_count: u32,
}
/// Emitted when a restart has been scheduled for a crashed session.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionRestartScheduled {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub scheduled_at: u64,
    #[prost(uint64, tag = "3")]
    pub restart_at: u64,
    #[prost(uint64, tag = "4")]
    pub resume_cursor: u64,
    #[prost(uint32, tag = "5")]
    pub attempt_number: u32,
    /// FIXED, EXPONENTIAL, LINEAR
    #[prost(string, tag = "6")]
    pub backoff_type: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionStarted {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub adapter_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub entropy_budget: u64,
    /// For restarted sessions: cursor to resume from
    #[prost(uint64, tag = "7")]
    pub resume_cursor: u64,
    /// For restarted sessions: restart attempt number (0 = first start)
    #[prost(uint32, tag = "8")]
    pub restart_attempt: u32,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionProgress {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub progress_sequence: u64,
    /// HEARTBEAT, TOOL_COMPLETE, MILESTONE
    #[prost(string, tag = "3")]
    pub progress_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub entropy_consumed: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionTerminated {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT, ENTROPY_EXCEEDED
    #[prost(string, tag = "2")]
    pub exit_classification: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub final_entropy: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionQuarantined {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub quarantine_until: u64,
}
/// ============================================================
/// WORK EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkEvent {
    #[prost(oneof = "work_event::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<work_event::Event>,
}
/// Nested message and enum types in `WorkEvent`.
pub mod work_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Opened(super::WorkOpened),
        #[prost(message, tag = "2")]
        Transitioned(super::WorkTransitioned),
        #[prost(message, tag = "3")]
        Completed(super::WorkCompleted),
        #[prost(message, tag = "4")]
        Aborted(super::WorkAborted),
        #[prost(message, tag = "5")]
        PrAssociated(super::WorkPrAssociated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkOpened {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// TICKET, PRD_REFINEMENT, RFC_REFINEMENT, REVIEW
    #[prost(string, tag = "2")]
    pub work_type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub spec_snapshot_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "4")]
    pub requirement_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub parent_work_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkTransitioned {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub from_state: ::prost::alloc::string::String,
    /// Valid states: OPEN, CLAIMED, IN_PROGRESS, CI_PENDING, READY_FOR_REVIEW,
    /// BLOCKED, REVIEW, NEEDS_INPUT, NEEDS_ADJUDICATION
    #[prost(string, tag = "3")]
    pub to_state: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rationale_code: ::prost::alloc::string::String,
    /// Previous transition count for replay protection.
    /// MUST match work.transition_count before this transition.
    /// This field is strictly validated to prevent replay attacks.
    /// For the first transition (Open -> Claimed), use 0.
    #[prost(uint32, tag = "5")]
    pub previous_transition_count: u32,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkCompleted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub evidence_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "3")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub gate_receipt_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkAborted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// POLICY_DENY, TIMEOUT, ENTROPY_EXCEEDED, MANUAL
    #[prost(string, tag = "2")]
    pub abort_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
}
/// Emitted when a PR is created and associated with a work item.
/// This enables CI event matching for phase transitions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkPrAssociated {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub pr_number: u64,
    /// The commit SHA that triggered the CI workflow
    #[prost(string, tag = "3")]
    pub commit_sha: ::prost::alloc::string::String,
}
/// ============================================================
/// TOOL EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolEvent {
    #[prost(oneof = "tool_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<tool_event::Event>,
}
/// Nested message and enum types in `ToolEvent`.
pub mod tool_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::ToolRequested),
        #[prost(message, tag = "2")]
        Decided(super::ToolDecided),
        #[prost(message, tag = "3")]
        Executed(super::ToolExecuted),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolRequested {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tool_name: ::prost::alloc::string::String,
    /// Hash of arguments (full args stored in CAS)
    #[prost(bytes = "vec", tag = "4")]
    pub tool_args_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub dedupe_key: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolDecided {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// ALLOW, DENY
    #[prost(string, tag = "2")]
    pub decision: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub budget_consumed: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolExecuted {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT
    #[prost(string, tag = "2")]
    pub outcome: ::prost::alloc::string::String,
    /// Hash of result (full result stored in CAS)
    #[prost(bytes = "vec", tag = "3")]
    pub result_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub duration_ms: u64,
}
/// ============================================================
/// LEASE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseEvent {
    #[prost(oneof = "lease_event::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<lease_event::Event>,
}
/// Nested message and enum types in `LeaseEvent`.
pub mod lease_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Issued(super::LeaseIssued),
        #[prost(message, tag = "2")]
        Renewed(super::LeaseRenewed),
        #[prost(message, tag = "3")]
        Released(super::LeaseReleased),
        #[prost(message, tag = "4")]
        Expired(super::LeaseExpired),
        #[prost(message, tag = "5")]
        Conflict(super::LeaseConflict),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseIssued {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub issued_at: u64,
    #[prost(uint64, tag = "5")]
    pub expires_at: u64,
    #[prost(bytes = "vec", tag = "6")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseRenewed {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub new_expires_at: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseReleased {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// COMPLETED, ABORTED, VOLUNTARY
    #[prost(string, tag = "2")]
    pub release_reason: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseExpired {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub expired_at: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseConflict {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub conflicting_lease_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// CANONICAL_ROOT, ADJUDICATION_REQUIRED
    #[prost(string, tag = "3")]
    pub resolution: ::prost::alloc::string::String,
}
/// ============================================================
/// POLICY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyEvent {
    #[prost(oneof = "policy_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<policy_event::Event>,
}
/// Nested message and enum types in `PolicyEvent`.
pub mod policy_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Loaded(super::PolicyLoaded),
        #[prost(message, tag = "2")]
        Violation(super::PolicyViolation),
        #[prost(message, tag = "3")]
        BudgetExceeded(super::BudgetExceeded),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyLoaded {
    #[prost(bytes = "vec", tag = "1")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub policy_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub rule_count: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyViolation {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub violation_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub details: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BudgetExceeded {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// TOKEN, TIME, TOOL_CALLS
    #[prost(string, tag = "2")]
    pub budget_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    #[prost(uint64, tag = "4")]
    pub consumed: u64,
}
/// ============================================================
/// ADJUDICATION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationEvent {
    #[prost(oneof = "adjudication_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<adjudication_event::Event>,
}
/// Nested message and enum types in `AdjudicationEvent`.
pub mod adjudication_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::AdjudicationRequested),
        #[prost(message, tag = "2")]
        Vote(super::AdjudicationVote),
        #[prost(message, tag = "3")]
        Resolved(super::AdjudicationResolved),
        #[prost(message, tag = "4")]
        Timeout(super::AdjudicationTimeout),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationRequested {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// BOUNDED_CHOICE, WAIVER, GATE_REVIEW
    #[prost(string, tag = "3")]
    pub request_type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "5")]
    pub deadline: u64,
    #[prost(string, tag = "6")]
    pub fallback_policy: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationVote {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub voter_actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub voter_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationResolved {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub votes_for: u64,
    #[prost(uint64, tag = "4")]
    pub votes_against: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub quorum_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationTimeout {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub applied_fallback: ::prost::alloc::string::String,
}
/// ============================================================
/// EVIDENCE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidenceEvent {
    #[prost(oneof = "evidence_event::Event", tags = "1, 2")]
    pub event: ::core::option::Option<evidence_event::Event>,
}
/// Nested message and enum types in `EvidenceEvent`.
pub mod evidence_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Published(super::EvidencePublished),
        #[prost(message, tag = "2")]
        GateReceipt(super::GateReceiptGenerated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidencePublished {
    #[prost(string, tag = "1")]
    pub evidence_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub category: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub artifact_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "5")]
    pub verification_command_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Data classification: PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED
    #[prost(string, tag = "6")]
    pub classification: ::prost::alloc::string::String,
    /// Artifact size in bytes (for bundle size tracking)
    #[prost(uint64, tag = "7")]
    pub artifact_size: u64,
    /// Metadata key-value pairs as "key=value" strings
    #[prost(string, repeated, tag = "8")]
    pub metadata: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateReceiptGenerated {
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gate_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub work_id: ::prost::alloc::string::String,
    /// PASS, FAIL
    #[prost(string, tag = "4")]
    pub result: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "6")]
    pub receipt_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityEvent {
    #[prost(oneof = "capability_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<capability_event::Event>,
}
/// Nested message and enum types in `CapabilityEvent`.
pub mod capability_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Required(super::CapabilityRequired),
        #[prost(message, tag = "2")]
        Granted(super::CapabilityGranted),
        #[prost(message, tag = "3")]
        Delegated(super::CapabilityDelegated),
        #[prost(message, tag = "4")]
        Revoked(super::CapabilityRevoked),
    }
}
/// Emitted during planning phase when a capability is required for a plan step.
/// This event enables capability negotiation and tracking.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityRequired {
    /// The capability ID that is required (e.g., "cac:patch:apply")
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// The work ID this requirement is associated with
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// Whether this capability is required (true) or optional (false)
    #[prost(bool, tag = "3")]
    pub required: bool,
    /// The status of the capability: AVAILABLE, UNAVAILABLE, DEGRADED
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
    /// Human-readable reason for the status
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
}
/// Emitted when a capability is granted to an actor by an authority.
/// This is the root of a delegation chain and must be signed by the registrar.
/// Links to the lease system: capability_id == lease_id.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityGranted {
    /// Unique identifier for this capability (equals lease_id for lease-backed capabilities)
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// Namespace this capability is bound to (prevents cross-namespace replay)
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor receiving the capability
    #[prost(string, tag = "3")]
    pub grantee_actor_id: ::prost::alloc::string::String,
    /// Actor granting the capability (must be an authority in the namespace)
    #[prost(string, tag = "4")]
    pub grantor_actor_id: ::prost::alloc::string::String,
    /// Hash of the serialized LeaseScope (stored in CAS)
    #[prost(bytes = "vec", tag = "5")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// Optional hash of the serialized Budget (stored in CAS)
    #[prost(bytes = "vec", tag = "6")]
    pub budget_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the capability was granted (Unix nanos)
    #[prost(uint64, tag = "7")]
    pub granted_at: u64,
    /// Timestamp when the capability expires (Unix nanos)
    #[prost(uint64, tag = "8")]
    pub expires_at: u64,
    /// Registrar signature over this grant (proves authority)
    #[prost(bytes = "vec", tag = "9")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
    /// Whether this capability can be delegated to others
    #[prost(bool, tag = "10")]
    pub delegatable: bool,
}
/// Emitted when a capability holder delegates their capability to another actor.
/// Forms part of the delegation chain for capability proofs.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityDelegated {
    /// New capability ID for the delegated capability
    #[prost(string, tag = "1")]
    pub delegated_capability_id: ::prost::alloc::string::String,
    /// Parent capability being delegated from
    #[prost(string, tag = "2")]
    pub parent_capability_id: ::prost::alloc::string::String,
    /// Hash of the parent CapabilityGranted or CapabilityDelegated event
    #[prost(bytes = "vec", tag = "3")]
    pub parent_capability_hash: ::prost::alloc::vec::Vec<u8>,
    /// Namespace this delegation is bound to (must match parent)
    #[prost(string, tag = "4")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor receiving the delegated capability
    #[prost(string, tag = "5")]
    pub delegatee_actor_id: ::prost::alloc::string::String,
    /// Actor delegating the capability (must hold parent capability)
    #[prost(string, tag = "6")]
    pub delegator_actor_id: ::prost::alloc::string::String,
    /// Hash of the serialized LeaseScope (must be subset of parent scope)
    #[prost(bytes = "vec", tag = "7")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// Optional hash of the serialized Budget (must be subset of parent budget)
    #[prost(bytes = "vec", tag = "8")]
    pub budget_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the delegation occurred (Unix nanos)
    #[prost(uint64, tag = "9")]
    pub delegated_at: u64,
    /// Timestamp when the delegated capability expires (Unix nanos, must be <= parent expires_at)
    #[prost(uint64, tag = "10")]
    pub expires_at: u64,
    /// Delegator's signature over this delegation (proves authority transfer)
    #[prost(bytes = "vec", tag = "11")]
    pub delegator_signature: ::prost::alloc::vec::Vec<u8>,
    /// Whether this delegated capability can be further delegated
    #[prost(bool, tag = "12")]
    pub delegatable: bool,
    /// Depth in the delegation chain (parent depth + 1)
    #[prost(uint32, tag = "13")]
    pub delegation_depth: u32,
}
/// Emitted when a capability is revoked before its natural expiration.
/// Revocation cascades to all delegated capabilities in the chain.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityRevoked {
    /// The capability being revoked
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// Namespace the capability belongs to
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor performing the revocation (must be grantor or authority)
    #[prost(string, tag = "3")]
    pub revoker_actor_id: ::prost::alloc::string::String,
    /// Reason for revocation: VOLUNTARY, POLICY_VIOLATION, KEY_COMPROMISE, SUPERSEDED
    #[prost(string, tag = "4")]
    pub revocation_reason: ::prost::alloc::string::String,
    /// Timestamp when the revocation occurred (Unix nanos)
    #[prost(uint64, tag = "5")]
    pub revoked_at: u64,
    /// Revoker's signature over this revocation
    #[prost(bytes = "vec", tag = "6")]
    pub revoker_signature: ::prost::alloc::vec::Vec<u8>,
    /// If true, revocation cascades to all delegated capabilities; if false, only this capability is revoked
    #[prost(bool, tag = "7")]
    pub cascade: bool,
}
/// ============================================================
/// KEY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyEvent {
    #[prost(oneof = "key_event::Event", tags = "1")]
    pub event: ::core::option::Option<key_event::Event>,
}
/// Nested message and enum types in `KeyEvent`.
pub mod key_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Rotated(super::KeyRotated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubLeaseEvent {
    #[prost(oneof = "git_hub_lease_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<git_hub_lease_event::Event>,
}
/// Nested message and enum types in `GitHubLeaseEvent`.
pub mod git_hub_lease_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Issued(super::GitHubLeaseIssued),
        #[prost(message, tag = "2")]
        Revoked(super::GitHubLeaseRevoked),
        #[prost(message, tag = "3")]
        OperationRecorded(super::GitHubOperationRecorded),
    }
}
/// Emitted when a GitHub installation access token is minted for an agent.
/// Links to the episode via episode_id and inherits risk tier constraints.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubLeaseIssued {
    /// Unique identifier for this GitHub lease
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// Episode this lease is bound to
    #[prost(string, tag = "2")]
    pub episode_id: ::prost::alloc::string::String,
    /// GitHub App ID (determines permission tier)
    #[prost(string, tag = "3")]
    pub github_app_id: ::prost::alloc::string::String,
    /// GitHub installation ID for the target repository/organization
    #[prost(string, tag = "4")]
    pub installation_id: ::prost::alloc::string::String,
    /// Risk tier of the requesting agent (0-4)
    /// Tier determines which GitHub App can be used:
    /// - T0: reader only
    /// - T1-T2: reader or developer
    /// - T3-T4: reader, developer, or operator
    #[prost(uint32, tag = "5")]
    pub risk_tier: u32,
    /// Hash of the requested GitHub scopes (scope list stored in CAS)
    #[prost(bytes = "vec", tag = "6")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// SHA-256 hash of the installation access token (NEVER store raw token)
    #[prost(bytes = "vec", tag = "7")]
    pub token_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the lease was issued (Unix nanos)
    #[prost(uint64, tag = "8")]
    pub issued_at: u64,
    /// Timestamp when the lease expires (Unix nanos)
    /// TTL is proportional to risk tier:
    /// - T0: 1 hour
    /// - T1-T2: 15-30 minutes
    /// - T3-T4: 2-5 minutes
    #[prost(uint64, tag = "9")]
    pub expires_at: u64,
    /// Hash of the capability manifest that authorized this lease
    #[prost(bytes = "vec", tag = "10")]
    pub capability_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// Issuer (registrar) signature over this event
    #[prost(bytes = "vec", tag = "11")]
    pub issuer_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted when a GitHub lease is revoked before expiration.
/// Revocation may be voluntary or forced (policy violation, key compromise).
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubLeaseRevoked {
    /// The lease being revoked
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// Episode the lease was bound to
    #[prost(string, tag = "2")]
    pub episode_id: ::prost::alloc::string::String,
    /// Reason for revocation: VOLUNTARY, EXPIRED, POLICY_VIOLATION, KEY_COMPROMISE
    #[prost(string, tag = "3")]
    pub revocation_reason: ::prost::alloc::string::String,
    /// Timestamp when the revocation occurred (Unix nanos)
    #[prost(uint64, tag = "4")]
    pub revoked_at: u64,
    /// Actor performing the revocation
    #[prost(string, tag = "5")]
    pub revoker_actor_id: ::prost::alloc::string::String,
    /// Revoker signature over this event
    #[prost(bytes = "vec", tag = "6")]
    pub revoker_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted for each GitHub API operation made with a leased token.
/// Provides audit trail for all GitHub interactions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubOperationRecorded {
    /// Unique identifier for this operation record
    #[prost(string, tag = "1")]
    pub operation_id: ::prost::alloc::string::String,
    /// The lease that authorized this operation
    #[prost(string, tag = "2")]
    pub lease_id: ::prost::alloc::string::String,
    /// Episode context
    #[prost(string, tag = "3")]
    pub episode_id: ::prost::alloc::string::String,
    /// GitHub API endpoint called (e.g., "POST /repos/{owner}/{repo}/pulls")
    #[prost(string, tag = "4")]
    pub api_endpoint: ::prost::alloc::string::String,
    /// HTTP method: GET, POST, PUT, PATCH, DELETE
    #[prost(string, tag = "5")]
    pub http_method: ::prost::alloc::string::String,
    /// Target repository in owner/repo format
    #[prost(string, tag = "6")]
    pub repository: ::prost::alloc::string::String,
    /// Hash of the request body (request body stored in CAS if needed)
    #[prost(bytes = "vec", tag = "7")]
    pub request_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the response body (response body stored in CAS if needed)
    #[prost(bytes = "vec", tag = "8")]
    pub response_hash: ::prost::alloc::vec::Vec<u8>,
    /// HTTP status code returned
    #[prost(uint32, tag = "9")]
    pub status_code: u32,
    /// Timestamp when the operation was performed (Unix nanos)
    #[prost(uint64, tag = "10")]
    pub performed_at: u64,
    /// Duration of the API call in milliseconds
    #[prost(uint64, tag = "11")]
    pub duration_ms: u64,
    /// GitHub rate limit remaining after this call
    #[prost(uint32, tag = "12")]
    pub rate_limit_remaining: u32,
}
/// Event emitted when an actor rotates their signing key.
/// This establishes a chain of custody for key transitions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyRotated {
    /// Actor whose key is being rotated
    #[prost(string, tag = "1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Hash of the old verifying key (for reference)
    #[prost(bytes = "vec", tag = "2")]
    pub old_key_hash: ::prost::alloc::vec::Vec<u8>,
    /// New verifying (public) key bytes
    #[prost(bytes = "vec", tag = "3")]
    pub new_verifying_key: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the rotation occurred (Unix nanos)
    #[prost(uint64, tag = "4")]
    pub rotated_at: u64,
    /// Signature from the OLD key over this message (proves control of old key)
    #[prost(bytes = "vec", tag = "5")]
    pub old_key_signature: ::prost::alloc::vec::Vec<u8>,
}
/// The anchor event that locks policy decisions for a changeset.
/// All subsequent lease issuance and receipt validation must reference
/// this anchor's resolved_policy_hash.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyResolvedForChangeSet {
    /// Work item this policy resolution applies to
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// Hash binding to specific changeset (32 bytes)
    #[prost(bytes = "vec", tag = "2")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the resolved policy tuple (32 bytes)
    /// Computed from: risk_tier || determinism_class || sorted(rcp_profile_ids) ||
    ///                 sorted(rcp_manifest_hashes) || sorted(verifier_policy_hashes)
    #[prost(bytes = "vec", tag = "3")]
    pub resolved_policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// Resolved risk tier (0-4)
    #[prost(uint32, tag = "4")]
    pub resolved_risk_tier: u32,
    /// Resolved determinism class (0=non, 1=soft, 2=fully)
    #[prost(uint32, tag = "5")]
    pub resolved_determinism_class: u32,
    /// Resolved RCP profile IDs (sorted for canonical encoding)
    #[prost(string, repeated, tag = "6")]
    pub resolved_rcp_profile_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Hashes of resolved RCP manifests (sorted, each 32 bytes)
    #[prost(bytes = "vec", repeated, tag = "7")]
    pub resolved_rcp_manifest_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// Hashes of resolved verifier policies (sorted, each 32 bytes)
    #[prost(bytes = "vec", repeated, tag = "8")]
    pub resolved_verifier_policy_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// Actor who performed the policy resolution
    #[prost(string, tag = "9")]
    pub resolver_actor_id: ::prost::alloc::string::String,
    /// Version of the resolver component
    #[prost(string, tag = "10")]
    pub resolver_version: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with POLICY_RESOLVED_FOR_CHANGESET: domain (64 bytes)
    #[prost(bytes = "vec", tag = "11")]
    pub resolver_signature: ::prost::alloc::vec::Vec<u8>,
}
/// GateReceipt envelope with versioning support.
/// This is the canonical receipt envelope that wraps gate-specific payloads.
/// The receipt binds a gate execution result to a specific lease and changeset.
///
/// Versioning:
/// - receipt_version: Envelope schema version (currently: 1)
/// - payload_kind: Type of payload ("aat", "quality", "security")
/// - payload_schema_version: Version of the payload schema
///
/// Security:
/// - receipt_signature uses GATE_RECEIPT: domain prefix
/// - All fields except signature are included in canonical bytes
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateReceipt {
    /// Unique identifier for this receipt
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    /// Gate that generated this receipt
    #[prost(string, tag = "2")]
    pub gate_id: ::prost::alloc::string::String,
    /// Lease that authorized this gate execution
    #[prost(string, tag = "3")]
    pub lease_id: ::prost::alloc::string::String,
    /// Hash binding to specific changeset (32 bytes)
    #[prost(bytes = "vec", tag = "4")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Actor who executed the gate
    #[prost(string, tag = "5")]
    pub executor_actor_id: ::prost::alloc::string::String,
    /// Envelope schema version (supported: 1)
    #[prost(uint32, tag = "6")]
    pub receipt_version: u32,
    /// Type of payload: "aat", "quality", "security"
    #[prost(string, tag = "7")]
    pub payload_kind: ::prost::alloc::string::String,
    /// Version of the payload schema
    #[prost(uint32, tag = "8")]
    pub payload_schema_version: u32,
    /// Hash of the payload content (32 bytes)
    #[prost(bytes = "vec", tag = "9")]
    pub payload_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the evidence bundle (32 bytes)
    #[prost(bytes = "vec", tag = "10")]
    pub evidence_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    /// Ed25519 signature over canonical bytes with GATE_RECEIPT: domain (64 bytes)
    #[prost(bytes = "vec", tag = "11")]
    pub receipt_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Output from a terminal verifier.
/// Terminal verifiers provide ground truth (exit codes, snapshot diffs, etc.).
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TerminalVerifierOutput {
    /// Kind of verifier: exit_code, snapshot_diff, structured_test_report, invariant_check
    #[prost(string, tag = "1")]
    pub verifier_kind: ::prost::alloc::string::String,
    /// Digest of the verifier output content (32 bytes).
    #[prost(bytes = "vec", tag = "2")]
    pub output_digest: ::prost::alloc::vec::Vec<u8>,
    /// Whether the machine predicate was satisfied.
    #[prost(bool, tag = "3")]
    pub predicate_satisfied: bool,
}
/// Attestation metadata for AAT execution environment.
/// Provides evidence chain for runtime environment verification.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatAttestation {
    /// Digest of the container image used (32 bytes).
    #[prost(bytes = "vec", tag = "1")]
    pub container_image_digest: ::prost::alloc::vec::Vec<u8>,
    /// Digests of toolchain components (each 32 bytes).
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub toolchain_digests: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Identity key ID of the runner.
    #[prost(string, tag = "3")]
    pub runner_identity_key_id: ::prost::alloc::string::String,
    /// Hash of the network policy profile (32 bytes).
    #[prost(bytes = "vec", tag = "4")]
    pub network_policy_profile_hash: ::prost::alloc::vec::Vec<u8>,
}
/// Typed payload for AAT gate receipts (22 required fields).
/// Stored in CAS and referenced by payload_hash from GateReceipt envelope.
///
/// Invariants:
/// - view_commitment_hash matches FAC-00 output
/// - rcp_manifest_hash matches FAC-02 output for profile
/// - run_receipt_hashes.len() == run_count
/// - transcript_chain_root_hash derivable from transcript_bundle_hash
/// - artifact_manifest_hash references CAS ArtifactManifest
/// - At least one terminal_verifier_output present for PASS
/// - predicate_satisfied == true for all verifier outputs when verdict == PASS
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatGateReceipt {
    /// ============== View commitment binding (fields 1-4) ==============
    /// Hash binding to view commitment from FAC-00 (32 bytes).
    #[prost(bytes = "vec", tag = "1")]
    pub view_commitment_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the RCP manifest for this profile (32 bytes).
    #[prost(bytes = "vec", tag = "2")]
    pub rcp_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// RCP profile identifier.
    #[prost(string, tag = "3")]
    pub rcp_profile_id: ::prost::alloc::string::String,
    /// Policy hash for anti-downgrade verification (32 bytes).
    #[prost(bytes = "vec", tag = "4")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// ============== Determinism tracking (fields 5-13) ==============
    /// Determinism class (0=non, 1=soft, 2=fully).
    #[prost(uint32, tag = "5")]
    pub determinism_class: u32,
    /// Whether terminal evidence was stable across runs.
    #[prost(enumeration = "DeterminismStatus", tag = "6")]
    pub determinism_status: i32,
    /// Classification of flakiness when mismatch occurs.
    #[prost(enumeration = "FlakeClass", tag = "7")]
    pub flake_class: i32,
    /// Number of AAT runs executed.
    #[prost(uint32, tag = "8")]
    pub run_count: u32,
    /// Hashes of individual run receipts (each 32 bytes, len == run_count).
    #[prost(bytes = "vec", repeated, tag = "9")]
    pub run_receipt_hashes: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Digest of machine-checkable terminal evidence (32 bytes).
    #[prost(bytes = "vec", tag = "10")]
    pub terminal_evidence_digest: ::prost::alloc::vec::Vec<u8>,
    /// Digest of observational evidence (logs, traces) - excluded from determinism (32 bytes).
    #[prost(bytes = "vec", tag = "11")]
    pub observational_evidence_digest: ::prost::alloc::vec::Vec<u8>,
    /// Digest of terminal verifier outputs (32 bytes).
    #[prost(bytes = "vec", tag = "12")]
    pub terminal_verifier_outputs_digest: ::prost::alloc::vec::Vec<u8>,
    /// Stability digest = hash(verdict, terminal_evidence_digest, terminal_verifier_outputs_digest) (32 bytes).
    #[prost(bytes = "vec", tag = "13")]
    pub stability_digest: ::prost::alloc::vec::Vec<u8>,
    /// ============== Verdict (field 14) ==============
    /// AAT outcome verdict.
    #[prost(enumeration = "AatVerdict", tag = "14")]
    pub verdict: i32,
    /// ============== Evidence binding (fields 15-19) ==============
    /// Root hash of the transcript chain (32 bytes).
    #[prost(bytes = "vec", tag = "15")]
    pub transcript_chain_root_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the transcript bundle in CAS (32 bytes).
    #[prost(bytes = "vec", tag = "16")]
    pub transcript_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the artifact manifest in CAS (32 bytes).
    #[prost(bytes = "vec", tag = "17")]
    pub artifact_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// Terminal verifier outputs with predicate satisfaction.
    #[prost(message, repeated, tag = "18")]
    pub terminal_verifier_outputs: ::prost::alloc::vec::Vec<TerminalVerifierOutput>,
    /// Hash of the verifier policy (32 bytes).
    #[prost(bytes = "vec", tag = "19")]
    pub verifier_policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// ============== Risk tier (fields 20-21) ==============
    /// Selection policy identifier.
    #[prost(string, tag = "20")]
    pub selection_policy_id: ::prost::alloc::string::String,
    /// Risk tier for AAT selection (0-4: Tier0-Tier4).
    /// Stored as uint32 for fidelity preservation across proto roundtrips.
    #[prost(uint32, tag = "21")]
    pub risk_tier: u32,
    /// ============== Attestation (field 22) ==============
    /// Execution environment attestation.
    #[prost(message, optional, tag = "22")]
    pub attestation: ::core::option::Option<AatAttestation>,
}
/// Emitted when divergence is detected between the ledger's MergeReceipt
/// and the external trunk HEAD. This freezes the specified scope to
/// prevent further admissions until adjudication.
///
/// Security: Divergence detection is critical for maintaining ledger integrity.
/// Any external modification of the trunk triggers immediate freeze.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterventionFreeze {
    /// Unique identifier for this freeze event.
    #[prost(string, tag = "1")]
    pub freeze_id: ::prost::alloc::string::String,
    /// Scope of the freeze (repository, work, namespace).
    #[prost(enumeration = "InterventionScope", tag = "2")]
    pub scope: i32,
    /// Value identifying the frozen scope (repo path, work_id, namespace).
    #[prost(string, tag = "3")]
    pub scope_value: ::prost::alloc::string::String,
    /// ID of the DefectRecord that triggered this freeze.
    #[prost(string, tag = "4")]
    pub trigger_defect_id: ::prost::alloc::string::String,
    /// Timestamp when the freeze was applied (Unix nanoseconds).
    #[prost(uint64, tag = "5")]
    pub frozen_at: u64,
    /// Expected trunk HEAD from the latest MergeReceipt.
    #[prost(bytes = "vec", tag = "6")]
    pub expected_trunk_head: ::prost::alloc::vec::Vec<u8>,
    /// Actual trunk HEAD observed externally.
    #[prost(bytes = "vec", tag = "7")]
    pub actual_trunk_head: ::prost::alloc::vec::Vec<u8>,
    /// Actor who detected the divergence and issued the freeze.
    #[prost(string, tag = "8")]
    pub gate_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with INTERVENTION_FREEZE: domain (64 bytes).
    #[prost(bytes = "vec", tag = "9")]
    pub gate_signature: ::prost::alloc::vec::Vec<u8>,
    /// Reference to the time envelope for temporal authority.
    #[prost(string, tag = "10")]
    pub time_envelope_ref: ::prost::alloc::string::String,
}
/// Emitted when a frozen scope is unfrozen after adjudication.
/// The unfreeze must reference a valid adjudication decision.
///
/// Security: Unfreeze cannot bypass adjudication. All unfreezes must
/// be traceable to a resolution decision.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct InterventionUnfreeze {
    /// ID of the InterventionFreeze being lifted.
    #[prost(string, tag = "1")]
    pub freeze_id: ::prost::alloc::string::String,
    /// How the freeze was resolved.
    #[prost(enumeration = "InterventionResolutionType", tag = "2")]
    pub resolution_type: i32,
    /// ID of the adjudication that resolved the freeze.
    #[prost(string, tag = "3")]
    pub adjudication_id: ::prost::alloc::string::String,
    /// Timestamp when the unfreeze was applied (Unix nanoseconds).
    #[prost(uint64, tag = "4")]
    pub unfrozen_at: u64,
    /// Actor who issued the unfreeze (must be authorized).
    #[prost(string, tag = "5")]
    pub gate_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with INTERVENTION_UNFREEZE: domain (64 bytes).
    #[prost(bytes = "vec", tag = "6")]
    pub gate_signature: ::prost::alloc::vec::Vec<u8>,
    /// Reference to the time envelope for temporal authority.
    #[prost(string, tag = "7")]
    pub time_envelope_ref: ::prost::alloc::string::String,
}
/// Digest and metadata for a single evidence artifact.
/// Each artifact is identified by its content digest and includes metadata
/// for access control, redaction tracking, and retention policy.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactDigest {
    /// Type of artifact (Log, Junit, Coverage, Snapshot, Binary).
    #[prost(enumeration = "ArtifactType", tag = "1")]
    pub artifact_type: i32,
    /// SHA-256 digest of the artifact content (32 bytes).
    #[prost(bytes = "vec", tag = "2")]
    pub digest: ::prost::alloc::vec::Vec<u8>,
    /// Data classification for access control.
    #[prost(enumeration = "DataClassification", tag = "3")]
    pub data_classification: i32,
    /// Whether redaction/sanitization was applied to this artifact.
    #[prost(bool, tag = "4")]
    pub redaction_applied: bool,
    /// Hash of the redaction profile used (32 bytes, required if redaction_applied).
    #[prost(bytes = "vec", tag = "5")]
    pub redaction_profile_hash: ::prost::alloc::vec::Vec<u8>,
    /// Reference to the retention window for this artifact.
    /// Uses HTF time envelope format (e.g., "htf:window:30d").
    #[prost(string, tag = "6")]
    pub retention_window_ref: ::prost::alloc::string::String,
}
/// Manifest of evidence artifacts for a gate receipt.
/// The manifest binds all evidence artifacts produced during gate execution,
/// enabling independent verification and retention management.
///
/// Invariants:
/// - Must contain at least one artifact (empty manifests are rejected)
/// - No duplicate digests allowed
/// - All artifacts must pass hygiene validation
///
/// Security: The manifest is referenced by artifact_manifest_hash in
/// AatGateReceipt and stored in CAS for independent verification.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ArtifactManifest {
    /// List of artifact digests and metadata.
    #[prost(message, repeated, tag = "1")]
    pub artifacts: ::prost::alloc::vec::Vec<ArtifactDigest>,
}
/// Provenance tuple identifying the context of an AAT execution.
/// Used to verify that a reused result is valid for the current context.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatProvenanceTuple {
    /// Hash binding to specific changeset (32 bytes).
    #[prost(bytes = "vec", tag = "1")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Hash binding to view commitment (32 bytes).
    #[prost(bytes = "vec", tag = "2")]
    pub view_commitment_hash: ::prost::alloc::vec::Vec<u8>,
    /// RCP profile identifier.
    #[prost(string, tag = "3")]
    pub rcp_profile_id: ::prost::alloc::string::String,
    /// Hash of the verifier policy (32 bytes).
    #[prost(bytes = "vec", tag = "4")]
    pub verifier_policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// Determinism class (0=non, 1=soft, 2=fully).
    #[prost(uint32, tag = "5")]
    pub determinism_class: u32,
}
/// Emitted when an AAT result is reused.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatResultReused {
    /// Hash of the original AatGateReceipt being reused (32 bytes).
    #[prost(bytes = "vec", tag = "1")]
    pub from_receipt_hash: ::prost::alloc::vec::Vec<u8>,
    /// Provenance tuple of the current context (must match original).
    #[prost(message, optional, tag = "2")]
    pub provenance: ::core::option::Option<AatProvenanceTuple>,
    /// Policy hash for the current admission attempt (32 bytes).
    #[prost(bytes = "vec", tag = "3")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// Human-readable justification for reuse.
    #[prost(string, tag = "4")]
    pub justification: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with AAT_RESULT_REUSED: domain (64 bytes).
    #[prost(bytes = "vec", tag = "5")]
    pub gate_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Determinism status for AAT runs.
/// Indicates whether multiple runs produced consistent terminal evidence.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DeterminismStatus {
    /// Unspecified status (invalid).
    Unspecified = 0,
    /// All runs produced identical terminal evidence.
    Stable = 1,
    /// Runs produced different terminal evidence.
    Mismatch = 2,
}
impl DeterminismStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DETERMINISM_STATUS_UNSPECIFIED",
            Self::Stable => "DETERMINISM_STATUS_STABLE",
            Self::Mismatch => "DETERMINISM_STATUS_MISMATCH",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DETERMINISM_STATUS_UNSPECIFIED" => Some(Self::Unspecified),
            "DETERMINISM_STATUS_STABLE" => Some(Self::Stable),
            "DETERMINISM_STATUS_MISMATCH" => Some(Self::Mismatch),
            _ => None,
        }
    }
}
/// Classification of flakiness when determinism mismatch occurs.
/// Used for routing to appropriate quarantine/remediation paths.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum FlakeClass {
    /// Unspecified class (invalid).
    Unspecified = 0,
    /// Deterministic failure - consistent FAIL across all runs.
    DeterministicFail = 1,
    /// Flakiness due to test harness issues (e.g., timing, resource contention).
    HarnessFlake = 2,
    /// Flakiness due to environment drift (e.g., dependency version mismatch).
    EnvironmentDrift = 3,
    /// Test-level non-semantic difference (e.g., output format changes).
    TestNonsemantic = 4,
    /// Code-level non-semantic difference (e.g., timestamps, random IDs).
    CodeNonsemantic = 5,
    /// Unknown flakiness cause requiring investigation.
    Unknown = 6,
}
impl FlakeClass {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "FLAKE_CLASS_UNSPECIFIED",
            Self::DeterministicFail => "FLAKE_CLASS_DETERMINISTIC_FAIL",
            Self::HarnessFlake => "FLAKE_CLASS_HARNESS_FLAKE",
            Self::EnvironmentDrift => "FLAKE_CLASS_ENVIRONMENT_DRIFT",
            Self::TestNonsemantic => "FLAKE_CLASS_TEST_NONSEMANTIC",
            Self::CodeNonsemantic => "FLAKE_CLASS_CODE_NONSEMANTIC",
            Self::Unknown => "FLAKE_CLASS_UNKNOWN",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "FLAKE_CLASS_UNSPECIFIED" => Some(Self::Unspecified),
            "FLAKE_CLASS_DETERMINISTIC_FAIL" => Some(Self::DeterministicFail),
            "FLAKE_CLASS_HARNESS_FLAKE" => Some(Self::HarnessFlake),
            "FLAKE_CLASS_ENVIRONMENT_DRIFT" => Some(Self::EnvironmentDrift),
            "FLAKE_CLASS_TEST_NONSEMANTIC" => Some(Self::TestNonsemantic),
            "FLAKE_CLASS_CODE_NONSEMANTIC" => Some(Self::CodeNonsemantic),
            "FLAKE_CLASS_UNKNOWN" => Some(Self::Unknown),
            _ => None,
        }
    }
}
/// AAT verdict outcome.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AatVerdict {
    /// Unspecified verdict (invalid).
    Unspecified = 0,
    /// All acceptance criteria passed.
    Pass = 1,
    /// One or more acceptance criteria failed.
    Fail = 2,
    /// Additional input required to determine outcome.
    NeedsInput = 3,
}
impl AatVerdict {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AAT_VERDICT_UNSPECIFIED",
            Self::Pass => "AAT_VERDICT_PASS",
            Self::Fail => "AAT_VERDICT_FAIL",
            Self::NeedsInput => "AAT_VERDICT_NEEDS_INPUT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AAT_VERDICT_UNSPECIFIED" => Some(Self::Unspecified),
            "AAT_VERDICT_PASS" => Some(Self::Pass),
            "AAT_VERDICT_FAIL" => Some(Self::Fail),
            "AAT_VERDICT_NEEDS_INPUT" => Some(Self::NeedsInput),
            _ => None,
        }
    }
}
/// Risk tier for AAT selection policy.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AatRiskTier {
    /// Unspecified tier (invalid).
    Unspecified = 0,
    /// High risk - AAT always required.
    High = 1,
    /// Medium risk - AAT required for sensitive domains.
    Med = 2,
    /// Low risk - AAT sampled with nightly full coverage.
    Low = 3,
}
impl AatRiskTier {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "AAT_RISK_TIER_UNSPECIFIED",
            Self::High => "AAT_RISK_TIER_HIGH",
            Self::Med => "AAT_RISK_TIER_MED",
            Self::Low => "AAT_RISK_TIER_LOW",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "AAT_RISK_TIER_UNSPECIFIED" => Some(Self::Unspecified),
            "AAT_RISK_TIER_HIGH" => Some(Self::High),
            "AAT_RISK_TIER_MED" => Some(Self::Med),
            "AAT_RISK_TIER_LOW" => Some(Self::Low),
            _ => None,
        }
    }
}
/// Scope of an intervention freeze.
/// Determines what is frozen by the intervention.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InterventionScope {
    /// Unspecified scope (invalid).
    Unspecified = 0,
    /// Freeze applies to a specific repository.
    Repository = 1,
    /// Freeze applies to a specific work item.
    Work = 2,
    /// Freeze applies to all repositories in a namespace.
    Namespace = 3,
}
impl InterventionScope {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "INTERVENTION_SCOPE_UNSPECIFIED",
            Self::Repository => "INTERVENTION_SCOPE_REPOSITORY",
            Self::Work => "INTERVENTION_SCOPE_WORK",
            Self::Namespace => "INTERVENTION_SCOPE_NAMESPACE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTERVENTION_SCOPE_UNSPECIFIED" => Some(Self::Unspecified),
            "INTERVENTION_SCOPE_REPOSITORY" => Some(Self::Repository),
            "INTERVENTION_SCOPE_WORK" => Some(Self::Work),
            "INTERVENTION_SCOPE_NAMESPACE" => Some(Self::Namespace),
            _ => None,
        }
    }
}
/// Resolution type for intervention unfreeze.
/// Indicates how the freeze was resolved.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum InterventionResolutionType {
    /// Unspecified resolution (invalid).
    InterventionResolutionUnspecified = 0,
    /// Resolved through adjudication process.
    InterventionResolutionAdjudication = 1,
    /// Resolved by manual operator intervention.
    InterventionResolutionManual = 2,
    /// Resolved by rollback to last known good state.
    InterventionResolutionRollback = 3,
    /// Resolved by accepting the divergent state as new baseline.
    InterventionResolutionAcceptDivergence = 4,
}
impl InterventionResolutionType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::InterventionResolutionUnspecified => {
                "INTERVENTION_RESOLUTION_UNSPECIFIED"
            }
            Self::InterventionResolutionAdjudication => {
                "INTERVENTION_RESOLUTION_ADJUDICATION"
            }
            Self::InterventionResolutionManual => "INTERVENTION_RESOLUTION_MANUAL",
            Self::InterventionResolutionRollback => "INTERVENTION_RESOLUTION_ROLLBACK",
            Self::InterventionResolutionAcceptDivergence => {
                "INTERVENTION_RESOLUTION_ACCEPT_DIVERGENCE"
            }
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "INTERVENTION_RESOLUTION_UNSPECIFIED" => {
                Some(Self::InterventionResolutionUnspecified)
            }
            "INTERVENTION_RESOLUTION_ADJUDICATION" => {
                Some(Self::InterventionResolutionAdjudication)
            }
            "INTERVENTION_RESOLUTION_MANUAL" => Some(Self::InterventionResolutionManual),
            "INTERVENTION_RESOLUTION_ROLLBACK" => {
                Some(Self::InterventionResolutionRollback)
            }
            "INTERVENTION_RESOLUTION_ACCEPT_DIVERGENCE" => {
                Some(Self::InterventionResolutionAcceptDivergence)
            }
            _ => None,
        }
    }
}
/// Type of evidence artifact.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ArtifactType {
    /// Unspecified type (invalid).
    Unspecified = 0,
    /// Execution logs and traces.
    Log = 1,
    /// JUnit/xUnit test reports.
    Junit = 2,
    /// Code coverage reports.
    Coverage = 3,
    /// State snapshots for determinism verification.
    Snapshot = 4,
    /// Compiled artifacts (executables, libraries).
    Binary = 5,
}
impl ArtifactType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ARTIFACT_TYPE_UNSPECIFIED",
            Self::Log => "ARTIFACT_TYPE_LOG",
            Self::Junit => "ARTIFACT_TYPE_JUNIT",
            Self::Coverage => "ARTIFACT_TYPE_COVERAGE",
            Self::Snapshot => "ARTIFACT_TYPE_SNAPSHOT",
            Self::Binary => "ARTIFACT_TYPE_BINARY",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ARTIFACT_TYPE_UNSPECIFIED" => Some(Self::Unspecified),
            "ARTIFACT_TYPE_LOG" => Some(Self::Log),
            "ARTIFACT_TYPE_JUNIT" => Some(Self::Junit),
            "ARTIFACT_TYPE_COVERAGE" => Some(Self::Coverage),
            "ARTIFACT_TYPE_SNAPSHOT" => Some(Self::Snapshot),
            "ARTIFACT_TYPE_BINARY" => Some(Self::Binary),
            _ => None,
        }
    }
}
/// Data classification level for evidence artifacts.
/// Determines access control and handling requirements.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum DataClassification {
    /// Unspecified classification (invalid).
    Unspecified = 0,
    /// No access restrictions.
    Public = 1,
    /// Organization-internal access only.
    Internal = 2,
    /// Restricted access with audit logging.
    Confidential = 3,
    /// Maximum security controls required.
    Restricted = 4,
}
impl DataClassification {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "DATA_CLASSIFICATION_UNSPECIFIED",
            Self::Public => "DATA_CLASSIFICATION_PUBLIC",
            Self::Internal => "DATA_CLASSIFICATION_INTERNAL",
            Self::Confidential => "DATA_CLASSIFICATION_CONFIDENTIAL",
            Self::Restricted => "DATA_CLASSIFICATION_RESTRICTED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "DATA_CLASSIFICATION_UNSPECIFIED" => Some(Self::Unspecified),
            "DATA_CLASSIFICATION_PUBLIC" => Some(Self::Public),
            "DATA_CLASSIFICATION_INTERNAL" => Some(Self::Internal),
            "DATA_CLASSIFICATION_CONFIDENTIAL" => Some(Self::Confidential),
            "DATA_CLASSIFICATION_RESTRICTED" => Some(Self::Restricted),
            _ => None,
        }
    }
}
