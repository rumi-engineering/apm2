// This file is @generated by prost-build.
/// Common envelope for all kernel events
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelEvent {
    /// Monotonic sequence number within this ledger
    #[prost(uint64, tag = "1")]
    pub sequence: u64,
    /// Hash of the previous event.
    /// For genesis events: use 32 zero bytes (canonical representation).
    /// Note: The ledger may store NULL for genesis as a storage optimization,
    /// but it must be normalized to 32 zero bytes at API boundaries.
    #[prost(bytes = "vec", tag = "2")]
    pub previous_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when event was created
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Actor ID that produced this event
    #[prost(string, tag = "4")]
    pub actor_id: ::prost::alloc::string::String,
    /// Session ID (if applicable)
    #[prost(string, tag = "5")]
    pub session_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes of this message
    #[prost(bytes = "vec", tag = "6")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// Schema version for forward/backward compatibility
    /// Current version: 1
    #[prost(uint32, tag = "7")]
    pub schema_version: u32,
    /// Event payload (oneof)
    #[prost(
        oneof = "kernel_event::Payload",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21"
    )]
    pub payload: ::core::option::Option<kernel_event::Payload>,
}
/// Nested message and enum types in `KernelEvent`.
pub mod kernel_event {
    /// Event payload (oneof)
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Session(super::SessionEvent),
        #[prost(message, tag = "11")]
        Work(super::WorkEvent),
        #[prost(message, tag = "12")]
        Tool(super::ToolEvent),
        #[prost(message, tag = "13")]
        Lease(super::LeaseEvent),
        #[prost(message, tag = "14")]
        Policy(super::PolicyEvent),
        #[prost(message, tag = "15")]
        Adjudication(super::AdjudicationEvent),
        #[prost(message, tag = "16")]
        Evidence(super::EvidenceEvent),
        #[prost(message, tag = "17")]
        Key(super::KeyEvent),
        #[prost(message, tag = "18")]
        Capability(super::CapabilityEvent),
        #[prost(message, tag = "19")]
        GithubLease(super::GitHubLeaseEvent),
        #[prost(message, tag = "20")]
        PolicyResolvedForChangeset(super::PolicyResolvedForChangeSet),
        #[prost(message, tag = "21")]
        GateReceipt(super::GateReceipt),
    }
}
/// ============================================================
/// SESSION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionEvent {
    #[prost(oneof = "session_event::Event", tags = "1, 2, 3, 4, 5, 6")]
    pub event: ::core::option::Option<session_event::Event>,
}
/// Nested message and enum types in `SessionEvent`.
pub mod session_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Started(super::SessionStarted),
        #[prost(message, tag = "2")]
        Progress(super::SessionProgress),
        #[prost(message, tag = "3")]
        Terminated(super::SessionTerminated),
        #[prost(message, tag = "4")]
        Quarantined(super::SessionQuarantined),
        #[prost(message, tag = "5")]
        CrashDetected(super::SessionCrashDetected),
        #[prost(message, tag = "6")]
        RestartScheduled(super::SessionRestartScheduled),
    }
}
/// Emitted when a session process exits unexpectedly or crashes.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionCrashDetected {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// CLEAN_EXIT, ERROR_EXIT, SIGNAL, TIMEOUT, ENTROPY_EXCEEDED
    #[prost(string, tag = "2")]
    pub crash_type: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub exit_code: i32,
    #[prost(int32, tag = "4")]
    pub signal: i32,
    #[prost(uint64, tag = "5")]
    pub uptime_ms: u64,
    #[prost(uint64, tag = "6")]
    pub last_cursor: u64,
    #[prost(uint32, tag = "7")]
    pub restart_count: u32,
}
/// Emitted when a restart has been scheduled for a crashed session.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionRestartScheduled {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub scheduled_at: u64,
    #[prost(uint64, tag = "3")]
    pub restart_at: u64,
    #[prost(uint64, tag = "4")]
    pub resume_cursor: u64,
    #[prost(uint32, tag = "5")]
    pub attempt_number: u32,
    /// FIXED, EXPONENTIAL, LINEAR
    #[prost(string, tag = "6")]
    pub backoff_type: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionStarted {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub adapter_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub entropy_budget: u64,
    /// For restarted sessions: cursor to resume from
    #[prost(uint64, tag = "7")]
    pub resume_cursor: u64,
    /// For restarted sessions: restart attempt number (0 = first start)
    #[prost(uint32, tag = "8")]
    pub restart_attempt: u32,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionProgress {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub progress_sequence: u64,
    /// HEARTBEAT, TOOL_COMPLETE, MILESTONE
    #[prost(string, tag = "3")]
    pub progress_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub entropy_consumed: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionTerminated {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT, ENTROPY_EXCEEDED
    #[prost(string, tag = "2")]
    pub exit_classification: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub final_entropy: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionQuarantined {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub quarantine_until: u64,
}
/// ============================================================
/// WORK EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkEvent {
    #[prost(oneof = "work_event::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<work_event::Event>,
}
/// Nested message and enum types in `WorkEvent`.
pub mod work_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Opened(super::WorkOpened),
        #[prost(message, tag = "2")]
        Transitioned(super::WorkTransitioned),
        #[prost(message, tag = "3")]
        Completed(super::WorkCompleted),
        #[prost(message, tag = "4")]
        Aborted(super::WorkAborted),
        #[prost(message, tag = "5")]
        PrAssociated(super::WorkPrAssociated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkOpened {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// TICKET, PRD_REFINEMENT, RFC_REFINEMENT, REVIEW
    #[prost(string, tag = "2")]
    pub work_type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub spec_snapshot_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "4")]
    pub requirement_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub parent_work_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkTransitioned {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub from_state: ::prost::alloc::string::String,
    /// Valid states: OPEN, CLAIMED, IN_PROGRESS, CI_PENDING, READY_FOR_REVIEW,
    /// BLOCKED, REVIEW, NEEDS_INPUT, NEEDS_ADJUDICATION
    #[prost(string, tag = "3")]
    pub to_state: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rationale_code: ::prost::alloc::string::String,
    /// Previous transition count for replay protection.
    /// MUST match work.transition_count before this transition.
    /// This field is strictly validated to prevent replay attacks.
    /// For the first transition (Open -> Claimed), use 0.
    #[prost(uint32, tag = "5")]
    pub previous_transition_count: u32,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkCompleted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub evidence_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "3")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub gate_receipt_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkAborted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// POLICY_DENY, TIMEOUT, ENTROPY_EXCEEDED, MANUAL
    #[prost(string, tag = "2")]
    pub abort_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
}
/// Emitted when a PR is created and associated with a work item.
/// This enables CI event matching for phase transitions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkPrAssociated {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub pr_number: u64,
    /// The commit SHA that triggered the CI workflow
    #[prost(string, tag = "3")]
    pub commit_sha: ::prost::alloc::string::String,
}
/// ============================================================
/// TOOL EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolEvent {
    #[prost(oneof = "tool_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<tool_event::Event>,
}
/// Nested message and enum types in `ToolEvent`.
pub mod tool_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::ToolRequested),
        #[prost(message, tag = "2")]
        Decided(super::ToolDecided),
        #[prost(message, tag = "3")]
        Executed(super::ToolExecuted),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolRequested {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tool_name: ::prost::alloc::string::String,
    /// Hash of arguments (full args stored in CAS)
    #[prost(bytes = "vec", tag = "4")]
    pub tool_args_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub dedupe_key: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolDecided {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// ALLOW, DENY
    #[prost(string, tag = "2")]
    pub decision: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub budget_consumed: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolExecuted {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT
    #[prost(string, tag = "2")]
    pub outcome: ::prost::alloc::string::String,
    /// Hash of result (full result stored in CAS)
    #[prost(bytes = "vec", tag = "3")]
    pub result_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub duration_ms: u64,
}
/// ============================================================
/// LEASE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseEvent {
    #[prost(oneof = "lease_event::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<lease_event::Event>,
}
/// Nested message and enum types in `LeaseEvent`.
pub mod lease_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Issued(super::LeaseIssued),
        #[prost(message, tag = "2")]
        Renewed(super::LeaseRenewed),
        #[prost(message, tag = "3")]
        Released(super::LeaseReleased),
        #[prost(message, tag = "4")]
        Expired(super::LeaseExpired),
        #[prost(message, tag = "5")]
        Conflict(super::LeaseConflict),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseIssued {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub issued_at: u64,
    #[prost(uint64, tag = "5")]
    pub expires_at: u64,
    #[prost(bytes = "vec", tag = "6")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseRenewed {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub new_expires_at: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseReleased {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// COMPLETED, ABORTED, VOLUNTARY
    #[prost(string, tag = "2")]
    pub release_reason: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseExpired {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub expired_at: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseConflict {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub conflicting_lease_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// CANONICAL_ROOT, ADJUDICATION_REQUIRED
    #[prost(string, tag = "3")]
    pub resolution: ::prost::alloc::string::String,
}
/// ============================================================
/// POLICY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyEvent {
    #[prost(oneof = "policy_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<policy_event::Event>,
}
/// Nested message and enum types in `PolicyEvent`.
pub mod policy_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Loaded(super::PolicyLoaded),
        #[prost(message, tag = "2")]
        Violation(super::PolicyViolation),
        #[prost(message, tag = "3")]
        BudgetExceeded(super::BudgetExceeded),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyLoaded {
    #[prost(bytes = "vec", tag = "1")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub policy_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub rule_count: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyViolation {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub violation_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub details: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BudgetExceeded {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// TOKEN, TIME, TOOL_CALLS
    #[prost(string, tag = "2")]
    pub budget_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    #[prost(uint64, tag = "4")]
    pub consumed: u64,
}
/// ============================================================
/// ADJUDICATION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationEvent {
    #[prost(oneof = "adjudication_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<adjudication_event::Event>,
}
/// Nested message and enum types in `AdjudicationEvent`.
pub mod adjudication_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::AdjudicationRequested),
        #[prost(message, tag = "2")]
        Vote(super::AdjudicationVote),
        #[prost(message, tag = "3")]
        Resolved(super::AdjudicationResolved),
        #[prost(message, tag = "4")]
        Timeout(super::AdjudicationTimeout),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationRequested {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// BOUNDED_CHOICE, WAIVER, GATE_REVIEW
    #[prost(string, tag = "3")]
    pub request_type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "5")]
    pub deadline: u64,
    #[prost(string, tag = "6")]
    pub fallback_policy: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationVote {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub voter_actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub voter_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationResolved {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub votes_for: u64,
    #[prost(uint64, tag = "4")]
    pub votes_against: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub quorum_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationTimeout {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub applied_fallback: ::prost::alloc::string::String,
}
/// ============================================================
/// EVIDENCE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidenceEvent {
    #[prost(oneof = "evidence_event::Event", tags = "1, 2")]
    pub event: ::core::option::Option<evidence_event::Event>,
}
/// Nested message and enum types in `EvidenceEvent`.
pub mod evidence_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Published(super::EvidencePublished),
        #[prost(message, tag = "2")]
        GateReceipt(super::GateReceiptGenerated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidencePublished {
    #[prost(string, tag = "1")]
    pub evidence_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub category: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub artifact_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "5")]
    pub verification_command_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Data classification: PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED
    #[prost(string, tag = "6")]
    pub classification: ::prost::alloc::string::String,
    /// Artifact size in bytes (for bundle size tracking)
    #[prost(uint64, tag = "7")]
    pub artifact_size: u64,
    /// Metadata key-value pairs as "key=value" strings
    #[prost(string, repeated, tag = "8")]
    pub metadata: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateReceiptGenerated {
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gate_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub work_id: ::prost::alloc::string::String,
    /// PASS, FAIL
    #[prost(string, tag = "4")]
    pub result: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "6")]
    pub receipt_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityEvent {
    #[prost(oneof = "capability_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<capability_event::Event>,
}
/// Nested message and enum types in `CapabilityEvent`.
pub mod capability_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Required(super::CapabilityRequired),
        #[prost(message, tag = "2")]
        Granted(super::CapabilityGranted),
        #[prost(message, tag = "3")]
        Delegated(super::CapabilityDelegated),
        #[prost(message, tag = "4")]
        Revoked(super::CapabilityRevoked),
    }
}
/// Emitted during planning phase when a capability is required for a plan step.
/// This event enables capability negotiation and tracking.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityRequired {
    /// The capability ID that is required (e.g., "cac:patch:apply")
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// The work ID this requirement is associated with
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// Whether this capability is required (true) or optional (false)
    #[prost(bool, tag = "3")]
    pub required: bool,
    /// The status of the capability: AVAILABLE, UNAVAILABLE, DEGRADED
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
    /// Human-readable reason for the status
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
}
/// Emitted when a capability is granted to an actor by an authority.
/// This is the root of a delegation chain and must be signed by the registrar.
/// Links to the lease system: capability_id == lease_id.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityGranted {
    /// Unique identifier for this capability (equals lease_id for lease-backed capabilities)
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// Namespace this capability is bound to (prevents cross-namespace replay)
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor receiving the capability
    #[prost(string, tag = "3")]
    pub grantee_actor_id: ::prost::alloc::string::String,
    /// Actor granting the capability (must be an authority in the namespace)
    #[prost(string, tag = "4")]
    pub grantor_actor_id: ::prost::alloc::string::String,
    /// Hash of the serialized LeaseScope (stored in CAS)
    #[prost(bytes = "vec", tag = "5")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// Optional hash of the serialized Budget (stored in CAS)
    #[prost(bytes = "vec", tag = "6")]
    pub budget_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the capability was granted (Unix nanos)
    #[prost(uint64, tag = "7")]
    pub granted_at: u64,
    /// Timestamp when the capability expires (Unix nanos)
    #[prost(uint64, tag = "8")]
    pub expires_at: u64,
    /// Registrar signature over this grant (proves authority)
    #[prost(bytes = "vec", tag = "9")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
    /// Whether this capability can be delegated to others
    #[prost(bool, tag = "10")]
    pub delegatable: bool,
}
/// Emitted when a capability holder delegates their capability to another actor.
/// Forms part of the delegation chain for capability proofs.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityDelegated {
    /// New capability ID for the delegated capability
    #[prost(string, tag = "1")]
    pub delegated_capability_id: ::prost::alloc::string::String,
    /// Parent capability being delegated from
    #[prost(string, tag = "2")]
    pub parent_capability_id: ::prost::alloc::string::String,
    /// Hash of the parent CapabilityGranted or CapabilityDelegated event
    #[prost(bytes = "vec", tag = "3")]
    pub parent_capability_hash: ::prost::alloc::vec::Vec<u8>,
    /// Namespace this delegation is bound to (must match parent)
    #[prost(string, tag = "4")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor receiving the delegated capability
    #[prost(string, tag = "5")]
    pub delegatee_actor_id: ::prost::alloc::string::String,
    /// Actor delegating the capability (must hold parent capability)
    #[prost(string, tag = "6")]
    pub delegator_actor_id: ::prost::alloc::string::String,
    /// Hash of the serialized LeaseScope (must be subset of parent scope)
    #[prost(bytes = "vec", tag = "7")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// Optional hash of the serialized Budget (must be subset of parent budget)
    #[prost(bytes = "vec", tag = "8")]
    pub budget_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the delegation occurred (Unix nanos)
    #[prost(uint64, tag = "9")]
    pub delegated_at: u64,
    /// Timestamp when the delegated capability expires (Unix nanos, must be <= parent expires_at)
    #[prost(uint64, tag = "10")]
    pub expires_at: u64,
    /// Delegator's signature over this delegation (proves authority transfer)
    #[prost(bytes = "vec", tag = "11")]
    pub delegator_signature: ::prost::alloc::vec::Vec<u8>,
    /// Whether this delegated capability can be further delegated
    #[prost(bool, tag = "12")]
    pub delegatable: bool,
    /// Depth in the delegation chain (parent depth + 1)
    #[prost(uint32, tag = "13")]
    pub delegation_depth: u32,
}
/// Emitted when a capability is revoked before its natural expiration.
/// Revocation cascades to all delegated capabilities in the chain.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityRevoked {
    /// The capability being revoked
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// Namespace the capability belongs to
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor performing the revocation (must be grantor or authority)
    #[prost(string, tag = "3")]
    pub revoker_actor_id: ::prost::alloc::string::String,
    /// Reason for revocation: VOLUNTARY, POLICY_VIOLATION, KEY_COMPROMISE, SUPERSEDED
    #[prost(string, tag = "4")]
    pub revocation_reason: ::prost::alloc::string::String,
    /// Timestamp when the revocation occurred (Unix nanos)
    #[prost(uint64, tag = "5")]
    pub revoked_at: u64,
    /// Revoker's signature over this revocation
    #[prost(bytes = "vec", tag = "6")]
    pub revoker_signature: ::prost::alloc::vec::Vec<u8>,
    /// If true, revocation cascades to all delegated capabilities; if false, only this capability is revoked
    #[prost(bool, tag = "7")]
    pub cascade: bool,
}
/// ============================================================
/// KEY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyEvent {
    #[prost(oneof = "key_event::Event", tags = "1")]
    pub event: ::core::option::Option<key_event::Event>,
}
/// Nested message and enum types in `KeyEvent`.
pub mod key_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Rotated(super::KeyRotated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubLeaseEvent {
    #[prost(oneof = "git_hub_lease_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<git_hub_lease_event::Event>,
}
/// Nested message and enum types in `GitHubLeaseEvent`.
pub mod git_hub_lease_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Issued(super::GitHubLeaseIssued),
        #[prost(message, tag = "2")]
        Revoked(super::GitHubLeaseRevoked),
        #[prost(message, tag = "3")]
        OperationRecorded(super::GitHubOperationRecorded),
    }
}
/// Emitted when a GitHub installation access token is minted for an agent.
/// Links to the episode via episode_id and inherits risk tier constraints.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubLeaseIssued {
    /// Unique identifier for this GitHub lease
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// Episode this lease is bound to
    #[prost(string, tag = "2")]
    pub episode_id: ::prost::alloc::string::String,
    /// GitHub App ID (determines permission tier)
    #[prost(string, tag = "3")]
    pub github_app_id: ::prost::alloc::string::String,
    /// GitHub installation ID for the target repository/organization
    #[prost(string, tag = "4")]
    pub installation_id: ::prost::alloc::string::String,
    /// Risk tier of the requesting agent (0-4)
    /// Tier determines which GitHub App can be used:
    /// - T0: reader only
    /// - T1-T2: reader or developer
    /// - T3-T4: reader, developer, or operator
    #[prost(uint32, tag = "5")]
    pub risk_tier: u32,
    /// Hash of the requested GitHub scopes (scope list stored in CAS)
    #[prost(bytes = "vec", tag = "6")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// SHA-256 hash of the installation access token (NEVER store raw token)
    #[prost(bytes = "vec", tag = "7")]
    pub token_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the lease was issued (Unix nanos)
    #[prost(uint64, tag = "8")]
    pub issued_at: u64,
    /// Timestamp when the lease expires (Unix nanos)
    /// TTL is proportional to risk tier:
    /// - T0: 1 hour
    /// - T1-T2: 15-30 minutes
    /// - T3-T4: 2-5 minutes
    #[prost(uint64, tag = "9")]
    pub expires_at: u64,
    /// Hash of the capability manifest that authorized this lease
    #[prost(bytes = "vec", tag = "10")]
    pub capability_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// Issuer (registrar) signature over this event
    #[prost(bytes = "vec", tag = "11")]
    pub issuer_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted when a GitHub lease is revoked before expiration.
/// Revocation may be voluntary or forced (policy violation, key compromise).
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubLeaseRevoked {
    /// The lease being revoked
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// Episode the lease was bound to
    #[prost(string, tag = "2")]
    pub episode_id: ::prost::alloc::string::String,
    /// Reason for revocation: VOLUNTARY, EXPIRED, POLICY_VIOLATION, KEY_COMPROMISE
    #[prost(string, tag = "3")]
    pub revocation_reason: ::prost::alloc::string::String,
    /// Timestamp when the revocation occurred (Unix nanos)
    #[prost(uint64, tag = "4")]
    pub revoked_at: u64,
    /// Actor performing the revocation
    #[prost(string, tag = "5")]
    pub revoker_actor_id: ::prost::alloc::string::String,
    /// Revoker signature over this event
    #[prost(bytes = "vec", tag = "6")]
    pub revoker_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted for each GitHub API operation made with a leased token.
/// Provides audit trail for all GitHub interactions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GitHubOperationRecorded {
    /// Unique identifier for this operation record
    #[prost(string, tag = "1")]
    pub operation_id: ::prost::alloc::string::String,
    /// The lease that authorized this operation
    #[prost(string, tag = "2")]
    pub lease_id: ::prost::alloc::string::String,
    /// Episode context
    #[prost(string, tag = "3")]
    pub episode_id: ::prost::alloc::string::String,
    /// GitHub API endpoint called (e.g., "POST /repos/{owner}/{repo}/pulls")
    #[prost(string, tag = "4")]
    pub api_endpoint: ::prost::alloc::string::String,
    /// HTTP method: GET, POST, PUT, PATCH, DELETE
    #[prost(string, tag = "5")]
    pub http_method: ::prost::alloc::string::String,
    /// Target repository in owner/repo format
    #[prost(string, tag = "6")]
    pub repository: ::prost::alloc::string::String,
    /// Hash of the request body (request body stored in CAS if needed)
    #[prost(bytes = "vec", tag = "7")]
    pub request_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the response body (response body stored in CAS if needed)
    #[prost(bytes = "vec", tag = "8")]
    pub response_hash: ::prost::alloc::vec::Vec<u8>,
    /// HTTP status code returned
    #[prost(uint32, tag = "9")]
    pub status_code: u32,
    /// Timestamp when the operation was performed (Unix nanos)
    #[prost(uint64, tag = "10")]
    pub performed_at: u64,
    /// Duration of the API call in milliseconds
    #[prost(uint64, tag = "11")]
    pub duration_ms: u64,
    /// GitHub rate limit remaining after this call
    #[prost(uint32, tag = "12")]
    pub rate_limit_remaining: u32,
}
/// Event emitted when an actor rotates their signing key.
/// This establishes a chain of custody for key transitions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyRotated {
    /// Actor whose key is being rotated
    #[prost(string, tag = "1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Hash of the old verifying key (for reference)
    #[prost(bytes = "vec", tag = "2")]
    pub old_key_hash: ::prost::alloc::vec::Vec<u8>,
    /// New verifying (public) key bytes
    #[prost(bytes = "vec", tag = "3")]
    pub new_verifying_key: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the rotation occurred (Unix nanos)
    #[prost(uint64, tag = "4")]
    pub rotated_at: u64,
    /// Signature from the OLD key over this message (proves control of old key)
    #[prost(bytes = "vec", tag = "5")]
    pub old_key_signature: ::prost::alloc::vec::Vec<u8>,
}
/// The anchor event that locks policy decisions for a changeset.
/// All subsequent lease issuance and receipt validation must reference
/// this anchor's resolved_policy_hash.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyResolvedForChangeSet {
    /// Work item this policy resolution applies to
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// Hash binding to specific changeset (32 bytes)
    #[prost(bytes = "vec", tag = "2")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the resolved policy tuple (32 bytes)
    /// Computed from: risk_tier || determinism_class || sorted(rcp_profile_ids) ||
    ///                 sorted(rcp_manifest_hashes) || sorted(verifier_policy_hashes)
    #[prost(bytes = "vec", tag = "3")]
    pub resolved_policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// Resolved risk tier (0-4)
    #[prost(uint32, tag = "4")]
    pub resolved_risk_tier: u32,
    /// Resolved determinism class (0=non, 1=soft, 2=fully)
    #[prost(uint32, tag = "5")]
    pub resolved_determinism_class: u32,
    /// Resolved RCP profile IDs (sorted for canonical encoding)
    #[prost(string, repeated, tag = "6")]
    pub resolved_rcp_profile_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Hashes of resolved RCP manifests (sorted, each 32 bytes)
    #[prost(bytes = "vec", repeated, tag = "7")]
    pub resolved_rcp_manifest_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// Hashes of resolved verifier policies (sorted, each 32 bytes)
    #[prost(bytes = "vec", repeated, tag = "8")]
    pub resolved_verifier_policy_hashes: ::prost::alloc::vec::Vec<
        ::prost::alloc::vec::Vec<u8>,
    >,
    /// Actor who performed the policy resolution
    #[prost(string, tag = "9")]
    pub resolver_actor_id: ::prost::alloc::string::String,
    /// Version of the resolver component
    #[prost(string, tag = "10")]
    pub resolver_version: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with POLICY_RESOLVED_FOR_CHANGESET: domain (64 bytes)
    #[prost(bytes = "vec", tag = "11")]
    pub resolver_signature: ::prost::alloc::vec::Vec<u8>,
}
/// GateReceipt envelope with versioning support.
/// This is the canonical receipt envelope that wraps gate-specific payloads.
/// The receipt binds a gate execution result to a specific lease and changeset.
///
/// Versioning:
/// - receipt_version: Envelope schema version (currently: 1)
/// - payload_kind: Type of payload ("aat", "quality", "security")
/// - payload_schema_version: Version of the payload schema
///
/// Security:
/// - receipt_signature uses GATE_RECEIPT: domain prefix
/// - All fields except signature are included in canonical bytes
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateReceipt {
    /// Unique identifier for this receipt
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    /// Gate that generated this receipt
    #[prost(string, tag = "2")]
    pub gate_id: ::prost::alloc::string::String,
    /// Lease that authorized this gate execution
    #[prost(string, tag = "3")]
    pub lease_id: ::prost::alloc::string::String,
    /// Hash binding to specific changeset (32 bytes)
    #[prost(bytes = "vec", tag = "4")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Actor who executed the gate
    #[prost(string, tag = "5")]
    pub executor_actor_id: ::prost::alloc::string::String,
    /// Envelope schema version (supported: 1)
    #[prost(uint32, tag = "6")]
    pub receipt_version: u32,
    /// Type of payload: "aat", "quality", "security"
    #[prost(string, tag = "7")]
    pub payload_kind: ::prost::alloc::string::String,
    /// Version of the payload schema
    #[prost(uint32, tag = "8")]
    pub payload_schema_version: u32,
    /// Hash of the payload content (32 bytes)
    #[prost(bytes = "vec", tag = "9")]
    pub payload_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the evidence bundle (32 bytes)
    #[prost(bytes = "vec", tag = "10")]
    pub evidence_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    /// Ed25519 signature over canonical bytes with GATE_RECEIPT: domain (64 bytes)
    #[prost(bytes = "vec", tag = "11")]
    pub receipt_signature: ::prost::alloc::vec::Vec<u8>,
}
