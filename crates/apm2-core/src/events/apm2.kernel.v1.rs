// This file is @generated by prost-build.
/// Common envelope for all kernel events
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelEvent {
    /// Monotonic sequence number within this ledger
    #[prost(uint64, tag = "1")]
    pub sequence: u64,
    /// Hash of the previous event.
    /// For genesis events: use 32 zero bytes (canonical representation).
    /// Note: The ledger may store NULL for genesis as a storage optimization,
    /// but it must be normalized to 32 zero bytes at API boundaries.
    #[prost(bytes = "vec", tag = "2")]
    pub previous_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when event was created
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Actor ID that produced this event
    #[prost(string, tag = "4")]
    pub actor_id: ::prost::alloc::string::String,
    /// Session ID (if applicable)
    #[prost(string, tag = "5")]
    pub session_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes of this message
    #[prost(bytes = "vec", tag = "6")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// Schema version for forward/backward compatibility
    /// Current version: 1
    #[prost(uint32, tag = "7")]
    pub schema_version: u32,
    /// Event payload (oneof)
    #[prost(oneof = "kernel_event::Payload", tags = "10, 11, 12, 13, 14, 15, 16, 17")]
    pub payload: ::core::option::Option<kernel_event::Payload>,
}
/// Nested message and enum types in `KernelEvent`.
pub mod kernel_event {
    /// Event payload (oneof)
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Session(super::SessionEvent),
        #[prost(message, tag = "11")]
        Work(super::WorkEvent),
        #[prost(message, tag = "12")]
        Tool(super::ToolEvent),
        #[prost(message, tag = "13")]
        Lease(super::LeaseEvent),
        #[prost(message, tag = "14")]
        Policy(super::PolicyEvent),
        #[prost(message, tag = "15")]
        Adjudication(super::AdjudicationEvent),
        #[prost(message, tag = "16")]
        Evidence(super::EvidenceEvent),
        #[prost(message, tag = "17")]
        Key(super::KeyEvent),
    }
}
/// ============================================================
/// SESSION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionEvent {
    #[prost(oneof = "session_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<session_event::Event>,
}
/// Nested message and enum types in `SessionEvent`.
pub mod session_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Started(super::SessionStarted),
        #[prost(message, tag = "2")]
        Progress(super::SessionProgress),
        #[prost(message, tag = "3")]
        Terminated(super::SessionTerminated),
        #[prost(message, tag = "4")]
        Quarantined(super::SessionQuarantined),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionStarted {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub adapter_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub entropy_budget: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionProgress {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub progress_sequence: u64,
    /// HEARTBEAT, TOOL_COMPLETE, MILESTONE
    #[prost(string, tag = "3")]
    pub progress_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub entropy_consumed: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionTerminated {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT, ENTROPY_EXCEEDED
    #[prost(string, tag = "2")]
    pub exit_classification: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub final_entropy: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionQuarantined {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub quarantine_until: u64,
}
/// ============================================================
/// WORK EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkEvent {
    #[prost(oneof = "work_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<work_event::Event>,
}
/// Nested message and enum types in `WorkEvent`.
pub mod work_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Opened(super::WorkOpened),
        #[prost(message, tag = "2")]
        Transitioned(super::WorkTransitioned),
        #[prost(message, tag = "3")]
        Completed(super::WorkCompleted),
        #[prost(message, tag = "4")]
        Aborted(super::WorkAborted),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkOpened {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// TICKET, PRD_REFINEMENT, RFC_REFINEMENT, REVIEW
    #[prost(string, tag = "2")]
    pub work_type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub spec_snapshot_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "4")]
    pub requirement_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub parent_work_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkTransitioned {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub from_state: ::prost::alloc::string::String,
    /// OPEN, CLAIMED, IN_PROGRESS, REVIEW, NEEDS_INPUT, NEEDS_ADJUDICATION
    #[prost(string, tag = "3")]
    pub to_state: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rationale_code: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkCompleted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub evidence_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "3")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub gate_receipt_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkAborted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// POLICY_DENY, TIMEOUT, ENTROPY_EXCEEDED, MANUAL
    #[prost(string, tag = "2")]
    pub abort_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
}
/// ============================================================
/// TOOL EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolEvent {
    #[prost(oneof = "tool_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<tool_event::Event>,
}
/// Nested message and enum types in `ToolEvent`.
pub mod tool_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::ToolRequested),
        #[prost(message, tag = "2")]
        Decided(super::ToolDecided),
        #[prost(message, tag = "3")]
        Executed(super::ToolExecuted),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolRequested {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tool_name: ::prost::alloc::string::String,
    /// Hash of arguments (full args stored in CAS)
    #[prost(bytes = "vec", tag = "4")]
    pub tool_args_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub dedupe_key: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolDecided {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// ALLOW, DENY
    #[prost(string, tag = "2")]
    pub decision: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub budget_consumed: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolExecuted {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT
    #[prost(string, tag = "2")]
    pub outcome: ::prost::alloc::string::String,
    /// Hash of result (full result stored in CAS)
    #[prost(bytes = "vec", tag = "3")]
    pub result_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub duration_ms: u64,
}
/// ============================================================
/// LEASE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseEvent {
    #[prost(oneof = "lease_event::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<lease_event::Event>,
}
/// Nested message and enum types in `LeaseEvent`.
pub mod lease_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Issued(super::LeaseIssued),
        #[prost(message, tag = "2")]
        Renewed(super::LeaseRenewed),
        #[prost(message, tag = "3")]
        Released(super::LeaseReleased),
        #[prost(message, tag = "4")]
        Expired(super::LeaseExpired),
        #[prost(message, tag = "5")]
        Conflict(super::LeaseConflict),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseIssued {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub issued_at: u64,
    #[prost(uint64, tag = "5")]
    pub expires_at: u64,
    #[prost(bytes = "vec", tag = "6")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseRenewed {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub new_expires_at: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseReleased {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// COMPLETED, ABORTED, VOLUNTARY
    #[prost(string, tag = "2")]
    pub release_reason: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseExpired {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub expired_at: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseConflict {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub conflicting_lease_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// CANONICAL_ROOT, ADJUDICATION_REQUIRED
    #[prost(string, tag = "3")]
    pub resolution: ::prost::alloc::string::String,
}
/// ============================================================
/// POLICY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyEvent {
    #[prost(oneof = "policy_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<policy_event::Event>,
}
/// Nested message and enum types in `PolicyEvent`.
pub mod policy_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Loaded(super::PolicyLoaded),
        #[prost(message, tag = "2")]
        Violation(super::PolicyViolation),
        #[prost(message, tag = "3")]
        BudgetExceeded(super::BudgetExceeded),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyLoaded {
    #[prost(bytes = "vec", tag = "1")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub policy_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub rule_count: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyViolation {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub violation_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub details: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BudgetExceeded {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// TOKEN, TIME, TOOL_CALLS
    #[prost(string, tag = "2")]
    pub budget_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    #[prost(uint64, tag = "4")]
    pub consumed: u64,
}
/// ============================================================
/// ADJUDICATION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationEvent {
    #[prost(oneof = "adjudication_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<adjudication_event::Event>,
}
/// Nested message and enum types in `AdjudicationEvent`.
pub mod adjudication_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::AdjudicationRequested),
        #[prost(message, tag = "2")]
        Vote(super::AdjudicationVote),
        #[prost(message, tag = "3")]
        Resolved(super::AdjudicationResolved),
        #[prost(message, tag = "4")]
        Timeout(super::AdjudicationTimeout),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationRequested {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// BOUNDED_CHOICE, WAIVER, GATE_REVIEW
    #[prost(string, tag = "3")]
    pub request_type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "5")]
    pub deadline: u64,
    #[prost(string, tag = "6")]
    pub fallback_policy: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationVote {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub voter_actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub voter_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationResolved {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub votes_for: u64,
    #[prost(uint64, tag = "4")]
    pub votes_against: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub quorum_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationTimeout {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub applied_fallback: ::prost::alloc::string::String,
}
/// ============================================================
/// EVIDENCE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidenceEvent {
    #[prost(oneof = "evidence_event::Event", tags = "1, 2")]
    pub event: ::core::option::Option<evidence_event::Event>,
}
/// Nested message and enum types in `EvidenceEvent`.
pub mod evidence_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Published(super::EvidencePublished),
        #[prost(message, tag = "2")]
        GateReceipt(super::GateReceiptGenerated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidencePublished {
    #[prost(string, tag = "1")]
    pub evidence_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub category: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub artifact_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "5")]
    pub verification_command_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateReceiptGenerated {
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gate_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub work_id: ::prost::alloc::string::String,
    /// PASS, FAIL
    #[prost(string, tag = "4")]
    pub result: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "6")]
    pub receipt_signature: ::prost::alloc::vec::Vec<u8>,
}
/// ============================================================
/// KEY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyEvent {
    #[prost(oneof = "key_event::Event", tags = "1")]
    pub event: ::core::option::Option<key_event::Event>,
}
/// Nested message and enum types in `KeyEvent`.
pub mod key_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Rotated(super::KeyRotated),
    }
}
/// Event emitted when an actor rotates their signing key.
/// This establishes a chain of custody for key transitions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyRotated {
    /// Actor whose key is being rotated
    #[prost(string, tag = "1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Hash of the old verifying key (for reference)
    #[prost(bytes = "vec", tag = "2")]
    pub old_key_hash: ::prost::alloc::vec::Vec<u8>,
    /// New verifying (public) key bytes
    #[prost(bytes = "vec", tag = "3")]
    pub new_verifying_key: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the rotation occurred (Unix nanos)
    #[prost(uint64, tag = "4")]
    pub rotated_at: u64,
    /// Signature from the OLD key over this message (proves control of old key)
    #[prost(bytes = "vec", tag = "5")]
    pub old_key_signature: ::prost::alloc::vec::Vec<u8>,
}
