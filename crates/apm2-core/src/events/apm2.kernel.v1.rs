// This file is @generated by prost-build.
/// Common envelope for all kernel events
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KernelEvent {
    /// Monotonic sequence number within this ledger
    #[prost(uint64, tag = "1")]
    pub sequence: u64,
    /// Hash of the previous event.
    /// For genesis events: use 32 zero bytes (canonical representation).
    /// Note: The ledger may store NULL for genesis as a storage optimization,
    /// but it must be normalized to 32 zero bytes at API boundaries.
    #[prost(bytes = "vec", tag = "2")]
    pub previous_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when event was created
    #[prost(message, optional, tag = "3")]
    pub timestamp: ::core::option::Option<::prost_types::Timestamp>,
    /// Actor ID that produced this event
    #[prost(string, tag = "4")]
    pub actor_id: ::prost::alloc::string::String,
    /// Session ID (if applicable)
    #[prost(string, tag = "5")]
    pub session_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes of this message
    #[prost(bytes = "vec", tag = "6")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
    /// Schema version for forward/backward compatibility
    /// Current version: 1
    #[prost(uint32, tag = "7")]
    pub schema_version: u32,
    /// Event payload (oneof)
    #[prost(
        oneof = "kernel_event::Payload",
        tags = "10, 11, 12, 13, 14, 15, 16, 17, 18"
    )]
    pub payload: ::core::option::Option<kernel_event::Payload>,
}
/// Nested message and enum types in `KernelEvent`.
pub mod kernel_event {
    /// Event payload (oneof)
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Payload {
        #[prost(message, tag = "10")]
        Session(super::SessionEvent),
        #[prost(message, tag = "11")]
        Work(super::WorkEvent),
        #[prost(message, tag = "12")]
        Tool(super::ToolEvent),
        #[prost(message, tag = "13")]
        Lease(super::LeaseEvent),
        #[prost(message, tag = "14")]
        Policy(super::PolicyEvent),
        #[prost(message, tag = "15")]
        Adjudication(super::AdjudicationEvent),
        #[prost(message, tag = "16")]
        Evidence(super::EvidenceEvent),
        #[prost(message, tag = "17")]
        Key(super::KeyEvent),
        #[prost(message, tag = "18")]
        Capability(super::CapabilityEvent),
    }
}
/// ============================================================
/// SESSION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionEvent {
    #[prost(oneof = "session_event::Event", tags = "1, 2, 3, 4, 5, 6")]
    pub event: ::core::option::Option<session_event::Event>,
}
/// Nested message and enum types in `SessionEvent`.
pub mod session_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Started(super::SessionStarted),
        #[prost(message, tag = "2")]
        Progress(super::SessionProgress),
        #[prost(message, tag = "3")]
        Terminated(super::SessionTerminated),
        #[prost(message, tag = "4")]
        Quarantined(super::SessionQuarantined),
        #[prost(message, tag = "5")]
        CrashDetected(super::SessionCrashDetected),
        #[prost(message, tag = "6")]
        RestartScheduled(super::SessionRestartScheduled),
    }
}
/// Emitted when a session process exits unexpectedly or crashes.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionCrashDetected {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// CLEAN_EXIT, ERROR_EXIT, SIGNAL, TIMEOUT, ENTROPY_EXCEEDED
    #[prost(string, tag = "2")]
    pub crash_type: ::prost::alloc::string::String,
    #[prost(int32, tag = "3")]
    pub exit_code: i32,
    #[prost(int32, tag = "4")]
    pub signal: i32,
    #[prost(uint64, tag = "5")]
    pub uptime_ms: u64,
    #[prost(uint64, tag = "6")]
    pub last_cursor: u64,
    #[prost(uint32, tag = "7")]
    pub restart_count: u32,
}
/// Emitted when a restart has been scheduled for a crashed session.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionRestartScheduled {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub scheduled_at: u64,
    #[prost(uint64, tag = "3")]
    pub restart_at: u64,
    #[prost(uint64, tag = "4")]
    pub resume_cursor: u64,
    #[prost(uint32, tag = "5")]
    pub attempt_number: u32,
    /// FIXED, EXPONENTIAL, LINEAR
    #[prost(string, tag = "6")]
    pub backoff_type: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionStarted {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub adapter_type: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub entropy_budget: u64,
    /// For restarted sessions: cursor to resume from
    #[prost(uint64, tag = "7")]
    pub resume_cursor: u64,
    /// For restarted sessions: restart attempt number (0 = first start)
    #[prost(uint32, tag = "8")]
    pub restart_attempt: u32,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionProgress {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub progress_sequence: u64,
    /// HEARTBEAT, TOOL_COMPLETE, MILESTONE
    #[prost(string, tag = "3")]
    pub progress_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub entropy_consumed: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionTerminated {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT, ENTROPY_EXCEEDED
    #[prost(string, tag = "2")]
    pub exit_classification: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub final_entropy: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SessionQuarantined {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub reason: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub quarantine_until: u64,
}
/// ============================================================
/// WORK EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkEvent {
    #[prost(oneof = "work_event::Event", tags = "1, 2, 3, 4, 5")]
    pub event: ::core::option::Option<work_event::Event>,
}
/// Nested message and enum types in `WorkEvent`.
pub mod work_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Opened(super::WorkOpened),
        #[prost(message, tag = "2")]
        Transitioned(super::WorkTransitioned),
        #[prost(message, tag = "3")]
        Completed(super::WorkCompleted),
        #[prost(message, tag = "4")]
        Aborted(super::WorkAborted),
        #[prost(message, tag = "5")]
        PrAssociated(super::WorkPrAssociated),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkOpened {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// TICKET, PRD_REFINEMENT, RFC_REFINEMENT, REVIEW
    #[prost(string, tag = "2")]
    pub work_type: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "3")]
    pub spec_snapshot_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "4")]
    pub requirement_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, repeated, tag = "5")]
    pub parent_work_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkTransitioned {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub from_state: ::prost::alloc::string::String,
    /// Valid states: OPEN, CLAIMED, IN_PROGRESS, CI_PENDING, READY_FOR_REVIEW,
    /// BLOCKED, REVIEW, NEEDS_INPUT, NEEDS_ADJUDICATION
    #[prost(string, tag = "3")]
    pub to_state: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub rationale_code: ::prost::alloc::string::String,
    /// Previous transition count for replay protection.
    /// MUST match work.transition_count before this transition.
    /// This field is strictly validated to prevent replay attacks.
    /// For the first transition (Open -> Claimed), use 0.
    #[prost(uint32, tag = "5")]
    pub previous_transition_count: u32,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkCompleted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub evidence_bundle_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "3")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(string, tag = "4")]
    pub gate_receipt_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkAborted {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    /// POLICY_DENY, TIMEOUT, ENTROPY_EXCEEDED, MANUAL
    #[prost(string, tag = "2")]
    pub abort_reason: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rationale_code: ::prost::alloc::string::String,
}
/// Emitted when a PR is created and associated with a work item.
/// This enables CI event matching for phase transitions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WorkPrAssociated {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub pr_number: u64,
    /// The commit SHA that triggered the CI workflow
    #[prost(string, tag = "3")]
    pub commit_sha: ::prost::alloc::string::String,
}
/// ============================================================
/// TOOL EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolEvent {
    #[prost(oneof = "tool_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<tool_event::Event>,
}
/// Nested message and enum types in `ToolEvent`.
pub mod tool_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::ToolRequested),
        #[prost(message, tag = "2")]
        Decided(super::ToolDecided),
        #[prost(message, tag = "3")]
        Executed(super::ToolExecuted),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolRequested {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub tool_name: ::prost::alloc::string::String,
    /// Hash of arguments (full args stored in CAS)
    #[prost(bytes = "vec", tag = "4")]
    pub tool_args_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub dedupe_key: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolDecided {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// ALLOW, DENY
    #[prost(string, tag = "2")]
    pub decision: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "5")]
    pub rationale_code: ::prost::alloc::string::String,
    #[prost(uint64, tag = "6")]
    pub budget_consumed: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ToolExecuted {
    #[prost(string, tag = "1")]
    pub request_id: ::prost::alloc::string::String,
    /// SUCCESS, FAILURE, TIMEOUT
    #[prost(string, tag = "2")]
    pub outcome: ::prost::alloc::string::String,
    /// Hash of result (full result stored in CAS)
    #[prost(bytes = "vec", tag = "3")]
    pub result_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub duration_ms: u64,
}
/// ============================================================
/// LEASE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseEvent {
    #[prost(oneof = "lease_event::Event", tags = "1, 2, 3, 4, 5, 6")]
    pub event: ::core::option::Option<lease_event::Event>,
}
/// Nested message and enum types in `LeaseEvent`.
pub mod lease_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Issued(super::LeaseIssued),
        #[prost(message, tag = "2")]
        Renewed(super::LeaseRenewed),
        #[prost(message, tag = "3")]
        Released(super::LeaseReleased),
        #[prost(message, tag = "4")]
        Expired(super::LeaseExpired),
        #[prost(message, tag = "5")]
        Conflict(super::LeaseConflict),
        #[prost(message, tag = "6")]
        GateLeaseIssued(super::GateLeaseIssued),
    }
}
/// GateLease issued for Forge Admission Cycle execution.
/// Binds an executor actor to a specific changeset and time window.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateLeaseIssued {
    /// Unique identifier for this lease
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// Work item this lease authorizes
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// Gate this lease applies to
    #[prost(string, tag = "3")]
    pub gate_id: ::prost::alloc::string::String,
    /// Hash binding the lease to specific changeset
    #[prost(bytes = "vec", tag = "4")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Actor authorized to execute under this lease
    #[prost(string, tag = "5")]
    pub executor_actor_id: ::prost::alloc::string::String,
    /// Timestamp when lease was issued (Unix millis, observational)
    #[prost(uint64, tag = "6")]
    pub issued_at: u64,
    /// Timestamp when lease expires (Unix millis, observational)
    #[prost(uint64, tag = "7")]
    pub expires_at: u64,
    /// Hash of the policy configuration
    #[prost(bytes = "vec", tag = "8")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    /// Actor who issued this lease
    #[prost(string, tag = "9")]
    pub issuer_actor_id: ::prost::alloc::string::String,
    /// Ed25519 signature over canonical bytes with GATE_LEASE_ISSUED: prefix
    #[prost(bytes = "vec", tag = "10")]
    pub issuer_signature: ::prost::alloc::vec::Vec<u8>,
    /// HTF time envelope reference for temporal authority
    #[prost(string, tag = "11")]
    pub time_envelope_ref: ::prost::alloc::string::String,
    /// Optional AAT-specific extension fields
    #[prost(message, optional, tag = "12")]
    pub aat_extension: ::core::option::Option<AatLeaseExtension>,
}
/// AAT (Autonomous Agent Team) lease extension fields.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AatLeaseExtension {
    /// Hash of the view commitment for the AAT context
    #[prost(bytes = "vec", tag = "1")]
    pub view_commitment_hash: ::prost::alloc::vec::Vec<u8>,
    /// Hash of the RCP (Runnable Capability Profile) manifest
    #[prost(bytes = "vec", tag = "2")]
    pub rcp_manifest_hash: ::prost::alloc::vec::Vec<u8>,
    /// Identifier for the RCP profile being used
    #[prost(string, tag = "3")]
    pub rcp_profile_id: ::prost::alloc::string::String,
    /// Identifier for the selection policy used
    #[prost(string, tag = "4")]
    pub selection_policy_id: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseIssued {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub actor_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "4")]
    pub issued_at: u64,
    #[prost(uint64, tag = "5")]
    pub expires_at: u64,
    #[prost(bytes = "vec", tag = "6")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseRenewed {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub new_expires_at: u64,
    #[prost(bytes = "vec", tag = "3")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseReleased {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    /// COMPLETED, ABORTED, VOLUNTARY
    #[prost(string, tag = "2")]
    pub release_reason: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseExpired {
    #[prost(string, tag = "1")]
    pub lease_id: ::prost::alloc::string::String,
    #[prost(uint64, tag = "2")]
    pub expired_at: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct LeaseConflict {
    #[prost(string, tag = "1")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "2")]
    pub conflicting_lease_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// CANONICAL_ROOT, ADJUDICATION_REQUIRED
    #[prost(string, tag = "3")]
    pub resolution: ::prost::alloc::string::String,
}
/// ============================================================
/// POLICY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyEvent {
    #[prost(oneof = "policy_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<policy_event::Event>,
}
/// Nested message and enum types in `PolicyEvent`.
pub mod policy_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Loaded(super::PolicyLoaded),
        #[prost(message, tag = "2")]
        Violation(super::PolicyViolation),
        #[prost(message, tag = "3")]
        BudgetExceeded(super::BudgetExceeded),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyLoaded {
    #[prost(bytes = "vec", tag = "1")]
    pub policy_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub policy_version: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub rule_count: u64,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PolicyViolation {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub violation_type: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub rule_id: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub details: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BudgetExceeded {
    #[prost(string, tag = "1")]
    pub session_id: ::prost::alloc::string::String,
    /// TOKEN, TIME, TOOL_CALLS
    #[prost(string, tag = "2")]
    pub budget_type: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub limit: u64,
    #[prost(uint64, tag = "4")]
    pub consumed: u64,
}
/// ============================================================
/// ADJUDICATION EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationEvent {
    #[prost(oneof = "adjudication_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<adjudication_event::Event>,
}
/// Nested message and enum types in `AdjudicationEvent`.
pub mod adjudication_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Requested(super::AdjudicationRequested),
        #[prost(message, tag = "2")]
        Vote(super::AdjudicationVote),
        #[prost(message, tag = "3")]
        Resolved(super::AdjudicationResolved),
        #[prost(message, tag = "4")]
        Timeout(super::AdjudicationTimeout),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationRequested {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// BOUNDED_CHOICE, WAIVER, GATE_REVIEW
    #[prost(string, tag = "3")]
    pub request_type: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "4")]
    pub options: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(uint64, tag = "5")]
    pub deadline: u64,
    #[prost(string, tag = "6")]
    pub fallback_policy: ::prost::alloc::string::String,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationVote {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub voter_actor_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub voter_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationResolved {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub chosen_option: ::prost::alloc::string::String,
    #[prost(uint64, tag = "3")]
    pub votes_for: u64,
    #[prost(uint64, tag = "4")]
    pub votes_against: u64,
    #[prost(bytes = "vec", tag = "5")]
    pub quorum_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AdjudicationTimeout {
    #[prost(string, tag = "1")]
    pub adjudication_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub applied_fallback: ::prost::alloc::string::String,
}
/// ============================================================
/// EVIDENCE EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidenceEvent {
    #[prost(oneof = "evidence_event::Event", tags = "1, 2, 3")]
    pub event: ::core::option::Option<evidence_event::Event>,
}
/// Nested message and enum types in `EvidenceEvent`.
pub mod evidence_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Published(super::EvidencePublished),
        #[prost(message, tag = "2")]
        GateReceipt(super::GateReceiptGenerated),
        #[prost(message, tag = "3")]
        GateRunCompleted(super::GateRunCompleted),
    }
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct EvidencePublished {
    #[prost(string, tag = "1")]
    pub evidence_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub category: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "4")]
    pub artifact_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, repeated, tag = "5")]
    pub verification_command_ids: ::prost::alloc::vec::Vec<
        ::prost::alloc::string::String,
    >,
    /// Data classification: PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED
    #[prost(string, tag = "6")]
    pub classification: ::prost::alloc::string::String,
    /// Artifact size in bytes (for bundle size tracking)
    #[prost(uint64, tag = "7")]
    pub artifact_size: u64,
    /// Metadata key-value pairs as "key=value" strings
    #[prost(string, repeated, tag = "8")]
    pub metadata: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateReceiptGenerated {
    #[prost(string, tag = "1")]
    pub receipt_id: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub gate_id: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub work_id: ::prost::alloc::string::String,
    /// PASS, FAIL
    #[prost(string, tag = "4")]
    pub result: ::prost::alloc::string::String,
    #[prost(string, repeated, tag = "5")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    #[prost(bytes = "vec", tag = "6")]
    pub receipt_signature: ::prost::alloc::vec::Vec<u8>,
}
/// Emitted when a gate run completes execution under a GateLease.
/// This is the critical event for FAC admission decisions.
/// All validation steps must pass for admission to proceed.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GateRunCompleted {
    /// Unique identifier for this completion event
    #[prost(string, tag = "1")]
    pub run_id: ::prost::alloc::string::String,
    /// Gate this run completed for
    #[prost(string, tag = "2")]
    pub gate_id: ::prost::alloc::string::String,
    /// Work item this run is associated with
    #[prost(string, tag = "3")]
    pub work_id: ::prost::alloc::string::String,
    /// Lease ID authorizing this run
    #[prost(string, tag = "4")]
    pub lease_id: ::prost::alloc::string::String,
    /// Hash of the changeset executed
    #[prost(bytes = "vec", tag = "5")]
    pub changeset_digest: ::prost::alloc::vec::Vec<u8>,
    /// Actor who executed the run
    #[prost(string, tag = "6")]
    pub executor_actor_id: ::prost::alloc::string::String,
    /// Outcome of the run: PASS, FAIL
    #[prost(string, tag = "7")]
    pub result: ::prost::alloc::string::String,
    /// Evidence IDs produced by this run
    #[prost(string, repeated, tag = "8")]
    pub evidence_ids: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// HTF timestamp when the run completed (Unix millis)
    #[prost(uint64, tag = "9")]
    pub completed_at: u64,
    /// Ed25519 signature over canonical bytes with GATE_RUN_COMPLETED: prefix
    #[prost(bytes = "vec", tag = "10")]
    pub executor_signature: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityEvent {
    #[prost(oneof = "capability_event::Event", tags = "1, 2, 3, 4")]
    pub event: ::core::option::Option<capability_event::Event>,
}
/// Nested message and enum types in `CapabilityEvent`.
pub mod capability_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Required(super::CapabilityRequired),
        #[prost(message, tag = "2")]
        Granted(super::CapabilityGranted),
        #[prost(message, tag = "3")]
        Delegated(super::CapabilityDelegated),
        #[prost(message, tag = "4")]
        Revoked(super::CapabilityRevoked),
    }
}
/// Emitted during planning phase when a capability is required for a plan step.
/// This event enables capability negotiation and tracking.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityRequired {
    /// The capability ID that is required (e.g., "cac:patch:apply")
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// The work ID this requirement is associated with
    #[prost(string, tag = "2")]
    pub work_id: ::prost::alloc::string::String,
    /// Whether this capability is required (true) or optional (false)
    #[prost(bool, tag = "3")]
    pub required: bool,
    /// The status of the capability: AVAILABLE, UNAVAILABLE, DEGRADED
    #[prost(string, tag = "4")]
    pub status: ::prost::alloc::string::String,
    /// Human-readable reason for the status
    #[prost(string, tag = "5")]
    pub reason: ::prost::alloc::string::String,
}
/// Emitted when a capability is granted to an actor by an authority.
/// This is the root of a delegation chain and must be signed by the registrar.
/// Links to the lease system: capability_id == lease_id.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityGranted {
    /// Unique identifier for this capability (equals lease_id for lease-backed capabilities)
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// Namespace this capability is bound to (prevents cross-namespace replay)
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor receiving the capability
    #[prost(string, tag = "3")]
    pub grantee_actor_id: ::prost::alloc::string::String,
    /// Actor granting the capability (must be an authority in the namespace)
    #[prost(string, tag = "4")]
    pub grantor_actor_id: ::prost::alloc::string::String,
    /// Hash of the serialized LeaseScope (stored in CAS)
    #[prost(bytes = "vec", tag = "5")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// Optional hash of the serialized Budget (stored in CAS)
    #[prost(bytes = "vec", tag = "6")]
    pub budget_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the capability was granted (Unix nanos)
    #[prost(uint64, tag = "7")]
    pub granted_at: u64,
    /// Timestamp when the capability expires (Unix nanos)
    #[prost(uint64, tag = "8")]
    pub expires_at: u64,
    /// Registrar signature over this grant (proves authority)
    #[prost(bytes = "vec", tag = "9")]
    pub registrar_signature: ::prost::alloc::vec::Vec<u8>,
    /// Whether this capability can be delegated to others
    #[prost(bool, tag = "10")]
    pub delegatable: bool,
}
/// Emitted when a capability holder delegates their capability to another actor.
/// Forms part of the delegation chain for capability proofs.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityDelegated {
    /// New capability ID for the delegated capability
    #[prost(string, tag = "1")]
    pub delegated_capability_id: ::prost::alloc::string::String,
    /// Parent capability being delegated from
    #[prost(string, tag = "2")]
    pub parent_capability_id: ::prost::alloc::string::String,
    /// Hash of the parent CapabilityGranted or CapabilityDelegated event
    #[prost(bytes = "vec", tag = "3")]
    pub parent_capability_hash: ::prost::alloc::vec::Vec<u8>,
    /// Namespace this delegation is bound to (must match parent)
    #[prost(string, tag = "4")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor receiving the delegated capability
    #[prost(string, tag = "5")]
    pub delegatee_actor_id: ::prost::alloc::string::String,
    /// Actor delegating the capability (must hold parent capability)
    #[prost(string, tag = "6")]
    pub delegator_actor_id: ::prost::alloc::string::String,
    /// Hash of the serialized LeaseScope (must be subset of parent scope)
    #[prost(bytes = "vec", tag = "7")]
    pub scope_hash: ::prost::alloc::vec::Vec<u8>,
    /// Optional hash of the serialized Budget (must be subset of parent budget)
    #[prost(bytes = "vec", tag = "8")]
    pub budget_hash: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the delegation occurred (Unix nanos)
    #[prost(uint64, tag = "9")]
    pub delegated_at: u64,
    /// Timestamp when the delegated capability expires (Unix nanos, must be <= parent expires_at)
    #[prost(uint64, tag = "10")]
    pub expires_at: u64,
    /// Delegator's signature over this delegation (proves authority transfer)
    #[prost(bytes = "vec", tag = "11")]
    pub delegator_signature: ::prost::alloc::vec::Vec<u8>,
    /// Whether this delegated capability can be further delegated
    #[prost(bool, tag = "12")]
    pub delegatable: bool,
    /// Depth in the delegation chain (parent depth + 1)
    #[prost(uint32, tag = "13")]
    pub delegation_depth: u32,
}
/// Emitted when a capability is revoked before its natural expiration.
/// Revocation cascades to all delegated capabilities in the chain.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct CapabilityRevoked {
    /// The capability being revoked
    #[prost(string, tag = "1")]
    pub capability_id: ::prost::alloc::string::String,
    /// Namespace the capability belongs to
    #[prost(string, tag = "2")]
    pub namespace: ::prost::alloc::string::String,
    /// Actor performing the revocation (must be grantor or authority)
    #[prost(string, tag = "3")]
    pub revoker_actor_id: ::prost::alloc::string::String,
    /// Reason for revocation: VOLUNTARY, POLICY_VIOLATION, KEY_COMPROMISE, SUPERSEDED
    #[prost(string, tag = "4")]
    pub revocation_reason: ::prost::alloc::string::String,
    /// Timestamp when the revocation occurred (Unix nanos)
    #[prost(uint64, tag = "5")]
    pub revoked_at: u64,
    /// Revoker's signature over this revocation
    #[prost(bytes = "vec", tag = "6")]
    pub revoker_signature: ::prost::alloc::vec::Vec<u8>,
    /// If true, revocation cascades to all delegated capabilities; if false, only this capability is revoked
    #[prost(bool, tag = "7")]
    pub cascade: bool,
}
/// ============================================================
/// KEY EVENTS
/// ============================================================
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyEvent {
    #[prost(oneof = "key_event::Event", tags = "1")]
    pub event: ::core::option::Option<key_event::Event>,
}
/// Nested message and enum types in `KeyEvent`.
pub mod key_event {
    #[derive(Eq, Hash)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "1")]
        Rotated(super::KeyRotated),
    }
}
/// Event emitted when an actor rotates their signing key.
/// This establishes a chain of custody for key transitions.
#[derive(Eq, Hash)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyRotated {
    /// Actor whose key is being rotated
    #[prost(string, tag = "1")]
    pub actor_id: ::prost::alloc::string::String,
    /// Hash of the old verifying key (for reference)
    #[prost(bytes = "vec", tag = "2")]
    pub old_key_hash: ::prost::alloc::vec::Vec<u8>,
    /// New verifying (public) key bytes
    #[prost(bytes = "vec", tag = "3")]
    pub new_verifying_key: ::prost::alloc::vec::Vec<u8>,
    /// Timestamp when the rotation occurred (Unix nanos)
    #[prost(uint64, tag = "4")]
    pub rotated_at: u64,
    /// Signature from the OLD key over this message (proves control of old key)
    #[prost(bytes = "vec", tag = "5")]
    pub old_key_signature: ::prost::alloc::vec::Vec<u8>,
}
