syntax = "proto3";

package apm2.daemon.v1;

// CTR-PROTO-001: Handshake
message Hello {
  uint32 protocol_version = 1;
  ClientInfo client_info = 2;
  repeated string requested_caps = 3;
}

message HelloAck {
  ServerInfo server_info = 1;
  repeated string granted_caps = 2;
  bytes policy_hash = 3;
  map<string, uint32> canonicalizer_versions = 4;
}

message ClientInfo {
  string name = 1;
  string version = 2;
}

message ServerInfo {
  string name = 1;
  string version = 2;
}

// CTR-PROTO-002: Episode Control
message CreateEpisode {
  bytes envelope_hash = 1;
}

message EpisodeCreated {
  string episode_id = 1;
  string session_id = 2;
}

message StartEpisode {
  string episode_id = 1;
}

message EpisodeStarted {
  uint32 session_pid = 1;
  string io_stream_id = 2;
}

message StopEpisode {
  string episode_id = 1;
  StopReason reason = 2;
}

message EpisodeStopped {
  TerminationClass termination_class = 1;
}

message SignalEpisode {
  string episode_id = 1;
  int32 signal = 2;
}

message ResizePty {
  string episode_id = 1;
  uint32 cols = 2;
  uint32 rows = 3;
}

// Minimal v1 vocabulary for evidence economics
message EpisodeQuarantined {
  string episode_id = 1;
  string reason = 2;
  repeated bytes evidence_pinned = 3;
}

enum StopReason {
  STOP_REASON_UNSPECIFIED = 0;
  GOAL_SATISFIED = 1;
  BUDGET_EXHAUSTED = 2;
  POLICY_VIOLATION = 3;
  USER_REQUEST = 4;
  HARNESS_CRASH = 5;
  ADAPTER_FAILURE = 6;
}

enum TerminationClass {
  TERMINATION_CLASS_UNSPECIFIED = 0;
  CLEAN_EXIT = 1;
  ERROR_EXIT = 2;
  QUARANTINED = 3;
}

// CTR-PROTO-003: I/O
message SendInput {
  string episode_id = 1;
  bytes data = 2;
}

message StreamOutput {
  bytes chunk = 1;
  StreamKind kind = 2;
  uint64 seq = 3;
  uint64 ts = 4;
}

enum StreamKind {
  STDOUT = 0;
  STDERR = 1;
}

// CTR-PROTO-004: Tool Mediation
message ToolRequest {
  string episode_id = 1;
  string request_id = 2;
  string tool = 3;
  bytes dedupe_key = 4;
  bytes args_hash = 5;
  optional bytes inline_args = 6;
}

message ToolDecision {
  string request_id = 1;
  DecisionType decision = 2;
  optional string rule_id = 3;
  bytes policy_hash = 4;
  BudgetDelta budget_delta = 5;
}

enum DecisionType {
  ALLOW = 0;
  DENY = 1;
  DEDUPE_HIT = 2;
}

message ToolResult {
  string request_id = 1;
  ToolOutcome outcome = 2;
  bytes result_hash = 3;
  optional bytes inline_result = 4;
}

message BudgetDelta {
  uint64 tokens = 1;
  uint32 tool_calls = 2;
  uint64 cpu_ms = 3;
}

enum ToolOutcome {
  TOOL_OUTCOME_UNSPECIFIED = 0;
  SUCCESS = 1;
  FAILURE = 2;
  ERROR = 3;
}

// CTR-PROTO-005: Telemetry
message TelemetryFrame {
  string episode_id = 1;
  uint64 seq = 2;
  uint64 ts_mono = 3;
  uint64 cpu_ns = 4;
  uint64 mem_rss_bytes = 5;
  uint64 io_read_bytes = 6;
  uint64 io_write_bytes = 7;
  optional CgroupStats cgroup_stats = 8;
  uint32 o11y_flags = 9;
}

message CgroupStats {
  uint64 cpu_usage_usec = 1;
  uint64 memory_current = 2;
  uint64 memory_max = 3;
}

message TelemetryPolicy {
  uint64 sample_period_ms = 1;
  repeated PromoteTrigger promote_triggers = 2;
  RingBufferLimits ring_buffer_limits = 3;
}

message PromoteTrigger {
  string metric = 1;
  double threshold = 2;
}

message RingBufferLimits {
  uint64 max_pty_bytes = 1;
  uint64 max_tool_bytes = 2;
  uint64 max_tel_frames = 3;
}

// CTR-PROTO-006: Receipts and Evidence
message PublishEvidence {
  bytes artifact_hash = 1;
  EvidenceKind kind = 2;
  RetentionHint retention_hint = 3;
}

message Receipt {
  ReceiptKind kind = 1;
  bytes unsigned_bytes_hash = 2;
  bytes signature = 3;
  repeated bytes evidence_refs = 4;
  bytes policy_hash = 5;
  bytes envelope_hash = 6;
  optional string issuer_id = 7;
  optional bytes issuer_signature = 8;
}

// Minimal v1 vocabulary events for evidence economics
message EvidencePinned {
  bytes artifact_hash = 1;
  string reason = 2;
  optional string defect_id = 3;
}

message EvidenceTtlExpired {
  bytes artifact_hash = 1;
  uint64 timestamp = 2;
}

message CompactionCompleted {
  bytes summary_receipt_hash = 1;
  repeated bytes tombstoned_hashes = 2;
}

enum ReceiptKind {
  TOOL_EXECUTION = 0;
  EPISODE_START = 1;
  EPISODE_STOP = 2;
  GATE = 3;
  TELEMETRY = 4;
  COMPACTION = 5;
  STOP_ORDER = 6;
}

enum EvidenceKind {
  EVIDENCE_KIND_UNSPECIFIED = 0;
  EVIDENCE_KIND_PTY_TRANSCRIPT = 1;
  EVIDENCE_KIND_TOOL_IO = 2;
  EVIDENCE_KIND_TELEMETRY_RAW = 3;
  EVIDENCE_KIND_ADAPTER_FAILURE = 4;
  EVIDENCE_KIND_INCIDENT_SNAPSHOT = 5;
}

enum RetentionHint {
  RETENTION_HINT_UNSPECIFIED = 0;
  EPHEMERAL = 1;
  STANDARD = 2;
  ARCHIVAL = 3;
}

// =============================================================================
// CTR-PROTO-007: Privileged Endpoints (RFC-0017)
// =============================================================================
// These endpoints require operator credentials (connection on operator.sock).
// Session connections receive PERMISSION_DENIED for all privileged requests.

// Role enumeration for work claiming and episode spawning.
enum WorkRole {
  WORK_ROLE_UNSPECIFIED = 0;
  IMPLEMENTER = 1;
  GATE_EXECUTOR = 2;
  REVIEWER = 3;
  COORDINATOR = 4;
}

// IPC-PRIV-001: ClaimWork
// Request work assignment with policy-resolved capabilities.
// Per DD-001: actor_id is a display hint; authoritative actor_id derived from credential.
message ClaimWorkRequest {
  // Display-only hint for actor name. Authoritative actor_id derived from credential.
  string actor_id = 1;
  // Role for work assignment.
  WorkRole role = 2;
  // Ed25519 signature over (actor_id || role || nonce) using operator key.
  bytes credential_signature = 3;
  // Nonce to prevent replay attacks.
  bytes nonce = 4;
}

message ClaimWorkResponse {
  // Assigned work identifier.
  string work_id = 1;
  // Lease identifier for this work claim.
  string lease_id = 2;
  // Blake3 hash of the capability manifest.
  bytes capability_manifest_hash = 3;
  // Reference to the PolicyResolvedForChangeSet event.
  string policy_resolved_ref = 4;
  // Blake3 hash of the sealed context pack.
  bytes context_pack_hash = 5;
}

// IPC-PRIV-002: SpawnEpisode
// Spawn execution episode with FAC preconditions.
message SpawnEpisodeRequest {
  // Work identifier from a prior ClaimWork.
  string work_id = 1;
  // Role for this episode (IMPLEMENTER, GATE_EXECUTOR, REVIEWER).
  WorkRole role = 2;
  // Required for GATE_EXECUTOR role; must reference valid GateLeaseIssued.
  optional string lease_id = 3;
  // TCK-00319: Workspace root directory for this episode.
  // All file operations will be confined to this directory.
  // REQUIRED: Episodes cannot be spawned without a workspace root.
  string workspace_root = 4;
}

message SpawnEpisodeResponse {
  // Session identifier for IPC communication.
  string session_id = 1;
  // Blake3 hash of the capability manifest governing this session.
  bytes capability_manifest_hash = 2;
  // Whether the context pack is sealed.
  bool context_pack_sealed = 3;
  // Ephemeral handle for session identification (not a credential).
  string ephemeral_handle = 4;
  // HMAC-signed session token for authenticating session-scoped IPC requests.
  // TCK-00287: Required for clients to access session endpoints.
  string session_token = 5;
}

// IPC-PRIV-003: IssueCapability
// Issue additional capability to an existing session.
message IssueCapabilityRequest {
  // Target session identifier.
  string session_id = 1;
  // Capability request details.
  CapabilityRequest capability_request = 2;
}

message CapabilityRequest {
  // Tool class to grant access to.
  string tool_class = 1;
  // Path patterns for read access (optional).
  repeated string read_patterns = 2;
  // Path patterns for write access (optional).
  repeated string write_patterns = 3;
  // Duration in seconds for the capability grant.
  uint64 duration_secs = 4;
}

message IssueCapabilityResponse {
  // Unique identifier for this capability grant.
  string capability_id = 1;
  // Unix timestamp when capability was granted.
  uint64 granted_at = 2;
  // Unix timestamp when capability expires.
  uint64 expires_at = 3;
}

// IPC-PRIV-004: Shutdown
// Gracefully shutdown the daemon.
message ShutdownRequest {
  // Optional reason for shutdown (for logging/audit).
  optional string reason = 1;
}

message ShutdownResponse {
  // Acknowledgment message.
  string message = 1;
}

// =============================================================================
// Error Codes for Privileged Endpoints
// =============================================================================
enum PrivilegedErrorCode {
  PRIVILEGED_ERROR_UNSPECIFIED = 0;
  // Caller lacks operator credential (not on operator.sock).
  PERMISSION_DENIED = 1;
  // Invalid parameter in request.
  CAPABILITY_REQUEST_REJECTED = 2;
  // Governance policy resolution failed.
  POLICY_RESOLUTION_FAILED = 3;
  // Required policy resolution missing for spawn.
  POLICY_RESOLUTION_MISSING = 4;
  // GATE_EXECUTOR spawn requires valid lease.
  GATE_LEASE_MISSING = 5;
  // Custody domain overlap detected (separation of duties violation).
  SOD_VIOLATION = 6;
  // Referenced session not found.
  SESSION_NOT_FOUND = 7;
  // Capability grant denied by policy.
  CAPABILITY_DENIED = 8;
}

// Generic error response for privileged endpoints.
message PrivilegedError {
  PrivilegedErrorCode code = 1;
  string message = 2;
}

// =============================================================================
// CTR-PROTO-008: Session-Scoped Endpoints (RFC-0017, TCK-00252)
// =============================================================================
// These endpoints require a valid session_token (connection on session.sock).
// Invalid or expired tokens receive SESSION_INVALID error.
// Operator socket connections receive PERMISSION_DENIED for session requests.

// IPC-SESS-001: RequestTool
// Request tool execution within session capability bounds.
message RequestToolRequest {
  // Session token for authentication (validated via HMAC-SHA256).
  string session_token = 1;
  // Tool identifier (e.g., "file_read", "shell_exec").
  string tool_id = 2;
  // Serialized tool arguments (JSON or binary).
  bytes arguments = 3;
  // Deduplication key for idempotent requests.
  string dedupe_key = 4;
}

message RequestToolResponse {
  // Request identifier for tracking.
  string request_id = 1;
  // Tool decision (ALLOW, DENY, DEDUPE_HIT).
  DecisionType decision = 2;
  // Rule that matched (if DENY).
  optional string rule_id = 3;
  // Policy hash at decision time.
  bytes policy_hash = 4;
  // Result hash from tool execution (CAS reference, populated on ALLOW after execution).
  // TCK-00316: Required for kernel-side execution model.
  optional bytes result_hash = 5;
  // Inline result for small outputs (bounded by MAX_INLINE_RESULT_SIZE = 64KB).
  // TCK-00316: Security - enforces DoS protection per SEC-CTRL-FAC-0015.
  optional bytes inline_result = 6;
}

// IPC-SESS-002: EmitEvent
// Emit a signed event to the ledger.
message EmitEventRequest {
  // Session token for authentication.
  string session_token = 1;
  // Event type identifier.
  string event_type = 2;
  // Event payload (JSON or binary).
  bytes payload = 3;
  // Correlation ID for event tracing.
  string correlation_id = 4;
}

message EmitEventResponse {
  // Event identifier in the ledger.
  string event_id = 1;
  // Sequence number in the session.
  uint64 seq = 2;
  // Timestamp when event was recorded (nanoseconds since epoch).
  uint64 timestamp_ns = 3;
}

// IPC-SESS-003: PublishEvidence
// Publish evidence artifact to content-addressed storage.
message PublishEvidenceRequest {
  // Session token for authentication.
  string session_token = 1;
  // Artifact content (binary).
  bytes artifact = 2;
  // Evidence kind for categorization.
  EvidenceKind kind = 3;
  // Retention hint for storage policy.
  RetentionHint retention_hint = 4;
}

message PublishEvidenceResponse {
  // Blake3 hash of the artifact (content address).
  bytes artifact_hash = 1;
  // Storage location hint.
  string storage_path = 2;
  // TTL in seconds (0 = permanent).
  uint64 ttl_secs = 3;
}

// IPC-SESS-004: StreamTelemetry
// Stream telemetry frames for observability.
message StreamTelemetryRequest {
  // Session token for authentication.
  string session_token = 1;
  // Telemetry frame to stream.
  TelemetryFrame frame = 2;
}

message StreamTelemetryResponse {
  // Acknowledgment sequence number.
  uint64 ack_seq = 1;
  // Whether frame was promoted to persistent storage.
  bool promoted = 2;
}

// =============================================================================
// Error Codes for Session-Scoped Endpoints
// =============================================================================
enum SessionErrorCode {
  SESSION_ERROR_UNSPECIFIED = 0;
  // Session token is invalid (expired, tampered, or missing).
  SESSION_ERROR_INVALID = 1;
  // Session has been terminated.
  SESSION_ERROR_TERMINATED = 2;
  // Tool not allowed by capability manifest.
  SESSION_ERROR_TOOL_NOT_ALLOWED = 3;
  // Budget exhausted for this session.
  SESSION_ERROR_BUDGET_EXHAUSTED = 4;
  // Context firewall violation (deny + terminate).
  SESSION_ERROR_CONTEXT_FIREWALL = 5;
  // Caller is on operator socket (session endpoints require session.sock).
  SESSION_ERROR_PERMISSION_DENIED = 6;
  // Endpoint not implemented (fail-closed for unimplemented features).
  SESSION_ERROR_NOT_IMPLEMENTED = 7;
  // Internal error (ledger, CAS, or other subsystem failure).
  SESSION_ERROR_INTERNAL = 8;
}

// Generic error response for session-scoped endpoints.
message SessionError {
  SessionErrorCode code = 1;
  string message = 2;
}

// =============================================================================
// CTR-PROTO-009: Crash Recovery Signals (TCK-00267)
// =============================================================================
// These messages support daemon crash recovery and lease revocation.

// Reason for lease revocation.
enum LeaseRevokedReason {
  LEASE_REVOKED_REASON_UNSPECIFIED = 0;
  // Daemon crashed and restarted, invalidating all prior leases.
  LEASE_REVOKED_DAEMON_RESTART = 1;
  // Lease expired during daemon downtime.
  LEASE_REVOKED_EXPIRED = 2;
  // Explicit revocation by operator.
  LEASE_REVOKED_BY_OPERATOR = 3;
  // Session violated policy (context firewall, etc.).
  LEASE_REVOKED_POLICY_VIOLATION = 4;
}

// Signal sent to sessions when their lease is revoked.
// Sessions receiving this signal MUST re-authenticate before continuing.
message LeaseRevoked {
  // The session whose lease is being revoked.
  string session_id = 1;
  // The lease that was revoked.
  string lease_id = 2;
  // Why the lease is being revoked.
  LeaseRevokedReason reason = 3;
  // Timestamp when the lease was revoked (nanoseconds since epoch).
  uint64 revoked_at_ns = 4;
  // Human-readable message explaining the revocation.
  optional string message = 5;
}

// Request to recover sessions after daemon restart.
// Privileged endpoint (operator.sock only).
message RecoverSessionsRequest {
  // Maximum time to wait for recovery (milliseconds).
  // Default: 5000 (5 seconds per acceptance criteria).
  uint32 timeout_ms = 1;
}

// Response from session recovery.
message RecoverSessionsResponse {
  // Number of sessions that were recovered.
  uint32 sessions_recovered = 1;
  // Number of orphaned processes cleaned up.
  uint32 orphaned_processes_cleaned = 2;
  // Number of LEASE_REVOKED signals sent.
  uint32 lease_revoked_signals_sent = 3;
  // Time taken for recovery (milliseconds).
  uint32 recovery_time_ms = 4;
}

// =============================================================================
// CTR-PROTO-010: HEF Pulse Plane (RFC-0018, TCK-00300)
// =============================================================================
// Holonic Event Fabric (HEF) pulse messages for lossy event notifications.
// Pulses are derived from committed ledger+CAS artifacts and provide hints
// only. Correctness requires ledger catch-up; pulse loss does not affect
// authoritative outcomes.
//
// ## Message Tag Range (HEF Reserved)
//
// HEF messages use tag range 64-79 to avoid collisions with existing messages:
// - Session socket (session.sock): Tags 64-71 reserved for HEF
// - Operator socket (operator.sock): Tags 64-71 reserved for HEF
//
// Current HEF tag assignments:
// - 64 = SubscribePulseRequest
// - 65 = SubscribePulseResponse
// - 66 = UnsubscribePulseRequest
// - 67 = UnsubscribePulseResponse
// - 68 = PulseEvent (server->client only)
// - 69-79 = Reserved for future HEF extensions
//
// ## Security Invariants
//
// - [INV-HEF-001] PulseEnvelopeV1 max size: 2048 bytes
// - [INV-HEF-002] Unknown fields MUST cause decode failure (fail-closed)
// - [INV-HEF-003] All string IDs are ASCII-only and length-bounded
// - [INV-HEF-004] since_ledger_cursor in subscriptions is for resume hints only
// - [INV-HEF-005] Pulse correctness requires ledger catch-up, not pulse replay

// -----------------------------------------------------------------------------
// HEF Supporting Types
// -----------------------------------------------------------------------------

// Entity reference within a pulse envelope.
// References opaque identifiers (work_id, episode_id, gate_id, defect_id).
// [CTR-HEF-0001] ASCII-only, length-bounded identifiers.
message EntityRef {
  // Entity kind discriminant.
  // Valid values: WORK, EPISODE, GATE, DEFECT, SESSION
  // Max length: 16 characters, ASCII only.
  string kind = 1;

  // Entity identifier.
  // Max length: 128 characters, ASCII only.
  string id = 2;

  // Optional content digest (32 bytes, typically Blake3).
  // Used for ChangeSet or artifact references.
  optional bytes digest = 3;
}

// Content-addressed storage reference.
// [CTR-HEF-0001] Used to reference CAS artifacts in pulse envelopes.
message CasRef {
  // Blake3 hash of the artifact (32 bytes).
  bytes hash = 1;

  // Size of the artifact in bytes.
  // Used for resource governance and prefetch decisions.
  uint64 size_bytes = 2;

  // Artifact kind discriminant.
  // Valid values: EVIDENCE, TIME_ENVELOPE, TOOL_RESULT, IO_CHUNK
  // Max length: 32 characters, ASCII only.
  string kind = 3;
}

// Hybrid Logical Clock timestamp (advisory only).
// [INV-HEF-004] HLC is observational; ledger cursor is authoritative.
message HlcStamp {
  // Wall clock component (nanoseconds since Unix epoch).
  uint64 wall_ns = 1;

  // Logical counter component.
  uint32 logical = 2;

  // Node identifier (32 bytes, truncated from node key hash).
  bytes node_id = 3;
}

// Bounded wall-clock interval (observational only).
// Represents the uncertainty window for event timing.
message BoundedWallInterval {
  // Earliest possible wall time (nanoseconds since Unix epoch).
  uint64 earliest_ns = 1;

  // Latest possible wall time (nanoseconds since Unix epoch).
  uint64 latest_ns = 2;
}

// -----------------------------------------------------------------------------
// PulseEnvelopeV1 (Core HEF Data Structure)
// -----------------------------------------------------------------------------

// Lossy event hint derived from committed ledger+CAS artifacts.
//
// ## Bounds (CTR-HEF-0001, REQ-HEF-0002)
//
// - Max total size: 2048 bytes
// - Max entities: 8
// - Max cas_refs: 8
// - pulse_id: max 64 chars, ASCII only
// - topic: max 128 chars, ASCII only, dot-delimited
// - event_type: max 64 chars
//
// ## Versioning
//
// schema_version MUST be 1 for this version. Unknown schema versions
// MUST cause decode failure (fail-closed per INV-HEF-002).
message PulseEnvelopeV1 {
  // Schema version discriminant. MUST be 1 for PulseEnvelopeV1.
  // Unknown versions cause decode failure.
  uint32 schema_version = 1;

  // Unique pulse identifier.
  // Max length: 64 characters, ASCII only.
  // Format: `{topic_hash}:{seq}:{random}` or daemon-assigned UUID.
  string pulse_id = 2;

  // Topic string (dot-delimited hierarchy).
  // Max length: 128 characters, ASCII only.
  // Examples: "work.W-123.events", "gate.W-123.CS-abc.G-001"
  string topic = 3;

  // Ledger sequence ID (cursor) at which this event was committed.
  // Authoritative for ordering and catch-up.
  uint64 ledger_cursor = 4;

  // Current ledger head at emission time (0 if unknown).
  // Advisory hint for client catch-up decisions.
  uint64 ledger_head = 5;

  // Blake3 hash of the ledger event (32 bytes, optional).
  // Used for content verification and deduplication.
  optional bytes event_hash = 6;

  // Event type discriminant (e.g., "WorkEvent", "GateReceipt").
  // Max length: 64 characters.
  string event_type = 7;

  // Entity references (max 8).
  // Contains opaque IDs for work, episode, gate, defect, session.
  repeated EntityRef entities = 8;

  // CAS artifact references (max 8).
  // Contains hashes of related evidence, time envelopes, tool results.
  repeated CasRef cas_refs = 9;

  // Optional time envelope hash (32 bytes).
  // References the HTF time envelope for this event.
  optional bytes time_envelope_hash = 10;

  // Optional HLC timestamp (advisory only).
  // Not authoritative; use ledger_cursor for ordering.
  optional HlcStamp hlc = 11;

  // Optional wall-clock interval (observational only).
  // Represents timing uncertainty bounds.
  optional BoundedWallInterval wall = 12;
}

// -----------------------------------------------------------------------------
// Subscribe/Unsubscribe Messages
// -----------------------------------------------------------------------------

// Pattern rejection reason in subscription responses.
// Explains why a specific pattern was rejected.
message PatternRejection {
  // The pattern that was rejected.
  // Max length: 128 characters.
  string pattern = 1;

  // Reason code for rejection.
  // Valid values: INVALID_PATTERN, ACL_DENY, LIMIT_EXCEEDED
  string reason_code = 2;
}

// Subscribe to pulse topics.
// [REQ-HEF-0008] since_ledger_cursor is for resume hint only; correctness
// requires ledger catch-up.
//
// ## Bounds
//
// - Max topic_patterns: 16
// - Each pattern: max 128 chars, ASCII only
// - session_token required on session.sock (INV-SESS-001)
//
// ## ACL Enforcement (handled by TCK-00302)
//
// - Session subscriptions: deny-by-default, capability-manifest allowlist
// - Operator subscriptions: full topic taxonomy access
// - Session wildcards: rejected in Phase 1
message SubscribePulseRequest {
  // Session token for authentication (required on session.sock).
  // Operator connections may omit (authenticated by socket type).
  string session_token = 1;

  // Client-assigned subscription ID for correlation (optional).
  // Max length: 64 characters.
  string client_sub_id = 2;

  // Topic patterns to subscribe to (max 16).
  // Supports dot-delimited hierarchy with bounded wildcards.
  // Wildcard '*' matches a single segment, '>' matches remaining segments (terminal only).
  // Max 2 wildcards per pattern. Session.sock rejects wildcards in Phase 1.
  repeated string topic_patterns = 3;

  // Resume hint: start from this ledger cursor (0 = from now).
  // [REQ-HEF-0008] This is advisory; pulse replay is non-authoritative.
  // Correctness requires ledger catch-up from this cursor.
  uint64 since_ledger_cursor = 4;

  // Optional rate limit request (pulses/sec).
  // Server may clamp to lower value based on resource governance.
  uint32 max_pulses_per_sec = 5;
}

// Response to pulse subscription request.
message SubscribePulseResponse {
  // Server-assigned subscription identifier.
  // Used for unsubscribe and tracking.
  string subscription_id = 1;

  // Effective starting cursor (may differ from requested).
  // Clients should use this for ledger catch-up.
  uint64 effective_since_cursor = 2;

  // Patterns that were accepted.
  repeated string accepted_patterns = 3;

  // Patterns that were rejected with reasons.
  repeated PatternRejection rejected_patterns = 4;
}

// Unsubscribe from a pulse subscription.
message UnsubscribePulseRequest {
  // Session token for authentication (required on session.sock).
  string session_token = 1;

  // Subscription identifier from SubscribePulseResponse.
  string subscription_id = 2;
}

// Response to unsubscribe request.
message UnsubscribePulseResponse {
  // Whether the subscription was found and removed.
  bool removed = 1;
}

// -----------------------------------------------------------------------------
// PulseEvent (Server-to-Client Notification)
// -----------------------------------------------------------------------------

// Server-to-client pulse notification.
// Contains a PulseEnvelopeV1 delivered to matching subscribers.
//
// ## Delivery Semantics
//
// - Pulses are best-effort; loss does not affect correctness
// - Clients MUST verify via ledger catch-up
// - Duplicate delivery is possible; dedupe via pulse_id
message PulseEvent {
  // The pulse envelope being delivered.
  PulseEnvelopeV1 envelope = 1;
}

// -----------------------------------------------------------------------------
// HEF Error Codes
// -----------------------------------------------------------------------------

// Error codes specific to HEF pulse operations.
enum HefErrorCode {
  HEF_ERROR_UNSPECIFIED = 0;

  // Invalid topic pattern (regex, empty segments, too many wildcards).
  HEF_ERROR_INVALID_PATTERN = 1;

  // ACL denied the subscription (not in capability allowlist).
  HEF_ERROR_ACL_DENIED = 2;

  // Resource limit exceeded (max subscriptions, patterns, rate).
  HEF_ERROR_RESOURCE_LIMIT = 3;

  // Subscription not found (for unsubscribe).
  HEF_ERROR_SUBSCRIPTION_NOT_FOUND = 4;

  // Pulse envelope exceeds size limit (2048 bytes).
  HEF_ERROR_ENVELOPE_TOO_LARGE = 5;

  // Unknown fields in strict-decode context.
  HEF_ERROR_UNKNOWN_FIELDS = 6;
}

// Error response for HEF operations.
message HefError {
  HefErrorCode code = 1;
  string message = 2;
}