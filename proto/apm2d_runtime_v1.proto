syntax = "proto3";

package apm2.daemon.v1;

// CTR-PROTO-001: Handshake
message Hello {
  uint32 protocol_version = 1;
  ClientInfo client_info = 2;
  repeated string requested_caps = 3;
}

message HelloAck {
  ServerInfo server_info = 1;
  repeated string granted_caps = 2;
  bytes policy_hash = 3;
  map<string, uint32> canonicalizer_versions = 4;
}

message ClientInfo {
  string name = 1;
  string version = 2;
}

message ServerInfo {
  string name = 1;
  string version = 2;
}

// CTR-PROTO-002: Episode Control
message CreateEpisode {
  bytes envelope_hash = 1;
}

message EpisodeCreated {
  string episode_id = 1;
  string session_id = 2;
}

message StartEpisode {
  string episode_id = 1;
}

message EpisodeStarted {
  uint32 session_pid = 1;
  string io_stream_id = 2;
}

message StopEpisode {
  string episode_id = 1;
  StopReason reason = 2;
}

message EpisodeStopped {
  TerminationClass termination_class = 1;
}

message SignalEpisode {
  string episode_id = 1;
  int32 signal = 2;
}

message ResizePty {
  string episode_id = 1;
  uint32 cols = 2;
  uint32 rows = 3;
}

// Minimal v1 vocabulary for evidence economics
message EpisodeQuarantined {
  string episode_id = 1;
  string reason = 2;
  repeated bytes evidence_pinned = 3;
}

enum StopReason {
  STOP_REASON_UNSPECIFIED = 0;
  GOAL_SATISFIED = 1;
  BUDGET_EXHAUSTED = 2;
  POLICY_VIOLATION = 3;
  USER_REQUEST = 4;
  HARNESS_CRASH = 5;
  ADAPTER_FAILURE = 6;
}

enum TerminationClass {
  TERMINATION_CLASS_UNSPECIFIED = 0;
  CLEAN_EXIT = 1;
  ERROR_EXIT = 2;
  QUARANTINED = 3;
}

// CTR-PROTO-003: I/O
message SendInput {
  string episode_id = 1;
  bytes data = 2;
}

message StreamOutput {
  bytes chunk = 1;
  StreamKind kind = 2;
  uint64 seq = 3;
  uint64 ts = 4;
}

enum StreamKind {
  STDOUT = 0;
  STDERR = 1;
}

// CTR-PROTO-004: Tool Mediation
message ToolRequest {
  string episode_id = 1;
  string request_id = 2;
  string tool = 3;
  bytes dedupe_key = 4;
  bytes args_hash = 5;
  optional bytes inline_args = 6;
}

message ToolDecision {
  string request_id = 1;
  DecisionType decision = 2;
  optional string rule_id = 3;
  bytes policy_hash = 4;
  BudgetDelta budget_delta = 5;
}

enum DecisionType {
  ALLOW = 0;
  DENY = 1;
  DEDUPE_HIT = 2;
}

message ToolResult {
  string request_id = 1;
  ToolOutcome outcome = 2;
  bytes result_hash = 3;
  optional bytes inline_result = 4;
}

message BudgetDelta {
  uint64 tokens = 1;
  uint32 tool_calls = 2;
  uint64 cpu_ms = 3;
}

enum ToolOutcome {
  TOOL_OUTCOME_UNSPECIFIED = 0;
  SUCCESS = 1;
  FAILURE = 2;
  ERROR = 3;
}

// CTR-PROTO-005: Telemetry
message TelemetryFrame {
  string episode_id = 1;
  uint64 seq = 2;
  uint64 ts_mono = 3;
  uint64 cpu_ns = 4;
  uint64 mem_rss_bytes = 5;
  uint64 io_read_bytes = 6;
  uint64 io_write_bytes = 7;
  optional CgroupStats cgroup_stats = 8;
  uint32 o11y_flags = 9;
}

message CgroupStats {
  uint64 cpu_usage_usec = 1;
  uint64 memory_current = 2;
  uint64 memory_max = 3;
}

message TelemetryPolicy {
  uint64 sample_period_ms = 1;
  repeated PromoteTrigger promote_triggers = 2;
  RingBufferLimits ring_buffer_limits = 3;
}

message PromoteTrigger {
  string metric = 1;
  double threshold = 2;
}

message RingBufferLimits {
  uint64 max_pty_bytes = 1;
  uint64 max_tool_bytes = 2;
  uint64 max_tel_frames = 3;
}

// CTR-PROTO-006: Receipts and Evidence
message PublishEvidence {
  bytes artifact_hash = 1;
  EvidenceKind kind = 2;
  RetentionHint retention_hint = 3;
}

message Receipt {
  ReceiptKind kind = 1;
  bytes unsigned_bytes_hash = 2;
  bytes signature = 3;
  repeated bytes evidence_refs = 4;
  bytes policy_hash = 5;
  bytes envelope_hash = 6;
  optional string issuer_id = 7;
  optional bytes issuer_signature = 8;
}

// Minimal v1 vocabulary events for evidence economics
message EvidencePinned {
  bytes artifact_hash = 1;
  string reason = 2;
  optional string defect_id = 3;
}

message EvidenceTtlExpired {
  bytes artifact_hash = 1;
  uint64 timestamp = 2;
}

message CompactionCompleted {
  bytes summary_receipt_hash = 1;
  repeated bytes tombstoned_hashes = 2;
}

enum ReceiptKind {
  TOOL_EXECUTION = 0;
  EPISODE_START = 1;
  EPISODE_STOP = 2;
  GATE = 3;
  TELEMETRY = 4;
  COMPACTION = 5;
  STOP_ORDER = 6;
}

enum EvidenceKind {
  EVIDENCE_KIND_UNSPECIFIED = 0;
  EVIDENCE_KIND_PTY_TRANSCRIPT = 1;
  EVIDENCE_KIND_TOOL_IO = 2;
  EVIDENCE_KIND_TELEMETRY_RAW = 3;
  EVIDENCE_KIND_ADAPTER_FAILURE = 4;
  EVIDENCE_KIND_INCIDENT_SNAPSHOT = 5;
}

enum RetentionHint {
  RETENTION_HINT_UNSPECIFIED = 0;
  EPHEMERAL = 1;
  STANDARD = 2;
  ARCHIVAL = 3;
}

// =============================================================================
// CTR-PROTO-007: Privileged Endpoints (RFC-0017)
// =============================================================================
// These endpoints require operator credentials (connection on operator.sock).
// Session connections receive PERMISSION_DENIED for all privileged requests.

// Role enumeration for work claiming and episode spawning.
enum WorkRole {
  WORK_ROLE_UNSPECIFIED = 0;
  IMPLEMENTER = 1;
  GATE_EXECUTOR = 2;
  REVIEWER = 3;
  COORDINATOR = 4;
}

// IPC-PRIV-001: ClaimWork
// Request work assignment with policy-resolved capabilities.
// Per DD-001: actor_id is a display hint; authoritative actor_id derived from credential.
message ClaimWorkRequest {
  // Display-only hint for actor name. Authoritative actor_id derived from credential.
  string actor_id = 1;
  // Role for work assignment.
  WorkRole role = 2;
  // Ed25519 signature over (actor_id || role || nonce) using operator key.
  bytes credential_signature = 3;
  // Nonce to prevent replay attacks.
  bytes nonce = 4;
}

message ClaimWorkResponse {
  // Assigned work identifier.
  string work_id = 1;
  // Lease identifier for this work claim.
  string lease_id = 2;
  // Blake3 hash of the capability manifest.
  bytes capability_manifest_hash = 3;
  // Reference to the PolicyResolvedForChangeSet event.
  string policy_resolved_ref = 4;
  // Blake3 hash of the sealed context pack.
  bytes context_pack_hash = 5;
}

// IPC-PRIV-002: SpawnEpisode
// Spawn execution episode with FAC preconditions.
message SpawnEpisodeRequest {
  // Work identifier from a prior ClaimWork.
  string work_id = 1;
  // Role for this episode (IMPLEMENTER, GATE_EXECUTOR, REVIEWER).
  WorkRole role = 2;
  // Required for GATE_EXECUTOR role; must reference valid GateLeaseIssued.
  optional string lease_id = 3;
  // TCK-00319: Workspace root directory for this episode.
  // All file operations will be confined to this directory.
  // REQUIRED: Episodes cannot be spawned without a workspace root.
  string workspace_root = 4;
  // TCK-00351 BLOCKER 1: Authoritative stop conditions from the episode
  // envelope.  When present, these override StopConditions::default() so
  // that max_episodes and escalation_predicate are actually enforced.
  // When absent, the handler falls back to fail-closed defaults
  // (max_episodes=1, empty predicates).
  optional uint64 max_episodes = 5;
  // Escalation predicate from the episode envelope (free-form v1).
  // Non-empty string triggers EscalationTriggered stop denial.
  optional string escalation_predicate = 6;
  // TCK-00397: Optional adapter profile hash for explicit adapter binding.
  // Must be a 32-byte BLAKE3 digest and must resolve in CAS (fail-closed).
  // Tag 8 chosen to avoid renumbering existing fields (wire stability).
  optional bytes adapter_profile_hash = 8;
}

message SpawnEpisodeResponse {
  // Session identifier for IPC communication.
  string session_id = 1;
  // Blake3 hash of the capability manifest governing this session.
  bytes capability_manifest_hash = 2;
  // Whether the context pack is sealed.
  bool context_pack_sealed = 3;
  // Ephemeral handle for session identification (not a credential).
  string ephemeral_handle = 4;
  // HMAC-signed session token for authenticating session-scoped IPC requests.
  // TCK-00287: Required for clients to access session endpoints.
  string session_token = 5;
}

// IPC-PRIV-003: IssueCapability
// Issue additional capability to an existing session.
message IssueCapabilityRequest {
  // Target session identifier.
  string session_id = 1;
  // Capability request details.
  CapabilityRequest capability_request = 2;
}

message CapabilityRequest {
  // Tool class to grant access to.
  string tool_class = 1;
  // Path patterns for read access (optional).
  repeated string read_patterns = 2;
  // Path patterns for write access (optional).
  repeated string write_patterns = 3;
  // Duration in seconds for the capability grant.
  uint64 duration_secs = 4;
}

message IssueCapabilityResponse {
  // Unique identifier for this capability grant.
  string capability_id = 1;
  // Unix timestamp when capability was granted.
  uint64 granted_at = 2;
  // Unix timestamp when capability expires.
  uint64 expires_at = 3;
}

// IPC-PRIV-004: Shutdown
// Gracefully shutdown the daemon.
message ShutdownRequest {
  // Optional reason for shutdown (for logging/audit).
  optional string reason = 1;
}

message ShutdownResponse {
  // Acknowledgment message.
  string message = 1;
}

// IPC-PRIV-018: UpdateStopFlags
// Mutate runtime emergency/governance stop flags used by pre-actuation gating.
message UpdateStopFlagsRequest {
  // Optional emergency stop state update.
  optional bool emergency_stop_active = 1;
  // Optional governance stop state update.
  optional bool governance_stop_active = 2;
}

message UpdateStopFlagsResponse {
  // Effective emergency stop state after applying updates.
  bool emergency_stop_active = 1;
  // Effective governance stop state after applying updates.
  bool governance_stop_active = 2;
}

// IPC-PRIV-005: WorkStatus (TCK-00344)
// Query the status of a work item from the work queue.
message WorkStatusRequest {
  // Work identifier to query.
  string work_id = 1;
}

message WorkStatusResponse {
  // Work identifier.
  string work_id = 1;
  // Current work status (UNCLAIMED, CLAIMED, SPAWNED, COMPLETED, FAILED).
  string status = 2;
  // Actor who claimed this work (if claimed).
  optional string actor_id = 3;
  // Role of the actor (if claimed).
  optional WorkRole role = 4;
  // Associated session ID (if spawned).
  optional string session_id = 5;
  // Lease ID (if claimed).
  optional string lease_id = 6;
  // Work creation timestamp (nanoseconds since epoch).
  uint64 created_at_ns = 7;
  // Work claimed timestamp (nanoseconds since epoch, if claimed).
  optional uint64 claimed_at_ns = 8;
}

// IPC-PRIV-019: WorkList (TCK-00415)
// List all work items known to projection authority.
message WorkListRequest {
  // If true, return only claimable work items.
  bool claimable_only = 1;
  // Maximum number of rows to return. Server enforces a hard cap of 500
  // regardless of this value. 0 means use the server default (500).
  uint32 limit = 2;
  // Pagination cursor: work_id to start after (exclusive).
  // Empty string means start from the beginning.
  string cursor = 3;
}

message WorkListResponse {
  // Projection-derived status rows ordered deterministically by work_id.
  repeated WorkStatusResponse work_items = 1;
}

// =============================================================================
// IPC-PRIV-017: PublishChangeSet (TCK-00394, RFC-0018)
// =============================================================================
// Accepts a ChangeSetBundleV1 payload, validates it, stores it in DurableCas,
// emits a ChangeSetPublished ledger event, and returns the changeset_digest and
// cas_hash for subsequent gate lease binding.

// Request to publish a changeset bundle.
message PublishChangeSetRequest {
  // Work identifier this changeset belongs to.
  string work_id = 1;
  // Serialized ChangeSetBundleV1 (canonical JSON bytes).
  bytes bundle_bytes = 2;
}

// Response confirming changeset publication.
message PublishChangeSetResponse {
  // BLAKE3 digest of the canonical bundle (hex-encoded, 64 chars).
  string changeset_digest = 1;
  // CAS hash of the stored bundle artifact (hex-encoded, 64 chars).
  string cas_hash = 2;
  // Work identifier this changeset belongs to.
  string work_id = 3;
  // Ledger event ID for the ChangeSetPublished event.
  string event_id = 4;
}

// =============================================================================
// IPC-PRIV-016: EndSession (TCK-00395)
// =============================================================================
// Terminates an active session and emits SessionTerminated + WorkTransitioned
// ledger events. Wires the SessionTerminated code-path into production use.

// Typed termination outcome for EndSession (TCK-00395 Quality v3 MAJOR).
// Replaces free-form string matching for success/failure inference.
enum TerminationOutcome {
  // Unspecified outcome (treated as failure for safety).
  TERMINATION_OUTCOME_UNSPECIFIED = 0;
  // Session completed successfully (exit_code = 0).
  TERMINATION_OUTCOME_SUCCESS = 1;
  // Session failed (exit_code = 1).
  TERMINATION_OUTCOME_FAILURE = 2;
  // Session was cancelled by the operator.
  TERMINATION_OUTCOME_CANCELLED = 3;
  // Session timed out.
  TERMINATION_OUTCOME_TIMEOUT = 4;
}

// Request to end an active session.
message EndSessionRequest {
  // Identifier of the session to terminate.
  string session_id = 1;
  // Human-readable reason for termination.
  string reason = 2;
  // Typed termination outcome (TCK-00395 Quality v3 MAJOR).
  // When set, this takes precedence over string-based reason matching.
  TerminationOutcome outcome = 3;
}

// Response confirming session termination.
message EndSessionResponse {
  // Identifier of the terminated session.
  string session_id = 1;
  // Human-readable confirmation message.
  string message = 2;
}

// =============================================================================
// CTR-PROTO-012: Credential Management Endpoints (RFC-0018, TCK-00343)
// =============================================================================
// These endpoints manage credential profiles for agent authentication.
// All credential operations are privileged and require operator.sock (mode 0600).
// Credential secrets are never exposed in responses or logged.

// Credential provider enumeration.
enum CredentialProvider {
  CREDENTIAL_PROVIDER_UNSPECIFIED = 0;
  // GitHub OAuth/PAT authentication.
  CREDENTIAL_PROVIDER_GITHUB = 1;
  // Anthropic API key authentication.
  CREDENTIAL_PROVIDER_ANTHROPIC = 2;
  // OpenAI API key authentication.
  CREDENTIAL_PROVIDER_OPENAI = 3;
  // Generic API key authentication.
  CREDENTIAL_PROVIDER_API_KEY = 4;
}

// Authentication method enumeration.
enum CredentialAuthMethod {
  CREDENTIAL_AUTH_METHOD_UNSPECIFIED = 0;
  // OAuth 2.0 flow.
  CREDENTIAL_AUTH_METHOD_OAUTH = 1;
  // Personal Access Token.
  CREDENTIAL_AUTH_METHOD_PAT = 2;
  // API key.
  CREDENTIAL_AUTH_METHOD_API_KEY = 3;
  // SSH key (agent-based).
  CREDENTIAL_AUTH_METHOD_SSH = 4;
}

// Credential profile metadata (secrets are never included).
message CredentialProfile {
  // Unique identifier for this profile.
  string profile_id = 1;
  // Credential provider.
  CredentialProvider provider = 2;
  // Authentication method.
  CredentialAuthMethod auth_method = 3;
  // Unix timestamp when credential was created.
  uint64 created_at = 4;
  // Unix timestamp when credential expires (0 = never).
  uint64 expires_at = 5;
  // Whether the credential is currently active.
  bool is_active = 6;
  // Optional display name for the profile.
  string display_name = 7;
}

// IPC-PRIV-021: ListCredentials
// List all credential profiles (secrets are never included).
message ListCredentialsRequest {
  // Optional filter by provider.
  optional CredentialProvider provider_filter = 1;
}

message ListCredentialsResponse {
  // List of credential profiles.
  repeated CredentialProfile profiles = 1;
  // Total count of profiles (may differ from list if filtered).
  uint32 total_count = 2;
}

// IPC-PRIV-022: AddCredential
// Add a new credential profile.
message AddCredentialRequest {
  // Unique identifier for this profile.
  string profile_id = 1;
  // Credential provider.
  CredentialProvider provider = 2;
  // Authentication method.
  CredentialAuthMethod auth_method = 3;
  // Credential secret (will be stored securely, never logged).
  // For OAuth: access token; for PAT/API_KEY: the key itself.
  bytes credential_secret = 4;
  // Optional display name for the profile.
  string display_name = 5;
  // Optional expiration time (Unix timestamp, 0 = never).
  uint64 expires_at = 6;
}

message AddCredentialResponse {
  // The created profile metadata (secret is never returned).
  CredentialProfile profile = 1;
}

// IPC-PRIV-023: RemoveCredential
// Remove a credential profile.
message RemoveCredentialRequest {
  // Profile ID to remove.
  string profile_id = 1;
}

message RemoveCredentialResponse {
  // Whether the profile was removed (false if not found).
  bool removed = 1;
}

// IPC-PRIV-024: RefreshCredential
// Refresh an OAuth credential (request new token).
message RefreshCredentialRequest {
  // Profile ID to refresh.
  string profile_id = 1;
}

message RefreshCredentialResponse {
  // The updated profile metadata (secret is never returned).
  CredentialProfile profile = 1;
  // New expiration time (0 = never).
  uint64 new_expires_at = 2;
}

// IPC-PRIV-025: SwitchCredential
// Switch active credential for a process.
message SwitchCredentialRequest {
  // Target process name or session ID.
  string process_name = 1;
  // Profile ID to switch to.
  string profile_id = 2;
}

message SwitchCredentialResponse {
  // Previous active profile ID (empty if none).
  string previous_profile_id = 1;
  // Whether the switch was successful.
  bool success = 2;
}

// IPC-PRIV-026: LoginCredential
// Interactive login for a provider (initiates OAuth flow or prompts for key).
message LoginCredentialRequest {
  // Provider to login with.
  CredentialProvider provider = 1;
  // Optional profile ID to create/update (auto-generated if not provided).
  optional string profile_id = 2;
  // Optional display name for the profile.
  string display_name = 3;
}

message LoginCredentialResponse {
  // The created/updated profile metadata.
  CredentialProfile profile = 1;
  // Login URL for OAuth flows (empty for non-OAuth).
  string login_url = 2;
  // Whether login completed immediately (false if OAuth redirect required).
  bool completed = 3;
}

// =============================================================================
// Error Codes for Privileged Endpoints
// =============================================================================
enum PrivilegedErrorCode {
  PRIVILEGED_ERROR_UNSPECIFIED = 0;
  // Caller lacks operator credential (not on operator.sock).
  PERMISSION_DENIED = 1;
  // Invalid parameter in request.
  CAPABILITY_REQUEST_REJECTED = 2;
  // Governance policy resolution failed.
  POLICY_RESOLUTION_FAILED = 3;
  // Required policy resolution missing for spawn.
  POLICY_RESOLUTION_MISSING = 4;
  // GATE_EXECUTOR spawn requires valid lease.
  GATE_LEASE_MISSING = 5;
  // Custody domain overlap detected (separation of duties violation).
  SOD_VIOLATION = 6;
  // Referenced session not found.
  SESSION_NOT_FOUND = 7;
  // Capability grant denied by policy.
  CAPABILITY_DENIED = 8;
  // Referenced work item not found.
  WORK_NOT_FOUND = 9;
  // Credential profile not found.
  CREDENTIAL_NOT_FOUND = 14;
  // Credential profile already exists.
  CREDENTIAL_ALREADY_EXISTS = 15;
  // Credential operation failed (keychain error).
  CREDENTIAL_OPERATION_FAILED = 16;
  // Credential refresh not supported for this auth method.
  CREDENTIAL_REFRESH_NOT_SUPPORTED = 17;
  // Invalid credential provider or auth method.
  CREDENTIAL_INVALID_CONFIG = 18;
}

// Generic error response for privileged endpoints.
message PrivilegedError {
  PrivilegedErrorCode code = 1;
  string message = 2;
}

// =============================================================================
// CTR-PROTO-008: Session-Scoped Endpoints (RFC-0017, TCK-00252)
// =============================================================================
// These endpoints require a valid session_token (connection on session.sock).
// Invalid or expired tokens receive SESSION_INVALID error.
// Operator socket connections receive PERMISSION_DENIED for session requests.

// IPC-SESS-001: RequestTool
// Request tool execution within session capability bounds.
message RequestToolRequest {
  // Session token for authentication (validated via HMAC-SHA256).
  string session_token = 1;
  // Tool identifier (e.g., "file_read", "shell_exec").
  string tool_id = 2;
  // Serialized tool arguments (JSON or binary).
  bytes arguments = 3;
  // Deduplication key for idempotent requests.
  string dedupe_key = 4;
}

message RequestToolResponse {
  // Request identifier for tracking.
  string request_id = 1;
  // Tool decision (ALLOW, DENY, DEDUPE_HIT).
  DecisionType decision = 2;
  // Rule that matched (if DENY).
  optional string rule_id = 3;
  // Policy hash at decision time.
  bytes policy_hash = 4;
  // Result hash from tool execution (CAS reference, populated on ALLOW after execution).
  // TCK-00316: Required for kernel-side execution model.
  optional bytes result_hash = 5;
  // Inline result for small outputs (bounded by MAX_INLINE_RESULT_SIZE = 64KB).
  // TCK-00316: Security - enforces DoS protection per SEC-CTRL-FAC-0015.
  optional bytes inline_result = 6;
  // TCK-00351: Pre-actuation stop check proof.
  // True indicates stop conditions were evaluated and cleared before actuation.
  // False or absent indicates stop check was not performed (fail-closed: deny).
  bool stop_checked = 7;
  // TCK-00351: Pre-actuation budget check proof.
  // True indicates budget was enforced at pre-actuation.
  // False is only valid when `budget_enforcement_deferred=true`.
  // Replayers MUST reject traces where both `budget_checked=false` and
  // `budget_enforcement_deferred=false`.
  bool budget_checked = 8;
  // TCK-00351: Explicitly marks budget enforcement deferred beyond
  // pre-actuation (e.g., to EpisodeRuntime).
  bool budget_enforcement_deferred = 9;
  // TCK-00351: HTF timestamp (nanoseconds) when pre-actuation checks completed.
  // Provides replay-verifiable ordering proof that checks preceded actuation.
  uint64 preactuation_timestamp_ns = 10;
}

// IPC-SESS-002: EmitEvent
// Emit a signed event to the ledger.
message EmitEventRequest {
  // Session token for authentication.
  string session_token = 1;
  // Event type identifier.
  string event_type = 2;
  // Event payload (JSON or binary).
  bytes payload = 3;
  // Correlation ID for event tracing.
  string correlation_id = 4;
}

message EmitEventResponse {
  // Event identifier in the ledger.
  string event_id = 1;
  // Sequence number in the session.
  uint64 seq = 2;
  // Timestamp when event was recorded (nanoseconds since epoch).
  uint64 timestamp_ns = 3;
}

// IPC-SESS-003: PublishEvidence
// Publish evidence artifact to content-addressed storage.
message PublishEvidenceRequest {
  // Session token for authentication.
  string session_token = 1;
  // Artifact content (binary).
  bytes artifact = 2;
  // Evidence kind for categorization.
  EvidenceKind kind = 3;
  // Retention hint for storage policy.
  RetentionHint retention_hint = 4;
}

message PublishEvidenceResponse {
  // Blake3 hash of the artifact (content address).
  bytes artifact_hash = 1;
  // Storage location hint.
  string storage_path = 2;
  // TTL in seconds (0 = permanent).
  uint64 ttl_secs = 3;
}

// IPC-SESS-004: StreamTelemetry
// Stream telemetry frames for observability.
message StreamTelemetryRequest {
  // Session token for authentication.
  string session_token = 1;
  // Telemetry frame to stream.
  TelemetryFrame frame = 2;
}

message StreamTelemetryResponse {
  // Acknowledgment sequence number.
  uint64 ack_seq = 1;
  // Whether frame was promoted to persistent storage.
  bool promoted = 2;
}

// IPC-SESS-005: SessionStatus (TCK-00344)
// Query session-scoped status via session.sock.
message SessionStatusRequest {
  // Session token for authentication.
  string session_token = 1;
}

message SessionStatusResponse {
  // Session identifier.
  string session_id = 1;
  // Current session state (ACTIVE, SUSPENDED, TERMINATED).
  string state = 2;
  // Work ID this session is associated with.
  string work_id = 3;
  // Role of the session.
  WorkRole role = 4;
  // Episode ID (if associated).
  optional string episode_id = 5;
  // Telemetry summary: total tool calls executed.
  uint32 tool_calls = 6;
  // Telemetry summary: total events emitted.
  uint32 events_emitted = 7;
  // Session start timestamp (nanoseconds since epoch).
  uint64 started_at_ns = 8;
  // Session duration in milliseconds.
  uint64 duration_ms = 9;

  // TCK-00385: Session termination fields.
  // Present only when state == "TERMINATED".

  // Termination reason (normal, crash, timeout, quarantined, budget_exhausted).
  optional string termination_reason = 10;
  // Process exit code (0 = success).
  optional int32 exit_code = 11;
  // Timestamp when session terminated (nanoseconds since epoch).
  optional uint64 terminated_at_ns = 12;
  // Actual tokens consumed by the session (if available from agent adapter).
  optional uint64 actual_tokens_consumed = 13;
}

// =============================================================================
// Error Codes for Session-Scoped Endpoints
// =============================================================================
enum SessionErrorCode {
  SESSION_ERROR_UNSPECIFIED = 0;
  // Session token is invalid (expired, tampered, or missing).
  SESSION_ERROR_INVALID = 1;
  // Session has been terminated.
  SESSION_ERROR_TERMINATED = 2;
  // Tool not allowed by capability manifest.
  SESSION_ERROR_TOOL_NOT_ALLOWED = 3;
  // Budget exhausted for this session.
  SESSION_ERROR_BUDGET_EXHAUSTED = 4;
  // Context firewall violation (deny + terminate).
  SESSION_ERROR_CONTEXT_FIREWALL = 5;
  // Caller is on operator socket (session endpoints require session.sock).
  SESSION_ERROR_PERMISSION_DENIED = 6;
  // Endpoint not implemented (fail-closed for unimplemented features).
  SESSION_ERROR_NOT_IMPLEMENTED = 7;
  // Internal error (ledger, CAS, or other subsystem failure).
  SESSION_ERROR_INTERNAL = 8;
}

// Generic error response for session-scoped endpoints.
message SessionError {
  SessionErrorCode code = 1;
  string message = 2;
}

// =============================================================================
// CTR-PROTO-009: Crash Recovery Signals (TCK-00267)
// =============================================================================
// These messages support daemon crash recovery and lease revocation.

// Reason for lease revocation.
enum LeaseRevokedReason {
  LEASE_REVOKED_REASON_UNSPECIFIED = 0;
  // Daemon crashed and restarted, invalidating all prior leases.
  LEASE_REVOKED_DAEMON_RESTART = 1;
  // Lease expired during daemon downtime.
  LEASE_REVOKED_EXPIRED = 2;
  // Explicit revocation by operator.
  LEASE_REVOKED_BY_OPERATOR = 3;
  // Session violated policy (context firewall, etc.).
  LEASE_REVOKED_POLICY_VIOLATION = 4;
}

// Signal sent to sessions when their lease is revoked.
// Sessions receiving this signal MUST re-authenticate before continuing.
message LeaseRevoked {
  // The session whose lease is being revoked.
  string session_id = 1;
  // The lease that was revoked.
  string lease_id = 2;
  // Why the lease is being revoked.
  LeaseRevokedReason reason = 3;
  // Timestamp when the lease was revoked (nanoseconds since epoch).
  uint64 revoked_at_ns = 4;
  // Human-readable message explaining the revocation.
  optional string message = 5;
}

// Request to recover sessions after daemon restart.
// Privileged endpoint (operator.sock only).
message RecoverSessionsRequest {
  // Maximum time to wait for recovery (milliseconds).
  // Default: 5000 (5 seconds per acceptance criteria).
  uint32 timeout_ms = 1;
}

// Response from session recovery.
message RecoverSessionsResponse {
  // Number of sessions that were recovered.
  uint32 sessions_recovered = 1;
  // Number of orphaned processes cleaned up.
  uint32 orphaned_processes_cleaned = 2;
  // Number of LEASE_REVOKED signals sent.
  uint32 lease_revoked_signals_sent = 3;
  // Time taken for recovery (milliseconds).
  uint32 recovery_time_ms = 4;
}

// =============================================================================
// CTR-PROTO-010: HEF Pulse Plane (RFC-0018, TCK-00300)
// =============================================================================
// Holonic Event Fabric (HEF) pulse messages for lossy event notifications.
// Pulses are derived from committed ledger+CAS artifacts and provide hints
// only. Correctness requires ledger catch-up; pulse loss does not affect
// authoritative outcomes.
//
// ## Message Tag Range (HEF Reserved)
//
// HEF messages use tag range 64-79 to avoid collisions with existing messages:
// - Session socket (session.sock): Tags 64-71 reserved for HEF
// - Operator socket (operator.sock): Tags 64-71 reserved for HEF
//
// Current HEF tag assignments:
// - 64 = SubscribePulseRequest
// - 65 = SubscribePulseResponse
// - 66 = UnsubscribePulseRequest
// - 67 = UnsubscribePulseResponse
// - 68 = PulseEvent (server->client only)
// - 69-79 = Reserved for future HEF extensions
//
// ## Security Invariants
//
// - [INV-HEF-001] PulseEnvelopeV1 max size: 2048 bytes
// - [INV-HEF-002] Unknown fields MUST cause decode failure (fail-closed)
// - [INV-HEF-003] All string IDs are ASCII-only and length-bounded
// - [INV-HEF-004] since_ledger_cursor in subscriptions is for resume hints only
// - [INV-HEF-005] Pulse correctness requires ledger catch-up, not pulse replay

// -----------------------------------------------------------------------------
// HEF Supporting Types
// -----------------------------------------------------------------------------

// Entity reference within a pulse envelope.
// References opaque identifiers (work_id, episode_id, gate_id, defect_id).
// [CTR-HEF-0001] ASCII-only, length-bounded identifiers.
message EntityRef {
  // Entity kind discriminant.
  // Valid values: WORK, EPISODE, GATE, DEFECT, SESSION
  // Max length: 16 characters, ASCII only.
  string kind = 1;

  // Entity identifier.
  // Max length: 128 characters, ASCII only.
  string id = 2;

  // Optional content digest (32 bytes, typically Blake3).
  // Used for ChangeSet or artifact references.
  optional bytes digest = 3;
}

// Content-addressed storage reference.
// [CTR-HEF-0001] Used to reference CAS artifacts in pulse envelopes.
message CasRef {
  // Blake3 hash of the artifact (32 bytes).
  bytes hash = 1;

  // Size of the artifact in bytes.
  // Used for resource governance and prefetch decisions.
  uint64 size_bytes = 2;

  // Artifact kind discriminant.
  // Valid values: EVIDENCE, TIME_ENVELOPE, TOOL_RESULT, IO_CHUNK
  // Max length: 32 characters, ASCII only.
  string kind = 3;
}

// Hybrid Logical Clock timestamp (advisory only).
// [INV-HEF-004] HLC is observational; ledger cursor is authoritative.
message HlcStamp {
  // Wall clock component (nanoseconds since Unix epoch).
  uint64 wall_ns = 1;

  // Logical counter component.
  uint32 logical = 2;

  // Node identifier (32 bytes, truncated from node key hash).
  bytes node_id = 3;
}

// Bounded wall-clock interval (observational only).
// Represents the uncertainty window for event timing.
message BoundedWallInterval {
  // Earliest possible wall time (nanoseconds since Unix epoch).
  uint64 earliest_ns = 1;

  // Latest possible wall time (nanoseconds since Unix epoch).
  uint64 latest_ns = 2;
}

// -----------------------------------------------------------------------------
// PulseEnvelopeV1 (Core HEF Data Structure)
// -----------------------------------------------------------------------------

// Lossy event hint derived from committed ledger+CAS artifacts.
//
// ## Bounds (CTR-HEF-0001, REQ-HEF-0002)
//
// - Max total size: 2048 bytes
// - Max entities: 8
// - Max cas_refs: 8
// - pulse_id: max 64 chars, ASCII only
// - topic: max 128 chars, ASCII only, dot-delimited
// - event_type: max 64 chars
//
// ## Versioning
//
// schema_version MUST be 1 for this version. Unknown schema versions
// MUST cause decode failure (fail-closed per INV-HEF-002).
message PulseEnvelopeV1 {
  // Schema version discriminant. MUST be 1 for PulseEnvelopeV1.
  // Unknown versions cause decode failure.
  uint32 schema_version = 1;

  // Unique pulse identifier.
  // Max length: 64 characters, ASCII only.
  // Format: `{topic_hash}:{seq}:{random}` or daemon-assigned UUID.
  string pulse_id = 2;

  // Topic string (dot-delimited hierarchy).
  // Max length: 128 characters, ASCII only.
  // Examples: "work.W-123.events", "gate.W-123.CS-abc.G-001"
  string topic = 3;

  // Ledger sequence ID (cursor) at which this event was committed.
  // Authoritative for ordering and catch-up.
  uint64 ledger_cursor = 4;

  // Current ledger head at emission time (0 if unknown).
  // Advisory hint for client catch-up decisions.
  uint64 ledger_head = 5;

  // Blake3 hash of the ledger event (32 bytes, optional).
  // Used for content verification and deduplication.
  optional bytes event_hash = 6;

  // Event type discriminant (e.g., "WorkEvent", "GateReceipt").
  // Max length: 64 characters.
  string event_type = 7;

  // Entity references (max 8).
  // Contains opaque IDs for work, episode, gate, defect, session.
  repeated EntityRef entities = 8;

  // CAS artifact references (max 8).
  // Contains hashes of related evidence, time envelopes, tool results.
  repeated CasRef cas_refs = 9;

  // Optional time envelope hash (32 bytes).
  // References the HTF time envelope for this event.
  optional bytes time_envelope_hash = 10;

  // Optional HLC timestamp (advisory only).
  // Not authoritative; use ledger_cursor for ordering.
  optional HlcStamp hlc = 11;

  // Optional wall-clock interval (observational only).
  // Represents timing uncertainty bounds.
  optional BoundedWallInterval wall = 12;
}

// -----------------------------------------------------------------------------
// Subscribe/Unsubscribe Messages
// -----------------------------------------------------------------------------

// Pattern rejection reason in subscription responses.
// Explains why a specific pattern was rejected.
message PatternRejection {
  // The pattern that was rejected.
  // Max length: 128 characters.
  string pattern = 1;

  // Reason code for rejection.
  // Valid values: INVALID_PATTERN, ACL_DENY, LIMIT_EXCEEDED
  string reason_code = 2;
}

// Subscribe to pulse topics.
// [REQ-HEF-0008] since_ledger_cursor is for resume hint only; correctness
// requires ledger catch-up.
//
// ## Bounds
//
// - Max topic_patterns: 16
// - Each pattern: max 128 chars, ASCII only
// - session_token required on session.sock (INV-SESS-001)
//
// ## ACL Enforcement (handled by TCK-00302)
//
// - Session subscriptions: deny-by-default, capability-manifest allowlist
// - Operator subscriptions: full topic taxonomy access
// - Session wildcards: rejected in Phase 1
message SubscribePulseRequest {
  // Session token for authentication (required on session.sock).
  // Operator connections may omit (authenticated by socket type).
  string session_token = 1;

  // Client-assigned subscription ID for correlation (optional).
  // Max length: 64 characters.
  string client_sub_id = 2;

  // Topic patterns to subscribe to (max 16).
  // Supports dot-delimited hierarchy with bounded wildcards.
  // Wildcard '*' matches a single segment, '>' matches remaining segments (terminal only).
  // Max 2 wildcards per pattern. Session.sock rejects wildcards in Phase 1.
  repeated string topic_patterns = 3;

  // Resume hint: start from this ledger cursor (0 = from now).
  // [REQ-HEF-0008] This is advisory; pulse replay is non-authoritative.
  // Correctness requires ledger catch-up from this cursor.
  uint64 since_ledger_cursor = 4;

  // Optional rate limit request (pulses/sec).
  // Server may clamp to lower value based on resource governance.
  uint32 max_pulses_per_sec = 5;
}

// Response to pulse subscription request.
message SubscribePulseResponse {
  // Server-assigned subscription identifier.
  // Used for unsubscribe and tracking.
  string subscription_id = 1;

  // Effective starting cursor (may differ from requested).
  // Clients should use this for ledger catch-up.
  uint64 effective_since_cursor = 2;

  // Patterns that were accepted.
  repeated string accepted_patterns = 3;

  // Patterns that were rejected with reasons.
  repeated PatternRejection rejected_patterns = 4;
}

// Unsubscribe from a pulse subscription.
message UnsubscribePulseRequest {
  // Session token for authentication (required on session.sock).
  string session_token = 1;

  // Subscription identifier from SubscribePulseResponse.
  string subscription_id = 2;
}

// Response to unsubscribe request.
message UnsubscribePulseResponse {
  // Whether the subscription was found and removed.
  bool removed = 1;
}

// -----------------------------------------------------------------------------
// PulseEvent (Server-to-Client Notification)
// -----------------------------------------------------------------------------

// Server-to-client pulse notification.
// Contains a PulseEnvelopeV1 delivered to matching subscribers.
//
// ## Delivery Semantics
//
// - Pulses are best-effort; loss does not affect correctness
// - Clients MUST verify via ledger catch-up
// - Duplicate delivery is possible; dedupe via pulse_id
message PulseEvent {
  // The pulse envelope being delivered.
  PulseEnvelopeV1 envelope = 1;
}

// -----------------------------------------------------------------------------
// HEF Error Codes
// -----------------------------------------------------------------------------

// Error codes specific to HEF pulse operations.
enum HefErrorCode {
  HEF_ERROR_UNSPECIFIED = 0;

  // Invalid topic pattern (regex, empty segments, too many wildcards).
  HEF_ERROR_INVALID_PATTERN = 1;

  // ACL denied the subscription (not in capability allowlist).
  HEF_ERROR_ACL_DENIED = 2;

  // Resource limit exceeded (max subscriptions, patterns, rate).
  HEF_ERROR_RESOURCE_LIMIT = 3;

  // Subscription not found (for unsubscribe).
  HEF_ERROR_SUBSCRIPTION_NOT_FOUND = 4;

  // Pulse envelope exceeds size limit (2048 bytes).
  HEF_ERROR_ENVELOPE_TOO_LARGE = 5;

  // Unknown fields in strict-decode context.
  HEF_ERROR_UNKNOWN_FIELDS = 6;
}

// Error response for HEF operations.
message HefError {
  HefErrorCode code = 1;
  string message = 2;
}

// =============================================================================
// CTR-PROTO-011: Process Management Endpoints (TCK-00342)
// =============================================================================
// These endpoints provide process lifecycle management via operator.sock.
// All process management operations (except StreamLogs) require operator
// credentials. StreamLogs uses session.sock with a valid session_token.
//
// ## Message Tag Range
//
// Process management messages use tag range 5-10 for privileged endpoints:
// - 5 = ListProcesses
// - 6 = ProcessStatus
// - 7 = StartProcess
// - 8 = StopProcess
// - 9 = RestartProcess
// - 10 = ReloadProcess
//
// Session-scoped process messages use tag 5 in session namespace:
// - 5 = StreamLogs (session.sock)

// -----------------------------------------------------------------------------
// Process State Enum
// -----------------------------------------------------------------------------

// Process lifecycle state.
enum ProcessStateEnum {
  PROCESS_STATE_UNSPECIFIED = 0;
  PROCESS_STATE_STARTING = 1;
  PROCESS_STATE_RUNNING = 2;
  PROCESS_STATE_UNHEALTHY = 3;
  PROCESS_STATE_STOPPING = 4;
  PROCESS_STATE_STOPPED = 5;
  PROCESS_STATE_CRASHED = 6;
  PROCESS_STATE_TERMINATED = 7;
}

// -----------------------------------------------------------------------------
// IPC-PRIV-005: ListProcesses
// -----------------------------------------------------------------------------

// Request to list all configured processes.
message ListProcessesRequest {
  // No parameters required - lists all processes.
}

// Information about a single process.
message ProcessInfo {
  // Process name (unique identifier).
  string name = 1;
  // Current process state.
  ProcessStateEnum state = 2;
  // Total number of configured instances.
  uint32 instances = 3;
  // Number of currently running instances.
  uint32 running_instances = 4;
  // OS process ID (if running, first instance).
  optional uint32 pid = 5;
  // Uptime in seconds (if running).
  optional uint64 uptime_secs = 6;
  // Exit code (if stopped/crashed).
  optional int32 exit_code = 7;
}

// Response containing list of all processes.
message ListProcessesResponse {
  // List of all configured processes.
  repeated ProcessInfo processes = 1;
}

// -----------------------------------------------------------------------------
// IPC-PRIV-006: ProcessStatus
// -----------------------------------------------------------------------------

// Request detailed status for a specific process.
message ProcessStatusRequest {
  // Process name to query.
  string name = 1;
}

// Detailed status response for a process.
message ProcessStatusResponse {
  // Basic process information.
  ProcessInfo info = 1;
  // Total restart count across all instances.
  uint32 restart_count = 2;
  // CPU usage percentage (0-100, if available).
  optional float cpu_percent = 3;
  // Memory usage in bytes (if available).
  optional uint64 memory_bytes = 4;
  // Command being executed.
  string command = 5;
  // Working directory.
  optional string cwd = 6;
}

// -----------------------------------------------------------------------------
// IPC-PRIV-007: StartProcess
// -----------------------------------------------------------------------------

// Request to start a configured process.
message StartProcessRequest {
  // Process name to start.
  string name = 1;
}

// Response after starting a process.
message StartProcessResponse {
  // Process name that was started.
  string name = 1;
  // Number of instances that were started.
  uint32 instances_started = 2;
  // Message describing the result.
  string message = 3;
}

// -----------------------------------------------------------------------------
// IPC-PRIV-008: StopProcess
// -----------------------------------------------------------------------------

// Request to stop a running process.
message StopProcessRequest {
  // Process name to stop.
  string name = 1;
}

// Response after stopping a process.
message StopProcessResponse {
  // Process name that was stopped.
  string name = 1;
  // Number of instances that were stopped.
  uint32 instances_stopped = 2;
  // Message describing the result.
  string message = 3;
}

// -----------------------------------------------------------------------------
// IPC-PRIV-009: RestartProcess
// -----------------------------------------------------------------------------

// Request to restart a process (stop then start).
message RestartProcessRequest {
  // Process name to restart.
  string name = 1;
}

// Response after restarting a process.
message RestartProcessResponse {
  // Process name that was restarted.
  string name = 1;
  // Number of instances that were restarted.
  uint32 instances_restarted = 2;
  // Message describing the result.
  string message = 3;
}

// -----------------------------------------------------------------------------
// IPC-PRIV-010: ReloadProcess
// -----------------------------------------------------------------------------

// Request to perform a rolling restart (graceful reload).
message ReloadProcessRequest {
  // Process name to reload.
  string name = 1;
}

// Response after reload operation.
message ReloadProcessResponse {
  // Process name that was reloaded.
  string name = 1;
  // Whether the reload was successful.
  bool success = 2;
  // Message describing the result.
  string message = 3;
}

// -----------------------------------------------------------------------------
// IPC-SESS-005: StreamLogs (Session Socket)
// -----------------------------------------------------------------------------

// Request to stream process logs.
// This endpoint uses session.sock and requires a valid session_token.
message StreamLogsRequest {
  // Session token for authentication.
  string session_token = 1;
  // Process name to stream logs for.
  string process_name = 2;
  // Number of historical lines to return (max 1000).
  uint32 lines = 3;
  // Whether to follow (stream new lines). Reserved for future use.
  bool follow = 4;
}

// A single log entry.
message LogEntry {
  // Timestamp in nanoseconds since epoch.
  uint64 timestamp_ns = 1;
  // Log line content.
  string line = 2;
  // Stream kind (stdout/stderr).
  StreamKind stream = 3;
  // Instance index (for multi-instance processes).
  uint32 instance = 4;
}

// Response containing log entries.
message StreamLogsResponse {
  // Log entries (most recent last).
  repeated LogEntry entries = 1;
  // Whether there are more entries available.
  bool has_more = 2;
  // Process name the logs are from.
  string process_name = 3;
}

// -----------------------------------------------------------------------------
// Process Management Error Codes
// -----------------------------------------------------------------------------

// Error codes for process management operations.
enum ProcessErrorCode {
  PROCESS_ERROR_UNSPECIFIED = 0;
  // Process not found by name.
  PROCESS_ERROR_NOT_FOUND = 1;
  // Process is already running (for start).
  PROCESS_ERROR_ALREADY_RUNNING = 2;
  // Process is not running (for stop).
  PROCESS_ERROR_NOT_RUNNING = 3;
  // Failed to start process.
  PROCESS_ERROR_START_FAILED = 4;
  // Failed to stop process.
  PROCESS_ERROR_STOP_FAILED = 5;
  // Invalid process name.
  PROCESS_ERROR_INVALID_NAME = 6;
}

// =============================================================================
// CTR-PROTO-011: Consensus Query Endpoints (RFC-0014, TCK-00345)
// =============================================================================
// Privileged endpoints for querying consensus subsystem state.
// These endpoints are only accessible via operator.sock.
//
// ## Message Tag Range (Consensus Reserved)
//
// Consensus query messages use tag range 11-14 on operator socket:
// - 11 = ConsensusStatusRequest/Response
// - 12 = ConsensusValidatorsRequest/Response
// - 13 = ConsensusByzantineEvidenceRequest/Response
// - 14 = ConsensusMetricsRequest/Response
//
// ## Behavior When Consensus Not Configured
//
// If the consensus subsystem is not configured (single-node mode), these
// endpoints return CONSENSUS_NOT_CONFIGURED error rather than mock data.

// IPC-PRIV-011: ConsensusStatus
// Query current consensus cluster status.
message ConsensusStatusRequest {
  // Include verbose details (QC info, committed block hash).
  bool verbose = 1;
}

message ConsensusStatusResponse {
  // Node ID reporting this status.
  string node_id = 1;
  // Current consensus epoch.
  uint64 epoch = 2;
  // Current consensus round.
  uint64 round = 3;
  // Current leader validator ID (hex).
  string leader_id = 4;
  // Whether this node is the current leader.
  bool is_leader = 5;
  // Total validators in cluster.
  uint32 validator_count = 6;
  // Active validators.
  uint32 active_validators = 7;
  // Quorum threshold (2f+1).
  uint32 quorum_threshold = 8;
  // Whether quorum is currently met.
  bool quorum_met = 9;
  // Cluster health status: "healthy", "degraded", "critical", "unknown".
  string health = 10;
  // Highest QC round (if verbose).
  optional uint64 high_qc_round = 11;
  // Locked QC round (if verbose).
  optional uint64 locked_qc_round = 12;
  // Committed blocks count (if verbose).
  optional uint32 committed_blocks = 13;
  // Last committed hash (hex, if verbose).
  optional string last_committed_hash = 14;
}

// IPC-PRIV-012: ConsensusValidators
// Query validator list and status.
message ConsensusValidatorsRequest {
  // Show only active validators.
  bool active_only = 1;
}

// Validator information.
message ValidatorInfo {
  // Validator ID (hex).
  string id = 1;
  // Validator index in the set.
  uint32 index = 2;
  // Public key (hex).
  string public_key = 3;
  // Whether validator is active (reachable).
  bool active = 4;
  // Last seen timestamp (RFC 3339, optional).
  optional string last_seen = 5;
}

message ConsensusValidatorsResponse {
  // List of validators.
  repeated ValidatorInfo validators = 1;
  // Total count.
  uint32 total = 2;
  // Active count.
  uint32 active = 3;
}

// IPC-PRIV-013: ConsensusByzantineEvidence
// Query detected Byzantine fault evidence.
message ConsensusByzantineEvidenceRequest {
  // Filter by fault type: "equivocation", "invalid_signature",
  // "quorum_forgery", "replay", or empty for all.
  optional string fault_type = 1;
  // Maximum number of entries to return (max 1000).
  uint32 limit = 2;
}

// Byzantine fault evidence entry.
message ByzantineEvidenceEntry {
  // Evidence ID.
  string id = 1;
  // Fault type.
  string fault_type = 2;
  // Validator ID that generated the fault.
  string validator_id = 3;
  // Evidence details.
  string details = 4;
  // Timestamp (RFC 3339).
  string timestamp = 5;
  // Epoch when detected.
  uint64 epoch = 6;
  // Round when detected.
  uint64 round = 7;
}

message ConsensusByzantineEvidenceResponse {
  // List of evidence entries.
  repeated ByzantineEvidenceEntry evidence = 1;
  // Total count.
  uint32 total = 2;
}

// IPC-PRIV-014: ConsensusMetrics
// Query consensus metrics summary.
message ConsensusMetricsRequest {
  // Time period for rate calculations (seconds).
  uint64 period_secs = 1;
}

message ConsensusMetricsResponse {
  // Node ID.
  string node_id = 1;
  // Proposals committed (total).
  uint64 proposals_committed = 2;
  // Proposals rejected (total).
  uint64 proposals_rejected = 3;
  // Proposals timed out (total).
  uint64 proposals_timeout = 4;
  // Leader elections (total).
  uint64 leader_elections = 5;
  // Anti-entropy sync events (total).
  uint64 sync_events = 6;
  // Anti-entropy conflicts (total).
  uint64 conflicts = 7;
  // Byzantine evidence count (total).
  uint64 byzantine_evidence = 8;
  // Finalization latency p50 (ms).
  double latency_p50_ms = 9;
  // Finalization latency p99 (ms).
  double latency_p99_ms = 10;
}

// Error code for consensus queries.
enum ConsensusErrorCode {
  CONSENSUS_ERROR_UNSPECIFIED = 0;
  // Consensus subsystem is not configured (single-node mode).
  CONSENSUS_NOT_CONFIGURED = 1;
  // Invalid parameter in request.
  CONSENSUS_INVALID_PARAMETER = 2;
}

// Error response for consensus query endpoints.
message ConsensusError {
  ConsensusErrorCode code = 1;
  string message = 2;
}

// =============================================================================
// IPC-PRIV-017: IngestReviewReceipt (TCK-00389)
// =============================================================================
// Ingests a review receipt from an external reviewer into the FAC ledger.
// Validates reviewer identity against gate lease, verifies artifact bundle
// integrity via CAS hash, and emits either ReviewReceiptRecorded or
// ReviewBlockedRecorded event.

// Review verdict enum for receipt ingestion.
enum ReviewReceiptVerdict {
  REVIEW_RECEIPT_VERDICT_UNSPECIFIED = 0;
  // Review approved the changeset.
  REVIEW_RECEIPT_VERDICT_APPROVE = 1;
  // Review was blocked (tool failure, apply failure, etc.).
  REVIEW_RECEIPT_VERDICT_BLOCKED = 2;
}

// Request to ingest a review receipt from an external reviewer.
message IngestReviewReceiptRequest {
  // Gate lease ID that authorized this review.
  string lease_id = 1;
  // Unique receipt identifier for idempotency.
  string receipt_id = 2;
  // Reviewer identity (must match gate lease executor_actor_id).
  string reviewer_actor_id = 3;
  // BLAKE3 digest of the changeset being reviewed.
  bytes changeset_digest = 4;
  // BLAKE3 hash of the ReviewArtifactBundleV1 stored in CAS.
  bytes artifact_bundle_hash = 5;
  // Review verdict.
  ReviewReceiptVerdict verdict = 6;
  // Reason code for blocked reviews (only used when verdict is BLOCKED).
  // Maps to ReasonCode numeric codes (1=APPLY_FAILED, 2=TOOL_FAILED, etc.).
  uint32 blocked_reason_code = 7;
  // BLAKE3 hash of blocked logs stored in CAS (only for BLOCKED verdict).
  bytes blocked_log_hash = 8;
  // CAS hash pointer to IdentityProofV1 for reviewer identity verification.
  bytes identity_proof_hash = 9;
}

// Response confirming review receipt ingestion.
message IngestReviewReceiptResponse {
  // The receipt ID that was ingested.
  string receipt_id = 1;
  // The event type that was emitted (ReviewReceiptRecorded or ReviewBlockedRecorded).
  string event_type = 2;
  // The ledger event ID for the emitted event.
  string event_id = 3;
}

// Request to delegate a sublease from a parent gate lease (TCK-00340).
//
// The daemon validates the parent lease, checks strict-subset constraints,
// and issues a signed sublease for the delegatee actor.
message DelegateSubleaseRequest {
  // Parent lease ID to delegate from.
  string parent_lease_id = 1;
  // Actor ID of the delegatee (child holon).
  string delegatee_actor_id = 2;
  // Requested expiry timestamp in nanoseconds since epoch.
  uint64 requested_expiry_ns = 3;
  // Sublease ID to assign (must be unique).
  string sublease_id = 4;
  // CAS hash pointer to IdentityProofV1 for delegatee identity verification.
  bytes identity_proof_hash = 5;
}

// Response confirming sublease delegation.
message DelegateSubleaseResponse {
  // The sublease ID that was issued.
  string sublease_id = 1;
  // The parent lease ID that was delegated from.
  string parent_lease_id = 2;
  // The delegatee actor ID.
  string delegatee_actor_id = 3;
  // The gate ID from the parent lease.
  string gate_id = 4;
  // Expiry timestamp of the sublease in nanoseconds.
  uint64 expires_at_ns = 5;
  // Ledger event ID for the SubleaseIssued event.
  string event_id = 6;
}
