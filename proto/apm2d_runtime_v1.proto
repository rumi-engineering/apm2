syntax = "proto3";

package apm2.daemon.v1;

// CTR-PROTO-001: Handshake
message Hello {
  uint32 protocol_version = 1;
  ClientInfo client_info = 2;
  repeated string requested_caps = 3;
}

message HelloAck {
  ServerInfo server_info = 1;
  repeated string granted_caps = 2;
  bytes policy_hash = 3;
  map<string, uint32> canonicalizer_versions = 4;
}

message ClientInfo {
  string name = 1;
  string version = 2;
}

message ServerInfo {
  string name = 1;
  string version = 2;
}

// CTR-PROTO-002: Episode Control
message CreateEpisode {
  bytes envelope_hash = 1;
}

message EpisodeCreated {
  string episode_id = 1;
  string session_id = 2;
}

message StartEpisode {
  string episode_id = 1;
}

message EpisodeStarted {
  uint32 session_pid = 1;
  string io_stream_id = 2;
}

message StopEpisode {
  string episode_id = 1;
  StopReason reason = 2;
}

message EpisodeStopped {
  TerminationClass termination_class = 1;
}

message SignalEpisode {
  string episode_id = 1;
  int32 signal = 2;
}

message ResizePty {
  string episode_id = 1;
  uint32 cols = 2;
  uint32 rows = 3;
}

// Minimal v1 vocabulary for evidence economics
message EpisodeQuarantined {
  string episode_id = 1;
  string reason = 2;
  repeated bytes evidence_pinned = 3;
}

enum StopReason {
  STOP_REASON_UNSPECIFIED = 0;
  GOAL_SATISFIED = 1;
  BUDGET_EXHAUSTED = 2;
  POLICY_VIOLATION = 3;
  USER_REQUEST = 4;
  HARNESS_CRASH = 5;
  ADAPTER_FAILURE = 6;
}

enum TerminationClass {
  TERMINATION_CLASS_UNSPECIFIED = 0;
  CLEAN_EXIT = 1;
  ERROR_EXIT = 2;
  QUARANTINED = 3;
}

// CTR-PROTO-003: I/O
message SendInput {
  string episode_id = 1;
  bytes data = 2;
}

message StreamOutput {
  bytes chunk = 1;
  StreamKind kind = 2;
  uint64 seq = 3;
  uint64 ts = 4;
}

enum StreamKind {
  STDOUT = 0;
  STDERR = 1;
}

// CTR-PROTO-004: Tool Mediation
message ToolRequest {
  string episode_id = 1;
  string request_id = 2;
  string tool = 3;
  bytes dedupe_key = 4;
  bytes args_hash = 5;
  optional bytes inline_args = 6;
}

message ToolDecision {
  string request_id = 1;
  DecisionType decision = 2;
  optional string rule_id = 3;
  bytes policy_hash = 4;
  BudgetDelta budget_delta = 5;
}

enum DecisionType {
  ALLOW = 0;
  DENY = 1;
  DEDUPE_HIT = 2;
}

message ToolResult {
  string request_id = 1;
  ToolOutcome outcome = 2;
  bytes result_hash = 3;
  optional bytes inline_result = 4;
}

message BudgetDelta {
  uint64 tokens = 1;
  uint32 tool_calls = 2;
  uint64 cpu_ms = 3;
}

enum ToolOutcome {
  TOOL_OUTCOME_UNSPECIFIED = 0;
  SUCCESS = 1;
  FAILURE = 2;
  ERROR = 3;
}

// CTR-PROTO-005: Telemetry
message TelemetryFrame {
  string episode_id = 1;
  uint64 seq = 2;
  uint64 ts_mono = 3;
  uint64 cpu_ns = 4;
  uint64 mem_rss_bytes = 5;
  uint64 io_read_bytes = 6;
  uint64 io_write_bytes = 7;
  optional CgroupStats cgroup_stats = 8;
  uint32 o11y_flags = 9;
}

message CgroupStats {
  uint64 cpu_usage_usec = 1;
  uint64 memory_current = 2;
  uint64 memory_max = 3;
}

message TelemetryPolicy {
  uint64 sample_period_ms = 1;
  repeated PromoteTrigger promote_triggers = 2;
  RingBufferLimits ring_buffer_limits = 3;
}

message PromoteTrigger {
  string metric = 1;
  double threshold = 2;
}

message RingBufferLimits {
  uint64 max_pty_bytes = 1;
  uint64 max_tool_bytes = 2;
  uint64 max_tel_frames = 3;
}

// CTR-PROTO-006: Receipts and Evidence
message PublishEvidence {
  bytes artifact_hash = 1;
  EvidenceKind kind = 2;
  RetentionHint retention_hint = 3;
}

message Receipt {
  ReceiptKind kind = 1;
  bytes unsigned_bytes_hash = 2;
  bytes signature = 3;
  repeated bytes evidence_refs = 4;
  bytes policy_hash = 5;
  bytes envelope_hash = 6;
  optional string issuer_id = 7;
  optional bytes issuer_signature = 8;
}

// Minimal v1 vocabulary events for evidence economics
message EvidencePinned {
  bytes artifact_hash = 1;
  string reason = 2;
  optional string defect_id = 3;
}

message EvidenceTtlExpired {
  bytes artifact_hash = 1;
  uint64 timestamp = 2;
}

message CompactionCompleted {
  bytes summary_receipt_hash = 1;
  repeated bytes tombstoned_hashes = 2;
}

enum ReceiptKind {
  TOOL_EXECUTION = 0;
  EPISODE_START = 1;
  EPISODE_STOP = 2;
  GATE = 3;
  TELEMETRY = 4;
  COMPACTION = 5;
  STOP_ORDER = 6;
}

enum EvidenceKind {
  EVIDENCE_KIND_UNSPECIFIED = 0;
  EVIDENCE_KIND_PTY_TRANSCRIPT = 1;
  EVIDENCE_KIND_TOOL_IO = 2;
  EVIDENCE_KIND_TELEMETRY_RAW = 3;
  EVIDENCE_KIND_ADAPTER_FAILURE = 4;
  EVIDENCE_KIND_INCIDENT_SNAPSHOT = 5;
}

enum RetentionHint {
  RETENTION_HINT_UNSPECIFIED = 0;
  EPHEMERAL = 1;
  STANDARD = 2;
  ARCHIVAL = 3;
}

// =============================================================================
// CTR-PROTO-007: Privileged Endpoints (RFC-0017)
// =============================================================================
// These endpoints require operator credentials (connection on operator.sock).
// Session connections receive PERMISSION_DENIED for all privileged requests.

// Role enumeration for work claiming and episode spawning.
enum WorkRole {
  WORK_ROLE_UNSPECIFIED = 0;
  IMPLEMENTER = 1;
  GATE_EXECUTOR = 2;
  REVIEWER = 3;
  COORDINATOR = 4;
}

// IPC-PRIV-001: ClaimWork
// Request work assignment with policy-resolved capabilities.
// Per DD-001: actor_id is a display hint; authoritative actor_id derived from credential.
message ClaimWorkRequest {
  // Display-only hint for actor name. Authoritative actor_id derived from credential.
  string actor_id = 1;
  // Role for work assignment.
  WorkRole role = 2;
  // Ed25519 signature over (actor_id || role || nonce) using operator key.
  bytes credential_signature = 3;
  // Nonce to prevent replay attacks.
  bytes nonce = 4;
}

message ClaimWorkResponse {
  // Assigned work identifier.
  string work_id = 1;
  // Lease identifier for this work claim.
  string lease_id = 2;
  // Blake3 hash of the capability manifest.
  bytes capability_manifest_hash = 3;
  // Reference to the PolicyResolvedForChangeSet event.
  string policy_resolved_ref = 4;
  // Blake3 hash of the sealed context pack.
  bytes context_pack_hash = 5;
}

// IPC-PRIV-002: SpawnEpisode
// Spawn execution episode with FAC preconditions.
message SpawnEpisodeRequest {
  // Work identifier from a prior ClaimWork.
  string work_id = 1;
  // Role for this episode (IMPLEMENTER, GATE_EXECUTOR, REVIEWER).
  WorkRole role = 2;
  // Required for GATE_EXECUTOR role; must reference valid GateLeaseIssued.
  optional string lease_id = 3;
}

message SpawnEpisodeResponse {
  // Session identifier for IPC communication.
  string session_id = 1;
  // Blake3 hash of the capability manifest governing this session.
  bytes capability_manifest_hash = 2;
  // Whether the context pack is sealed.
  bool context_pack_sealed = 3;
  // Ephemeral handle for session identification (not a credential).
  string ephemeral_handle = 4;
}

// IPC-PRIV-003: IssueCapability
// Issue additional capability to an existing session.
message IssueCapabilityRequest {
  // Target session identifier.
  string session_id = 1;
  // Capability request details.
  CapabilityRequest capability_request = 2;
}

message CapabilityRequest {
  // Tool class to grant access to.
  string tool_class = 1;
  // Path patterns for read access (optional).
  repeated string read_patterns = 2;
  // Path patterns for write access (optional).
  repeated string write_patterns = 3;
  // Duration in seconds for the capability grant.
  uint64 duration_secs = 4;
}

message IssueCapabilityResponse {
  // Unique identifier for this capability grant.
  string capability_id = 1;
  // Unix timestamp when capability was granted.
  uint64 granted_at = 2;
  // Unix timestamp when capability expires.
  uint64 expires_at = 3;
}

// IPC-PRIV-004: Shutdown
// Gracefully shutdown the daemon.
message ShutdownRequest {
  // Optional reason for shutdown (for logging/audit).
  optional string reason = 1;
}

message ShutdownResponse {
  // Acknowledgment message.
  string message = 1;
}

// =============================================================================
// Error Codes for Privileged Endpoints
// =============================================================================
enum PrivilegedErrorCode {
  PRIVILEGED_ERROR_UNSPECIFIED = 0;
  // Caller lacks operator credential (not on operator.sock).
  PERMISSION_DENIED = 1;
  // Invalid parameter in request.
  CAPABILITY_REQUEST_REJECTED = 2;
  // Governance policy resolution failed.
  POLICY_RESOLUTION_FAILED = 3;
  // Required policy resolution missing for spawn.
  POLICY_RESOLUTION_MISSING = 4;
  // GATE_EXECUTOR spawn requires valid lease.
  GATE_LEASE_MISSING = 5;
  // Custody domain overlap detected (separation of duties violation).
  SOD_VIOLATION = 6;
  // Referenced session not found.
  SESSION_NOT_FOUND = 7;
  // Capability grant denied by policy.
  CAPABILITY_DENIED = 8;
}

// Generic error response for privileged endpoints.
message PrivilegedError {
  PrivilegedErrorCode code = 1;
  string message = 2;
}

// =============================================================================
// CTR-PROTO-008: Session-Scoped Endpoints (RFC-0017, TCK-00252)
// =============================================================================
// These endpoints require a valid session_token (connection on session.sock).
// Invalid or expired tokens receive SESSION_INVALID error.
// Operator socket connections receive PERMISSION_DENIED for session requests.

// IPC-SESS-001: RequestTool
// Request tool execution within session capability bounds.
message RequestToolRequest {
  // Session token for authentication (validated via HMAC-SHA256).
  string session_token = 1;
  // Tool identifier (e.g., "file_read", "shell_exec").
  string tool_id = 2;
  // Serialized tool arguments (JSON or binary).
  bytes arguments = 3;
  // Deduplication key for idempotent requests.
  string dedupe_key = 4;
}

message RequestToolResponse {
  // Request identifier for tracking.
  string request_id = 1;
  // Tool decision (ALLOW, DENY, DEDUPE_HIT).
  DecisionType decision = 2;
  // Rule that matched (if DENY).
  optional string rule_id = 3;
  // Policy hash at decision time.
  bytes policy_hash = 4;
}

// IPC-SESS-002: EmitEvent
// Emit a signed event to the ledger.
message EmitEventRequest {
  // Session token for authentication.
  string session_token = 1;
  // Event type identifier.
  string event_type = 2;
  // Event payload (JSON or binary).
  bytes payload = 3;
  // Correlation ID for event tracing.
  string correlation_id = 4;
}

message EmitEventResponse {
  // Event identifier in the ledger.
  string event_id = 1;
  // Sequence number in the session.
  uint64 seq = 2;
  // Timestamp when event was recorded (nanoseconds since epoch).
  uint64 timestamp_ns = 3;
}

// IPC-SESS-003: PublishEvidence
// Publish evidence artifact to content-addressed storage.
message PublishEvidenceRequest {
  // Session token for authentication.
  string session_token = 1;
  // Artifact content (binary).
  bytes artifact = 2;
  // Evidence kind for categorization.
  EvidenceKind kind = 3;
  // Retention hint for storage policy.
  RetentionHint retention_hint = 4;
}

message PublishEvidenceResponse {
  // Blake3 hash of the artifact (content address).
  bytes artifact_hash = 1;
  // Storage location hint.
  string storage_path = 2;
  // TTL in seconds (0 = permanent).
  uint64 ttl_secs = 3;
}

// IPC-SESS-004: StreamTelemetry
// Stream telemetry frames for observability.
message StreamTelemetryRequest {
  // Session token for authentication.
  string session_token = 1;
  // Telemetry frame to stream.
  TelemetryFrame frame = 2;
}

message StreamTelemetryResponse {
  // Acknowledgment sequence number.
  uint64 ack_seq = 1;
  // Whether frame was promoted to persistent storage.
  bool promoted = 2;
}

// =============================================================================
// Error Codes for Session-Scoped Endpoints
// =============================================================================
enum SessionErrorCode {
  SESSION_ERROR_UNSPECIFIED = 0;
  // Session token is invalid (expired, tampered, or missing).
  SESSION_ERROR_INVALID = 1;
  // Session has been terminated.
  SESSION_ERROR_TERMINATED = 2;
  // Tool not allowed by capability manifest.
  SESSION_ERROR_TOOL_NOT_ALLOWED = 3;
  // Budget exhausted for this session.
  SESSION_ERROR_BUDGET_EXHAUSTED = 4;
  // Context firewall violation (deny + terminate).
  SESSION_ERROR_CONTEXT_FIREWALL = 5;
  // Caller is on operator socket (session endpoints require session.sock).
  SESSION_ERROR_PERMISSION_DENIED = 6;
}

// Generic error response for session-scoped endpoints.
message SessionError {
  SessionErrorCode code = 1;
  string message = 2;
}

// =============================================================================
// CTR-PROTO-009: Crash Recovery Signals (TCK-00267)
// =============================================================================
// These messages support daemon crash recovery and lease revocation.

// Reason for lease revocation.
enum LeaseRevokedReason {
  LEASE_REVOKED_REASON_UNSPECIFIED = 0;
  // Daemon crashed and restarted, invalidating all prior leases.
  LEASE_REVOKED_DAEMON_RESTART = 1;
  // Lease expired during daemon downtime.
  LEASE_REVOKED_EXPIRED = 2;
  // Explicit revocation by operator.
  LEASE_REVOKED_BY_OPERATOR = 3;
  // Session violated policy (context firewall, etc.).
  LEASE_REVOKED_POLICY_VIOLATION = 4;
}

// Signal sent to sessions when their lease is revoked.
// Sessions receiving this signal MUST re-authenticate before continuing.
message LeaseRevoked {
  // The session whose lease is being revoked.
  string session_id = 1;
  // The lease that was revoked.
  string lease_id = 2;
  // Why the lease is being revoked.
  LeaseRevokedReason reason = 3;
  // Timestamp when the lease was revoked (nanoseconds since epoch).
  uint64 revoked_at_ns = 4;
  // Human-readable message explaining the revocation.
  optional string message = 5;
}

// Request to recover sessions after daemon restart.
// Privileged endpoint (operator.sock only).
message RecoverSessionsRequest {
  // Maximum time to wait for recovery (milliseconds).
  // Default: 5000 (5 seconds per acceptance criteria).
  uint32 timeout_ms = 1;
}

// Response from session recovery.
message RecoverSessionsResponse {
  // Number of sessions that were recovered.
  uint32 sessions_recovered = 1;
  // Number of orphaned processes cleaned up.
  uint32 orphaned_processes_cleaned = 2;
  // Number of LEASE_REVOKED signals sent.
  uint32 lease_revoked_signals_sent = 3;
  // Time taken for recovery (milliseconds).
  uint32 recovery_time_ms = 4;
}