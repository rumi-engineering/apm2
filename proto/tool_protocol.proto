// APM2 Tool Protocol Schema
// Version: 0.1.0
//
// This file defines the agent-to-kernel tool request/response protocol.
// Agents submit ToolRequest messages, the kernel evaluates policy and
// executes allowed requests, returning ToolResponse messages.
//
// IMPORTANT: Maps are forbidden in signed messages to ensure canonical encoding.
//
// SECURITY: This protocol implements default-deny, least-privilege, fail-closed.
// All tool requests are subject to policy evaluation before execution.

syntax = "proto3";
package apm2.tool.v1;

// ============================================================
// TOOL REQUEST
// ============================================================

// Tool request from agent to kernel.
//
// Each request includes a unique request_id for correlation with responses,
// a session_token for authentication, and an optional dedupe_key to prevent
// duplicate execution of identical requests.
message ToolRequest {
  // Unique identifier for this request (UUID format recommended).
  string request_id = 1;

  // Session token for authentication and authorization.
  // Must match an active session in the kernel.
  string session_token = 2;

  // Optional deduplication key.
  // If set, the kernel will return cached results for identical keys
  // within the same session.
  string dedupe_key = 3;

  // Whether the request is part of a consumption workflow (read-only/strict).
  bool consumption_mode = 4;

  // The specific tool operation requested.
  oneof tool {
    FileRead file_read = 10;
    FileWrite file_write = 11;
    FileEdit file_edit = 12;
    ShellExec shell_exec = 13;
    GitOperation git_op = 14;
    InferenceCall inference = 15;
    ArtifactPublish artifact_publish = 16;
    ArtifactFetch artifact_fetch = 17;
  }
}

// ============================================================
// FILE OPERATIONS
// ============================================================

// Request to read file contents.
//
// Policy may restrict:
// - Allowed paths (glob patterns)
// - Maximum read size
// - Excluded paths (secrets, system files)
message FileRead {
  // Absolute or relative path to read.
  // Relative paths are resolved against the session's working directory.
  string path = 1;

  // Byte offset to start reading from (0 = beginning of file).
  uint64 offset = 2;

  // Maximum number of bytes to read (0 = read entire file).
  uint64 limit = 3;
}

// Request to write file contents.
//
// Policy may restrict:
// - Allowed paths (glob patterns)
// - Maximum file size
// - Prohibited content patterns
// - Overwrite vs create-only
message FileWrite {
  // Absolute or relative path to write.
  string path = 1;

  // Content to write to the file.
  bytes content = 2;

  // If true, only create the file if it doesn't exist (fail on overwrite).
  bool create_only = 3;

  // If true, append to existing file instead of overwriting.
  bool append = 4;
}

// Request to edit file contents using search/replace.
//
// This operation is atomic: either the edit succeeds completely or fails
// without modifying the file. The old_content must match exactly once.
//
// Policy may restrict:
// - Allowed paths (glob patterns)
// - Maximum edit size
message FileEdit {
  // Path to the file to edit.
  string path = 1;

  // Content to search for (must match exactly once in the file).
  string old_content = 2;

  // Content to replace with.
  string new_content = 3;
}

// ============================================================
// SHELL OPERATIONS
// ============================================================

// Request to execute a shell command.
//
// SECURITY: Shell execution is high-risk and subject to strict policy.
//
// Policy may restrict:
// - Allowed commands (allowlist patterns)
// - Prohibited commands (denylist patterns)
// - Working directory constraints
// - Timeout limits
// - Network access
// - Environment variables
message ShellExec {
  // Command to execute (passed to shell).
  string command = 1;

  // Working directory for command execution.
  // If empty, uses the session's working directory.
  string cwd = 2;

  // Timeout in milliseconds (0 = use default timeout).
  uint64 timeout_ms = 3;

  // Whether network access is required.
  // Policy may deny network access even if requested.
  bool network_access = 4;

  // Environment variables to set for the command.
  // Note: This is a repeated field of key=value strings to avoid maps.
  // Example: ["PATH=/usr/bin", "HOME=/home/user"]
  repeated string env = 5;
}

// ============================================================
// GIT OPERATIONS
// ============================================================

// Request to perform a git operation.
//
// Git operations are mediated separately from shell execution to enable
// more granular policy (e.g., allow git diff but not git push).
message GitOperation {
  // Git operation type.
  string operation = 1;  // CLONE, FETCH, DIFF, COMMIT, PUSH, STATUS, LOG, BRANCH, CHECKOUT, MERGE, REBASE

  // Arguments for the operation.
  repeated string args = 2;

  // Working directory (repository root).
  string cwd = 3;
}

// ============================================================
// INFERENCE OPERATIONS
// ============================================================

// Request to make an inference call to an AI provider.
//
// Policy may restrict:
// - Allowed providers
// - Allowed models
// - Token limits
// - Cost limits per session
message InferenceCall {
  // Provider identifier (e.g., "anthropic", "openai", "google").
  string provider = 1;

  // Model identifier (e.g., "claude-3-opus", "gpt-4").
  string model = 2;

  // Hash of the prompt (full prompt stored in CAS).
  // This avoids transmitting large prompts in the protocol.
  bytes prompt_hash = 3;

  // Maximum tokens to generate.
  uint64 max_tokens = 4;

  // Temperature for sampling, scaled by 100 (e.g., 70 = 0.70).
  // Using uint32 instead of float to ensure Hash derivation compatibility.
  uint32 temperature_scaled = 5;

  // System prompt hash (optional, stored in CAS).
  bytes system_prompt_hash = 6;
}

// ============================================================
// ARTIFACT OPERATIONS
// ============================================================

// Request to publish an artifact to the content-addressed store.
//
// Artifacts are immutable once published and referenced by hash.
message ArtifactPublish {
  // Unique identifier for this artifact within the work context.
  string artifact_id = 1;

  // Hash of the artifact content (content already stored or being uploaded).
  bytes content_hash = 2;

  // Category for organizing artifacts (e.g., "test_results", "logs", "code").
  string category = 3;

  // Optional metadata as key=value strings.
  repeated string metadata = 4;
}

// Request to fetch an artifact by stable ID or content hash.
//
// In consumption mode, policy enforces that only allowlisted stable_ids
// can be fetched to ensure hermeticity.
message ArtifactFetch {
  // Stable identifier for resolution (e.g., "org:ticket:TCK-001").
  // If set, the kernel resolves this to a content hash.
  string stable_id = 1;

  // Direct content hash reference (BLAKE3, 32 bytes).
  // Policy may restrict usage in consumption mode to prevent side-channel bypass.
  // Note: Changed from string (hex) to bytes for consistency with ArtifactPublish.
  bytes content_hash = 2;

  // Expected content hash for validation when using stable_id (BLAKE3, 32 bytes).
  // If resolution yields a different hash, the fetch fails.
  // Note: Changed from string (hex) to bytes for consistency with content_hash.
  bytes expected_hash = 3;

  // Maximum bytes to return (inline or total).
  uint64 max_bytes = 4;

  // Requested format (e.g., "json", "yaml", "raw").
  // The kernel may perform transcoding if supported.
  string format = 5;
}

// ============================================================
// TOOL RESPONSE
// ============================================================

// Tool response from kernel to agent.
//
// Every ToolRequest receives exactly one ToolResponse.
message ToolResponse {
  // Request ID this response corresponds to.
  string request_id = 1;

  // The result of the tool execution.
  oneof result {
    ToolSuccess success = 2;
    ToolDenied denied = 3;
    ToolError error = 4;
  }
}

// Successful tool execution result.
message ToolSuccess {
  // Hash of the full result (stored in CAS if large).
  bytes result_hash = 1;

  // Small results can be returned inline (up to 1MB).
  bytes inline_result = 2;

  // Budget consumed by this operation.
  uint64 budget_consumed = 3;

  // Duration of the operation in milliseconds.
  uint64 duration_ms = 4;
}

// Tool request was denied by policy.
message ToolDenied {
  // Rule ID that caused the denial.
  string rule_id = 1;

  // Machine-readable rationale code.
  string rationale_code = 2;

  // Human-readable message explaining the denial.
  string message = 3;
}

// Tool execution failed with an error.
message ToolError {
  // Error code for programmatic handling.
  string error_code = 1;

  // Human-readable error message.
  string message = 2;

  // Whether the error is retryable.
  bool retryable = 3;

  // Suggested retry delay in milliseconds (if retryable).
  uint64 retry_after_ms = 4;
}

// ============================================================
// VALIDATION ERRORS
// ============================================================

// Validation error details for malformed requests.
message ValidationError {
  // Field that failed validation.
  string field = 1;

  // Validation rule that was violated.
  string rule = 2;

  // Human-readable description of the error.
  string message = 3;
}
