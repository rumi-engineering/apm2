// APM2 Kernel Event Schema
// Version: 0.11.0
//
// CHANGELOG (0.11.0):
// - Added WorkGraphEvent for work dependency graph edges (RFC-0032, TCK-00642)
// - Added WorkEdgeAdded, WorkEdgeRemoved, WorkEdgeWaived messages
// - Added WorkEdgeType enum (DEPENDENCY, BLOCKS, ENABLES, SEQUENCE)
// - Added WorkGraphEvent to KernelEvent payload (tag 35)
// - Event type strings: work_graph.edge.added/removed/waived
// - MUST NOT start with `work.` to avoid WorkReducer decoding
// - Multi-topic derivation: emits work topics for both from_work_id and to_work_id
//
// CHANGELOG (0.10.0):
// - Added role_spec_hash to ReviewReceiptRecorded (RFC-0019, TCK-00331)
// - Binds review outcomes to RoleSpecV1 for attribution and conformance verification
//
// CHANGELOG (0.9.0):
// - Added capability_manifest_hash and context_pack_hash to ReviewBlockedRecorded (RFC-0019, TCK-00326)
// - Added capability_manifest_hash and context_pack_hash to ReviewReceiptRecorded (RFC-0019, TCK-00326)
// - These fields bind authority hashes for audit traceability per RFC-0019 sealing requirements
// - Added REVIEW_BLOCKED_REASON_CONTEXT_PACK_MISSING and REVIEW_BLOCKED_REASON_CONTEXT_PACK_INVALID
//
// CHANGELOG (0.8.0):
// - Added ProjectionReceiptRecorded event for FAC projection receipts (RFC-0019, TCK-00323)
// - Added ProjectionReceiptRecorded to KernelEvent payload (tag 34)
// - Binds changeset_digest + artifact_bundle_hash + time_envelope_ref for projection outcomes
// - Enables work.<work_id>.projection topic derivation for successful projections
// - Supports idempotency via receipt lookup (work_id, changeset_digest, ledger_head)
//
// CHANGELOG (0.7.0):
// - Added ReviewReceiptRecorded event for FAC v0 review receipts (RFC-0018, TCK-00312)
// - Added ReviewReceiptRecorded to KernelEvent payload (tag 33)
// - Binds changeset_digest + artifact_bundle_hash + time_envelope_ref for review outcomes
// - Enables work.<work_id>.review topic derivation for successful reviews
//
// CHANGELOG (0.6.0):
// - Added ReviewBlockedRecorded event for FAC v0 review liveness (RFC-0018, TCK-00311)
// - Added ReviewBlockedRecorded to KernelEvent payload (tag 32)
// - Added ReviewBlockedReasonCode enum for failure classification
// - Enables work.<work_id>.blocked topic derivation and durable blocked outcomes
//
// CHANGELOG (0.5.0):
// - Added DefectRecorded event for HEF defect pulse derivation (RFC-0018, TCK-00307)
// - Added DefectRecorded to KernelEvent payload (tag 31)
// - Added DefectSource enum for defect source classification
// - Enables defect.new pulse topic derivation from ledger events
//
// CHANGELOG (0.4.0):
// - Added episode_id field to Session events for HEF topic derivation (RFC-0018, TCK-00306):
//   SessionStarted, SessionProgress, SessionTerminated, SessionQuarantined
// - Added episode_id field to Tool events for HEF topic derivation (RFC-0018, TCK-00306):
//   ToolRequested, ToolDecided, ToolExecuted
// - Added IoArtifactPublished event for episode IO artifact tracking (TCK-00306)
// - Added IoArtifactPublished to KernelEvent payload (tag 30)
// - Backward compatible: episode_id defaults to empty string for existing events
//
// CHANGELOG (0.3.0):
// - Added TimeEnvelopeRef message type for HTF time authority (RFC-0016)
// - Added optional time_envelope_ref field to critical events:
//   SessionStarted, SessionTerminated, ToolDecided, ToolExecuted,
//   LeaseIssued, LeaseReleased, AdjudicationResolved, EvidencePublished,
//   GateReceipt, MergeReceipt, InterventionFreeze, InterventionUnfreeze,
//   RunnerPoolQuarantined, AATSpecQuarantined, QuarantineCleared
// - Marked legacy timestamp fields as OBSERVATIONAL (not for protocol authority)
//
// This file defines the core event types for the APM2 kernel.
// All events are stored in the ledger and form a hash chain.
//
// IMPORTANT: Maps are forbidden in signed messages to ensure canonical encoding.
//
// CANONICAL ENCODING REQUIREMENTS:
// To ensure deterministic serialization (required for signature verification):
// 1. Maps are forbidden (non-deterministic key ordering)
// 2. Repeated fields MUST be sorted before signing:
//    - String fields: lexicographic ordering
//    - Numeric fields: ascending order
// 3. Use BTreeMap for any map-like structures in Rust implementations
// 4. Empty repeated fields should be omitted from wire format

syntax = "proto3";
package apm2.kernel.v1;

import "google/protobuf/timestamp.proto";

// ============================================================
// HTF TIME ENVELOPE REFERENCE (RFC-0016)
// ============================================================
//
// TimeEnvelopeRef provides a content-addressed reference to a full
// TimeEnvelopeV1 stored in CAS. Critical events include this reference
// to bind HTF time authority to protocol decisions.
//
// Security: The 32-byte hash provides integrity verification and enables
// independent retrieval/validation of the full time envelope.

// Content hash reference to a TimeEnvelopeV1 artifact in CAS.
// Used by critical events to bind HTF time authority without embedding
// the full envelope in hot-path messages.
message TimeEnvelopeRef {
  // Content hash (SHA-256) of the TimeEnvelopeV1 artifact (32 bytes).
  // The referenced envelope can be retrieved from CAS for verification.
  bytes hash = 1;
}

// Common envelope for all kernel events
message KernelEvent {
  // Monotonic sequence number within this ledger
  uint64 sequence = 1;
  // Hash of the previous event.
  // For genesis events: use 32 zero bytes (canonical representation).
  // Note: The ledger may store NULL for genesis as a storage optimization,
  // but it must be normalized to 32 zero bytes at API boundaries.
  bytes previous_hash = 2;
  // Timestamp when event was created
  google.protobuf.Timestamp timestamp = 3;
  // Actor ID that produced this event
  string actor_id = 4;
  // Session ID (if applicable)
  string session_id = 5;
  // Ed25519 signature over canonical bytes of this message
  bytes signature = 6;
  // Schema version for forward/backward compatibility
  // Current version: 1
  uint32 schema_version = 7;
  // Event payload (oneof)
  oneof payload {
    SessionEvent session = 10;
    WorkEvent work = 11;
    ToolEvent tool = 12;
    LeaseEvent lease = 13;
    PolicyEvent policy = 14;
    AdjudicationEvent adjudication = 15;
    EvidenceEvent evidence = 16;
    KeyEvent key = 17;
    CapabilityEvent capability = 18;
    GitHubLeaseEvent github_lease = 19;
    PolicyResolvedForChangeSet policy_resolved_for_changeset = 20;
    GateReceipt gate_receipt = 21;
    InterventionFreeze intervention_freeze = 22;
    InterventionUnfreeze intervention_unfreeze = 23;
    AATResultReused aat_result_reused = 24;
    MergeReceipt merge_receipt = 25;
    RunnerPoolQuarantined runner_pool_quarantined = 26;
    AATSpecQuarantined aat_spec_quarantined = 27;
    QuarantineCleared quarantine_cleared = 28;
    ChangeSetPublished changeset_published = 29;
    IoArtifactPublished io_artifact_published = 30;
    DefectRecorded defect_recorded = 31;
    ReviewBlockedRecorded review_blocked_recorded = 32;
    ReviewReceiptRecorded review_receipt_recorded = 33;
    ProjectionReceiptRecorded projection_receipt_recorded = 34;
    WorkGraphEvent work_graph = 35;
  }
}

// ============================================================
// SESSION EVENTS
// ============================================================
message SessionEvent {
  oneof event {
    SessionStarted started = 1;
    SessionProgress progress = 2;
    SessionTerminated terminated = 3;
    SessionQuarantined quarantined = 4;
    SessionCrashDetected crash_detected = 5;
    SessionRestartScheduled restart_scheduled = 6;
  }
}

// Emitted when a session process exits unexpectedly or crashes.
message SessionCrashDetected {
  string session_id = 1;
  string crash_type = 2;  // CLEAN_EXIT, ERROR_EXIT, SIGNAL, TIMEOUT, ENTROPY_EXCEEDED
  int32 exit_code = 3;
  int32 signal = 4;
  uint64 uptime_ms = 5;
  uint64 last_cursor = 6;
  uint32 restart_count = 7;
}

// Emitted when a restart has been scheduled for a crashed session.
message SessionRestartScheduled {
  string session_id = 1;
  uint64 scheduled_at = 2;
  uint64 restart_at = 3;
  uint64 resume_cursor = 4;
  uint32 attempt_number = 5;
  string backoff_type = 6;  // FIXED, EXPONENTIAL, LINEAR
}

message SessionStarted {
  string session_id = 1;
  string actor_id = 2;
  string adapter_type = 3;
  string work_id = 4;
  string lease_id = 5;
  uint64 entropy_budget = 6;
  // For restarted sessions: cursor to resume from
  uint64 resume_cursor = 7;
  // For restarted sessions: restart attempt number (0 = first start)
  uint32 restart_attempt = 8;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds this event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 9;
  // Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
  // Empty string for non-episode sessions; populated from episode context.
  // Enables episode.<episode_id>.lifecycle topic routing.
  string episode_id = 10;
}

message SessionProgress {
  string session_id = 1;
  uint64 progress_sequence = 2;
  string progress_type = 3;  // HEARTBEAT, TOOL_COMPLETE, MILESTONE
  uint64 entropy_consumed = 4;
  // Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
  // Empty string for non-episode sessions; populated from episode context.
  // Enables episode.<episode_id>.lifecycle topic routing.
  string episode_id = 5;
}

message SessionTerminated {
  string session_id = 1;
  string exit_classification = 2;  // SUCCESS, FAILURE, TIMEOUT, ENTROPY_EXCEEDED
  string rationale_code = 3;
  uint64 final_entropy = 4;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds this event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 5;
  // Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
  // Empty string for non-episode sessions; populated from episode context.
  // Enables episode.<episode_id>.lifecycle topic routing.
  string episode_id = 6;
}

message SessionQuarantined {
  string session_id = 1;
  string reason = 2;
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Retained for backwards compatibility and display purposes.
  uint64 quarantine_until = 3;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the quarantine event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 4;
  // Monotonic tick when the quarantine was issued (RFC-0016 HTF).
  // Authoritative for timing decisions; immune to wall-clock manipulation.
  uint64 issued_at_tick = 5;
  // Monotonic tick when the quarantine expires (RFC-0016 HTF).
  // Authoritative for expiry checks; immune to wall-clock manipulation.
  uint64 expires_at_tick = 6;
  // Tick rate in Hz for issued_at_tick and expires_at_tick.
  // Required for interpreting tick values as durations.
  uint64 tick_rate_hz = 7;
  // Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
  // Empty string for non-episode sessions; populated from episode context.
  // Enables episode.<episode_id>.lifecycle topic routing.
  string episode_id = 8;
}

// ============================================================
// WORK EVENTS
// ============================================================
message WorkEvent {
  oneof event {
    WorkOpened opened = 1;
    WorkTransitioned transitioned = 2;
    WorkCompleted completed = 3;
    WorkAborted aborted = 4;
    WorkPrAssociated pr_associated = 5;
  }
}

message WorkOpened {
  string work_id = 1;
  string work_type = 2;  // TICKET, PRD_REFINEMENT, RFC_REFINEMENT, REVIEW
  bytes spec_snapshot_hash = 3;
  repeated string requirement_ids = 4;
  repeated string parent_work_ids = 5;
}

message WorkTransitioned {
  string work_id = 1;
  string from_state = 2;
  // Valid states: OPEN, CLAIMED, IN_PROGRESS, CI_PENDING, READY_FOR_REVIEW,
  // BLOCKED, REVIEW, NEEDS_INPUT, NEEDS_ADJUDICATION
  string to_state = 3;
  string rationale_code = 4;
  // Previous transition count for replay protection.
  // MUST match work.transition_count before this transition.
  // This field is strictly validated to prevent replay attacks.
  // For the first transition (Open -> Claimed), use 0.
  uint32 previous_transition_count = 5;
}

message WorkCompleted {
  string work_id = 1;
  bytes evidence_bundle_hash = 2;
  repeated string evidence_ids = 3;
  string gate_receipt_id = 4;
  // Dedicated merge receipt identifier, separate from gate_receipt_id.
  // Populated when work completes via merge executor.  The merge receipt
  // atomically binds gate outcomes to the observed merge result.
  string merge_receipt_id = 5;
}

message WorkAborted {
  string work_id = 1;
  string abort_reason = 2;  // POLICY_DENY, TIMEOUT, ENTROPY_EXCEEDED, MANUAL
  string rationale_code = 3;
}

// Emitted when a PR is created and associated with a work item.
// This enables CI event matching for phase transitions.
message WorkPrAssociated {
  string work_id = 1;
  uint64 pr_number = 2;
  string commit_sha = 3;  // The commit SHA that triggered the CI workflow
}

// ============================================================
// TOOL EVENTS
// ============================================================
message ToolEvent {
  oneof event {
    ToolRequested requested = 1;
    ToolDecided decided = 2;
    ToolExecuted executed = 3;
  }
}

message ToolRequested {
  string request_id = 1;
  string session_id = 2;
  string tool_name = 3;
  bytes tool_args_hash = 4;  // Hash of arguments (full args stored in CAS)
  string dedupe_key = 5;
  // Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
  // Empty string for non-episode sessions; populated from episode context.
  // Enables episode.<episode_id>.tool topic routing.
  string episode_id = 6;
}

message ToolDecided {
  string request_id = 1;
  string decision = 2;  // ALLOW, DENY
  string rule_id = 3;
  bytes policy_hash = 4;
  string rationale_code = 5;
  uint64 budget_consumed = 6;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the decision receipt to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 7;
  // Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
  // Empty string for non-episode sessions; populated from episode context.
  // Enables episode.<episode_id>.tool topic routing.
  string episode_id = 8;
}

message ToolExecuted {
  string request_id = 1;
  string outcome = 2;  // SUCCESS, FAILURE, TIMEOUT
  bytes result_hash = 3;  // Hash of result (full result stored in CAS)
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Duration is recorded for observational purposes only; authoritative
  // timing uses HTF tick deltas from the time_envelope_ref.
  uint64 duration_ms = 4;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the execution receipt to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 5;
  // Episode ID for HEF topic derivation (RFC-0018, TCK-00306).
  // Empty string for non-episode sessions; populated from episode context.
  // Enables episode.<episode_id>.tool topic routing.
  string episode_id = 6;
}

// ============================================================
// LEASE EVENTS
// ============================================================
message LeaseEvent {
  oneof event {
    LeaseIssued issued = 1;
    LeaseRenewed renewed = 2;
    LeaseReleased released = 3;
    LeaseExpired expired = 4;
    LeaseConflict conflict = 5;
    LeaseIssueDenied issue_denied = 6;
  }
}

message LeaseIssued {
  string lease_id = 1;
  string work_id = 2;
  string actor_id = 3;
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Retained for display/audit purposes; authoritative timing uses
  // tick-based expiry from the time_envelope_ref.
  uint64 issued_at = 4;
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Retained for display/audit purposes; authoritative expiry uses
  // tick-based checks from the time_envelope_ref.
  uint64 expires_at = 5;
  bytes registrar_signature = 6;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the lease issuance to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 7;
  // Monotonic tick when the lease was issued (RFC-0016 HTF).
  // Authoritative for timing decisions; immune to wall-clock manipulation.
  uint64 issued_at_tick = 8;
  // Monotonic tick when the lease expires (RFC-0016 HTF).
  // Authoritative for expiry checks; immune to wall-clock manipulation.
  uint64 expires_at_tick = 9;
  // Tick rate in Hz for issued_at_tick and expires_at_tick.
  // Required for interpreting tick values as durations.
  uint64 tick_rate_hz = 10;
}

message LeaseRenewed {
  string lease_id = 1;
  uint64 new_expires_at = 2;
  bytes registrar_signature = 3;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the lease renewal to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 4;
  // Monotonic tick when the renewed lease expires (RFC-0016 HTF).
  // Authoritative for expiry checks; immune to wall-clock manipulation.
  uint64 new_expires_at_tick = 5;
  // Tick rate in Hz for new_expires_at_tick.
  // Required for interpreting tick values as durations.
  uint64 tick_rate_hz = 6;
}

message LeaseReleased {
  string lease_id = 1;
  string release_reason = 2;  // COMPLETED, ABORTED, VOLUNTARY
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the lease release to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 3;
}

message LeaseExpired {
  string lease_id = 1;
  uint64 expired_at = 2;
}

message LeaseConflict {
  string work_id = 1;
  repeated string conflicting_lease_ids = 2;
  string resolution = 3;  // CANONICAL_ROOT, ADJUDICATION_REQUIRED
}

// Emitted when a lease issuance is denied for security policy reasons.
//
// Per TCK-00258, this event is emitted when a SpawnEpisode request is
// rejected due to policy violations such as custody domain overlap (SoD).
// This provides an audit trail for denied lease requests.
//
// Security: All denial events are logged for non-repudiation and
// security audit purposes.
message LeaseIssueDenied {
  // Work ID that was denied a lease.
  string work_id = 1;
  // Reason for denial: SOD_VIOLATION, POLICY_VIOLATION, EXPIRED_CLAIM
  string denial_reason = 2;
  // Human-readable details about the denial.
  string denial_details = 3;
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Retained for display/audit purposes; authoritative timing uses
  // HTF time from the time_envelope_ref.
  uint64 denied_at = 4;
  // Executor's custody domain that caused the SoD violation (if applicable).
  string executor_domain = 5;
  // Author's custody domain that caused the SoD violation (if applicable).
  string author_domain = 6;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the denial event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 7;
}

// ============================================================
// POLICY EVENTS
// ============================================================
message PolicyEvent {
  oneof event {
    PolicyLoaded loaded = 1;
    PolicyViolation violation = 2;
    BudgetExceeded budget_exceeded = 3;
  }
}

message PolicyLoaded {
  bytes policy_hash = 1;
  string policy_version = 2;
  uint64 rule_count = 3;
}

message PolicyViolation {
  string session_id = 1;
  string violation_type = 2;
  string rule_id = 3;
  string details = 4;
}

message BudgetExceeded {
  string session_id = 1;
  string budget_type = 2;  // TOKEN, TIME, TOOL_CALLS
  uint64 limit = 3;
  uint64 consumed = 4;
}

// ============================================================
// ADJUDICATION EVENTS
// ============================================================
message AdjudicationEvent {
  oneof event {
    AdjudicationRequested requested = 1;
    AdjudicationVote vote = 2;
    AdjudicationResolved resolved = 3;
    AdjudicationTimeout timeout = 4;
  }
}

message AdjudicationRequested {
  string adjudication_id = 1;
  string work_id = 2;
  string request_type = 3;  // BOUNDED_CHOICE, WAIVER, GATE_REVIEW
  repeated string options = 4;
  uint64 deadline = 5;
  string fallback_policy = 6;
}

message AdjudicationVote {
  string adjudication_id = 1;
  string voter_actor_id = 2;
  string chosen_option = 3;
  bytes voter_signature = 4;
}

message AdjudicationResolved {
  string adjudication_id = 1;
  string chosen_option = 2;
  uint64 votes_for = 3;
  uint64 votes_against = 4;
  bytes quorum_signature = 5;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the adjudication decision to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 6;
}

message AdjudicationTimeout {
  string adjudication_id = 1;
  string applied_fallback = 2;
}

// ============================================================
// EVIDENCE EVENTS
// ============================================================
message EvidenceEvent {
  oneof event {
    EvidencePublished published = 1;
    GateReceiptGenerated gate_receipt = 2;
  }
}

message EvidencePublished {
  string evidence_id = 1;
  string work_id = 2;
  string category = 3;
  bytes artifact_hash = 4;
  repeated string verification_command_ids = 5;
  // Data classification: PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED
  string classification = 6;
  // Artifact size in bytes (for bundle size tracking)
  uint64 artifact_size = 7;
  // Metadata key-value pairs as "key=value" strings
  repeated string metadata = 8;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the evidence submission to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 9;
}

message GateReceiptGenerated {
  string receipt_id = 1;
  string gate_id = 2;
  string work_id = 3;
  string result = 4;  // PASS, FAIL
  repeated string evidence_ids = 5;
  bytes receipt_signature = 6;
}

// ============================================================
// CAPABILITY EVENTS
// ============================================================
//
// Capability events implement the OCAP (Object Capability) model for
// cross-node authority verification. All capability events are TotalOrder
// authority events requiring BFT consensus finalization.
//
// Key concepts:
// - capability_id == lease_id (capabilities are linked to leases)
// - namespace binding prevents cross-namespace replay attacks
// - Delegation chains support hierarchical authority delegation
// - Proofs are ledger-verifiable across nodes

message CapabilityEvent {
  oneof event {
    CapabilityRequired required = 1;
    CapabilityGranted granted = 2;
    CapabilityDelegated delegated = 3;
    CapabilityRevoked revoked = 4;
  }
}

// Emitted during planning phase when a capability is required for a plan step.
// This event enables capability negotiation and tracking.
message CapabilityRequired {
  // The capability ID that is required (e.g., "cac:patch:apply")
  string capability_id = 1;
  // The work ID this requirement is associated with
  string work_id = 2;
  // Whether this capability is required (true) or optional (false)
  bool required = 3;
  // The status of the capability: AVAILABLE, UNAVAILABLE, DEGRADED
  string status = 4;
  // Human-readable reason for the status
  string reason = 5;
}

// Emitted when a capability is granted to an actor by an authority.
// This is the root of a delegation chain and must be signed by the registrar.
// Links to the lease system: capability_id == lease_id.
message CapabilityGranted {
  // Unique identifier for this capability (equals lease_id for lease-backed capabilities)
  string capability_id = 1;
  // Namespace this capability is bound to (prevents cross-namespace replay)
  string namespace = 2;
  // Actor receiving the capability
  string grantee_actor_id = 3;
  // Actor granting the capability (must be an authority in the namespace)
  string grantor_actor_id = 4;
  // Hash of the serialized LeaseScope (stored in CAS)
  bytes scope_hash = 5;
  // Optional hash of the serialized Budget (stored in CAS)
  bytes budget_hash = 6;
  // Timestamp when the capability was granted (Unix nanos)
  uint64 granted_at = 7;
  // Timestamp when the capability expires (Unix nanos)
  uint64 expires_at = 8;
  // Registrar signature over this grant (proves authority)
  bytes registrar_signature = 9;
  // Whether this capability can be delegated to others
  bool delegatable = 10;
}

// Emitted when a capability holder delegates their capability to another actor.
// Forms part of the delegation chain for capability proofs.
message CapabilityDelegated {
  // New capability ID for the delegated capability
  string delegated_capability_id = 1;
  // Parent capability being delegated from
  string parent_capability_id = 2;
  // Hash of the parent CapabilityGranted or CapabilityDelegated event
  bytes parent_capability_hash = 3;
  // Namespace this delegation is bound to (must match parent)
  string namespace = 4;
  // Actor receiving the delegated capability
  string delegatee_actor_id = 5;
  // Actor delegating the capability (must hold parent capability)
  string delegator_actor_id = 6;
  // Hash of the serialized LeaseScope (must be subset of parent scope)
  bytes scope_hash = 7;
  // Optional hash of the serialized Budget (must be subset of parent budget)
  bytes budget_hash = 8;
  // Timestamp when the delegation occurred (Unix nanos)
  uint64 delegated_at = 9;
  // Timestamp when the delegated capability expires (Unix nanos, must be <= parent expires_at)
  uint64 expires_at = 10;
  // Delegator's signature over this delegation (proves authority transfer)
  bytes delegator_signature = 11;
  // Whether this delegated capability can be further delegated
  bool delegatable = 12;
  // Depth in the delegation chain (parent depth + 1)
  uint32 delegation_depth = 13;
}

// Emitted when a capability is revoked before its natural expiration.
// Revocation cascades to all delegated capabilities in the chain.
message CapabilityRevoked {
  // The capability being revoked
  string capability_id = 1;
  // Namespace the capability belongs to
  string namespace = 2;
  // Actor performing the revocation (must be grantor or authority)
  string revoker_actor_id = 3;
  // Reason for revocation: VOLUNTARY, POLICY_VIOLATION, KEY_COMPROMISE, SUPERSEDED
  string revocation_reason = 4;
  // Timestamp when the revocation occurred (Unix nanos)
  uint64 revoked_at = 5;
  // Revoker's signature over this revocation
  bytes revoker_signature = 6;
  // If true, revocation cascades to all delegated capabilities; if false, only this capability is revoked
  bool cascade = 7;
}

// ============================================================
// KEY EVENTS
// ============================================================
message KeyEvent {
  oneof event {
    KeyRotated rotated = 1;
  }
}

// ============================================================
// GITHUB LEASE EVENTS
// ============================================================
//
// GitHub lease events implement tiered GitHub App access control for AI agents.
// Each GitHub App corresponds to a risk tier range:
// - apm2-reader (T0): contents:read, metadata:read
// - apm2-developer (T1-T2): + pull_requests:write, checks:write, statuses:write
// - apm2-operator (T3-T4): + contents:write, admin:read, releases:write
//
// Key security properties:
// - Raw tokens are NEVER stored in the ledger (only hashes)
// - Token TTLs are proportional to risk tier (shorter for higher tiers)
// - Scope attenuation only (cannot escalate permissions)
// - All operations are audited for non-repudiation

message GitHubLeaseEvent {
  oneof event {
    GitHubLeaseIssued issued = 1;
    GitHubLeaseRevoked revoked = 2;
    GitHubOperationRecorded operation_recorded = 3;
  }
}

// Emitted when a GitHub installation access token is minted for an agent.
// Links to the episode via episode_id and inherits risk tier constraints.
message GitHubLeaseIssued {
  // Unique identifier for this GitHub lease
  string lease_id = 1;
  // Episode this lease is bound to
  string episode_id = 2;
  // GitHub App ID (determines permission tier)
  string github_app_id = 3;
  // GitHub installation ID for the target repository/organization
  string installation_id = 4;
  // Risk tier of the requesting agent (0-4)
  // Tier determines which GitHub App can be used:
  // - T0: reader only
  // - T1-T2: reader or developer
  // - T3-T4: reader, developer, or operator
  uint32 risk_tier = 5;
  // Hash of the requested GitHub scopes (scope list stored in CAS)
  bytes scope_hash = 6;
  // SHA-256 hash of the installation access token (NEVER store raw token)
  bytes token_hash = 7;
  // Timestamp when the lease was issued (Unix nanos)
  uint64 issued_at = 8;
  // Timestamp when the lease expires (Unix nanos)
  // TTL is proportional to risk tier:
  // - T0: 1 hour
  // - T1-T2: 15-30 minutes
  // - T3-T4: 2-5 minutes
  uint64 expires_at = 9;
  // Hash of the capability manifest that authorized this lease
  bytes capability_manifest_hash = 10;
  // Issuer (registrar) signature over this event
  bytes issuer_signature = 11;
}

// Emitted when a GitHub lease is revoked before expiration.
// Revocation may be voluntary or forced (policy violation, key compromise).
message GitHubLeaseRevoked {
  // The lease being revoked
  string lease_id = 1;
  // Episode the lease was bound to
  string episode_id = 2;
  // Reason for revocation: VOLUNTARY, EXPIRED, POLICY_VIOLATION, KEY_COMPROMISE
  string revocation_reason = 3;
  // Timestamp when the revocation occurred (Unix nanos)
  uint64 revoked_at = 4;
  // Actor performing the revocation
  string revoker_actor_id = 5;
  // Revoker signature over this event
  bytes revoker_signature = 6;
}

// Emitted for each GitHub API operation made with a leased token.
// Provides audit trail for all GitHub interactions.
message GitHubOperationRecorded {
  // Unique identifier for this operation record
  string operation_id = 1;
  // The lease that authorized this operation
  string lease_id = 2;
  // Episode context
  string episode_id = 3;
  // GitHub API endpoint called (e.g., "POST /repos/{owner}/{repo}/pulls")
  string api_endpoint = 4;
  // HTTP method: GET, POST, PUT, PATCH, DELETE
  string http_method = 5;
  // Target repository in owner/repo format
  string repository = 6;
  // Hash of the request body (request body stored in CAS if needed)
  bytes request_hash = 7;
  // Hash of the response body (response body stored in CAS if needed)
  bytes response_hash = 8;
  // HTTP status code returned
  uint32 status_code = 9;
  // Timestamp when the operation was performed (Unix nanos)
  uint64 performed_at = 10;
  // Duration of the API call in milliseconds
  uint64 duration_ms = 11;
  // GitHub rate limit remaining after this call
  uint32 rate_limit_remaining = 12;
}

// Event emitted when an actor rotates their signing key.
// This establishes a chain of custody for key transitions.
message KeyRotated {
  // Actor whose key is being rotated
  string actor_id = 1;
  // Hash of the old verifying key (for reference)
  bytes old_key_hash = 2;
  // New verifying (public) key bytes
  bytes new_verifying_key = 3;
  // Timestamp when the rotation occurred (Unix nanos)
  uint64 rotated_at = 4;
  // Signature from the OLD key over this message (proves control of old key)
  bytes old_key_signature = 5;
}

// ============================================================
// FORGE ADMISSION CYCLE (FAC) EVENTS
// ============================================================
//
// FAC events implement the policy resolution and gate lease lifecycle
// for the Forge Admission Cycle. These events ensure that all changes
// flow through quality gates with locked policy configurations.
//
// Ordering Invariant: PolicyResolvedForChangeSet MUST exist before
// any GateLeaseIssued for the same work_id/changeset.

// The anchor event that locks policy decisions for a changeset.
// All subsequent lease issuance and receipt validation must reference
// this anchor's resolved_policy_hash.
message PolicyResolvedForChangeSet {
  // Work item this policy resolution applies to
  string work_id = 1;
  // Hash binding to specific changeset (32 bytes)
  bytes changeset_digest = 2;
  // Hash of the resolved policy tuple (32 bytes)
  // Computed from: risk_tier || determinism_class || sorted(rcp_profile_ids) ||
  //                sorted(rcp_manifest_hashes) || sorted(verifier_policy_hashes)
  bytes resolved_policy_hash = 3;
  // Resolved risk tier (0-4)
  uint32 resolved_risk_tier = 4;
  // Resolved determinism class (0=non, 1=soft, 2=fully)
  uint32 resolved_determinism_class = 5;
  // Resolved RCP profile IDs (sorted for canonical encoding)
  repeated string resolved_rcp_profile_ids = 6;
  // Hashes of resolved RCP manifests (sorted, each 32 bytes)
  repeated bytes resolved_rcp_manifest_hashes = 7;
  // Hashes of resolved verifier policies (sorted, each 32 bytes)
  repeated bytes resolved_verifier_policy_hashes = 8;
  // Actor who performed the policy resolution
  string resolver_actor_id = 9;
  // Version of the resolver component
  string resolver_version = 10;
  // Ed25519 signature over canonical bytes with POLICY_RESOLVED_FOR_CHANGESET: domain (64 bytes)
  bytes resolver_signature = 11;
  // BLAKE3 hash of the authoritative RoleSpecV2 contract (32 bytes, TCK-00448).
  bytes role_spec_hash = 12;
  // BLAKE3 hash of the compiled ContextPackRecipe lineage artifact (32 bytes, TCK-00448).
  bytes context_pack_recipe_hash = 13;
}

// GateReceipt envelope with versioning support.
// This is the canonical receipt envelope that wraps gate-specific payloads.
// The receipt binds a gate execution result to a specific lease and changeset.
//
// Versioning:
// - receipt_version: Envelope schema version (currently: 1)
// - payload_kind: Type of payload ("aat", "quality", "security")
// - payload_schema_version: Version of the payload schema
//
// Security:
// - receipt_signature uses GATE_RECEIPT: domain prefix
// - All fields except signature are included in canonical bytes
message GateReceipt {
  // Unique identifier for this receipt
  string receipt_id = 1;
  // Gate that generated this receipt
  string gate_id = 2;
  // Lease that authorized this gate execution
  string lease_id = 3;
  // Hash binding to specific changeset (32 bytes)
  bytes changeset_digest = 4;
  // Actor who executed the gate
  string executor_actor_id = 5;
  // Envelope schema version (supported: 1)
  uint32 receipt_version = 6;
  // Type of payload: "aat", "quality", "security"
  string payload_kind = 7;
  // Version of the payload schema
  uint32 payload_schema_version = 8;
  // Hash of the payload content (32 bytes)
  bytes payload_hash = 9;
  // Hash of the evidence bundle (32 bytes)
  bytes evidence_bundle_hash = 10;
  // BLAKE3 digest of the job spec that authorized this gate execution.
  // Present when the gate was triggered from a FacJobSpecV1 queue item.
  optional string job_spec_digest = 14;
  // BLAKE3 digest of the sandbox hardening profile used for gate execution.
  // Present when gate execution is bound to a materialized hardening profile.
  optional string sandbox_hardening_hash = 15;
  // BLAKE3 digest of the network policy used for gate execution (TCK-00574).
  // Present when gate execution is bound to a materialized network policy.
  optional string network_policy_hash = 16;
  // Ed25519 signature over canonical bytes with GATE_RECEIPT: domain (64 bytes)
  bytes receipt_signature = 11;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the gate receipt to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 12;
  // Explicit pass/fail verdict declared by the gate executor.
  // This is the authoritative verdict field - not derived from hash inspection.
  // MUST be set by the executor; ambiguous payloads without an explicit verdict
  // are rejected at the admission boundary (TCK-00388 Quality BLOCKER 2).
  bool passed = 13;
}

// ============================================================
// AAT GATE RECEIPT PAYLOAD (TCK-00218)
// ============================================================
//
// AatGateReceipt is the typed payload for AAT gate receipts with evidence binding.
// This payload is stored in CAS and referenced by payload_hash from GateReceipt.
//
// All 22 fields are required to ensure complete evidence binding and traceability.
// The run_receipt_hashes.len() MUST equal run_count for validation.
//
// Security: This payload captures all machine-checkable evidence from AAT execution,
// including terminal verifier outputs, determinism tracking, and attestation metadata.

// Determinism status for AAT runs.
// Indicates whether multiple runs produced consistent terminal evidence.
enum DeterminismStatus {
  // Unspecified status (invalid).
  DETERMINISM_STATUS_UNSPECIFIED = 0;
  // All runs produced identical terminal evidence.
  DETERMINISM_STATUS_STABLE = 1;
  // Runs produced different terminal evidence.
  DETERMINISM_STATUS_MISMATCH = 2;
}

// Classification of flakiness when determinism mismatch occurs.
// Used for routing to appropriate quarantine/remediation paths.
enum FlakeClass {
  // Unspecified class (invalid).
  FLAKE_CLASS_UNSPECIFIED = 0;
  // Deterministic failure - consistent FAIL across all runs.
  FLAKE_CLASS_DETERMINISTIC_FAIL = 1;
  // Flakiness due to test harness issues (e.g., timing, resource contention).
  FLAKE_CLASS_HARNESS_FLAKE = 2;
  // Flakiness due to environment drift (e.g., dependency version mismatch).
  FLAKE_CLASS_ENVIRONMENT_DRIFT = 3;
  // Test-level non-semantic difference (e.g., output format changes).
  FLAKE_CLASS_TEST_NONSEMANTIC = 4;
  // Code-level non-semantic difference (e.g., timestamps, random IDs).
  FLAKE_CLASS_CODE_NONSEMANTIC = 5;
  // Unknown flakiness cause requiring investigation.
  FLAKE_CLASS_UNKNOWN = 6;
}

// AAT verdict outcome.
enum AatVerdict {
  // Unspecified verdict (invalid).
  AAT_VERDICT_UNSPECIFIED = 0;
  // All acceptance criteria passed.
  AAT_VERDICT_PASS = 1;
  // One or more acceptance criteria failed.
  AAT_VERDICT_FAIL = 2;
  // Additional input required to determine outcome.
  AAT_VERDICT_NEEDS_INPUT = 3;
}

// Risk tier for AAT selection policy.
enum AatRiskTier {
  // Unspecified tier (invalid).
  AAT_RISK_TIER_UNSPECIFIED = 0;
  // High risk - AAT always required.
  AAT_RISK_TIER_HIGH = 1;
  // Medium risk - AAT required for sensitive domains.
  AAT_RISK_TIER_MED = 2;
  // Low risk - AAT sampled with nightly full coverage.
  AAT_RISK_TIER_LOW = 3;
}

// Output from a terminal verifier.
// Terminal verifiers provide ground truth (exit codes, snapshot diffs, etc.).
message TerminalVerifierOutput {
  // Kind of verifier: exit_code, snapshot_diff, structured_test_report, invariant_check
  string verifier_kind = 1;
  // Digest of the verifier output content (32 bytes).
  bytes output_digest = 2;
  // Whether the machine predicate was satisfied.
  bool predicate_satisfied = 3;
}

// Attestation metadata for AAT execution environment.
// Provides evidence chain for runtime environment verification.
message AatAttestation {
  // Digest of the container image used (32 bytes).
  bytes container_image_digest = 1;
  // Digests of toolchain components (each 32 bytes).
  repeated bytes toolchain_digests = 2;
  // Identity key ID of the runner.
  string runner_identity_key_id = 3;
  // Hash of the network policy profile (32 bytes).
  bytes network_policy_profile_hash = 4;
}

// Typed payload for AAT gate receipts (22 required fields).
// Stored in CAS and referenced by payload_hash from GateReceipt envelope.
//
// Invariants:
// - view_commitment_hash matches FAC-00 output
// - rcp_manifest_hash matches FAC-02 output for profile
// - run_receipt_hashes.len() == run_count
// - transcript_chain_root_hash derivable from transcript_bundle_hash
// - artifact_manifest_hash references CAS ArtifactManifest
// - At least one terminal_verifier_output present for PASS
// - predicate_satisfied == true for all verifier outputs when verdict == PASS
message AatGateReceipt {
  // ============== View commitment binding (fields 1-4) ==============
  // Hash binding to view commitment from FAC-00 (32 bytes).
  bytes view_commitment_hash = 1;
  // Hash of the RCP manifest for this profile (32 bytes).
  bytes rcp_manifest_hash = 2;
  // RCP profile identifier.
  string rcp_profile_id = 3;
  // Policy hash for anti-downgrade verification (32 bytes).
  bytes policy_hash = 4;

  // ============== Determinism tracking (fields 5-13) ==============
  // Determinism class (0=non, 1=soft, 2=fully).
  uint32 determinism_class = 5;
  // Whether terminal evidence was stable across runs.
  DeterminismStatus determinism_status = 6;
  // Classification of flakiness when mismatch occurs.
  FlakeClass flake_class = 7;
  // Number of AAT runs executed.
  uint32 run_count = 8;
  // Hashes of individual run receipts (each 32 bytes, len == run_count).
  repeated bytes run_receipt_hashes = 9;
  // Digest of machine-checkable terminal evidence (32 bytes).
  bytes terminal_evidence_digest = 10;
  // Digest of observational evidence (logs, traces) - excluded from determinism (32 bytes).
  bytes observational_evidence_digest = 11;
  // Digest of terminal verifier outputs (32 bytes).
  bytes terminal_verifier_outputs_digest = 12;
  // Stability digest = hash(verdict, terminal_evidence_digest, terminal_verifier_outputs_digest) (32 bytes).
  bytes stability_digest = 13;

  // ============== Verdict (field 14) ==============
  // AAT outcome verdict.
  AatVerdict verdict = 14;

  // ============== Evidence binding (fields 15-19) ==============
  // Root hash of the transcript chain (32 bytes).
  bytes transcript_chain_root_hash = 15;
  // Hash of the transcript bundle in CAS (32 bytes).
  bytes transcript_bundle_hash = 16;
  // Hash of the artifact manifest in CAS (32 bytes).
  bytes artifact_manifest_hash = 17;
  // Terminal verifier outputs with predicate satisfaction.
  repeated TerminalVerifierOutput terminal_verifier_outputs = 18;
  // Hash of the verifier policy (32 bytes).
  bytes verifier_policy_hash = 19;

  // ============== Risk tier (fields 20-21) ==============
  // Selection policy identifier.
  string selection_policy_id = 20;
  // Risk tier for AAT selection (0-4: Tier0-Tier4).
  // Stored as uint32 for fidelity preservation across proto roundtrips.
  uint32 risk_tier = 21;

  // ============== Attestation (field 22) ==============
  // Execution environment attestation.
  AatAttestation attestation = 22;
}

// ============================================================
// INTERVENTION EVENTS (FAC Divergence Watchdog)
// ============================================================
//
// Intervention events implement the freeze/unfreeze mechanism for the
// Divergence Watchdog (TCK-00213). When external modifications to the
// trunk are detected (divergence from MergeReceipt), the system emits
// an InterventionFreeze to halt all new admissions until adjudication.
//
// Key security properties:
// - Divergence detection triggers immediate freeze
// - Frozen repos reject all new admissions with REPO_FROZEN error
// - Unfreeze requires adjudication (cannot be bypassed)
// - All freeze/unfreeze events are signed for non-repudiation

// Scope of an intervention freeze.
// Determines what is frozen by the intervention.
enum InterventionScope {
  // Unspecified scope (invalid).
  INTERVENTION_SCOPE_UNSPECIFIED = 0;
  // Freeze applies to a specific repository.
  INTERVENTION_SCOPE_REPOSITORY = 1;
  // Freeze applies to a specific work item.
  INTERVENTION_SCOPE_WORK = 2;
  // Freeze applies to all repositories in a namespace.
  INTERVENTION_SCOPE_NAMESPACE = 3;
}

// Resolution type for intervention unfreeze.
// Indicates how the freeze was resolved.
enum InterventionResolutionType {
  // Unspecified resolution (invalid).
  INTERVENTION_RESOLUTION_UNSPECIFIED = 0;
  // Resolved through adjudication process.
  INTERVENTION_RESOLUTION_ADJUDICATION = 1;
  // Resolved by manual operator intervention.
  INTERVENTION_RESOLUTION_MANUAL = 2;
  // Resolved by rollback to last known good state.
  INTERVENTION_RESOLUTION_ROLLBACK = 3;
  // Resolved by accepting the divergent state as new baseline.
  INTERVENTION_RESOLUTION_ACCEPT_DIVERGENCE = 4;
}

// Emitted when divergence is detected between the ledger's MergeReceipt
// and the external trunk HEAD. This freezes the specified scope to
// prevent further admissions until adjudication.
//
// Security: Divergence detection is critical for maintaining ledger integrity.
// Any external modification of the trunk triggers immediate freeze.
message InterventionFreeze {
  // Unique identifier for this freeze event.
  string freeze_id = 1;
  // Scope of the freeze (repository, work, namespace).
  InterventionScope scope = 2;
  // Value identifying the frozen scope (repo path, work_id, namespace).
  string scope_value = 3;
  // ID of the DefectRecord that triggered this freeze.
  string trigger_defect_id = 4;
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Retained for display/audit purposes; authoritative timing uses
  // HTF time from the time_envelope_ref.
  uint64 frozen_at = 5;
  // Expected trunk HEAD from the latest MergeReceipt.
  bytes expected_trunk_head = 6;
  // Actual trunk HEAD observed externally.
  bytes actual_trunk_head = 7;
  // Actor who detected the divergence and issued the freeze.
  string gate_actor_id = 8;
  // Ed25519 signature over canonical bytes with INTERVENTION_FREEZE: domain (64 bytes).
  bytes gate_signature = 9;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the freeze event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 10;
}

// Emitted when a frozen scope is unfrozen after adjudication.
// The unfreeze must reference a valid adjudication decision.
//
// Security: Unfreeze cannot bypass adjudication. All unfreezes must
// be traceable to a resolution decision.
message InterventionUnfreeze {
  // ID of the InterventionFreeze being lifted.
  string freeze_id = 1;
  // How the freeze was resolved.
  InterventionResolutionType resolution_type = 2;
  // ID of the adjudication that resolved the freeze.
  string adjudication_id = 3;
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Retained for display/audit purposes; authoritative timing uses
  // HTF time from the time_envelope_ref.
  uint64 unfrozen_at = 4;
  // Actor who issued the unfreeze (must be authorized).
  string gate_actor_id = 5;
  // Ed25519 signature over canonical bytes with INTERVENTION_UNFREEZE: domain (64 bytes).
  bytes gate_signature = 6;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the unfreeze event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 7;
}

// ============================================================
// ARTIFACT MANIFEST (TCK-00221)
// ============================================================
//
// ArtifactManifest binds evidence artifacts to gate receipts with
// data classification, redaction metadata, and retention policy.
// This supports evidence hygiene requirements (FAC-REQ-0014).
//
// Key security properties:
// - All artifacts have data classification for access control
// - Redaction profiles are bound to specific sanitization rules
// - Retention windows enable automated cleanup per policy
// - Admission rejects evidence policy violations

// Type of evidence artifact.
enum ArtifactType {
  // Unspecified type (invalid).
  ARTIFACT_TYPE_UNSPECIFIED = 0;
  // Execution logs and traces.
  ARTIFACT_TYPE_LOG = 1;
  // JUnit/xUnit test reports.
  ARTIFACT_TYPE_JUNIT = 2;
  // Code coverage reports.
  ARTIFACT_TYPE_COVERAGE = 3;
  // State snapshots for determinism verification.
  ARTIFACT_TYPE_SNAPSHOT = 4;
  // Compiled artifacts (executables, libraries).
  ARTIFACT_TYPE_BINARY = 5;
}

// Data classification level for evidence artifacts.
// Determines access control and handling requirements.
enum DataClassification {
  // Unspecified classification (invalid).
  DATA_CLASSIFICATION_UNSPECIFIED = 0;
  // No access restrictions.
  DATA_CLASSIFICATION_PUBLIC = 1;
  // Organization-internal access only.
  DATA_CLASSIFICATION_INTERNAL = 2;
  // Restricted access with audit logging.
  DATA_CLASSIFICATION_CONFIDENTIAL = 3;
  // Maximum security controls required.
  DATA_CLASSIFICATION_RESTRICTED = 4;
}

// Digest and metadata for a single evidence artifact.
// Each artifact is identified by its content digest and includes metadata
// for access control, redaction tracking, and retention policy.
message ArtifactDigest {
  // Type of artifact (Log, Junit, Coverage, Snapshot, Binary).
  ArtifactType artifact_type = 1;
  // SHA-256 digest of the artifact content (32 bytes).
  bytes digest = 2;
  // Data classification for access control.
  DataClassification data_classification = 3;
  // Whether redaction/sanitization was applied to this artifact.
  bool redaction_applied = 4;
  // Hash of the redaction profile used (32 bytes, required if redaction_applied).
  bytes redaction_profile_hash = 5;
  // Reference to the retention window for this artifact.
  // Uses HTF time envelope format (e.g., "htf:window:30d").
  string retention_window_ref = 6;
}

// Manifest of evidence artifacts for a gate receipt.
// The manifest binds all evidence artifacts produced during gate execution,
// enabling independent verification and retention management.
//
// Invariants:
// - Must contain at least one artifact (empty manifests are rejected)
// - No duplicate digests allowed
// - All artifacts must pass hygiene validation
//
// Security: The manifest is referenced by artifact_manifest_hash in
// AatGateReceipt and stored in CAS for independent verification.
message ArtifactManifest {
  // List of artifact digests and metadata.
  repeated ArtifactDigest artifacts = 1;
}

// ============================================================
// AAT REUSE EVENTS (TCK-00228)
// ============================================================
//
// AATResultReused records when a previous AAT result is reused for a
// new admission attempt. This avoids redundant execution while
// strictly enforcing provenance matching.
//
// Security:
// - Provenance tuple MUST match exactly (High/Low risk differentiation logic is in code)
// - Policy hash binds to the current policy, not the reused one (if different)
// - Gate signature proves authorization for the reuse decision

// Provenance tuple identifying the context of an AAT execution.
// Used to verify that a reused result is valid for the current context.
message AatProvenanceTuple {
  // Hash binding to specific changeset (32 bytes).
  bytes changeset_digest = 1;
  // Hash binding to view commitment (32 bytes).
  bytes view_commitment_hash = 2;
  // RCP profile identifier.
  string rcp_profile_id = 3;
  // Hash of the verifier policy (32 bytes).
  bytes verifier_policy_hash = 4;
  // Determinism class (0=non, 1=soft, 2=fully).
  uint32 determinism_class = 5;
}

// Emitted when an AAT result is reused.
message AATResultReused {
  // Hash of the original AatGateReceipt being reused (32 bytes).
  bytes from_receipt_hash = 1;
  // Provenance tuple of the current context (must match original).
  AatProvenanceTuple provenance = 2;
  // Policy hash for the current admission attempt (32 bytes).
  bytes policy_hash = 3;
  // Human-readable justification for reuse.
  string justification = 4;
  // Ed25519 signature over canonical bytes with AAT_RESULT_REUSED: domain (64 bytes).
  bytes gate_signature = 5;
}

// ============================================================
// HARNESS SANDBOX SCHEMA (TCK-00230)
// ============================================================
//
// Network policy profile and egress rule types for AAT harness sandboxing.
// AAT harnesses run in strict sandbox environments with deny-by-default egress.
//
// Key security properties:
// - Deny-by-default egress control
// - Policy-declared access only
// - Receipt recording for audit
// - Pinned snapshot mounts
//
// Phase 1: Schema only. Phase 2 will implement runtime enforcement.

// Namespace for harness sandbox types.
message harness_sandbox {
  // Intentionally empty - serves as namespace for nested types.
}

// Transport protocol for egress rules.
enum Protocol {
  // Unspecified protocol (invalid).
  PROTOCOL_UNSPECIFIED = 0;
  // Transmission Control Protocol (connection-oriented).
  PROTOCOL_TCP = 1;
  // User Datagram Protocol (connectionless).
  PROTOCOL_UDP = 2;
}

// An individual egress rule defining allowed network access.
// Each rule specifies a single (host, port, protocol) tuple that is
// permitted for outbound network connections.
//
// Security:
// - Wildcards are NOT supported (explicit hosts only)
// - Port ranges are NOT supported (explicit ports only)
// - CIDR notation is NOT supported for hosts
message EgressRule {
  // Target hostname or IP address (max 253 characters).
  // Wildcards are not supported for security reasons.
  string host = 1;
  // Target port number (1-65535, port 0 is reserved).
  uint32 port = 2;
  // Transport protocol (TCP or UDP).
  Protocol protocol = 3;
}

// Network policy profile for AAT harness sandboxing.
//
// Defines the allowed egress rules for an AAT harness execution environment.
// The profile uses a deny-by-default model where all egress is blocked unless
// explicitly allowed by a rule.
//
// Security:
// - deny_by_default MUST be true (fail-closed security model)
// - Egress rules are sorted by hash for canonical encoding
// - Profile hash provides integrity verification
// - Profile referenced by network_policy_profile_hash in AatAttestation
message NetworkPolicyProfile {
  // Unique identifier for this policy profile.
  string profile_id = 1;
  // BLAKE3 hash of the canonical profile representation (32 bytes).
  // Computed from: profile_id || len(allowed_egress) || sorted(egress_hashes) || deny_by_default
  bytes profile_hash = 2;
  // List of allowed egress rules (max 256 rules).
  // Each rule specifies a (host, port, protocol) tuple that is permitted.
  repeated EgressRule allowed_egress = 3;
  // Deny-by-default flag (MUST be true).
  // When true, all egress not matching a rule is blocked.
  bool deny_by_default = 4;
}

// ============================================================
// QUARANTINE EVENTS (TCK-00235)
// ============================================================
//
// Quarantine events implement the pool and spec quarantine mechanism for the
// Forge Admission Cycle. When flakiness is detected and classified, the
// system quarantines either the runner pool (infrastructure issues) or the
// AAT spec (test/code issues) to prevent repeated failures.
//
// Key security properties:
// - Quarantined pools/specs are excluded from selection
// - Quarantine requires evidence binding (evidence_refs, time_envelope_ref)
// - All quarantine events are signed for non-repudiation
// - QuarantineCleared re-enables targets after investigation

// Emitted when a runner pool is quarantined due to infrastructure flakiness.
//
// This event is triggered when FlakeClass::HarnessFlake routing determines
// that flakiness is attributed to runner/infrastructure issues (timing,
// resource contention, runner-specific bugs).
//
// Security: Quarantined pools are excluded from future AAT runner selection
// until the issue is investigated and QuarantineCleared is emitted.
message RunnerPoolQuarantined {
  // Unique identifier for this quarantine event.
  string quarantine_id = 1;
  // ID of the runner pool being quarantined.
  string pool_id = 2;
  // Human-readable reason for quarantine.
  string reason = 3;
  // References to evidence supporting the quarantine decision.
  repeated string evidence_refs = 4;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the quarantine event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 5;
  // Actor who issued the quarantine.
  string issuer_actor_id = 6;
  // Ed25519 signature over canonical bytes with QUARANTINE_EVENT: domain (64 bytes).
  bytes issuer_signature = 7;
}

// Emitted when an AAT spec is quarantined due to test/code flakiness.
//
// This event is triggered when FlakeClass::TestNonsemantic or
// FlakeClass::CodeNonsemantic routing determines that flakiness is in the
// test specification itself (output format changes, timestamps, random IDs).
//
// Security: Quarantined specs are excluded from AAT selection until the
// non-determinism is resolved and QuarantineCleared is emitted.
message AATSpecQuarantined {
  // Unique identifier for this quarantine event.
  string quarantine_id = 1;
  // ID of the AAT spec being quarantined.
  string spec_id = 2;
  // Human-readable reason for quarantine.
  string reason = 3;
  // References to evidence supporting the quarantine decision.
  repeated string evidence_refs = 4;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the quarantine event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 5;
  // Actor who issued the quarantine.
  string issuer_actor_id = 6;
  // Ed25519 signature over canonical bytes with QUARANTINE_EVENT: domain (64 bytes).
  bytes issuer_signature = 7;
}

// Emitted when a quarantine is cleared after investigation.
//
// This event re-enables the previously quarantined pool or spec for selection.
// The target_id must match either a pool_id from RunnerPoolQuarantined or a
// spec_id from AATSpecQuarantined.
//
// Security: Clearing requires investigation and is audited via signature.
message QuarantineCleared {
  // ID of the original quarantine event being cleared.
  string quarantine_id = 1;
  // ID of the target being cleared (pool_id or spec_id).
  string target_id = 2;
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Retained for display/audit purposes; authoritative timing uses
  // HTF time from the time_envelope_ref.
  uint64 cleared_at = 3;
  // Actor who cleared the quarantine.
  string issuer_actor_id = 4;
  // Ed25519 signature over canonical bytes with QUARANTINE_EVENT: domain (64 bytes).
  bytes issuer_signature = 5;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the quarantine clearing event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 6;
}

// ============================================================
// MERGE EVENTS
// ============================================================

// Emitted when a merge is executed atomically after observing the result_selector.
//
// This receipt binds the inputs (base, changeset, policy, receipts) to the
// observed outcome (result_selector), ensuring that the merge cannot be
// claimed for a different result than what was actually produced.
message MergeReceipt {
  // Base selector (e.g., branch name "main")
  string base_selector = 1;
  // Hash of the changeset being merged (32 bytes)
  bytes changeset_digest = 2;
  // List of gate receipt IDs that authorized this merge
  repeated string gate_receipt_ids = 3;
  // Policy hash that governed this merge decision (32 bytes)
  bytes policy_hash = 4;
  // Observed result selector (e.g., new commit SHA)
  string result_selector = 5;
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Retained for display/audit purposes; authoritative timing uses
  // HTF time from the time_envelope_ref.
  uint64 merged_at = 6;
  // Actor who performed the merge
  string gate_actor_id = 7;
  // Ed25519 signature over canonical bytes with MERGE_RECEIPT: domain (64 bytes)
  bytes gate_signature = 8;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the merge receipt to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 9;
}

// ============================================================
// CHANGESET PUBLISHED EVENTS (TCK-00310)
// ============================================================
//
// ChangeSetPublished anchors a changeset before any review begins.
// This event binds the changeset_digest (computed over canonical bundle
// bytes with the digest field itself omitted) to its CAS hash, enabling
// deterministic digest verification and replay protection.
//
// Key security properties:
// - Anchors changeset_digest BEFORE any review activity
// - CAS hash provides content integrity verification
// - Domain-separated signature prevents replay attacks
// - Deterministic digest enables independent verification

// Emitted when a changeset is published to CAS and anchored in the ledger.
//
// This event MUST be emitted before any review activities begin for a work item.
// The changeset_digest is computed deterministically over the canonicalized
// bundle bytes with the changeset_digest field itself excluded from the hash
// input (to prevent circular dependency).
//
// Security: The signature uses CHANGESET_PUBLISHED: domain prefix.
message ChangeSetPublished {
  // Unique work item ID this changeset belongs to.
  string work_id = 1;
  // BLAKE3 digest of the canonical bundle (32 bytes).
  // Computed over bundle bytes with this field excluded from hash input.
  bytes changeset_digest = 2;
  // CAS hash of the full ChangeSetBundleV1 artifact (32 bytes).
  // Used for content-addressed retrieval and integrity verification.
  bytes cas_hash = 3;
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  // Retained for display/audit purposes; authoritative timing uses
  // HTF time from the time_envelope_ref.
  uint64 published_at = 4;
  // Actor who published the changeset.
  string publisher_actor_id = 5;
  // Ed25519 signature over canonical bytes with CHANGESET_PUBLISHED: domain (64 bytes).
  bytes publisher_signature = 6;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the changeset publication to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 7;
}

// ============================================================
// IO ARTIFACT EVENTS (TCK-00306)
// ============================================================
//
// IoArtifactPublished records IO artifacts produced during episode execution.
// This event enables the episode.<episode_id>.io topic derivation for HEF
// Pulse Plane (RFC-0018).
//
// Key properties:
// - Links IO artifacts to specific episodes for observability
// - Supports multiple artifact types (stdin, stdout, stderr, files)
// - Binds to CAS for content-addressed retrieval
// - Enables audit trail for episode IO operations

// Emitted when an IO artifact is published from an episode.
//
// This event captures IO operations (reads, writes, stream outputs) from
// episode execution, enabling the episode.<episode_id>.io pulse topic.
//
// Security: IO artifacts may contain sensitive data. The artifact_hash
// references CAS storage; access control is enforced at the CAS layer.
message IoArtifactPublished {
  // Episode ID this artifact belongs to.
  // Required; enables episode.<episode_id>.io topic routing.
  string episode_id = 1;
  // Session ID for correlation with session events.
  string session_id = 2;
  // Artifact type: STDIN, STDOUT, STDERR, FILE_READ, FILE_WRITE
  string artifact_type = 3;
  // BLAKE3 hash of the artifact content (32 bytes).
  // Full content is stored in CAS for retrieval.
  bytes artifact_hash = 4;
  // Size of the artifact in bytes.
  uint64 artifact_size = 5;
  // Optional path for file-based artifacts.
  string path = 6;
  // Timestamp when the artifact was produced (Unix nanos).
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  uint64 produced_at = 7;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the artifact event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 8;
  // Data classification: PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED
  // Defaults to INTERNAL if not specified.
  string classification = 9;
}

// ============================================================
// DEFECT EVENTS (TCK-00307)
// ============================================================
//
// DefectRecorded events enable the defect.new pulse topic derivation for HEF
// Pulse Plane (RFC-0018). These events are emitted when defects are detected
// by various producers (divergence watchdog, context miss, HTF regression).
//
// Key properties:
// - Provides structured defect notification for observability
// - References full DefectRecord in CAS via cas_hash
// - Enables audit trail for defect detection events
// - Supports defect.new topic derivation from ledger events

// Source of the defect detection.
// Identifies which producer emitted the DefectRecorded event.
enum DefectSource {
  // Unspecified source (invalid).
  DEFECT_SOURCE_UNSPECIFIED = 0;
  // Divergence watchdog detected trunk HEAD mismatch.
  DEFECT_SOURCE_DIVERGENCE_WATCHDOG = 1;
  // Context miss detected unplanned context read.
  DEFECT_SOURCE_CONTEXT_MISS = 2;
  // HTF regression producer detected test regression.
  DEFECT_SOURCE_HTF_REGRESSION = 3;
  // Projection tamper detected status spoofing.
  DEFECT_SOURCE_PROJECTION_TAMPER = 4;
  // Schema validation rejected an artifact.
  DEFECT_SOURCE_SCHEMA_REJECT = 5;
  // AAT failure detected.
  DEFECT_SOURCE_AAT_FAIL = 6;
  // Required capability unavailable.
  DEFECT_SOURCE_CAPABILITY_UNAVAILABLE = 7;
}

// Emitted when a defect is detected and recorded.
//
// This event is emitted by defect producers (divergence watchdog, context miss
// handlers, HTF regression producers) when a defect is detected. The full
// DefectRecord is stored in CAS and referenced by cas_hash.
//
// Security: DefectRecorded events must flow through the ledger before pulse
// emission per REQ-HEF-0006 ordering invariant.
message DefectRecorded {
  // Unique identifier for this defect.
  // Format: `DEF-{uuid}` or similar unique string.
  string defect_id = 1;
  // Classification of the defect type.
  // Examples: PROJECTION_DIVERGENCE, UNPLANNED_CONTEXT_READ, AAT_FAIL
  string defect_type = 2;
  // BLAKE3 hash of the full DefectRecord artifact in CAS (32 bytes).
  // The full DefectRecord can be retrieved from CAS for detailed analysis.
  bytes cas_hash = 3;
  // Source that detected and emitted this defect.
  DefectSource source = 4;
  // Work ID associated with this defect (if applicable).
  string work_id = 5;
  // Severity level: S0 (critical), S1 (high), S2 (medium), S3 (low).
  string severity = 6;
  // Timestamp when the defect was detected (Unix nanos).
  // OBSERVATIONAL - see HTF RFC-0016; not used for protocol authority.
  uint64 detected_at = 7;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the defect event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 8;
}

// ============================================================
// REVIEW BLOCKED EVENTS (TCK-00311)
// ============================================================
//
// ReviewBlockedRecorded events capture workspace apply failures and tool
// execution failures during FAC v0 review. These events ensure blocked
// outcomes are durable in the ledger.
//
// Key properties:
// - Records blocked outcomes with structured reason codes
// - References blocked logs in CAS via blocked_log_hash
// - Enables retry bound enforcement via HTF time envelope
// - Supports work.<work_id>.blocked topic derivation

// Reason code for review blocked events.
// Classifies the specific failure that caused the review to be blocked.
enum ReviewBlockedReasonCode {
  // Unspecified reason (invalid).
  REVIEW_BLOCKED_REASON_UNSPECIFIED = 0;
  // Workspace apply operation failed.
  REVIEW_BLOCKED_REASON_APPLY_FAILED = 1;
  // Tool execution failed during review.
  REVIEW_BLOCKED_REASON_TOOL_FAILED = 2;
  // Binary file detected (unsupported in v0).
  REVIEW_BLOCKED_REASON_BINARY_UNSUPPORTED = 3;
  // Required artifact missing from CAS.
  REVIEW_BLOCKED_REASON_MISSING_ARTIFACT = 4;
  // Invalid changeset bundle format.
  REVIEW_BLOCKED_REASON_INVALID_BUNDLE = 5;
  // Operation timed out.
  REVIEW_BLOCKED_REASON_TIMEOUT = 6;
  // Policy denied the operation.
  REVIEW_BLOCKED_REASON_POLICY_DENIED = 7;
  // Context miss detected.
  REVIEW_BLOCKED_REASON_CONTEXT_MISS = 8;
  // Context pack not found in CAS (TCK-00326).
  REVIEW_BLOCKED_REASON_CONTEXT_PACK_MISSING = 9;
  // Context pack seal verification failed (TCK-00326).
  REVIEW_BLOCKED_REASON_CONTEXT_PACK_INVALID = 10;
}

// Emitted when a review is blocked due to workspace apply or tool failure.
//
// This event captures the blocked outcome and stores it durably in the ledger.
// It binds the failure to the changeset and provides CAS references for logs.
//
// Security: The signature uses REVIEW_BLOCKED_RECORDED: domain prefix.
message ReviewBlockedRecorded {
  // Unique identifier for this blocked event.
  // Format: `BLK-{uuid}` or similar unique string.
  string blocked_id = 1;
  // BLAKE3 digest of the changeset that was being reviewed (32 bytes).
  bytes changeset_digest = 2;
  // Reason code classifying the failure.
  int32 reason_code = 3;
  // BLAKE3 hash of the blocked logs stored in CAS (32 bytes).
  bytes blocked_log_hash = 4;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the blocked event to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 5;
  // Actor who recorded the blocked event.
  string recorder_actor_id = 6;
  // Ed25519 signature over canonical bytes with REVIEW_BLOCKED_RECORDED: domain (64 bytes).
  bytes recorder_signature = 7;
  // BLAKE3 hash of the CapabilityManifest in effect (32 bytes, TCK-00326).
  // Binds the blocked event to the authority under which the review was attempted.
  bytes capability_manifest_hash = 8;
  // BLAKE3 hash of the sealed ContextPackManifest in effect (32 bytes, TCK-00326).
  // Binds the blocked event to the context firewall configuration.
  bytes context_pack_hash = 9;
  // BLAKE3 hash of the RoleSpecV2 used during review (32 bytes, TCK-00448).
  // Binds the blocked event to the role specification used for the attempted run.
  bytes role_spec_hash = 10;
}

// ============================================================
// REVIEW RECEIPT EVENTS (TCK-00312)
// ============================================================
//
// ReviewReceiptRecorded events capture successful review completion in the FAC v0
// pipeline. This event binds the review artifacts (review text, tool logs) to the
// changeset being reviewed and provides temporal anchoring via HTF.
//
// Key properties:
// - Binds changeset_digest to artifact_bundle_hash for integrity
// - References ReviewArtifactBundleV1 stored in CAS
// - Provides time_envelope_ref for temporal authority
// - Enables work.<work_id>.review topic derivation

// Emitted when a review is successfully completed.
//
// This event records the successful review outcome and stores it durably in the
// ledger. It binds the review artifacts to the changeset and provides CAS
// references for verification.
//
// Security: The signature uses REVIEW_RECEIPT_RECORDED: domain prefix.
message ReviewReceiptRecorded {
  // Unique identifier for this receipt.
  // Format: `RR-{uuid}` or similar unique string.
  string receipt_id = 1;
  // BLAKE3 digest of the changeset that was reviewed (32 bytes).
  // This is the same digest from the ChangeSetPublished event.
  bytes changeset_digest = 2;
  // BLAKE3 hash of the ReviewArtifactBundleV1 stored in CAS (32 bytes).
  // Contains review_text_hash, tool_log_hashes, and metadata.
  bytes artifact_bundle_hash = 3;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the receipt to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 4;
  // Actor who recorded the receipt (the reviewer).
  string reviewer_actor_id = 5;
  // Ed25519 signature over canonical bytes with REVIEW_RECEIPT_RECORDED: domain (64 bytes).
  bytes reviewer_signature = 6;
  // BLAKE3 hash of the CapabilityManifest used during review (32 bytes, TCK-00326).
  // Binds the review to the authority under which it was performed.
  bytes capability_manifest_hash = 7;
  // BLAKE3 hash of the sealed ContextPackManifest used during review (32 bytes, TCK-00326).
  // Binds the review to the context firewall configuration.
  bytes context_pack_hash = 8;
  // BLAKE3 hash of the RoleSpecV1 used during review (32 bytes, TCK-00331).
  // Binds the review to the role specification for attribution and conformance verification.
  bytes role_spec_hash = 9;
}

// ============================================================
// PROJECTION RECEIPT EVENTS (TCK-00323)
// ============================================================
//
// ProjectionReceiptRecorded events capture successful projection completion
// in the FAC pipeline. This event binds the projection artifacts (status,
// context) to the changeset being projected and provides temporal anchoring.
//
// Key properties:
// - Binds changeset_digest to artifact_bundle_hash for integrity
// - References ProjectionArtifactBundleV1 stored in CAS
// - Provides time_envelope_ref for temporal authority
// - Enables work.<work_id>.projection topic derivation
// - Idempotency key: (work_id, changeset_digest, ledger_head)

// Emitted when a projection is successfully completed.
//
// This event records the successful projection outcome and stores it durably
// in the ledger. It binds the projection artifacts to the changeset and
// provides CAS references for verification and idempotency.
//
// Security: The signature uses PROJECTION_RECEIPT_RECORDED: domain prefix.
message ProjectionReceiptRecorded {
  // Unique identifier for this receipt.
  // Format: `PR-{uuid}` or similar unique string.
  string receipt_id = 1;
  // BLAKE3 digest of the changeset that was projected (32 bytes).
  // This is the same digest from the ChangeSetPublished event.
  bytes changeset_digest = 2;
  // BLAKE3 hash of the ProjectionArtifactBundleV1 stored in CAS (32 bytes).
  // Contains projection_status, ledger_head, and metadata.
  bytes artifact_bundle_hash = 3;
  // HTF time envelope reference for temporal authority (RFC-0016).
  // Binds the receipt to verifiable HTF time.
  optional TimeEnvelopeRef time_envelope_ref = 4;
  // Actor who recorded the receipt (the projector).
  string projector_actor_id = 5;
  // Ed25519 signature over canonical bytes with PROJECTION_RECEIPT_RECORDED: domain (64 bytes).
  bytes projector_signature = 6;
}

// ============================================================
// WORK GRAPH EVENTS (RFC-0032, TCK-00642)
// ============================================================
//
// WorkGraphEvent models dependency edges between work items in the
// work graph. These events form a DAG of work dependencies that is
// separate from the WorkReducer's lifecycle state machine.
//
// IMPORTANT: Event type strings use the `work_graph.edge.*` prefix,
// NOT `work.*`, to avoid collision with WorkReducer event decoding.
//
// Key properties:
// - Edges are directional: from_work_id -> to_work_id
// - Multi-topic derivation: events emit topics for BOTH work IDs
// - Edge types classify the dependency relationship
// - Waived edges record intentional dependency overrides

// Type of dependency edge between work items.
enum WorkEdgeType {
  // Unspecified edge type (invalid).
  WORK_EDGE_TYPE_UNSPECIFIED = 0;
  // from_work_id depends on to_work_id (must complete first).
  WORK_EDGE_TYPE_DEPENDENCY = 1;
  // from_work_id blocks to_work_id (prevents progress).
  WORK_EDGE_TYPE_BLOCKS = 2;
  // from_work_id enables to_work_id (prerequisite capability).
  WORK_EDGE_TYPE_ENABLES = 3;
  // from_work_id must complete before to_work_id starts (ordering).
  WORK_EDGE_TYPE_SEQUENCE = 4;
}

// Envelope for work graph edge events.
message WorkGraphEvent {
  oneof event {
    WorkEdgeAdded added = 1;
    WorkEdgeRemoved removed = 2;
    WorkEdgeWaived waived = 3;
  }
}

// Emitted when a dependency edge is added between two work items.
//
// This event establishes a directional relationship in the work graph.
// The edge_type classifies the nature of the dependency.
//
// Topic derivation produces topics for BOTH from_work_id and to_work_id
// so that subscribers to either work item receive the notification.
message WorkEdgeAdded {
  // Source work item in the edge.
  string from_work_id = 1;
  // Target work item in the edge.
  string to_work_id = 2;
  // Type of dependency relationship.
  WorkEdgeType edge_type = 3;
  // Human-readable rationale for why this edge exists.
  string rationale = 4;
}

// Emitted when a dependency edge is removed between two work items.
//
// This event removes a previously established edge from the work graph.
//
// Topic derivation produces topics for BOTH from_work_id and to_work_id.
message WorkEdgeRemoved {
  // Source work item in the edge.
  string from_work_id = 1;
  // Target work item in the edge.
  string to_work_id = 2;
  // Reason for edge removal.
  string reason = 3;
}

// Emitted when a dependency edge is waived (intentionally overridden).
//
// A waiver records that a dependency was acknowledged but intentionally
// skipped, with audit evidence for the override decision.
//
// Topic derivation produces topics for BOTH from_work_id and to_work_id.
message WorkEdgeWaived {
  // Source work item in the edge.
  string from_work_id = 1;
  // Target work item in the edge.
  string to_work_id = 2;
  // Type of the original edge being waived.
  WorkEdgeType original_edge_type = 3;
  // Justification for the waiver.
  string waiver_justification = 4;
  // Actor who authorized the waiver.
  string waiver_actor_id = 5;
}
