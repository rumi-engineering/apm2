// APM2 Kernel Event Schema
// Version: 0.2.0
//
// This file defines the core event types for the APM2 kernel.
// All events are stored in the ledger and form a hash chain.
//
// IMPORTANT: Maps are forbidden in signed messages to ensure canonical encoding.
//
// CANONICAL ENCODING REQUIREMENTS:
// To ensure deterministic serialization (required for signature verification):
// 1. Maps are forbidden (non-deterministic key ordering)
// 2. Repeated fields MUST be sorted before signing:
//    - String fields: lexicographic ordering
//    - Numeric fields: ascending order
// 3. Use BTreeMap for any map-like structures in Rust implementations
// 4. Empty repeated fields should be omitted from wire format

syntax = "proto3";
package apm2.kernel.v1;

import "google/protobuf/timestamp.proto";

// Common envelope for all kernel events
message KernelEvent {
  // Monotonic sequence number within this ledger
  uint64 sequence = 1;
  // Hash of the previous event.
  // For genesis events: use 32 zero bytes (canonical representation).
  // Note: The ledger may store NULL for genesis as a storage optimization,
  // but it must be normalized to 32 zero bytes at API boundaries.
  bytes previous_hash = 2;
  // Timestamp when event was created
  google.protobuf.Timestamp timestamp = 3;
  // Actor ID that produced this event
  string actor_id = 4;
  // Session ID (if applicable)
  string session_id = 5;
  // Ed25519 signature over canonical bytes of this message
  bytes signature = 6;
  // Schema version for forward/backward compatibility
  // Current version: 1
  uint32 schema_version = 7;
  // Event payload (oneof)
  oneof payload {
    SessionEvent session = 10;
    WorkEvent work = 11;
    ToolEvent tool = 12;
    LeaseEvent lease = 13;
    PolicyEvent policy = 14;
    AdjudicationEvent adjudication = 15;
    EvidenceEvent evidence = 16;
    KeyEvent key = 17;
    CapabilityEvent capability = 18;
    GitHubLeaseEvent github_lease = 19;
    PolicyResolvedForChangeSet policy_resolved_for_changeset = 20;
    GateReceipt gate_receipt = 21;
    InterventionFreeze intervention_freeze = 22;
    InterventionUnfreeze intervention_unfreeze = 23;
  }
}

// ============================================================
// SESSION EVENTS
// ============================================================
message SessionEvent {
  oneof event {
    SessionStarted started = 1;
    SessionProgress progress = 2;
    SessionTerminated terminated = 3;
    SessionQuarantined quarantined = 4;
    SessionCrashDetected crash_detected = 5;
    SessionRestartScheduled restart_scheduled = 6;
  }
}

// Emitted when a session process exits unexpectedly or crashes.
message SessionCrashDetected {
  string session_id = 1;
  string crash_type = 2;  // CLEAN_EXIT, ERROR_EXIT, SIGNAL, TIMEOUT, ENTROPY_EXCEEDED
  int32 exit_code = 3;
  int32 signal = 4;
  uint64 uptime_ms = 5;
  uint64 last_cursor = 6;
  uint32 restart_count = 7;
}

// Emitted when a restart has been scheduled for a crashed session.
message SessionRestartScheduled {
  string session_id = 1;
  uint64 scheduled_at = 2;
  uint64 restart_at = 3;
  uint64 resume_cursor = 4;
  uint32 attempt_number = 5;
  string backoff_type = 6;  // FIXED, EXPONENTIAL, LINEAR
}

message SessionStarted {
  string session_id = 1;
  string actor_id = 2;
  string adapter_type = 3;
  string work_id = 4;
  string lease_id = 5;
  uint64 entropy_budget = 6;
  // For restarted sessions: cursor to resume from
  uint64 resume_cursor = 7;
  // For restarted sessions: restart attempt number (0 = first start)
  uint32 restart_attempt = 8;
}

message SessionProgress {
  string session_id = 1;
  uint64 progress_sequence = 2;
  string progress_type = 3;  // HEARTBEAT, TOOL_COMPLETE, MILESTONE
  uint64 entropy_consumed = 4;
}

message SessionTerminated {
  string session_id = 1;
  string exit_classification = 2;  // SUCCESS, FAILURE, TIMEOUT, ENTROPY_EXCEEDED
  string rationale_code = 3;
  uint64 final_entropy = 4;
}

message SessionQuarantined {
  string session_id = 1;
  string reason = 2;
  uint64 quarantine_until = 3;
}

// ============================================================
// WORK EVENTS
// ============================================================
message WorkEvent {
  oneof event {
    WorkOpened opened = 1;
    WorkTransitioned transitioned = 2;
    WorkCompleted completed = 3;
    WorkAborted aborted = 4;
    WorkPrAssociated pr_associated = 5;
  }
}

message WorkOpened {
  string work_id = 1;
  string work_type = 2;  // TICKET, PRD_REFINEMENT, RFC_REFINEMENT, REVIEW
  bytes spec_snapshot_hash = 3;
  repeated string requirement_ids = 4;
  repeated string parent_work_ids = 5;
}

message WorkTransitioned {
  string work_id = 1;
  string from_state = 2;
  // Valid states: OPEN, CLAIMED, IN_PROGRESS, CI_PENDING, READY_FOR_REVIEW,
  // BLOCKED, REVIEW, NEEDS_INPUT, NEEDS_ADJUDICATION
  string to_state = 3;
  string rationale_code = 4;
  // Previous transition count for replay protection.
  // MUST match work.transition_count before this transition.
  // This field is strictly validated to prevent replay attacks.
  // For the first transition (Open -> Claimed), use 0.
  uint32 previous_transition_count = 5;
}

message WorkCompleted {
  string work_id = 1;
  bytes evidence_bundle_hash = 2;
  repeated string evidence_ids = 3;
  string gate_receipt_id = 4;
}

message WorkAborted {
  string work_id = 1;
  string abort_reason = 2;  // POLICY_DENY, TIMEOUT, ENTROPY_EXCEEDED, MANUAL
  string rationale_code = 3;
}

// Emitted when a PR is created and associated with a work item.
// This enables CI event matching for phase transitions.
message WorkPrAssociated {
  string work_id = 1;
  uint64 pr_number = 2;
  string commit_sha = 3;  // The commit SHA that triggered the CI workflow
}

// ============================================================
// TOOL EVENTS
// ============================================================
message ToolEvent {
  oneof event {
    ToolRequested requested = 1;
    ToolDecided decided = 2;
    ToolExecuted executed = 3;
  }
}

message ToolRequested {
  string request_id = 1;
  string session_id = 2;
  string tool_name = 3;
  bytes tool_args_hash = 4;  // Hash of arguments (full args stored in CAS)
  string dedupe_key = 5;
}

message ToolDecided {
  string request_id = 1;
  string decision = 2;  // ALLOW, DENY
  string rule_id = 3;
  bytes policy_hash = 4;
  string rationale_code = 5;
  uint64 budget_consumed = 6;
}

message ToolExecuted {
  string request_id = 1;
  string outcome = 2;  // SUCCESS, FAILURE, TIMEOUT
  bytes result_hash = 3;  // Hash of result (full result stored in CAS)
  uint64 duration_ms = 4;
}

// ============================================================
// LEASE EVENTS
// ============================================================
message LeaseEvent {
  oneof event {
    LeaseIssued issued = 1;
    LeaseRenewed renewed = 2;
    LeaseReleased released = 3;
    LeaseExpired expired = 4;
    LeaseConflict conflict = 5;
  }
}

message LeaseIssued {
  string lease_id = 1;
  string work_id = 2;
  string actor_id = 3;
  uint64 issued_at = 4;
  uint64 expires_at = 5;
  bytes registrar_signature = 6;
}

message LeaseRenewed {
  string lease_id = 1;
  uint64 new_expires_at = 2;
  bytes registrar_signature = 3;
}

message LeaseReleased {
  string lease_id = 1;
  string release_reason = 2;  // COMPLETED, ABORTED, VOLUNTARY
}

message LeaseExpired {
  string lease_id = 1;
  uint64 expired_at = 2;
}

message LeaseConflict {
  string work_id = 1;
  repeated string conflicting_lease_ids = 2;
  string resolution = 3;  // CANONICAL_ROOT, ADJUDICATION_REQUIRED
}

// ============================================================
// POLICY EVENTS
// ============================================================
message PolicyEvent {
  oneof event {
    PolicyLoaded loaded = 1;
    PolicyViolation violation = 2;
    BudgetExceeded budget_exceeded = 3;
  }
}

message PolicyLoaded {
  bytes policy_hash = 1;
  string policy_version = 2;
  uint64 rule_count = 3;
}

message PolicyViolation {
  string session_id = 1;
  string violation_type = 2;
  string rule_id = 3;
  string details = 4;
}

message BudgetExceeded {
  string session_id = 1;
  string budget_type = 2;  // TOKEN, TIME, TOOL_CALLS
  uint64 limit = 3;
  uint64 consumed = 4;
}

// ============================================================
// ADJUDICATION EVENTS
// ============================================================
message AdjudicationEvent {
  oneof event {
    AdjudicationRequested requested = 1;
    AdjudicationVote vote = 2;
    AdjudicationResolved resolved = 3;
    AdjudicationTimeout timeout = 4;
  }
}

message AdjudicationRequested {
  string adjudication_id = 1;
  string work_id = 2;
  string request_type = 3;  // BOUNDED_CHOICE, WAIVER, GATE_REVIEW
  repeated string options = 4;
  uint64 deadline = 5;
  string fallback_policy = 6;
}

message AdjudicationVote {
  string adjudication_id = 1;
  string voter_actor_id = 2;
  string chosen_option = 3;
  bytes voter_signature = 4;
}

message AdjudicationResolved {
  string adjudication_id = 1;
  string chosen_option = 2;
  uint64 votes_for = 3;
  uint64 votes_against = 4;
  bytes quorum_signature = 5;
}

message AdjudicationTimeout {
  string adjudication_id = 1;
  string applied_fallback = 2;
}

// ============================================================
// EVIDENCE EVENTS
// ============================================================
message EvidenceEvent {
  oneof event {
    EvidencePublished published = 1;
    GateReceiptGenerated gate_receipt = 2;
  }
}

message EvidencePublished {
  string evidence_id = 1;
  string work_id = 2;
  string category = 3;
  bytes artifact_hash = 4;
  repeated string verification_command_ids = 5;
  // Data classification: PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED
  string classification = 6;
  // Artifact size in bytes (for bundle size tracking)
  uint64 artifact_size = 7;
  // Metadata key-value pairs as "key=value" strings
  repeated string metadata = 8;
}

message GateReceiptGenerated {
  string receipt_id = 1;
  string gate_id = 2;
  string work_id = 3;
  string result = 4;  // PASS, FAIL
  repeated string evidence_ids = 5;
  bytes receipt_signature = 6;
}

// ============================================================
// CAPABILITY EVENTS
// ============================================================
//
// Capability events implement the OCAP (Object Capability) model for
// cross-node authority verification. All capability events are TotalOrder
// authority events requiring BFT consensus finalization.
//
// Key concepts:
// - capability_id == lease_id (capabilities are linked to leases)
// - namespace binding prevents cross-namespace replay attacks
// - Delegation chains support hierarchical authority delegation
// - Proofs are ledger-verifiable across nodes

message CapabilityEvent {
  oneof event {
    CapabilityRequired required = 1;
    CapabilityGranted granted = 2;
    CapabilityDelegated delegated = 3;
    CapabilityRevoked revoked = 4;
  }
}

// Emitted during planning phase when a capability is required for a plan step.
// This event enables capability negotiation and tracking.
message CapabilityRequired {
  // The capability ID that is required (e.g., "cac:patch:apply")
  string capability_id = 1;
  // The work ID this requirement is associated with
  string work_id = 2;
  // Whether this capability is required (true) or optional (false)
  bool required = 3;
  // The status of the capability: AVAILABLE, UNAVAILABLE, DEGRADED
  string status = 4;
  // Human-readable reason for the status
  string reason = 5;
}

// Emitted when a capability is granted to an actor by an authority.
// This is the root of a delegation chain and must be signed by the registrar.
// Links to the lease system: capability_id == lease_id.
message CapabilityGranted {
  // Unique identifier for this capability (equals lease_id for lease-backed capabilities)
  string capability_id = 1;
  // Namespace this capability is bound to (prevents cross-namespace replay)
  string namespace = 2;
  // Actor receiving the capability
  string grantee_actor_id = 3;
  // Actor granting the capability (must be an authority in the namespace)
  string grantor_actor_id = 4;
  // Hash of the serialized LeaseScope (stored in CAS)
  bytes scope_hash = 5;
  // Optional hash of the serialized Budget (stored in CAS)
  bytes budget_hash = 6;
  // Timestamp when the capability was granted (Unix nanos)
  uint64 granted_at = 7;
  // Timestamp when the capability expires (Unix nanos)
  uint64 expires_at = 8;
  // Registrar signature over this grant (proves authority)
  bytes registrar_signature = 9;
  // Whether this capability can be delegated to others
  bool delegatable = 10;
}

// Emitted when a capability holder delegates their capability to another actor.
// Forms part of the delegation chain for capability proofs.
message CapabilityDelegated {
  // New capability ID for the delegated capability
  string delegated_capability_id = 1;
  // Parent capability being delegated from
  string parent_capability_id = 2;
  // Hash of the parent CapabilityGranted or CapabilityDelegated event
  bytes parent_capability_hash = 3;
  // Namespace this delegation is bound to (must match parent)
  string namespace = 4;
  // Actor receiving the delegated capability
  string delegatee_actor_id = 5;
  // Actor delegating the capability (must hold parent capability)
  string delegator_actor_id = 6;
  // Hash of the serialized LeaseScope (must be subset of parent scope)
  bytes scope_hash = 7;
  // Optional hash of the serialized Budget (must be subset of parent budget)
  bytes budget_hash = 8;
  // Timestamp when the delegation occurred (Unix nanos)
  uint64 delegated_at = 9;
  // Timestamp when the delegated capability expires (Unix nanos, must be <= parent expires_at)
  uint64 expires_at = 10;
  // Delegator's signature over this delegation (proves authority transfer)
  bytes delegator_signature = 11;
  // Whether this delegated capability can be further delegated
  bool delegatable = 12;
  // Depth in the delegation chain (parent depth + 1)
  uint32 delegation_depth = 13;
}

// Emitted when a capability is revoked before its natural expiration.
// Revocation cascades to all delegated capabilities in the chain.
message CapabilityRevoked {
  // The capability being revoked
  string capability_id = 1;
  // Namespace the capability belongs to
  string namespace = 2;
  // Actor performing the revocation (must be grantor or authority)
  string revoker_actor_id = 3;
  // Reason for revocation: VOLUNTARY, POLICY_VIOLATION, KEY_COMPROMISE, SUPERSEDED
  string revocation_reason = 4;
  // Timestamp when the revocation occurred (Unix nanos)
  uint64 revoked_at = 5;
  // Revoker's signature over this revocation
  bytes revoker_signature = 6;
  // If true, revocation cascades to all delegated capabilities; if false, only this capability is revoked
  bool cascade = 7;
}

// ============================================================
// KEY EVENTS
// ============================================================
message KeyEvent {
  oneof event {
    KeyRotated rotated = 1;
  }
}

// ============================================================
// GITHUB LEASE EVENTS
// ============================================================
//
// GitHub lease events implement tiered GitHub App access control for AI agents.
// Each GitHub App corresponds to a risk tier range:
// - apm2-reader (T0): contents:read, metadata:read
// - apm2-developer (T1-T2): + pull_requests:write, checks:write, statuses:write
// - apm2-operator (T3-T4): + contents:write, admin:read, releases:write
//
// Key security properties:
// - Raw tokens are NEVER stored in the ledger (only hashes)
// - Token TTLs are proportional to risk tier (shorter for higher tiers)
// - Scope attenuation only (cannot escalate permissions)
// - All operations are audited for non-repudiation

message GitHubLeaseEvent {
  oneof event {
    GitHubLeaseIssued issued = 1;
    GitHubLeaseRevoked revoked = 2;
    GitHubOperationRecorded operation_recorded = 3;
  }
}

// Emitted when a GitHub installation access token is minted for an agent.
// Links to the episode via episode_id and inherits risk tier constraints.
message GitHubLeaseIssued {
  // Unique identifier for this GitHub lease
  string lease_id = 1;
  // Episode this lease is bound to
  string episode_id = 2;
  // GitHub App ID (determines permission tier)
  string github_app_id = 3;
  // GitHub installation ID for the target repository/organization
  string installation_id = 4;
  // Risk tier of the requesting agent (0-4)
  // Tier determines which GitHub App can be used:
  // - T0: reader only
  // - T1-T2: reader or developer
  // - T3-T4: reader, developer, or operator
  uint32 risk_tier = 5;
  // Hash of the requested GitHub scopes (scope list stored in CAS)
  bytes scope_hash = 6;
  // SHA-256 hash of the installation access token (NEVER store raw token)
  bytes token_hash = 7;
  // Timestamp when the lease was issued (Unix nanos)
  uint64 issued_at = 8;
  // Timestamp when the lease expires (Unix nanos)
  // TTL is proportional to risk tier:
  // - T0: 1 hour
  // - T1-T2: 15-30 minutes
  // - T3-T4: 2-5 minutes
  uint64 expires_at = 9;
  // Hash of the capability manifest that authorized this lease
  bytes capability_manifest_hash = 10;
  // Issuer (registrar) signature over this event
  bytes issuer_signature = 11;
}

// Emitted when a GitHub lease is revoked before expiration.
// Revocation may be voluntary or forced (policy violation, key compromise).
message GitHubLeaseRevoked {
  // The lease being revoked
  string lease_id = 1;
  // Episode the lease was bound to
  string episode_id = 2;
  // Reason for revocation: VOLUNTARY, EXPIRED, POLICY_VIOLATION, KEY_COMPROMISE
  string revocation_reason = 3;
  // Timestamp when the revocation occurred (Unix nanos)
  uint64 revoked_at = 4;
  // Actor performing the revocation
  string revoker_actor_id = 5;
  // Revoker signature over this event
  bytes revoker_signature = 6;
}

// Emitted for each GitHub API operation made with a leased token.
// Provides audit trail for all GitHub interactions.
message GitHubOperationRecorded {
  // Unique identifier for this operation record
  string operation_id = 1;
  // The lease that authorized this operation
  string lease_id = 2;
  // Episode context
  string episode_id = 3;
  // GitHub API endpoint called (e.g., "POST /repos/{owner}/{repo}/pulls")
  string api_endpoint = 4;
  // HTTP method: GET, POST, PUT, PATCH, DELETE
  string http_method = 5;
  // Target repository in owner/repo format
  string repository = 6;
  // Hash of the request body (request body stored in CAS if needed)
  bytes request_hash = 7;
  // Hash of the response body (response body stored in CAS if needed)
  bytes response_hash = 8;
  // HTTP status code returned
  uint32 status_code = 9;
  // Timestamp when the operation was performed (Unix nanos)
  uint64 performed_at = 10;
  // Duration of the API call in milliseconds
  uint64 duration_ms = 11;
  // GitHub rate limit remaining after this call
  uint32 rate_limit_remaining = 12;
}

// Event emitted when an actor rotates their signing key.
// This establishes a chain of custody for key transitions.
message KeyRotated {
  // Actor whose key is being rotated
  string actor_id = 1;
  // Hash of the old verifying key (for reference)
  bytes old_key_hash = 2;
  // New verifying (public) key bytes
  bytes new_verifying_key = 3;
  // Timestamp when the rotation occurred (Unix nanos)
  uint64 rotated_at = 4;
  // Signature from the OLD key over this message (proves control of old key)
  bytes old_key_signature = 5;
}

// ============================================================
// FORGE ADMISSION CYCLE (FAC) EVENTS
// ============================================================
//
// FAC events implement the policy resolution and gate lease lifecycle
// for the Forge Admission Cycle. These events ensure that all changes
// flow through quality gates with locked policy configurations.
//
// Ordering Invariant: PolicyResolvedForChangeSet MUST exist before
// any GateLeaseIssued for the same work_id/changeset.

// The anchor event that locks policy decisions for a changeset.
// All subsequent lease issuance and receipt validation must reference
// this anchor's resolved_policy_hash.
message PolicyResolvedForChangeSet {
  // Work item this policy resolution applies to
  string work_id = 1;
  // Hash binding to specific changeset (32 bytes)
  bytes changeset_digest = 2;
  // Hash of the resolved policy tuple (32 bytes)
  // Computed from: risk_tier || determinism_class || sorted(rcp_profile_ids) ||
  //                sorted(rcp_manifest_hashes) || sorted(verifier_policy_hashes)
  bytes resolved_policy_hash = 3;
  // Resolved risk tier (0-4)
  uint32 resolved_risk_tier = 4;
  // Resolved determinism class (0=non, 1=soft, 2=fully)
  uint32 resolved_determinism_class = 5;
  // Resolved RCP profile IDs (sorted for canonical encoding)
  repeated string resolved_rcp_profile_ids = 6;
  // Hashes of resolved RCP manifests (sorted, each 32 bytes)
  repeated bytes resolved_rcp_manifest_hashes = 7;
  // Hashes of resolved verifier policies (sorted, each 32 bytes)
  repeated bytes resolved_verifier_policy_hashes = 8;
  // Actor who performed the policy resolution
  string resolver_actor_id = 9;
  // Version of the resolver component
  string resolver_version = 10;
  // Ed25519 signature over canonical bytes with POLICY_RESOLVED_FOR_CHANGESET: domain (64 bytes)
  bytes resolver_signature = 11;
}

// GateReceipt envelope with versioning support.
// This is the canonical receipt envelope that wraps gate-specific payloads.
// The receipt binds a gate execution result to a specific lease and changeset.
//
// Versioning:
// - receipt_version: Envelope schema version (currently: 1)
// - payload_kind: Type of payload ("aat", "quality", "security")
// - payload_schema_version: Version of the payload schema
//
// Security:
// - receipt_signature uses GATE_RECEIPT: domain prefix
// - All fields except signature are included in canonical bytes
message GateReceipt {
  // Unique identifier for this receipt
  string receipt_id = 1;
  // Gate that generated this receipt
  string gate_id = 2;
  // Lease that authorized this gate execution
  string lease_id = 3;
  // Hash binding to specific changeset (32 bytes)
  bytes changeset_digest = 4;
  // Actor who executed the gate
  string executor_actor_id = 5;
  // Envelope schema version (supported: 1)
  uint32 receipt_version = 6;
  // Type of payload: "aat", "quality", "security"
  string payload_kind = 7;
  // Version of the payload schema
  uint32 payload_schema_version = 8;
  // Hash of the payload content (32 bytes)
  bytes payload_hash = 9;
  // Hash of the evidence bundle (32 bytes)
  bytes evidence_bundle_hash = 10;
  // Ed25519 signature over canonical bytes with GATE_RECEIPT: domain (64 bytes)
  bytes receipt_signature = 11;
}

// ============================================================
// AAT GATE RECEIPT PAYLOAD (TCK-00218)
// ============================================================
//
// AatGateReceipt is the typed payload for AAT gate receipts with evidence binding.
// This payload is stored in CAS and referenced by payload_hash from GateReceipt.
//
// All 22 fields are required to ensure complete evidence binding and traceability.
// The run_receipt_hashes.len() MUST equal run_count for validation.
//
// Security: This payload captures all machine-checkable evidence from AAT execution,
// including terminal verifier outputs, determinism tracking, and attestation metadata.

// Determinism status for AAT runs.
// Indicates whether multiple runs produced consistent terminal evidence.
enum DeterminismStatus {
  // Unspecified status (invalid).
  DETERMINISM_STATUS_UNSPECIFIED = 0;
  // All runs produced identical terminal evidence.
  DETERMINISM_STATUS_STABLE = 1;
  // Runs produced different terminal evidence.
  DETERMINISM_STATUS_MISMATCH = 2;
}

// Classification of flakiness when determinism mismatch occurs.
// Used for routing to appropriate quarantine/remediation paths.
enum FlakeClass {
  // Unspecified class (invalid).
  FLAKE_CLASS_UNSPECIFIED = 0;
  // Deterministic failure - consistent FAIL across all runs.
  FLAKE_CLASS_DETERMINISTIC_FAIL = 1;
  // Flakiness due to test harness issues (e.g., timing, resource contention).
  FLAKE_CLASS_HARNESS_FLAKE = 2;
  // Flakiness due to environment drift (e.g., dependency version mismatch).
  FLAKE_CLASS_ENVIRONMENT_DRIFT = 3;
  // Test-level non-semantic difference (e.g., output format changes).
  FLAKE_CLASS_TEST_NONSEMANTIC = 4;
  // Code-level non-semantic difference (e.g., timestamps, random IDs).
  FLAKE_CLASS_CODE_NONSEMANTIC = 5;
  // Unknown flakiness cause requiring investigation.
  FLAKE_CLASS_UNKNOWN = 6;
}

// AAT verdict outcome.
enum AatVerdict {
  // Unspecified verdict (invalid).
  AAT_VERDICT_UNSPECIFIED = 0;
  // All acceptance criteria passed.
  AAT_VERDICT_PASS = 1;
  // One or more acceptance criteria failed.
  AAT_VERDICT_FAIL = 2;
  // Additional input required to determine outcome.
  AAT_VERDICT_NEEDS_INPUT = 3;
}

// Risk tier for AAT selection policy.
enum AatRiskTier {
  // Unspecified tier (invalid).
  AAT_RISK_TIER_UNSPECIFIED = 0;
  // High risk - AAT always required.
  AAT_RISK_TIER_HIGH = 1;
  // Medium risk - AAT required for sensitive domains.
  AAT_RISK_TIER_MED = 2;
  // Low risk - AAT sampled with nightly full coverage.
  AAT_RISK_TIER_LOW = 3;
}

// Output from a terminal verifier.
// Terminal verifiers provide ground truth (exit codes, snapshot diffs, etc.).
message TerminalVerifierOutput {
  // Kind of verifier: exit_code, snapshot_diff, structured_test_report, invariant_check
  string verifier_kind = 1;
  // Digest of the verifier output content (32 bytes).
  bytes output_digest = 2;
  // Whether the machine predicate was satisfied.
  bool predicate_satisfied = 3;
}

// Attestation metadata for AAT execution environment.
// Provides evidence chain for runtime environment verification.
message AatAttestation {
  // Digest of the container image used (32 bytes).
  bytes container_image_digest = 1;
  // Digests of toolchain components (each 32 bytes).
  repeated bytes toolchain_digests = 2;
  // Identity key ID of the runner.
  string runner_identity_key_id = 3;
  // Hash of the network policy profile (32 bytes).
  bytes network_policy_profile_hash = 4;
}

// Typed payload for AAT gate receipts (22 required fields).
// Stored in CAS and referenced by payload_hash from GateReceipt envelope.
//
// Invariants:
// - view_commitment_hash matches FAC-00 output
// - rcp_manifest_hash matches FAC-02 output for profile
// - run_receipt_hashes.len() == run_count
// - transcript_chain_root_hash derivable from transcript_bundle_hash
// - artifact_manifest_hash references CAS ArtifactManifest
// - At least one terminal_verifier_output present for PASS
// - predicate_satisfied == true for all verifier outputs when verdict == PASS
message AatGateReceipt {
  // ============== View commitment binding (fields 1-4) ==============
  // Hash binding to view commitment from FAC-00 (32 bytes).
  bytes view_commitment_hash = 1;
  // Hash of the RCP manifest for this profile (32 bytes).
  bytes rcp_manifest_hash = 2;
  // RCP profile identifier.
  string rcp_profile_id = 3;
  // Policy hash for anti-downgrade verification (32 bytes).
  bytes policy_hash = 4;

  // ============== Determinism tracking (fields 5-13) ==============
  // Determinism class (0=non, 1=soft, 2=fully).
  uint32 determinism_class = 5;
  // Whether terminal evidence was stable across runs.
  DeterminismStatus determinism_status = 6;
  // Classification of flakiness when mismatch occurs.
  FlakeClass flake_class = 7;
  // Number of AAT runs executed.
  uint32 run_count = 8;
  // Hashes of individual run receipts (each 32 bytes, len == run_count).
  repeated bytes run_receipt_hashes = 9;
  // Digest of machine-checkable terminal evidence (32 bytes).
  bytes terminal_evidence_digest = 10;
  // Digest of observational evidence (logs, traces) - excluded from determinism (32 bytes).
  bytes observational_evidence_digest = 11;
  // Digest of terminal verifier outputs (32 bytes).
  bytes terminal_verifier_outputs_digest = 12;
  // Stability digest = hash(verdict, terminal_evidence_digest, terminal_verifier_outputs_digest) (32 bytes).
  bytes stability_digest = 13;

  // ============== Verdict (field 14) ==============
  // AAT outcome verdict.
  AatVerdict verdict = 14;

  // ============== Evidence binding (fields 15-19) ==============
  // Root hash of the transcript chain (32 bytes).
  bytes transcript_chain_root_hash = 15;
  // Hash of the transcript bundle in CAS (32 bytes).
  bytes transcript_bundle_hash = 16;
  // Hash of the artifact manifest in CAS (32 bytes).
  bytes artifact_manifest_hash = 17;
  // Terminal verifier outputs with predicate satisfaction.
  repeated TerminalVerifierOutput terminal_verifier_outputs = 18;
  // Hash of the verifier policy (32 bytes).
  bytes verifier_policy_hash = 19;

  // ============== Risk tier (fields 20-21) ==============
  // Selection policy identifier.
  string selection_policy_id = 20;
  // Risk tier for AAT selection (0-4: Tier0-Tier4).
  // Stored as uint32 for fidelity preservation across proto roundtrips.
  uint32 risk_tier = 21;

  // ============== Attestation (field 22) ==============
  // Execution environment attestation.
  AatAttestation attestation = 22;
}

// ============================================================
// INTERVENTION EVENTS (FAC Divergence Watchdog)
// ============================================================
//
// Intervention events implement the freeze/unfreeze mechanism for the
// Divergence Watchdog (TCK-00213). When external modifications to the
// trunk are detected (divergence from MergeReceipt), the system emits
// an InterventionFreeze to halt all new admissions until adjudication.
//
// Key security properties:
// - Divergence detection triggers immediate freeze
// - Frozen repos reject all new admissions with REPO_FROZEN error
// - Unfreeze requires adjudication (cannot be bypassed)
// - All freeze/unfreeze events are signed for non-repudiation

// Scope of an intervention freeze.
// Determines what is frozen by the intervention.
enum InterventionScope {
  // Unspecified scope (invalid).
  INTERVENTION_SCOPE_UNSPECIFIED = 0;
  // Freeze applies to a specific repository.
  INTERVENTION_SCOPE_REPOSITORY = 1;
  // Freeze applies to a specific work item.
  INTERVENTION_SCOPE_WORK = 2;
  // Freeze applies to all repositories in a namespace.
  INTERVENTION_SCOPE_NAMESPACE = 3;
}

// Resolution type for intervention unfreeze.
// Indicates how the freeze was resolved.
enum InterventionResolutionType {
  // Unspecified resolution (invalid).
  INTERVENTION_RESOLUTION_UNSPECIFIED = 0;
  // Resolved through adjudication process.
  INTERVENTION_RESOLUTION_ADJUDICATION = 1;
  // Resolved by manual operator intervention.
  INTERVENTION_RESOLUTION_MANUAL = 2;
  // Resolved by rollback to last known good state.
  INTERVENTION_RESOLUTION_ROLLBACK = 3;
  // Resolved by accepting the divergent state as new baseline.
  INTERVENTION_RESOLUTION_ACCEPT_DIVERGENCE = 4;
}

// Emitted when divergence is detected between the ledger's MergeReceipt
// and the external trunk HEAD. This freezes the specified scope to
// prevent further admissions until adjudication.
//
// Security: Divergence detection is critical for maintaining ledger integrity.
// Any external modification of the trunk triggers immediate freeze.
message InterventionFreeze {
  // Unique identifier for this freeze event.
  string freeze_id = 1;
  // Scope of the freeze (repository, work, namespace).
  InterventionScope scope = 2;
  // Value identifying the frozen scope (repo path, work_id, namespace).
  string scope_value = 3;
  // ID of the DefectRecord that triggered this freeze.
  string trigger_defect_id = 4;
  // Timestamp when the freeze was applied (Unix nanoseconds).
  uint64 frozen_at = 5;
  // Expected trunk HEAD from the latest MergeReceipt.
  bytes expected_trunk_head = 6;
  // Actual trunk HEAD observed externally.
  bytes actual_trunk_head = 7;
  // Actor who detected the divergence and issued the freeze.
  string gate_actor_id = 8;
  // Ed25519 signature over canonical bytes with INTERVENTION_FREEZE: domain (64 bytes).
  bytes gate_signature = 9;
  // Reference to the time envelope for temporal authority.
  string time_envelope_ref = 10;
}

// Emitted when a frozen scope is unfrozen after adjudication.
// The unfreeze must reference a valid adjudication decision.
//
// Security: Unfreeze cannot bypass adjudication. All unfreezes must
// be traceable to a resolution decision.
message InterventionUnfreeze {
  // ID of the InterventionFreeze being lifted.
  string freeze_id = 1;
  // How the freeze was resolved.
  InterventionResolutionType resolution_type = 2;
  // ID of the adjudication that resolved the freeze.
  string adjudication_id = 3;
  // Timestamp when the unfreeze was applied (Unix nanoseconds).
  uint64 unfrozen_at = 4;
  // Actor who issued the unfreeze (must be authorized).
  string gate_actor_id = 5;
  // Ed25519 signature over canonical bytes with INTERVENTION_UNFREEZE: domain (64 bytes).
  bytes gate_signature = 6;
  // Reference to the time envelope for temporal authority.
  string time_envelope_ref = 7;
}

// ============================================================
// ARTIFACT MANIFEST (TCK-00221)
// ============================================================
//
// ArtifactManifest binds evidence artifacts to gate receipts with
// data classification, redaction metadata, and retention policy.
// This supports evidence hygiene requirements (FAC-REQ-0014).
//
// Key security properties:
// - All artifacts have data classification for access control
// - Redaction profiles are bound to specific sanitization rules
// - Retention windows enable automated cleanup per policy
// - Admission rejects evidence policy violations

// Type of evidence artifact.
enum ArtifactType {
  // Unspecified type (invalid).
  ARTIFACT_TYPE_UNSPECIFIED = 0;
  // Execution logs and traces.
  ARTIFACT_TYPE_LOG = 1;
  // JUnit/xUnit test reports.
  ARTIFACT_TYPE_JUNIT = 2;
  // Code coverage reports.
  ARTIFACT_TYPE_COVERAGE = 3;
  // State snapshots for determinism verification.
  ARTIFACT_TYPE_SNAPSHOT = 4;
  // Compiled artifacts (executables, libraries).
  ARTIFACT_TYPE_BINARY = 5;
}

// Data classification level for evidence artifacts.
// Determines access control and handling requirements.
enum DataClassification {
  // Unspecified classification (invalid).
  DATA_CLASSIFICATION_UNSPECIFIED = 0;
  // No access restrictions.
  DATA_CLASSIFICATION_PUBLIC = 1;
  // Organization-internal access only.
  DATA_CLASSIFICATION_INTERNAL = 2;
  // Restricted access with audit logging.
  DATA_CLASSIFICATION_CONFIDENTIAL = 3;
  // Maximum security controls required.
  DATA_CLASSIFICATION_RESTRICTED = 4;
}

// Digest and metadata for a single evidence artifact.
// Each artifact is identified by its content digest and includes metadata
// for access control, redaction tracking, and retention policy.
message ArtifactDigest {
  // Type of artifact (Log, Junit, Coverage, Snapshot, Binary).
  ArtifactType artifact_type = 1;
  // SHA-256 digest of the artifact content (32 bytes).
  bytes digest = 2;
  // Data classification for access control.
  DataClassification data_classification = 3;
  // Whether redaction/sanitization was applied to this artifact.
  bool redaction_applied = 4;
  // Hash of the redaction profile used (32 bytes, required if redaction_applied).
  bytes redaction_profile_hash = 5;
  // Reference to the retention window for this artifact.
  // Uses HTF time envelope format (e.g., "htf:window:30d").
  string retention_window_ref = 6;
}

// Manifest of evidence artifacts for a gate receipt.
// The manifest binds all evidence artifacts produced during gate execution,
// enabling independent verification and retention management.
//
// Invariants:
// - Must contain at least one artifact (empty manifests are rejected)
// - No duplicate digests allowed
// - All artifacts must pass hygiene validation
//
// Security: The manifest is referenced by artifact_manifest_hash in
// AatGateReceipt and stored in CAS for independent verification.
message ArtifactManifest {
  // List of artifact digests and metadata.
  repeated ArtifactDigest artifacts = 1;
}
