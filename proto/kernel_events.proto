// APM2 Kernel Event Schema
// Version: 0.2.0
//
// This file defines the core event types for the APM2 kernel.
// All events are stored in the ledger and form a hash chain.
//
// IMPORTANT: Maps are forbidden in signed messages to ensure canonical encoding.
//
// CANONICAL ENCODING REQUIREMENTS:
// To ensure deterministic serialization (required for signature verification):
// 1. Maps are forbidden (non-deterministic key ordering)
// 2. Repeated fields MUST be sorted before signing:
//    - String fields: lexicographic ordering
//    - Numeric fields: ascending order
// 3. Use BTreeMap for any map-like structures in Rust implementations
// 4. Empty repeated fields should be omitted from wire format

syntax = "proto3";
package apm2.kernel.v1;

import "google/protobuf/timestamp.proto";

// Common envelope for all kernel events
message KernelEvent {
  // Monotonic sequence number within this ledger
  uint64 sequence = 1;
  // Hash of the previous event.
  // For genesis events: use 32 zero bytes (canonical representation).
  // Note: The ledger may store NULL for genesis as a storage optimization,
  // but it must be normalized to 32 zero bytes at API boundaries.
  bytes previous_hash = 2;
  // Timestamp when event was created
  google.protobuf.Timestamp timestamp = 3;
  // Actor ID that produced this event
  string actor_id = 4;
  // Session ID (if applicable)
  string session_id = 5;
  // Ed25519 signature over canonical bytes of this message
  bytes signature = 6;
  // Schema version for forward/backward compatibility
  // Current version: 1
  uint32 schema_version = 7;
  // Event payload (oneof)
  oneof payload {
    SessionEvent session = 10;
    WorkEvent work = 11;
    ToolEvent tool = 12;
    LeaseEvent lease = 13;
    PolicyEvent policy = 14;
    AdjudicationEvent adjudication = 15;
    EvidenceEvent evidence = 16;
    KeyEvent key = 17;
    CapabilityEvent capability = 18;
    GitHubLeaseEvent github_lease = 19;
  }
}

// ============================================================
// SESSION EVENTS
// ============================================================
message SessionEvent {
  oneof event {
    SessionStarted started = 1;
    SessionProgress progress = 2;
    SessionTerminated terminated = 3;
    SessionQuarantined quarantined = 4;
    SessionCrashDetected crash_detected = 5;
    SessionRestartScheduled restart_scheduled = 6;
  }
}

// Emitted when a session process exits unexpectedly or crashes.
message SessionCrashDetected {
  string session_id = 1;
  string crash_type = 2;  // CLEAN_EXIT, ERROR_EXIT, SIGNAL, TIMEOUT, ENTROPY_EXCEEDED
  int32 exit_code = 3;
  int32 signal = 4;
  uint64 uptime_ms = 5;
  uint64 last_cursor = 6;
  uint32 restart_count = 7;
}

// Emitted when a restart has been scheduled for a crashed session.
message SessionRestartScheduled {
  string session_id = 1;
  uint64 scheduled_at = 2;
  uint64 restart_at = 3;
  uint64 resume_cursor = 4;
  uint32 attempt_number = 5;
  string backoff_type = 6;  // FIXED, EXPONENTIAL, LINEAR
}

message SessionStarted {
  string session_id = 1;
  string actor_id = 2;
  string adapter_type = 3;
  string work_id = 4;
  string lease_id = 5;
  uint64 entropy_budget = 6;
  // For restarted sessions: cursor to resume from
  uint64 resume_cursor = 7;
  // For restarted sessions: restart attempt number (0 = first start)
  uint32 restart_attempt = 8;
}

message SessionProgress {
  string session_id = 1;
  uint64 progress_sequence = 2;
  string progress_type = 3;  // HEARTBEAT, TOOL_COMPLETE, MILESTONE
  uint64 entropy_consumed = 4;
}

message SessionTerminated {
  string session_id = 1;
  string exit_classification = 2;  // SUCCESS, FAILURE, TIMEOUT, ENTROPY_EXCEEDED
  string rationale_code = 3;
  uint64 final_entropy = 4;
}

message SessionQuarantined {
  string session_id = 1;
  string reason = 2;
  uint64 quarantine_until = 3;
}

// ============================================================
// WORK EVENTS
// ============================================================
message WorkEvent {
  oneof event {
    WorkOpened opened = 1;
    WorkTransitioned transitioned = 2;
    WorkCompleted completed = 3;
    WorkAborted aborted = 4;
    WorkPrAssociated pr_associated = 5;
  }
}

message WorkOpened {
  string work_id = 1;
  string work_type = 2;  // TICKET, PRD_REFINEMENT, RFC_REFINEMENT, REVIEW
  bytes spec_snapshot_hash = 3;
  repeated string requirement_ids = 4;
  repeated string parent_work_ids = 5;
}

message WorkTransitioned {
  string work_id = 1;
  string from_state = 2;
  // Valid states: OPEN, CLAIMED, IN_PROGRESS, CI_PENDING, READY_FOR_REVIEW,
  // BLOCKED, REVIEW, NEEDS_INPUT, NEEDS_ADJUDICATION
  string to_state = 3;
  string rationale_code = 4;
  // Previous transition count for replay protection.
  // MUST match work.transition_count before this transition.
  // This field is strictly validated to prevent replay attacks.
  // For the first transition (Open -> Claimed), use 0.
  uint32 previous_transition_count = 5;
}

message WorkCompleted {
  string work_id = 1;
  bytes evidence_bundle_hash = 2;
  repeated string evidence_ids = 3;
  string gate_receipt_id = 4;
}

message WorkAborted {
  string work_id = 1;
  string abort_reason = 2;  // POLICY_DENY, TIMEOUT, ENTROPY_EXCEEDED, MANUAL
  string rationale_code = 3;
}

// Emitted when a PR is created and associated with a work item.
// This enables CI event matching for phase transitions.
message WorkPrAssociated {
  string work_id = 1;
  uint64 pr_number = 2;
  string commit_sha = 3;  // The commit SHA that triggered the CI workflow
}

// ============================================================
// TOOL EVENTS
// ============================================================
message ToolEvent {
  oneof event {
    ToolRequested requested = 1;
    ToolDecided decided = 2;
    ToolExecuted executed = 3;
  }
}

message ToolRequested {
  string request_id = 1;
  string session_id = 2;
  string tool_name = 3;
  bytes tool_args_hash = 4;  // Hash of arguments (full args stored in CAS)
  string dedupe_key = 5;
}

message ToolDecided {
  string request_id = 1;
  string decision = 2;  // ALLOW, DENY
  string rule_id = 3;
  bytes policy_hash = 4;
  string rationale_code = 5;
  uint64 budget_consumed = 6;
}

message ToolExecuted {
  string request_id = 1;
  string outcome = 2;  // SUCCESS, FAILURE, TIMEOUT
  bytes result_hash = 3;  // Hash of result (full result stored in CAS)
  uint64 duration_ms = 4;
}

// ============================================================
// LEASE EVENTS
// ============================================================
message LeaseEvent {
  oneof event {
    LeaseIssued issued = 1;
    LeaseRenewed renewed = 2;
    LeaseReleased released = 3;
    LeaseExpired expired = 4;
    LeaseConflict conflict = 5;
  }
}

message LeaseIssued {
  string lease_id = 1;
  string work_id = 2;
  string actor_id = 3;
  uint64 issued_at = 4;
  uint64 expires_at = 5;
  bytes registrar_signature = 6;
}

message LeaseRenewed {
  string lease_id = 1;
  uint64 new_expires_at = 2;
  bytes registrar_signature = 3;
}

message LeaseReleased {
  string lease_id = 1;
  string release_reason = 2;  // COMPLETED, ABORTED, VOLUNTARY
}

message LeaseExpired {
  string lease_id = 1;
  uint64 expired_at = 2;
}

message LeaseConflict {
  string work_id = 1;
  repeated string conflicting_lease_ids = 2;
  string resolution = 3;  // CANONICAL_ROOT, ADJUDICATION_REQUIRED
}

// ============================================================
// POLICY EVENTS
// ============================================================
message PolicyEvent {
  oneof event {
    PolicyLoaded loaded = 1;
    PolicyViolation violation = 2;
    BudgetExceeded budget_exceeded = 3;
  }
}

message PolicyLoaded {
  bytes policy_hash = 1;
  string policy_version = 2;
  uint64 rule_count = 3;
}

message PolicyViolation {
  string session_id = 1;
  string violation_type = 2;
  string rule_id = 3;
  string details = 4;
}

message BudgetExceeded {
  string session_id = 1;
  string budget_type = 2;  // TOKEN, TIME, TOOL_CALLS
  uint64 limit = 3;
  uint64 consumed = 4;
}

// ============================================================
// ADJUDICATION EVENTS
// ============================================================
message AdjudicationEvent {
  oneof event {
    AdjudicationRequested requested = 1;
    AdjudicationVote vote = 2;
    AdjudicationResolved resolved = 3;
    AdjudicationTimeout timeout = 4;
  }
}

message AdjudicationRequested {
  string adjudication_id = 1;
  string work_id = 2;
  string request_type = 3;  // BOUNDED_CHOICE, WAIVER, GATE_REVIEW
  repeated string options = 4;
  uint64 deadline = 5;
  string fallback_policy = 6;
}

message AdjudicationVote {
  string adjudication_id = 1;
  string voter_actor_id = 2;
  string chosen_option = 3;
  bytes voter_signature = 4;
}

message AdjudicationResolved {
  string adjudication_id = 1;
  string chosen_option = 2;
  uint64 votes_for = 3;
  uint64 votes_against = 4;
  bytes quorum_signature = 5;
}

message AdjudicationTimeout {
  string adjudication_id = 1;
  string applied_fallback = 2;
}

// ============================================================
// EVIDENCE EVENTS
// ============================================================
message EvidenceEvent {
  oneof event {
    EvidencePublished published = 1;
    GateReceiptGenerated gate_receipt = 2;
  }
}

message EvidencePublished {
  string evidence_id = 1;
  string work_id = 2;
  string category = 3;
  bytes artifact_hash = 4;
  repeated string verification_command_ids = 5;
  // Data classification: PUBLIC, INTERNAL, CONFIDENTIAL, RESTRICTED
  string classification = 6;
  // Artifact size in bytes (for bundle size tracking)
  uint64 artifact_size = 7;
  // Metadata key-value pairs as "key=value" strings
  repeated string metadata = 8;
}

message GateReceiptGenerated {
  string receipt_id = 1;
  string gate_id = 2;
  string work_id = 3;
  string result = 4;  // PASS, FAIL
  repeated string evidence_ids = 5;
  bytes receipt_signature = 6;
}

// ============================================================
// CAPABILITY EVENTS
// ============================================================
//
// Capability events implement the OCAP (Object Capability) model for
// cross-node authority verification. All capability events are TotalOrder
// authority events requiring BFT consensus finalization.
//
// Key concepts:
// - capability_id == lease_id (capabilities are linked to leases)
// - namespace binding prevents cross-namespace replay attacks
// - Delegation chains support hierarchical authority delegation
// - Proofs are ledger-verifiable across nodes

message CapabilityEvent {
  oneof event {
    CapabilityRequired required = 1;
    CapabilityGranted granted = 2;
    CapabilityDelegated delegated = 3;
    CapabilityRevoked revoked = 4;
  }
}

// Emitted during planning phase when a capability is required for a plan step.
// This event enables capability negotiation and tracking.
message CapabilityRequired {
  // The capability ID that is required (e.g., "cac:patch:apply")
  string capability_id = 1;
  // The work ID this requirement is associated with
  string work_id = 2;
  // Whether this capability is required (true) or optional (false)
  bool required = 3;
  // The status of the capability: AVAILABLE, UNAVAILABLE, DEGRADED
  string status = 4;
  // Human-readable reason for the status
  string reason = 5;
}

// Emitted when a capability is granted to an actor by an authority.
// This is the root of a delegation chain and must be signed by the registrar.
// Links to the lease system: capability_id == lease_id.
message CapabilityGranted {
  // Unique identifier for this capability (equals lease_id for lease-backed capabilities)
  string capability_id = 1;
  // Namespace this capability is bound to (prevents cross-namespace replay)
  string namespace = 2;
  // Actor receiving the capability
  string grantee_actor_id = 3;
  // Actor granting the capability (must be an authority in the namespace)
  string grantor_actor_id = 4;
  // Hash of the serialized LeaseScope (stored in CAS)
  bytes scope_hash = 5;
  // Optional hash of the serialized Budget (stored in CAS)
  bytes budget_hash = 6;
  // Timestamp when the capability was granted (Unix nanos)
  uint64 granted_at = 7;
  // Timestamp when the capability expires (Unix nanos)
  uint64 expires_at = 8;
  // Registrar signature over this grant (proves authority)
  bytes registrar_signature = 9;
  // Whether this capability can be delegated to others
  bool delegatable = 10;
}

// Emitted when a capability holder delegates their capability to another actor.
// Forms part of the delegation chain for capability proofs.
message CapabilityDelegated {
  // New capability ID for the delegated capability
  string delegated_capability_id = 1;
  // Parent capability being delegated from
  string parent_capability_id = 2;
  // Hash of the parent CapabilityGranted or CapabilityDelegated event
  bytes parent_capability_hash = 3;
  // Namespace this delegation is bound to (must match parent)
  string namespace = 4;
  // Actor receiving the delegated capability
  string delegatee_actor_id = 5;
  // Actor delegating the capability (must hold parent capability)
  string delegator_actor_id = 6;
  // Hash of the serialized LeaseScope (must be subset of parent scope)
  bytes scope_hash = 7;
  // Optional hash of the serialized Budget (must be subset of parent budget)
  bytes budget_hash = 8;
  // Timestamp when the delegation occurred (Unix nanos)
  uint64 delegated_at = 9;
  // Timestamp when the delegated capability expires (Unix nanos, must be <= parent expires_at)
  uint64 expires_at = 10;
  // Delegator's signature over this delegation (proves authority transfer)
  bytes delegator_signature = 11;
  // Whether this delegated capability can be further delegated
  bool delegatable = 12;
  // Depth in the delegation chain (parent depth + 1)
  uint32 delegation_depth = 13;
}

// Emitted when a capability is revoked before its natural expiration.
// Revocation cascades to all delegated capabilities in the chain.
message CapabilityRevoked {
  // The capability being revoked
  string capability_id = 1;
  // Namespace the capability belongs to
  string namespace = 2;
  // Actor performing the revocation (must be grantor or authority)
  string revoker_actor_id = 3;
  // Reason for revocation: VOLUNTARY, POLICY_VIOLATION, KEY_COMPROMISE, SUPERSEDED
  string revocation_reason = 4;
  // Timestamp when the revocation occurred (Unix nanos)
  uint64 revoked_at = 5;
  // Revoker's signature over this revocation
  bytes revoker_signature = 6;
  // If true, revocation cascades to all delegated capabilities; if false, only this capability is revoked
  bool cascade = 7;
}

// ============================================================
// KEY EVENTS
// ============================================================
message KeyEvent {
  oneof event {
    KeyRotated rotated = 1;
  }
}

// ============================================================
// GITHUB LEASE EVENTS
// ============================================================
//
// GitHub lease events implement tiered GitHub App access control for AI agents.
// Each GitHub App corresponds to a risk tier range:
// - apm2-reader (T0): contents:read, metadata:read
// - apm2-developer (T1-T2): + pull_requests:write, checks:write, statuses:write
// - apm2-operator (T3-T4): + contents:write, admin:read, releases:write
//
// Key security properties:
// - Raw tokens are NEVER stored in the ledger (only hashes)
// - Token TTLs are proportional to risk tier (shorter for higher tiers)
// - Scope attenuation only (cannot escalate permissions)
// - All operations are audited for non-repudiation

message GitHubLeaseEvent {
  oneof event {
    GitHubLeaseIssued issued = 1;
    GitHubLeaseRevoked revoked = 2;
    GitHubOperationRecorded operation_recorded = 3;
  }
}

// Emitted when a GitHub installation access token is minted for an agent.
// Links to the episode via episode_id and inherits risk tier constraints.
message GitHubLeaseIssued {
  // Unique identifier for this GitHub lease
  string lease_id = 1;
  // Episode this lease is bound to
  string episode_id = 2;
  // GitHub App ID (determines permission tier)
  string github_app_id = 3;
  // GitHub installation ID for the target repository/organization
  string installation_id = 4;
  // Risk tier of the requesting agent (0-4)
  // Tier determines which GitHub App can be used:
  // - T0: reader only
  // - T1-T2: reader or developer
  // - T3-T4: reader, developer, or operator
  uint32 risk_tier = 5;
  // Hash of the requested GitHub scopes (scope list stored in CAS)
  bytes scope_hash = 6;
  // SHA-256 hash of the installation access token (NEVER store raw token)
  bytes token_hash = 7;
  // Timestamp when the lease was issued (Unix nanos)
  uint64 issued_at = 8;
  // Timestamp when the lease expires (Unix nanos)
  // TTL is proportional to risk tier:
  // - T0: 1 hour
  // - T1-T2: 15-30 minutes
  // - T3-T4: 2-5 minutes
  uint64 expires_at = 9;
  // Hash of the capability manifest that authorized this lease
  bytes capability_manifest_hash = 10;
  // Issuer (registrar) signature over this event
  bytes issuer_signature = 11;
}

// Emitted when a GitHub lease is revoked before expiration.
// Revocation may be voluntary or forced (policy violation, key compromise).
message GitHubLeaseRevoked {
  // The lease being revoked
  string lease_id = 1;
  // Episode the lease was bound to
  string episode_id = 2;
  // Reason for revocation: VOLUNTARY, EXPIRED, POLICY_VIOLATION, KEY_COMPROMISE
  string revocation_reason = 3;
  // Timestamp when the revocation occurred (Unix nanos)
  uint64 revoked_at = 4;
  // Actor performing the revocation
  string revoker_actor_id = 5;
  // Revoker signature over this event
  bytes revoker_signature = 6;
}

// Emitted for each GitHub API operation made with a leased token.
// Provides audit trail for all GitHub interactions.
message GitHubOperationRecorded {
  // Unique identifier for this operation record
  string operation_id = 1;
  // The lease that authorized this operation
  string lease_id = 2;
  // Episode context
  string episode_id = 3;
  // GitHub API endpoint called (e.g., "POST /repos/{owner}/{repo}/pulls")
  string api_endpoint = 4;
  // HTTP method: GET, POST, PUT, PATCH, DELETE
  string http_method = 5;
  // Target repository in owner/repo format
  string repository = 6;
  // Hash of the request body (request body stored in CAS if needed)
  bytes request_hash = 7;
  // Hash of the response body (response body stored in CAS if needed)
  bytes response_hash = 8;
  // HTTP status code returned
  uint32 status_code = 9;
  // Timestamp when the operation was performed (Unix nanos)
  uint64 performed_at = 10;
  // Duration of the API call in milliseconds
  uint64 duration_ms = 11;
  // GitHub rate limit remaining after this call
  uint32 rate_limit_remaining = 12;
}

// Event emitted when an actor rotates their signing key.
// This establishes a chain of custody for key transitions.
message KeyRotated {
  // Actor whose key is being rotated
  string actor_id = 1;
  // Hash of the old verifying key (for reference)
  bytes old_key_hash = 2;
  // New verifying (public) key bytes
  bytes new_verifying_key = 3;
  // Timestamp when the rotation occurred (Unix nanos)
  uint64 rotated_at = 4;
  // Signature from the OLD key over this message (proves control of old key)
  bytes old_key_signature = 5;
}
